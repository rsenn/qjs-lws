{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"getOwn",
				"getOwnPropertySymbols(...)"
			],
			[
				"stra",
				"strategy"
			],
			[
				"un",
				"underlyingSource"
			],
			[
				"asyn",
				"asyncIterable"
			],
			[
				"JS_Is",
				"JS_IsUndefined"
			],
			[
				"asy",
				"asyncIterator"
			],
			[
				"is",
				"isPrototypeOf"
			],
			[
				"Read",
				"ReadableStream"
			],
			[
				"remote",
				"remoteAddress"
			],
			[
				"LWS",
				"LWS_WRITE_HTTP_FINAL"
			],
			[
				"LWS_WRI",
				"LWS_WRITE_HTTP_FINAL"
			],
			[
				"JS_Get",
				"JS_GetPropertyUint32"
			],
			[
				"GET",
				"GET_VHOST_BY_NAME"
			],
			[
				"JS_C",
				"JS_CFUNC_MAGIC_DEF"
			],
			[
				"JS_Free",
				"JS_FreeCString"
			],
			[
				"opt",
				"options_or_protocols"
			],
			[
				"op",
				"options_or_protocols"
			],
			[
				"to",
				"toStringTag"
			],
			[
				"LWS_SER",
				"LWS_SERVER_OPTION_ALLOW_NON_SSL_ON_SSL_PORT"
			],
			[
				"LWS_SE",
				"LWS_SERVER_OPTION_CREATE_VHOST_SSL_CTX"
			],
			[
				"LWS_",
				"LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT"
			],
			[
				"getLo",
				"getLogLevelColour"
			],
			[
				"lwsjs_log_",
				"lwsjs_log_colours"
			],
			[
				"JS_Throw",
				"JS_ThrowTypeError"
			],
			[
				"LCCSCF_",
				"LCCSCF_HTTP_MULTIPART_MIME"
			],
			[
				"onCli",
				"onClientHttpWriteable"
			],
			[
				"JS_Set",
				"JS_SetPropertyUint32"
			],
			[
				"cont",
				"content_type"
			],
			[
				"METHOD_",
				"METHOD_CLIENT_HTTP_MULTIPART"
			],
			[
				"METHOD_HT",
				"METHOD_CLIENT_HTTP_MULTIPART"
			],
			[
				"JS_SetProp",
				"JS_SetPropertyUint32"
			],
			[
				"WebSock",
				"WebSocketStream"
			],
			[
				"WebSo",
				"WebSocketStream"
			],
			[
				"WebSocke",
				"WebSocketStream"
			],
			[
				"define",
				"defineProperties(...)"
			],
			[
				"defin",
				"defineProperty(...)"
			],
			[
				"local",
				"local_protocol_name"
			],
			[
				"type",
				"typedListeners"
			],
			[
				"onRe",
				"onReceiveClientHttpRead"
			],
			[
				"JS_GetP",
				"JS_GetPropertyUint32"
			],
			[
				"lws_pr",
				"lws_process_html_args"
			],
			[
				"ioha",
				"iohandler_functions"
			],
			[
				"JS_Sert",
				"JS_SetPropertyUint32"
			],
			[
				"lwsjs",
				"lwsjs_loglevel"
			],
			[
				"lwsjs_clear",
				"lwsjs_clear_all_handlers"
			],
			[
				"js_is",
				"js_is_null_or_undefined"
			],
			[
				"lws_",
				"lws_context_class_id"
			],
			[
				"callba",
				"callback_names"
			],
			[
				"call",
				"callback_names"
			],
			[
				"FUNCTION_GET_",
				"FUNCTION_GET_CALLBACK_NUMBER"
			],
			[
				"PROP_PE",
				"PROP_PEER_WRITE_ALLOWANCE"
			],
			[
				"PROP_PEE",
				"PROP_PEER_WRITE_ALLOWANCE"
			],
			[
				"lws_callback",
				"lws_callback_names"
			],
			[
				"jsm_start_",
				"jsm_start_interactive3"
			],
			[
				"by",
				"byobRequest"
			],
			[
				"js_by",
				"js_readable_byob_request"
			],
			[
				"BY",
				"BYOB_REQUEST_METHOD_RESPONDWITHNEWVIEW"
			],
			[
				"JS_",
				"JS_NewObjectProtoClass"
			],
			[
				"is_",
				"is_exception"
			],
			[
				"JS_T",
				"JS_ThrowInternalError"
			],
			[
				"Repe",
				"RepeaterItem"
			],
			[
				"WRITER_PROP",
				"WRITER_PROP_READY"
			],
			[
				"Der",
				"DereferenceError"
			],
			[
				"Dere",
				"DereferenceError"
			],
			[
				"Is",
				"IsPunctuator"
			],
			[
				"js_magic_fun",
				"js_magic_function"
			],
			[
				"js_queue_iter",
				"js_queue_iterator_class_id"
			],
			[
				"js_queue_itreat",
				"js_queue_iterator_class_id"
			],
			[
				"js_",
				"js_archive_mode"
			],
			[
				"ENTRY_IS",
				"ENTRY_ISDATAENCRYPTED"
			],
			[
				"js_archivema",
				"js_archivematch_class_id"
			],
			[
				"JS_NewObjec",
				"JS_NewObjectProtoClass"
			],
			[
				"Module",
				"ModuleLoaderContext"
			],
			[
				"JS_Th",
				"JS_ThrowTypeError"
			],
			[
				"ModuleLo",
				"ModuleLoaderContext"
			],
			[
				"escape",
				"escape_noquote_tab"
			],
			[
				"max",
				"max_array_length"
			],
			[
				"tty",
				"tty_set_raw"
			],
			[
				"getOwnPrope",
				"getOwnPropertyDescriptor"
			],
			[
				"PATH_SKIP",
				"PATH_SKIP_SEPARATOR"
			],
			[
				"ListIterat",
				"ListIteratorKind"
			],
			[
				"_f",
				"_wfindnext64"
			],
			[
				"JS_PROP_",
				"JS_PROP_CONFIGURABLE"
			],
			[
				"JS_GetPr",
				"JS_GetPropertyStr"
			],
			[
				"js_sock",
				"js_sockaddr_data"
			],
			[
				"SET_",
				"SET_CONSOLE_MODE"
			],
			[
				"ERA",
				"ERASE_IN_LINE"
			],
			[
				"js_misc_set",
				"js_misc_settextattr"
			],
			[
				"dw",
				"dwCursorPosition"
			],
			[
				"prop",
				"property_recursion_top"
			],
			[
				"property_enumer",
				"property_enumeration_index"
			],
			[
				"INT",
				"INSPECT_INT32T_INRANGE"
			],
			[
				"js_inspect_print_arra",
				"js_inspect_print_arraybuffer2"
			],
			[
				"is_a",
				"is_arraybuffer"
			],
			[
				"fmt",
				"fmt_ulong"
			],
			[
				"inspec",
				"inspect_newline2"
			],
			[
				"property_",
				"property_recursion_top"
			],
			[
				"js_inspec",
				"js_inspect_print_value"
			],
			[
				"JS_Atom",
				"JS_AtomToValue"
			],
			[
				"mysql_op",
				"mysql_optionsv"
			],
			[
				"MY",
				"MYSQLConnectParameters"
			],
			[
				"js_connect",
				"js_connectparams_class_id"
			],
			[
				"js_conn",
				"js_connectparams_from"
			],
			[
				"MYSQL",
				"MYSQLConnectParameters"
			],
			[
				"mysql_get",
				"mysql_get_socket"
			],
			[
				"async",
				"asyncclosure_resolve"
			],
			[
				"res",
				"resolving_funcs"
			],
			[
				"HAVE_LIB",
				"HAVE_LIBMARIADBCLIENT"
			],
			[
				"js_is_null",
				"js_is_null_or_undefined"
			],
			[
				"FileDesc",
				"FileDescriptorHandlers"
			],
			[
				"js_generat",
				"js_generator_prototype"
			],
			[
				"tab_",
				"tab_atom_len"
			],
			[
				"proper",
				"property_recursion_pop"
			],
			[
				"property_rec",
				"property_recursion_top"
			],
			[
				"property",
				"property_recursion_top"
			],
			[
				"RETURN",
				"deep.RETURN_VALUE_PATH"
			],
			[
				"LIBS",
				"LIBSERIALPORT_LIBRARY_DIR"
			],
			[
				"js_misc_atexit_",
				"js_misc_atexit_called"
			],
			[
				"getO",
				"getOwnPropertyNames(...)"
			],
			[
				"Res",
				"ResolveAlias"
			],
			[
				"relati",
				"relativePath"
			],
			[
				"js_syscla",
				"js_syscallerror_defines"
			],
			[
				"get",
				"getOwnPropertyDescriptor(...)"
			],
			[
				"resol",
				"resolving_funcs"
			],
			[
				"set",
				"set_handler"
			],
			[
				"Async",
				"AsyncSocketClosure"
			],
			[
				"Asy",
				"AsyncSocketClosure"
			],
			[
				"js_socket_async_",
				"js_socket_async_resolver"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "â“‚  LWS_WRITE_RAW â€¦ â€” macro object\nâœŽ  NOTE: These public enums are part of the abi.  If you want to add one,\nâ€”â’¸â€“ lws_write_protocol { â€¦ } ; â€” type\nâ€”â’¸â€“ lws_write_passthru { â€¦ } ; â€” type\nâœŽ  IMPORTANT NOTICE!\n=== ==========================================================\nâ€”â’»â€“ lws_write ( ) { â€¦ } â€” function\nâ€”â“‚â€“ lws_write_http ( ) â€¦ â€” macro function\nâ€”â’»â€“ lws_write_ws_flags ( ) { â€¦ } â€” function\nâ’¡  lws_raw_transaction_completed ( ) ; â€” function declaration",
			"settings":
			{
				"buffer_size": 450,
				"line_ending": "Unix",
				"name": "ðŒ† Outline",
				"scratch": true
			},
			"undo_stack":
			[
				[
					77,
					2,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AwAAAAAAAAAAAAAAAAAAAAAAAADmAgAA4pKhICBsd3Nqc19sb2dfY2FsbGJhY2sgKCApIDsg4oCUIGZ1bmN0aW9uIGRlY2xhcmF0aW9uCuKAlOKSu+KAkyBjYW1lbGl6ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGRlY2FtZWxpemUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nqc19odG1sX3Byb2Nlc3NfYXJncyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c2pzX3VyaV90b2Nvbm5lY3RpbmZvICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfY29ubmVjdGluZm9fdG9fdXJpICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfZnVuY3Rpb25zICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfY2FsbGJhY2tfbmFtZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK44oCTIGx3c19jYWxsYmFja19yZWFzb25zIHsg4oCmIH0gOyDigJQgdHlwZQrigJTikrvigJMgbHdzanNfY2FsbGJhY2tfZmluZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c2pzX2dldF9sd3NfY2FsbGJhY2tzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfbG9nX2NhbGxiYWNrICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfaW5pdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX2luaXRfbW9kdWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					78,
					2,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					79,
					2,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					80,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					81,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					82,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					83,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					84,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					85,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					86,
					2,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					87,
					2,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					88,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					89,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/lws-socket.c",
						"symkeys":
						[
							[
								1052,
								1058
							],
							[
								1227,
								1245
							],
							[
								1458,
								1475
							],
							[
								1599,
								1609
							],
							[
								1670,
								1682
							],
							[
								2127,
								2138
							],
							[
								2333,
								2345
							],
							[
								2471,
								2482
							],
							[
								2744,
								2754
							],
							[
								2920,
								2933
							],
							[
								3135,
								3151
							],
							[
								3366,
								3377
							],
							[
								3943,
								3956
							],
							[
								4403,
								4414
							],
							[
								4534,
								4550
							],
							[
								4679,
								4696
							],
							[
								4920,
								4939
							],
							[
								5148,
								5168
							],
							[
								5385,
								5411
							],
							[
								5938,
								5951
							],
							[
								5966,
								5978
							],
							[
								6230,
								6253
							],
							[
								7052,
								7072
							],
							[
								8231,
								8251
							],
							[
								17018,
								17040
							],
							[
								18131,
								18147
							],
							[
								18574,
								18590
							],
							[
								22869,
								22891
							],
							[
								25693,
								25710
							]
						],
						"symlist":
						[
							"â€”â’»â€“â€ƒis_uriâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_method_indexâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_method_nameâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsocket_dupâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsocket_allocâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsocket_typeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsocket_getidâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsocket_findâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsocket_getâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_socket_getâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsocket_get_by_idâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsocket_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsocket_deleteâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsocket_obj2â€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_wsiâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_wrapâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_createâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_destroyâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_get_or_createâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€ƒâ“‰â€‚â€ƒCustomHeadersâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€”â’»â€“â€ƒset_propertyâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒcustom_headers_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_headersâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_methodsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_functionsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_setâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_getâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_finalizerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AQAAAAAAAAAAAAAAqQQAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					90,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"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"
				],
				[
					91,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/lws.c",
						"symkeys":
						[
							[
								313,
								331
							],
							[
								1070,
								1078
							],
							[
								1358,
								1368
							],
							[
								1634,
								1657
							],
							[
								2145,
								2168
							],
							[
								2912,
								2936
							],
							[
								3929,
								3944
							],
							[
								32580,
								32599
							],
							[
								32754,
								32774
							],
							[
								32775,
								32794
							],
							[
								33046,
								33069
							],
							[
								33515,
								33533
							],
							[
								34404,
								34414
							],
							[
								34708,
								34722
							]
						],
						"symlist":
						[
							"â€ƒâ’¡â€‚â€ƒlwsjs_log_callbackâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€”â’»â€“â€ƒcamelizeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒdecamelizeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_html_process_argsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_uri_toconnectinfoâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_connectinfo_to_uriâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_functionsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_callback_nameâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’¸â€“â€ƒlws_callback_reasonsâ€ƒ{â€‰â€¦â€‰}â€‰;â€ƒâ€”â€ƒtype",
							"â€”â’»â€“â€ƒlwsjs_callback_findâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_get_lws_callbacksâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_log_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_init_moduleâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AQAAAAAAAAAAAAAAYAIAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					92,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/fetch.js",
						"symkeys":
						[
							[
								914,
								948
							],
							[
								1409,
								1417
							],
							[
								1505,
								1525
							],
							[
								2153,
								2187
							],
							[
								2261,
								2297
							],
							[
								2606,
								2651
							],
							[
								3223,
								3261
							],
							[
								3558,
								3593
							],
							[
								4464,
								4498
							],
							[
								4657,
								4691
							],
							[
								5054,
								5080
							],
							[
								5198,
								5221
							],
							[
								5331,
								5371
							],
							[
								5510,
								5539
							],
							[
								5652,
								5682
							],
							[
								5885,
								5901
							]
						],
						"symlist":
						[
							" function fetch(url, options = {})",
							"start(c)",
							"(resolve, reject) =>",
							"onServerNewClientInstantiated(wsi)",
							"onEstablishedClientHttp(wsi, status)",
							"onClientAppendHandshakeHeader(wsi, data, len)",
							"onClientHttpRedirect(wsi, url, status)",
							"onClientHttpWriteable(wsi, ...args)",
							"onReceiveClientHttpRead(wsi, data)",
							"onReceiveClientHttp(wsi, buf, len)",
							"onCompletedClientHttp(wsi)",
							"onClosedClientHttp(wsi)",
							"onClientConnectionError(wsi, msg, errno)",
							"onClientHttpDropProtocol(wsi)",
							"callback(wsi, reason, ...args)",
							".onabort = () =>"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAADmAgAA4pKhICBsd3Nqc19sb2dfY2FsbGJhY2sgKCApIDsg4oCUIGZ1bmN0aW9uIGRlY2xhcmF0aW9uCuKAlOKSu+KAkyBjYW1lbGl6ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGRlY2FtZWxpemUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nqc19odG1sX3Byb2Nlc3NfYXJncyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c2pzX3VyaV90b2Nvbm5lY3RpbmZvICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfY29ubmVjdGluZm9fdG9fdXJpICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfZnVuY3Rpb25zICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfY2FsbGJhY2tfbmFtZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK44oCTIGx3c19jYWxsYmFja19yZWFzb25zIHsg4oCmIH0gOyDigJQgdHlwZQrigJTikrvigJMgbHdzanNfY2FsbGJhY2tfZmluZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c2pzX2dldF9sd3NfY2FsbGJhY2tzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfbG9nX2NhbGxiYWNrICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfaW5pdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX2luaXRfbW9kdWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgAAAAAAAAAABQIAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					93,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/fetch.js",
						"symkeys":
						[
							[
								914,
								948
							],
							[
								1409,
								1417
							],
							[
								1505,
								1525
							],
							[
								2153,
								2187
							],
							[
								2261,
								2297
							],
							[
								2606,
								2651
							],
							[
								3223,
								3261
							],
							[
								3558,
								3593
							],
							[
								4462,
								4496
							],
							[
								4655,
								4689
							],
							[
								5052,
								5078
							],
							[
								5196,
								5219
							],
							[
								5329,
								5369
							],
							[
								5508,
								5537
							],
							[
								5650,
								5680
							],
							[
								5883,
								5899
							]
						],
						"symlist":
						[
							" function fetch(url, options = {})",
							"start(c)",
							"(resolve, reject) =>",
							"onServerNewClientInstantiated(wsi)",
							"onEstablishedClientHttp(wsi, status)",
							"onClientAppendHandshakeHeader(wsi, data, len)",
							"onClientHttpRedirect(wsi, url, status)",
							"onClientHttpWriteable(wsi, ...args)",
							"onReceiveClientHttpRead(wsi, data)",
							"onReceiveClientHttp(wsi, buf, len)",
							"onCompletedClientHttp(wsi)",
							"onClosedClientHttp(wsi)",
							"onClientConnectionError(wsi, msg, errno)",
							"onClientHttpDropProtocol(wsi)",
							"callback(wsi, reason, ...args)",
							".onabort = () =>"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAFAgAAICBmZXRjaCh1cmwsIG9wdGlvbnMgPSB7fSkKICBzdGFydChjKQoocmVzb2x2ZSwgcmVqZWN0KSA9PgogIG9uU2VydmVyTmV3Q2xpZW50SW5zdGFudGlhdGVkKHdzaSkKICBvbkVzdGFibGlzaGVkQ2xpZW50SHR0cCh3c2ksIHN0YXR1cykKICBvbkNsaWVudEFwcGVuZEhhbmRzaGFrZUhlYWRlcih3c2ksIGRhdGEsIGxlbikKICBvbkNsaWVudEh0dHBSZWRpcmVjdCh3c2ksIHVybCwgc3RhdHVzKQogIG9uQ2xpZW50SHR0cFdyaXRlYWJsZSh3c2ksIC4uLmFyZ3MpCiAgb25SZWNlaXZlQ2xpZW50SHR0cFJlYWQod3NpLCBkYXRhKQogIG9uUmVjZWl2ZUNsaWVudEh0dHAod3NpLCBidWYsIGxlbikKICBvbkNvbXBsZXRlZENsaWVudEh0dHAod3NpKQogIG9uQ2xvc2VkQ2xpZW50SHR0cCh3c2kpCiAgb25DbGllbnRDb25uZWN0aW9uRXJyb3Iod3NpLCBtc2csIGVycm5vKQogIG9uQ2xpZW50SHR0cERyb3BQcm90b2NvbCh3c2kpCiAgY2FsbGJhY2sod3NpLCByZWFzb24sIC4uLmFyZ3MpCiAgLm9uYWJvcnQgPSAoKSA9PgAAAAAAAAAABQIAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					94,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/fetch.js",
						"symkeys":
						[
							[
								914,
								948
							],
							[
								1409,
								1417
							],
							[
								1505,
								1525
							],
							[
								2153,
								2187
							],
							[
								2261,
								2297
							],
							[
								2606,
								2651
							],
							[
								3223,
								3261
							],
							[
								3558,
								3593
							],
							[
								4462,
								4496
							],
							[
								4655,
								4689
							],
							[
								5052,
								5078
							],
							[
								5196,
								5219
							],
							[
								5329,
								5369
							],
							[
								5508,
								5537
							],
							[
								5650,
								5680
							],
							[
								5883,
								5899
							]
						],
						"symlist":
						[
							" function fetch(url, options = {})",
							"start(c)",
							"(resolve, reject) =>",
							"onServerNewClientInstantiated(wsi)",
							"onEstablishedClientHttp(wsi, status)",
							"onClientAppendHandshakeHeader(wsi, data, len)",
							"onClientHttpRedirect(wsi, url, status)",
							"onClientHttpWriteable(wsi, ...args)",
							"onReceiveClientHttpRead(wsi, data)",
							"onReceiveClientHttp(wsi, buf, len)",
							"onCompletedClientHttp(wsi)",
							"onClosedClientHttp(wsi)",
							"onClientConnectionError(wsi, msg, errno)",
							"onClientHttpDropProtocol(wsi)",
							"callback(wsi, reason, ...args)",
							".onabort = () =>"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAFAgAAICBmZXRjaCh1cmwsIG9wdGlvbnMgPSB7fSkKICBzdGFydChjKQoocmVzb2x2ZSwgcmVqZWN0KSA9PgogIG9uU2VydmVyTmV3Q2xpZW50SW5zdGFudGlhdGVkKHdzaSkKICBvbkVzdGFibGlzaGVkQ2xpZW50SHR0cCh3c2ksIHN0YXR1cykKICBvbkNsaWVudEFwcGVuZEhhbmRzaGFrZUhlYWRlcih3c2ksIGRhdGEsIGxlbikKICBvbkNsaWVudEh0dHBSZWRpcmVjdCh3c2ksIHVybCwgc3RhdHVzKQogIG9uQ2xpZW50SHR0cFdyaXRlYWJsZSh3c2ksIC4uLmFyZ3MpCiAgb25SZWNlaXZlQ2xpZW50SHR0cFJlYWQod3NpLCBkYXRhKQogIG9uUmVjZWl2ZUNsaWVudEh0dHAod3NpLCBidWYsIGxlbikKICBvbkNvbXBsZXRlZENsaWVudEh0dHAod3NpKQogIG9uQ2xvc2VkQ2xpZW50SHR0cCh3c2kpCiAgb25DbGllbnRDb25uZWN0aW9uRXJyb3Iod3NpLCBtc2csIGVycm5vKQogIG9uQ2xpZW50SHR0cERyb3BQcm90b2NvbCh3c2kpCiAgY2FsbGJhY2sod3NpLCByZWFzb24sIC4uLmFyZ3MpCiAgLm9uYWJvcnQgPSAoKSA9PgAAAAAAAAAABQIAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					95,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAFAgAAICBmZXRjaCh1cmwsIG9wdGlvbnMgPSB7fSkKICBzdGFydChjKQoocmVzb2x2ZSwgcmVqZWN0KSA9PgogIG9uU2VydmVyTmV3Q2xpZW50SW5zdGFudGlhdGVkKHdzaSkKICBvbkVzdGFibGlzaGVkQ2xpZW50SHR0cCh3c2ksIHN0YXR1cykKICBvbkNsaWVudEFwcGVuZEhhbmRzaGFrZUhlYWRlcih3c2ksIGRhdGEsIGxlbikKICBvbkNsaWVudEh0dHBSZWRpcmVjdCh3c2ksIHVybCwgc3RhdHVzKQogIG9uQ2xpZW50SHR0cFdyaXRlYWJsZSh3c2ksIC4uLmFyZ3MpCiAgb25SZWNlaXZlQ2xpZW50SHR0cFJlYWQod3NpLCBkYXRhKQogIG9uUmVjZWl2ZUNsaWVudEh0dHAod3NpLCBidWYsIGxlbikKICBvbkNvbXBsZXRlZENsaWVudEh0dHAod3NpKQogIG9uQ2xvc2VkQ2xpZW50SHR0cCh3c2kpCiAgb25DbGllbnRDb25uZWN0aW9uRXJyb3Iod3NpLCBtc2csIGVycm5vKQogIG9uQ2xpZW50SHR0cERyb3BQcm90b2NvbCh3c2kpCiAgY2FsbGJhY2sod3NpLCByZWFzb24sIC4uLmFyZ3MpCiAgLm9uYWJvcnQgPSAoKSA9PgAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					96,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					97,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/fetch.js",
						"symkeys":
						[
							[
								914,
								948
							],
							[
								1409,
								1417
							],
							[
								1505,
								1525
							],
							[
								2153,
								2187
							],
							[
								2261,
								2297
							],
							[
								2606,
								2651
							],
							[
								3223,
								3261
							],
							[
								3558,
								3593
							],
							[
								4462,
								4496
							],
							[
								4655,
								4689
							],
							[
								5052,
								5078
							],
							[
								5196,
								5219
							],
							[
								5329,
								5369
							],
							[
								5508,
								5537
							],
							[
								5650,
								5680
							],
							[
								5883,
								5899
							]
						],
						"symlist":
						[
							" function fetch(url, options = {})",
							"start(c)",
							"(resolve, reject) =>",
							"onServerNewClientInstantiated(wsi)",
							"onEstablishedClientHttp(wsi, status)",
							"onClientAppendHandshakeHeader(wsi, data, len)",
							"onClientHttpRedirect(wsi, url, status)",
							"onClientHttpWriteable(wsi, ...args)",
							"onReceiveClientHttpRead(wsi, data)",
							"onReceiveClientHttp(wsi, buf, len)",
							"onCompletedClientHttp(wsi)",
							"onClosedClientHttp(wsi)",
							"onClientConnectionError(wsi, msg, errno)",
							"onClientHttpDropProtocol(wsi)",
							"callback(wsi, reason, ...args)",
							".onabort = () =>"
						]
					},
					"AQAAAAAAAAAAAAAABQIAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					98,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAFAgAAICBmZXRjaCh1cmwsIG9wdGlvbnMgPSB7fSkKICBzdGFydChjKQoocmVzb2x2ZSwgcmVqZWN0KSA9PgogIG9uU2VydmVyTmV3Q2xpZW50SW5zdGFudGlhdGVkKHdzaSkKICBvbkVzdGFibGlzaGVkQ2xpZW50SHR0cCh3c2ksIHN0YXR1cykKICBvbkNsaWVudEFwcGVuZEhhbmRzaGFrZUhlYWRlcih3c2ksIGRhdGEsIGxlbikKICBvbkNsaWVudEh0dHBSZWRpcmVjdCh3c2ksIHVybCwgc3RhdHVzKQogIG9uQ2xpZW50SHR0cFdyaXRlYWJsZSh3c2ksIC4uLmFyZ3MpCiAgb25SZWNlaXZlQ2xpZW50SHR0cFJlYWQod3NpLCBkYXRhKQogIG9uUmVjZWl2ZUNsaWVudEh0dHAod3NpLCBidWYsIGxlbikKICBvbkNvbXBsZXRlZENsaWVudEh0dHAod3NpKQogIG9uQ2xvc2VkQ2xpZW50SHR0cCh3c2kpCiAgb25DbGllbnRDb25uZWN0aW9uRXJyb3Iod3NpLCBtc2csIGVycm5vKQogIG9uQ2xpZW50SHR0cERyb3BQcm90b2NvbCh3c2kpCiAgY2FsbGJhY2sod3NpLCByZWFzb24sIC4uLmFyZ3MpCiAgLm9uYWJvcnQgPSAoKSA9PgAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					99,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/fetch.js",
						"symkeys":
						[
							[
								914,
								948
							],
							[
								1409,
								1417
							],
							[
								1505,
								1525
							],
							[
								2153,
								2187
							],
							[
								2261,
								2297
							],
							[
								2606,
								2651
							],
							[
								3223,
								3261
							],
							[
								3558,
								3593
							],
							[
								4462,
								4496
							],
							[
								4655,
								4689
							],
							[
								5052,
								5078
							],
							[
								5196,
								5219
							],
							[
								5329,
								5369
							],
							[
								5508,
								5537
							],
							[
								5650,
								5680
							],
							[
								5883,
								5899
							]
						],
						"symlist":
						[
							" function fetch(url, options = {})",
							"start(c)",
							"(resolve, reject) =>",
							"onServerNewClientInstantiated(wsi)",
							"onEstablishedClientHttp(wsi, status)",
							"onClientAppendHandshakeHeader(wsi, data, len)",
							"onClientHttpRedirect(wsi, url, status)",
							"onClientHttpWriteable(wsi, ...args)",
							"onReceiveClientHttpRead(wsi, data)",
							"onReceiveClientHttp(wsi, buf, len)",
							"onCompletedClientHttp(wsi)",
							"onClosedClientHttp(wsi)",
							"onClientConnectionError(wsi, msg, errno)",
							"onClientHttpDropProtocol(wsi)",
							"callback(wsi, reason, ...args)",
							".onabort = () =>"
						]
					},
					"AQAAAAAAAAAAAAAABQIAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					100,
					2,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/fetch.js",
						"symkeys":
						[
							[
								914,
								948
							],
							[
								1409,
								1417
							],
							[
								1505,
								1525
							],
							[
								2153,
								2187
							],
							[
								2261,
								2297
							],
							[
								2606,
								2651
							],
							[
								3223,
								3261
							],
							[
								3558,
								3593
							],
							[
								4462,
								4496
							],
							[
								4655,
								4689
							],
							[
								5052,
								5078
							],
							[
								5196,
								5219
							],
							[
								5353,
								5393
							],
							[
								5532,
								5561
							],
							[
								5674,
								5704
							],
							[
								5907,
								5923
							]
						],
						"symlist":
						[
							" function fetch(url, options = {})",
							"start(c)",
							"(resolve, reject) =>",
							"onServerNewClientInstantiated(wsi)",
							"onEstablishedClientHttp(wsi, status)",
							"onClientAppendHandshakeHeader(wsi, data, len)",
							"onClientHttpRedirect(wsi, url, status)",
							"onClientHttpWriteable(wsi, ...args)",
							"onReceiveClientHttpRead(wsi, data)",
							"onReceiveClientHttp(wsi, buf, len)",
							"onCompletedClientHttp(wsi)",
							"onClosedClientHttp(wsi)",
							"onClientConnectionError(wsi, msg, errno)",
							"onClientHttpDropProtocol(wsi)",
							"callback(wsi, reason, ...args)",
							".onabort = () =>"
						]
					},
					"BAAAAAAAAAAAAAAAAAAAAAAAAAAFAgAAICBmZXRjaCh1cmwsIG9wdGlvbnMgPSB7fSkKICBzdGFydChjKQoocmVzb2x2ZSwgcmVqZWN0KSA9PgogIG9uU2VydmVyTmV3Q2xpZW50SW5zdGFudGlhdGVkKHdzaSkKICBvbkVzdGFibGlzaGVkQ2xpZW50SHR0cCh3c2ksIHN0YXR1cykKICBvbkNsaWVudEFwcGVuZEhhbmRzaGFrZUhlYWRlcih3c2ksIGRhdGEsIGxlbikKICBvbkNsaWVudEh0dHBSZWRpcmVjdCh3c2ksIHVybCwgc3RhdHVzKQogIG9uQ2xpZW50SHR0cFdyaXRlYWJsZSh3c2ksIC4uLmFyZ3MpCiAgb25SZWNlaXZlQ2xpZW50SHR0cFJlYWQod3NpLCBkYXRhKQogIG9uUmVjZWl2ZUNsaWVudEh0dHAod3NpLCBidWYsIGxlbikKICBvbkNvbXBsZXRlZENsaWVudEh0dHAod3NpKQogIG9uQ2xvc2VkQ2xpZW50SHR0cCh3c2kpCiAgb25DbGllbnRDb25uZWN0aW9uRXJyb3Iod3NpLCBtc2csIGVycm5vKQogIG9uQ2xpZW50SHR0cERyb3BQcm90b2NvbCh3c2kpCiAgY2FsbGJhY2sod3NpLCByZWFzb24sIC4uLmFyZ3MpCiAgLm9uYWJvcnQgPSAoKSA9PgAAAAAAAAAABQIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUCAAAgIGZldGNoKHVybCwgb3B0aW9ucyA9IHt9KQogIHN0YXJ0KGMpCihyZXNvbHZlLCByZWplY3QpID0+CiAgb25TZXJ2ZXJOZXdDbGllbnRJbnN0YW50aWF0ZWQod3NpKQogIG9uRXN0YWJsaXNoZWRDbGllbnRIdHRwKHdzaSwgc3RhdHVzKQogIG9uQ2xpZW50QXBwZW5kSGFuZHNoYWtlSGVhZGVyKHdzaSwgZGF0YSwgbGVuKQogIG9uQ2xpZW50SHR0cFJlZGlyZWN0KHdzaSwgdXJsLCBzdGF0dXMpCiAgb25DbGllbnRIdHRwV3JpdGVhYmxlKHdzaSwgLi4uYXJncykKICBvblJlY2VpdmVDbGllbnRIdHRwUmVhZCh3c2ksIGRhdGEpCiAgb25SZWNlaXZlQ2xpZW50SHR0cCh3c2ksIGJ1ZiwgbGVuKQogIG9uQ29tcGxldGVkQ2xpZW50SHR0cCh3c2kpCiAgb25DbG9zZWRDbGllbnRIdHRwKHdzaSkKICBvbkNsaWVudENvbm5lY3Rpb25FcnJvcih3c2ksIG1zZywgZXJybm8pCiAgb25DbGllbnRIdHRwRHJvcFByb3RvY29sKHdzaSkKICBjYWxsYmFjayh3c2ksIHJlYXNvbiwgLi4uYXJncykKICAub25hYm9ydCA9ICgpID0+AAAAAAAAAAAFAgAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					101,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/fetch.js",
						"symkeys":
						[
							[
								914,
								948
							],
							[
								1409,
								1417
							],
							[
								1505,
								1525
							],
							[
								2153,
								2187
							],
							[
								2261,
								2297
							],
							[
								2606,
								2651
							],
							[
								3223,
								3261
							],
							[
								3558,
								3593
							],
							[
								4462,
								4496
							],
							[
								4655,
								4689
							],
							[
								5052,
								5078
							],
							[
								5196,
								5219
							],
							[
								5357,
								5397
							],
							[
								5536,
								5565
							],
							[
								5678,
								5708
							],
							[
								5911,
								5927
							]
						],
						"symlist":
						[
							" function fetch(url, options = {})",
							"start(c)",
							"(resolve, reject) =>",
							"onServerNewClientInstantiated(wsi)",
							"onEstablishedClientHttp(wsi, status)",
							"onClientAppendHandshakeHeader(wsi, data, len)",
							"onClientHttpRedirect(wsi, url, status)",
							"onClientHttpWriteable(wsi, ...args)",
							"onReceiveClientHttpRead(wsi, data)",
							"onReceiveClientHttp(wsi, buf, len)",
							"onCompletedClientHttp(wsi)",
							"onClosedClientHttp(wsi)",
							"onClientConnectionError(wsi, msg, errno)",
							"onClientHttpDropProtocol(wsi)",
							"callback(wsi, reason, ...args)",
							".onabort = () =>"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAFAgAAICBmZXRjaCh1cmwsIG9wdGlvbnMgPSB7fSkKICBzdGFydChjKQoocmVzb2x2ZSwgcmVqZWN0KSA9PgogIG9uU2VydmVyTmV3Q2xpZW50SW5zdGFudGlhdGVkKHdzaSkKICBvbkVzdGFibGlzaGVkQ2xpZW50SHR0cCh3c2ksIHN0YXR1cykKICBvbkNsaWVudEFwcGVuZEhhbmRzaGFrZUhlYWRlcih3c2ksIGRhdGEsIGxlbikKICBvbkNsaWVudEh0dHBSZWRpcmVjdCh3c2ksIHVybCwgc3RhdHVzKQogIG9uQ2xpZW50SHR0cFdyaXRlYWJsZSh3c2ksIC4uLmFyZ3MpCiAgb25SZWNlaXZlQ2xpZW50SHR0cFJlYWQod3NpLCBkYXRhKQogIG9uUmVjZWl2ZUNsaWVudEh0dHAod3NpLCBidWYsIGxlbikKICBvbkNvbXBsZXRlZENsaWVudEh0dHAod3NpKQogIG9uQ2xvc2VkQ2xpZW50SHR0cCh3c2kpCiAgb25DbGllbnRDb25uZWN0aW9uRXJyb3Iod3NpLCBtc2csIGVycm5vKQogIG9uQ2xpZW50SHR0cERyb3BQcm90b2NvbCh3c2kpCiAgY2FsbGJhY2sod3NpLCByZWFzb24sIC4uLmFyZ3MpCiAgLm9uYWJvcnQgPSAoKSA9PgAAAAAAAAAABQIAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					102,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/fetch.js",
						"symkeys":
						[
							[
								914,
								948
							],
							[
								1409,
								1417
							],
							[
								1505,
								1525
							],
							[
								2153,
								2187
							],
							[
								2261,
								2297
							],
							[
								2606,
								2651
							],
							[
								3223,
								3261
							],
							[
								3558,
								3593
							],
							[
								4462,
								4496
							],
							[
								4655,
								4689
							],
							[
								5052,
								5078
							],
							[
								5196,
								5219
							],
							[
								5357,
								5397
							],
							[
								5536,
								5565
							],
							[
								5678,
								5708
							],
							[
								5911,
								5927
							]
						],
						"symlist":
						[
							" function fetch(url, options = {})",
							"start(c)",
							"(resolve, reject) =>",
							"onServerNewClientInstantiated(wsi)",
							"onEstablishedClientHttp(wsi, status)",
							"onClientAppendHandshakeHeader(wsi, data, len)",
							"onClientHttpRedirect(wsi, url, status)",
							"onClientHttpWriteable(wsi, ...args)",
							"onReceiveClientHttpRead(wsi, data)",
							"onReceiveClientHttp(wsi, buf, len)",
							"onCompletedClientHttp(wsi)",
							"onClosedClientHttp(wsi)",
							"onClientConnectionError(wsi, msg, errno)",
							"onClientHttpDropProtocol(wsi)",
							"callback(wsi, reason, ...args)",
							".onabort = () =>"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAFAgAAICBmZXRjaCh1cmwsIG9wdGlvbnMgPSB7fSkKICBzdGFydChjKQoocmVzb2x2ZSwgcmVqZWN0KSA9PgogIG9uU2VydmVyTmV3Q2xpZW50SW5zdGFudGlhdGVkKHdzaSkKICBvbkVzdGFibGlzaGVkQ2xpZW50SHR0cCh3c2ksIHN0YXR1cykKICBvbkNsaWVudEFwcGVuZEhhbmRzaGFrZUhlYWRlcih3c2ksIGRhdGEsIGxlbikKICBvbkNsaWVudEh0dHBSZWRpcmVjdCh3c2ksIHVybCwgc3RhdHVzKQogIG9uQ2xpZW50SHR0cFdyaXRlYWJsZSh3c2ksIC4uLmFyZ3MpCiAgb25SZWNlaXZlQ2xpZW50SHR0cFJlYWQod3NpLCBkYXRhKQogIG9uUmVjZWl2ZUNsaWVudEh0dHAod3NpLCBidWYsIGxlbikKICBvbkNvbXBsZXRlZENsaWVudEh0dHAod3NpKQogIG9uQ2xvc2VkQ2xpZW50SHR0cCh3c2kpCiAgb25DbGllbnRDb25uZWN0aW9uRXJyb3Iod3NpLCBtc2csIGVycm5vKQogIG9uQ2xpZW50SHR0cERyb3BQcm90b2NvbCh3c2kpCiAgY2FsbGJhY2sod3NpLCByZWFzb24sIC4uLmFyZ3MpCiAgLm9uYWJvcnQgPSAoKSA9PgAAAAAAAAAABQIAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					103,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAFAgAAICBmZXRjaCh1cmwsIG9wdGlvbnMgPSB7fSkKICBzdGFydChjKQoocmVzb2x2ZSwgcmVqZWN0KSA9PgogIG9uU2VydmVyTmV3Q2xpZW50SW5zdGFudGlhdGVkKHdzaSkKICBvbkVzdGFibGlzaGVkQ2xpZW50SHR0cCh3c2ksIHN0YXR1cykKICBvbkNsaWVudEFwcGVuZEhhbmRzaGFrZUhlYWRlcih3c2ksIGRhdGEsIGxlbikKICBvbkNsaWVudEh0dHBSZWRpcmVjdCh3c2ksIHVybCwgc3RhdHVzKQogIG9uQ2xpZW50SHR0cFdyaXRlYWJsZSh3c2ksIC4uLmFyZ3MpCiAgb25SZWNlaXZlQ2xpZW50SHR0cFJlYWQod3NpLCBkYXRhKQogIG9uUmVjZWl2ZUNsaWVudEh0dHAod3NpLCBidWYsIGxlbikKICBvbkNvbXBsZXRlZENsaWVudEh0dHAod3NpKQogIG9uQ2xvc2VkQ2xpZW50SHR0cCh3c2kpCiAgb25DbGllbnRDb25uZWN0aW9uRXJyb3Iod3NpLCBtc2csIGVycm5vKQogIG9uQ2xpZW50SHR0cERyb3BQcm90b2NvbCh3c2kpCiAgY2FsbGJhY2sod3NpLCByZWFzb24sIC4uLmFyZ3MpCiAgLm9uYWJvcnQgPSAoKSA9PgAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					104,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-write.h",
						"symkeys":
						[
							[
								1329,
								1342
							],
							[
								1365,
								1436
							],
							[
								1508,
								1526
							],
							[
								3641,
								3659
							],
							[
								4648,
								4666
							],
							[
								6639,
								6656
							],
							[
								8189,
								8198
							],
							[
								8343,
								8357
							],
							[
								8866,
								8884
							],
							[
								9573,
								9602
							]
						],
						"symlist":
						[
							"â€ƒâ“‚â€‚â€ƒLWS_WRITE_RAWâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€‚â€‚âœŽâ€‚â€ƒNOTE: These public enums are part of the abi.  If you want to add one,",
							"â€”â’¸â€“â€ƒlws_write_protocolâ€ƒ{â€‰â€¦â€‰}â€‰;â€ƒâ€”â€ƒtype",
							"â€”â’¸â€“â€ƒlws_write_passthruâ€ƒ{â€‰â€¦â€‰}â€‰;â€ƒâ€”â€ƒtype",
							"â€‚â€‚âœŽâ€‚â€ƒIMPORTANT NOTICE!",
							"===â€ƒ==========================================================",
							"â€”â’»â€“â€ƒlws_writeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â“‚â€“â€ƒlws_write_httpâ€‰(â€‰)â€ƒâ€¦â€ƒâ€”â€ƒmacro function",
							"â€”â’»â€“â€ƒlws_write_ws_flagsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€ƒâ’¡â€‚â€ƒlws_raw_transaction_completedâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration"
						]
					},
					"AQAAAAAAAAAAAAAAwgEAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					105,
					2,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AwAAAAAAAAAAAAAAAAAAAAAAAAACAgAA4pOCICBMV1NfV1JJVEVfUkFXIOKApiDigJQgbWFjcm8gb2JqZWN0CuKcjiAgTk9URTogVGhlc2UgcHVibGljIGVudW1zIGFyZSBwYXJ0IG9mIHRoZSBhYmkuICBJZiB5b3Ugd2FudCB0byBhZGQgb25lLArigJTikrjigJMgbHdzX3dyaXRlX3Byb3RvY29sIHsg4oCmIH0gOyDigJQgdHlwZQrigJTikrjigJMgbHdzX3dyaXRlX3Bhc3N0aHJ1IHsg4oCmIH0gOyDigJQgdHlwZQrinI4gIElNUE9SVEFOVCBOT1RJQ0UhCj09PSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CuKAlOKSu+KAkyBsd3Nfd3JpdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKTguKAkyBsd3Nfd3JpdGVfaHR0cCAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgrigJTikrvigJMgbHdzX3dyaXRlX3dzX2ZsYWdzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrikqEgIGx3c19yYXdfdHJhbnNhY3Rpb25fY29tcGxldGVkICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					106,
					3,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					107,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-write.h",
						"symkeys":
						[
							[
								1329,
								1342
							],
							[
								1365,
								1436
							],
							[
								1508,
								1526
							],
							[
								3641,
								3659
							],
							[
								4648,
								4666
							],
							[
								6639,
								6656
							],
							[
								8189,
								8198
							],
							[
								8343,
								8357
							],
							[
								8866,
								8884
							],
							[
								9573,
								9602
							]
						],
						"symlist":
						[
							"â€ƒâ“‚â€‚â€ƒLWS_WRITE_RAWâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€‚â€‚âœŽâ€‚â€ƒNOTE: These public enums are part of the abi.  If you want to add one,",
							"â€”â’¸â€“â€ƒlws_write_protocolâ€ƒ{â€‰â€¦â€‰}â€‰;â€ƒâ€”â€ƒtype",
							"â€”â’¸â€“â€ƒlws_write_passthruâ€ƒ{â€‰â€¦â€‰}â€‰;â€ƒâ€”â€ƒtype",
							"â€‚â€‚âœŽâ€‚â€ƒIMPORTANT NOTICE!",
							"===â€ƒ==========================================================",
							"â€”â’»â€“â€ƒlws_writeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â“‚â€“â€ƒlws_write_httpâ€‰(â€‰)â€ƒâ€¦â€ƒâ€”â€ƒmacro function",
							"â€”â’»â€“â€ƒlws_write_ws_flagsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€ƒâ’¡â€‚â€ƒlws_raw_transaction_completedâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration"
						]
					},
					"AQAAAAAAAAAAAAAAwgEAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					108,
					2,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AwAAAAAAAAAAAAAAAAAAAAAAAAACAgAA4pOCICBMV1NfV1JJVEVfUkFXIOKApiDigJQgbWFjcm8gb2JqZWN0CuKcjiAgTk9URTogVGhlc2UgcHVibGljIGVudW1zIGFyZSBwYXJ0IG9mIHRoZSBhYmkuICBJZiB5b3Ugd2FudCB0byBhZGQgb25lLArigJTikrjigJMgbHdzX3dyaXRlX3Byb3RvY29sIHsg4oCmIH0gOyDigJQgdHlwZQrigJTikrjigJMgbHdzX3dyaXRlX3Bhc3N0aHJ1IHsg4oCmIH0gOyDigJQgdHlwZQrinI4gIElNUE9SVEFOVCBOT1RJQ0UhCj09PSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CuKAlOKSu+KAkyBsd3Nfd3JpdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKTguKAkyBsd3Nfd3JpdGVfaHR0cCAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgrigJTikrvigJMgbHdzX3dyaXRlX3dzX2ZsYWdzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrikqEgIGx3c19yYXdfdHJhbnNhY3Rpb25fY29tcGxldGVkICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					109,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/output.c",
						"symkeys":
						[
							[
								1320,
								1333
							],
							[
								6211,
								6220
							],
							[
								6943,
								6970
							],
							[
								8212,
								8240
							],
							[
								9790,
								9812
							]
						],
						"symlist":
						[
							"â€”â’»â€“â€ƒlws_issue_rawâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_writeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_ssl_capable_read_no_sslâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_ssl_capable_write_no_sslâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_ssl_pending_no_sslâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AQAAAAAAAAAAAAAA5AAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					110,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAWAQAA4oCU4pK74oCTIGx3c19pc3N1ZV9yYXcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfd3JpdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfc3NsX2NhcGFibGVfcmVhZF9ub19zc2wgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfc3NsX2NhcGFibGVfd3JpdGVfbm9fc3NsICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3NzbF9wZW5kaW5nX25vX3NzbCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24AAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					111,
					2,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					112,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					113,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/optee/network.c",
						"symkeys":
						[
							[
								1409,
								1429
							],
							[
								1467,
								1487
							],
							[
								1526,
								1545
							],
							[
								1572,
								1601
							],
							[
								1675,
								1695
							],
							[
								2266,
								2284
							],
							[
								2356,
								2377
							],
							[
								4480,
								4496
							],
							[
								4606,
								4633
							],
							[
								4702,
								4721
							],
							[
								4869,
								4888
							],
							[
								4989,
								5020
							],
							[
								5183,
								5214
							],
							[
								5368,
								5390
							],
							[
								5498,
								5516
							],
							[
								5647,
								5665
							],
							[
								5757,
								5787
							],
							[
								5853,
								5887
							],
							[
								5963,
								5988
							],
							[
								6474,
								6499
							]
						],
						"symlist":
						[
							"â€”â’»â€“â€ƒlws_plat_pipe_createâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_pipe_signalâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_pipe_closeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_pipe_is_fd_assocatedâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_send_pipe_chokedâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_poll_listen_fdâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒ_lws_plat_service_tsiâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_serviceâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_socket_optionsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_write_certâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_interface_to_saâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_insert_socket_into_fdsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_delete_socket_from_fdsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_change_pollfdâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_inet_ntopâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_inet_ptonâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_socket_options_ipâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_vhost_tls_client_ctx_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_mbedtls_net_sendâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_mbedtls_net_recvâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AQAAAAAAAAAAAAAA1QMAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					114,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACdBAAA4oCU4pK74oCTIGx3c19wbGF0X3BpcGVfY3JlYXRlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfcGlwZV9zaWduYWwgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9waXBlX2Nsb3NlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfcGlwZV9pc19mZF9hc3NvY2F0ZWQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfc2VuZF9waXBlX2Nob2tlZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wb2xsX2xpc3Rlbl9mZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIF9sd3NfcGxhdF9zZXJ2aWNlX3RzaSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X3NlcnZpY2UgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9zZXRfc29ja2V0X29wdGlvbnMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF93cml0ZV9jZXJ0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX2ludGVyZmFjZV90b19zYSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2luc2VydF9zb2NrZXRfaW50b19mZHMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9kZWxldGVfc29ja2V0X2Zyb21fZmRzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfY2hhbmdlX3BvbGxmZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2luZXRfbnRvcCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2luZXRfcHRvbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X3NldF9zb2NrZXRfb3B0aW9uc19pcCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X3Zob3N0X3Rsc19jbGllbnRfY3R4X2luaXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9tYmVkdGxzX25ldF9zZW5kICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfbWJlZHRsc19uZXRfcmVjdiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24AAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					115,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-sockets.c",
						"symkeys":
						[
							[
								1427,
								1447
							],
							[
								2207,
								2225
							],
							[
								2410,
								2434
							],
							[
								2508,
								2535
							],
							[
								4324,
								4354
							],
							[
								5806,
								5825
							],
							[
								7427,
								7445
							],
							[
								7549,
								7567
							],
							[
								7653,
								7678
							],
							[
								7816,
								7841
							],
							[
								8021,
								8035
							],
							[
								8155,
								8176
							],
							[
								8300,
								8317
							],
							[
								8434,
								8468
							],
							[
								8544,
								8569
							],
							[
								9055,
								9080
							]
						],
						"symlist":
						[
							"â€”â’»â€“â€ƒlws_send_pipe_chokedâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_poll_listen_fdâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_nonblockingâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_socket_optionsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_socket_options_ipâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_interface_to_saâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_inet_ntopâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_inet_ptonâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_ifname_to_hwaddrâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_rawudp_broadcastâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_if_upâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_BINDTODEVICEâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_ifconfigâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_vhost_tls_client_ctx_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_mbedtls_net_sendâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_mbedtls_net_recvâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AQAAAAAAAAAAAAAABwMAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					116,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACnAwAA4oCU4pK74oCTIGx3c19zZW5kX3BpcGVfY2hva2VkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BvbGxfbGlzdGVuX2ZkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfc2V0X25vbmJsb2NraW5nICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfc2V0X3NvY2tldF9vcHRpb25zICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfc2V0X3NvY2tldF9vcHRpb25zX2lwICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX2ludGVyZmFjZV90b19zYSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2luZXRfbnRvcCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2luZXRfcHRvbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2lmbmFtZV90b19od2FkZHIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9yYXd1ZHBfYnJvYWRjYXN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfaWZfdXAgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9CSU5EVE9ERVZJQ0UgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9pZmNvbmZpZyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X3Zob3N0X3Rsc19jbGllbnRfY3R4X2luaXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9tYmVkdGxzX25ldF9zZW5kICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfbWJlZHRsc19uZXRfcmVjdiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24AAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					117,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-misc.c",
						"symkeys":
						[
							[
								1257,
								1268
							],
							[
								1498,
								1508
							],
							[
								1594,
								1607
							],
							[
								1981,
								1995
							],
							[
								2224,
								2240
							],
							[
								2581,
								2600
							],
							[
								2831,
								2860
							],
							[
								2950,
								2975
							]
						],
						"symlist":
						[
							"â€ƒâ“‚â€‚â€ƒ_GNU_SOURCEâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€”â’»â€“â€ƒlws_msleepâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_now_usecsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_get_randomâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsl_emit_syslogâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_write_certâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_recommended_rsa_bitsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_ntpclient_configâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AQAAAAAAAAAAAAAAUwEAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					118,
					2,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AwAAAAAAAAAAAAAAAAAAAAAAAACfAQAA4pOCICBfR05VX1NPVVJDRSDigKYg4oCUIG1hY3JvIG9iamVjdArigJTikrvigJMgbHdzX21zbGVlcCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19ub3dfdXNlY3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfZ2V0X3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c2xfZW1pdF9zeXNsb2cgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF93cml0ZV9jZXJ0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfcmVjb21tZW5kZWRfcnNhX2JpdHMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9udHBjbGllbnRfY29uZmlnICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					119,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-misc.c",
						"symkeys":
						[
							[
								1257,
								1268
							],
							[
								1498,
								1508
							],
							[
								1594,
								1607
							],
							[
								1981,
								1995
							],
							[
								2224,
								2240
							],
							[
								2581,
								2600
							],
							[
								2831,
								2860
							],
							[
								2950,
								2975
							]
						],
						"symlist":
						[
							"â€ƒâ“‚â€‚â€ƒ_GNU_SOURCEâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€”â’»â€“â€ƒlws_msleepâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_now_usecsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_get_randomâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsl_emit_syslogâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_write_certâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_recommended_rsa_bitsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_ntpclient_configâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AQAAAAAAAAAAAAAAUwEAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					120,
					2,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AwAAAAAAAAAAAAAAAAAAAAAAAACfAQAA4pOCICBfR05VX1NPVVJDRSDigKYg4oCUIG1hY3JvIG9iamVjdArigJTikrvigJMgbHdzX21zbGVlcCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19ub3dfdXNlY3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfZ2V0X3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c2xfZW1pdF9zeXNsb2cgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF93cml0ZV9jZXJ0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfcmVjb21tZW5kZWRfcnNhX2JpdHMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9udHBjbGllbnRfY29uZmlnICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					121,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/lws-context.c",
						"symkeys":
						[
							[
								255,
								272
							],
							[
								1423,
								1441
							],
							[
								1511,
								1533
							],
							[
								1569,
								1587
							],
							[
								1706,
								1721
							],
							[
								1739,
								1757
							],
							[
								2062,
								2076
							],
							[
								2350,
								2363
							],
							[
								2735,
								2751
							],
							[
								3026,
								3039
							],
							[
								3595,
								3610
							],
							[
								3733,
								3750
							],
							[
								4070,
								4086
							],
							[
								4514,
								4529
							],
							[
								6154,
								6167
							],
							[
								6468,
								6479
							],
							[
								7779,
								7792
							],
							[
								8214,
								8231
							],
							[
								18681,
								18691
							],
							[
								19434,
								19452
							],
							[
								20278,
								20291
							],
							[
								20292,
								20305
							],
							[
								21507,
								21520
							],
							[
								21908,
								21927
							],
							[
								23563,
								23577
							],
							[
								23755,
								23770
							],
							[
								26545,
								26561
							],
							[
								27809,
								27825
							],
							[
								28934,
								28951
							],
							[
								30037,
								30055
							],
							[
								30925,
								30947
							],
							[
								31113,
								31131
							],
							[
								31496,
								31523
							],
							[
								33333,
								33357
							],
							[
								34081,
								34116
							],
							[
								38249,
								38281
							],
							[
								40821,
								40832
							],
							[
								40983,
								40995
							],
							[
								41349,
								41374
							],
							[
								42707,
								42728
							],
							[
								46659,
								46676
							],
							[
								47661,
								47684
							],
							[
								49342,
								49360
							]
						],
						"symlist":
						[
							"â€ƒâ“‚â€‚â€ƒLWS_PLUGIN_STATICâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€ƒâ’¡â€‚â€ƒvhost_options_fromâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ’¡â€‚â€ƒvhost_options_fromfreeâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ’¡â€‚â€ƒvhost_options_freeâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ“‰â€‚â€ƒHandlerFunctionâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€”â’»â€“â€ƒiohandler_functionâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_findâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_addâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_removeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_setâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_clearâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_cleanupâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒprotocol_handlerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒpollfd_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒwsi_to_js_ctxâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhttp_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒprotocol_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒc_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_protocol_objâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’¸â€“â€ƒlws_protocolsâ€ƒ{â€‰â€¦â€‰}â€‰;â€ƒâ€”â€ƒtype",
							"â€”â’»â€“â€ƒprotocol_fromâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒprotocol_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒprotocols_fromarrayâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒprotocols_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhttp_mount_fromâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhttp_mounts_fromâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhttp_mounts_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒvhost_option_fromâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒvhost_options_fromâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒvhost_options_fromfreeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒvhost_options_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒclient_connect_info_fromobjâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒclient_connect_info_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_creation_info_fromobjâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_creation_info_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒcontext_newâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒcontext_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_constructorâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_methodsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_getâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_finalizerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AQAAAAAAAAAAAAAASQcAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					122,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-misc.c",
						"symkeys":
						[
							[
								1257,
								1268
							],
							[
								1498,
								1508
							],
							[
								1594,
								1607
							],
							[
								1981,
								1995
							],
							[
								2224,
								2240
							],
							[
								2581,
								2600
							],
							[
								2831,
								2860
							],
							[
								2950,
								2975
							]
						],
						"symlist":
						[
							"â€ƒâ“‚â€‚â€ƒ_GNU_SOURCEâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€”â’»â€“â€ƒlws_msleepâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_now_usecsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_get_randomâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsl_emit_syslogâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_write_certâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_recommended_rsa_bitsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_ntpclient_configâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAADbCAAA4pOCICBMV1NfUExVR0lOX1NUQVRJQyDigKYg4oCUIG1hY3JvIG9iamVjdArikqEgIHZob3N0X29wdGlvbnNfZnJvbSAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4pKhICB2aG9zdF9vcHRpb25zX2Zyb21mcmVlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgrikqEgIHZob3N0X29wdGlvbnNfZnJlZSAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4pOJICBIYW5kbGVyRnVuY3Rpb24gOyDigJQgdHlwZWRlZgrigJTikrvigJMgaW9oYW5kbGVyX2Z1bmN0aW9uICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgaW9oYW5kbGVyX2ZpbmQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBpb2hhbmRsZXJfYWRkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgaW9oYW5kbGVyX3JlbW92ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGlvaGFuZGxlcl9zZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBpb2hhbmRsZXJfY2xlYXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBpb2hhbmRsZXJfY2xlYW51cCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHByb3RvY29sX2hhbmRsZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwb2xsZmRfY2FsbGJhY2sgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB3c2lfdG9fanNfY3R4ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfY2FsbGJhY2sgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBodHRwX2NhbGxiYWNrICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgcHJvdG9jb2xfY2FsbGJhY2sgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBjX2NhbGxiYWNrICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfcHJvdG9jb2xfb2JqICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrjigJMgbHdzX3Byb3RvY29scyB7IOKApiB9IDsg4oCUIHR5cGUK4oCU4pK74oCTIHByb3RvY29sX2Zyb20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwcm90b2NvbF9mcmVlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgcHJvdG9jb2xzX2Zyb21hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHByb3RvY29sc19mcmVlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgaHR0cF9tb3VudF9mcm9tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgaHR0cF9tb3VudHNfZnJvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGh0dHBfbW91bnRzX2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2aG9zdF9vcHRpb25fZnJvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZob3N0X29wdGlvbnNfZnJvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZob3N0X29wdGlvbnNfZnJvbWZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2aG9zdF9vcHRpb25zX2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBjbGllbnRfY29ubmVjdF9pbmZvX2Zyb21vYmogKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBjbGllbnRfY29ubmVjdF9pbmZvX2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nqc19jb250ZXh0X2NyZWF0aW9uX2luZm9fZnJvbW9iaiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c2pzX2NvbnRleHRfY3JlYXRpb25faW5mb19mcmVlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgY29udGV4dF9uZXcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBjb250ZXh0X2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nqc19jb250ZXh0X2NvbnN0cnVjdG9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfY29udGV4dF9tZXRob2RzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfY29udGV4dF9nZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nqc19jb250ZXh0X2ZpbmFsaXplciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c2pzX2NvbnRleHRfaW5pdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24AAAAAAAAAAFMBAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					123,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-sockets.c",
						"symkeys":
						[
							[
								1427,
								1447
							],
							[
								2207,
								2225
							],
							[
								2410,
								2434
							],
							[
								2508,
								2535
							],
							[
								4324,
								4354
							],
							[
								5806,
								5825
							],
							[
								7427,
								7445
							],
							[
								7549,
								7567
							],
							[
								7653,
								7678
							],
							[
								7816,
								7841
							],
							[
								8021,
								8035
							],
							[
								8155,
								8176
							],
							[
								8300,
								8317
							],
							[
								8434,
								8468
							],
							[
								8544,
								8569
							],
							[
								9055,
								9080
							]
						],
						"symlist":
						[
							"â€”â’»â€“â€ƒlws_send_pipe_chokedâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_poll_listen_fdâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_nonblockingâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_socket_optionsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_socket_options_ipâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_interface_to_saâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_inet_ntopâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_inet_ptonâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_ifname_to_hwaddrâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_rawudp_broadcastâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_if_upâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_BINDTODEVICEâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_ifconfigâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_vhost_tls_client_ctx_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_mbedtls_net_sendâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_mbedtls_net_recvâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACfAQAA4pOCICBfR05VX1NPVVJDRSDigKYg4oCUIG1hY3JvIG9iamVjdArigJTikrvigJMgbHdzX21zbGVlcCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19ub3dfdXNlY3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfZ2V0X3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c2xfZW1pdF9zeXNsb2cgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF93cml0ZV9jZXJ0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfcmVjb21tZW5kZWRfcnNhX2JpdHMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9udHBjbGllbnRfY29uZmlnICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgAAAAAAAAAABwMAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					124,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/lws-context.c",
						"symkeys":
						[
							[
								255,
								272
							],
							[
								1423,
								1441
							],
							[
								1511,
								1533
							],
							[
								1569,
								1587
							],
							[
								1706,
								1721
							],
							[
								1739,
								1757
							],
							[
								2062,
								2076
							],
							[
								2350,
								2363
							],
							[
								2735,
								2751
							],
							[
								3026,
								3039
							],
							[
								3595,
								3610
							],
							[
								3733,
								3750
							],
							[
								4070,
								4086
							],
							[
								4514,
								4529
							],
							[
								6154,
								6167
							],
							[
								6468,
								6479
							],
							[
								7779,
								7792
							],
							[
								8214,
								8231
							],
							[
								18681,
								18691
							],
							[
								19434,
								19452
							],
							[
								20278,
								20291
							],
							[
								20292,
								20305
							],
							[
								21507,
								21520
							],
							[
								21908,
								21927
							],
							[
								23563,
								23577
							],
							[
								23755,
								23770
							],
							[
								26545,
								26561
							],
							[
								27809,
								27825
							],
							[
								28934,
								28951
							],
							[
								30037,
								30055
							],
							[
								30925,
								30947
							],
							[
								31113,
								31131
							],
							[
								31496,
								31523
							],
							[
								33333,
								33357
							],
							[
								34081,
								34116
							],
							[
								38249,
								38281
							],
							[
								40821,
								40832
							],
							[
								40983,
								40995
							],
							[
								41349,
								41374
							],
							[
								42707,
								42728
							],
							[
								46659,
								46676
							],
							[
								47661,
								47684
							],
							[
								49342,
								49360
							]
						],
						"symlist":
						[
							"â€ƒâ“‚â€‚â€ƒLWS_PLUGIN_STATICâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€ƒâ’¡â€‚â€ƒvhost_options_fromâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ’¡â€‚â€ƒvhost_options_fromfreeâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ’¡â€‚â€ƒvhost_options_freeâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ“‰â€‚â€ƒHandlerFunctionâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€”â’»â€“â€ƒiohandler_functionâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_findâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_addâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_removeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_setâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_clearâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_cleanupâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒprotocol_handlerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒpollfd_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒwsi_to_js_ctxâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhttp_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒprotocol_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒc_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_protocol_objâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’¸â€“â€ƒlws_protocolsâ€ƒ{â€‰â€¦â€‰}â€‰;â€ƒâ€”â€ƒtype",
							"â€”â’»â€“â€ƒprotocol_fromâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒprotocol_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒprotocols_fromarrayâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒprotocols_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhttp_mount_fromâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhttp_mounts_fromâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhttp_mounts_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒvhost_option_fromâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒvhost_options_fromâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒvhost_options_fromfreeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒvhost_options_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒclient_connect_info_fromobjâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒclient_connect_info_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_creation_info_fromobjâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_creation_info_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒcontext_newâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒcontext_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_constructorâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_methodsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_getâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_finalizerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACnAwAA4oCU4pK74oCTIGx3c19zZW5kX3BpcGVfY2hva2VkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BvbGxfbGlzdGVuX2ZkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfc2V0X25vbmJsb2NraW5nICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfc2V0X3NvY2tldF9vcHRpb25zICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfc2V0X3NvY2tldF9vcHRpb25zX2lwICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX2ludGVyZmFjZV90b19zYSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2luZXRfbnRvcCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2luZXRfcHRvbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2lmbmFtZV90b19od2FkZHIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9yYXd1ZHBfYnJvYWRjYXN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfaWZfdXAgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9CSU5EVE9ERVZJQ0UgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9pZmNvbmZpZyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X3Zob3N0X3Rsc19jbGllbnRfY3R4X2luaXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9tYmVkdGxzX25ldF9zZW5kICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfbWJlZHRsc19uZXRfcmVjdiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24AAAAAAAAAAEkHAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					125,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-sockets.c",
						"symkeys":
						[
							[
								1427,
								1447
							],
							[
								2207,
								2225
							],
							[
								2410,
								2434
							],
							[
								2508,
								2535
							],
							[
								4324,
								4354
							],
							[
								5806,
								5825
							],
							[
								7427,
								7445
							],
							[
								7549,
								7567
							],
							[
								7653,
								7678
							],
							[
								7816,
								7841
							],
							[
								8021,
								8035
							],
							[
								8155,
								8176
							],
							[
								8300,
								8317
							],
							[
								8434,
								8468
							],
							[
								8544,
								8569
							],
							[
								9055,
								9080
							]
						],
						"symlist":
						[
							"â€”â’»â€“â€ƒlws_send_pipe_chokedâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_poll_listen_fdâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_nonblockingâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_socket_optionsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_socket_options_ipâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_interface_to_saâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_inet_ntopâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_inet_ptonâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_ifname_to_hwaddrâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_rawudp_broadcastâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_if_upâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_BINDTODEVICEâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_ifconfigâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_vhost_tls_client_ctx_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_mbedtls_net_sendâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_mbedtls_net_recvâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAADbCAAA4pOCICBMV1NfUExVR0lOX1NUQVRJQyDigKYg4oCUIG1hY3JvIG9iamVjdArikqEgIHZob3N0X29wdGlvbnNfZnJvbSAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4pKhICB2aG9zdF9vcHRpb25zX2Zyb21mcmVlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgrikqEgIHZob3N0X29wdGlvbnNfZnJlZSAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4pOJICBIYW5kbGVyRnVuY3Rpb24gOyDigJQgdHlwZWRlZgrigJTikrvigJMgaW9oYW5kbGVyX2Z1bmN0aW9uICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgaW9oYW5kbGVyX2ZpbmQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBpb2hhbmRsZXJfYWRkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgaW9oYW5kbGVyX3JlbW92ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGlvaGFuZGxlcl9zZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBpb2hhbmRsZXJfY2xlYXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBpb2hhbmRsZXJfY2xlYW51cCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHByb3RvY29sX2hhbmRsZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwb2xsZmRfY2FsbGJhY2sgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB3c2lfdG9fanNfY3R4ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfY2FsbGJhY2sgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBodHRwX2NhbGxiYWNrICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgcHJvdG9jb2xfY2FsbGJhY2sgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBjX2NhbGxiYWNrICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfcHJvdG9jb2xfb2JqICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrjigJMgbHdzX3Byb3RvY29scyB7IOKApiB9IDsg4oCUIHR5cGUK4oCU4pK74oCTIHByb3RvY29sX2Zyb20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwcm90b2NvbF9mcmVlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgcHJvdG9jb2xzX2Zyb21hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHByb3RvY29sc19mcmVlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgaHR0cF9tb3VudF9mcm9tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgaHR0cF9tb3VudHNfZnJvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGh0dHBfbW91bnRzX2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2aG9zdF9vcHRpb25fZnJvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZob3N0X29wdGlvbnNfZnJvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZob3N0X29wdGlvbnNfZnJvbWZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2aG9zdF9vcHRpb25zX2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBjbGllbnRfY29ubmVjdF9pbmZvX2Zyb21vYmogKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBjbGllbnRfY29ubmVjdF9pbmZvX2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nqc19jb250ZXh0X2NyZWF0aW9uX2luZm9fZnJvbW9iaiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c2pzX2NvbnRleHRfY3JlYXRpb25faW5mb19mcmVlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgY29udGV4dF9uZXcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBjb250ZXh0X2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nqc19jb250ZXh0X2NvbnN0cnVjdG9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfY29udGV4dF9tZXRob2RzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfY29udGV4dF9nZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nqc19jb250ZXh0X2ZpbmFsaXplciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c2pzX2NvbnRleHRfaW5pdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24AAAAAAAAAAAcDAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					126,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/lws-context.c",
						"symkeys":
						[
							[
								255,
								272
							],
							[
								1423,
								1441
							],
							[
								1511,
								1533
							],
							[
								1569,
								1587
							],
							[
								1706,
								1721
							],
							[
								1739,
								1757
							],
							[
								2062,
								2076
							],
							[
								2350,
								2363
							],
							[
								2735,
								2751
							],
							[
								3026,
								3039
							],
							[
								3595,
								3610
							],
							[
								3733,
								3750
							],
							[
								4070,
								4086
							],
							[
								4514,
								4529
							],
							[
								6154,
								6167
							],
							[
								6468,
								6479
							],
							[
								7779,
								7792
							],
							[
								8214,
								8231
							],
							[
								18681,
								18691
							],
							[
								19434,
								19452
							],
							[
								20278,
								20291
							],
							[
								20292,
								20305
							],
							[
								21507,
								21520
							],
							[
								21908,
								21927
							],
							[
								23563,
								23577
							],
							[
								23755,
								23770
							],
							[
								26545,
								26561
							],
							[
								27809,
								27825
							],
							[
								28934,
								28951
							],
							[
								30037,
								30055
							],
							[
								30925,
								30947
							],
							[
								31113,
								31131
							],
							[
								31496,
								31523
							],
							[
								33333,
								33357
							],
							[
								34081,
								34116
							],
							[
								38249,
								38281
							],
							[
								40821,
								40832
							],
							[
								40983,
								40995
							],
							[
								41349,
								41374
							],
							[
								42707,
								42728
							],
							[
								46659,
								46676
							],
							[
								47661,
								47684
							],
							[
								49342,
								49360
							]
						],
						"symlist":
						[
							"â€ƒâ“‚â€‚â€ƒLWS_PLUGIN_STATICâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€ƒâ’¡â€‚â€ƒvhost_options_fromâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ’¡â€‚â€ƒvhost_options_fromfreeâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ’¡â€‚â€ƒvhost_options_freeâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ“‰â€‚â€ƒHandlerFunctionâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€”â’»â€“â€ƒiohandler_functionâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_findâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_addâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_removeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_setâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_clearâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_cleanupâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒprotocol_handlerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒpollfd_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒwsi_to_js_ctxâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhttp_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒprotocol_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒc_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_protocol_objâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’¸â€“â€ƒlws_protocolsâ€ƒ{â€‰â€¦â€‰}â€‰;â€ƒâ€”â€ƒtype",
							"â€”â’»â€“â€ƒprotocol_fromâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒprotocol_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒprotocols_fromarrayâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒprotocols_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhttp_mount_fromâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhttp_mounts_fromâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhttp_mounts_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒvhost_option_fromâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒvhost_options_fromâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒvhost_options_fromfreeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒvhost_options_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒclient_connect_info_fromobjâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒclient_connect_info_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_creation_info_fromobjâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_creation_info_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒcontext_newâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒcontext_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_constructorâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_methodsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_getâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_finalizerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACnAwAA4oCU4pK74oCTIGx3c19zZW5kX3BpcGVfY2hva2VkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BvbGxfbGlzdGVuX2ZkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfc2V0X25vbmJsb2NraW5nICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfc2V0X3NvY2tldF9vcHRpb25zICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfc2V0X3NvY2tldF9vcHRpb25zX2lwICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX2ludGVyZmFjZV90b19zYSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2luZXRfbnRvcCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2luZXRfcHRvbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2lmbmFtZV90b19od2FkZHIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9yYXd1ZHBfYnJvYWRjYXN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfaWZfdXAgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9CSU5EVE9ERVZJQ0UgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9pZmNvbmZpZyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X3Zob3N0X3Rsc19jbGllbnRfY3R4X2luaXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9tYmVkdGxzX25ldF9zZW5kICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfbWJlZHRsc19uZXRfcmVjdiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24AAAAAAAAAAEkHAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					127,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/lws.c",
						"symkeys":
						[
							[
								313,
								331
							],
							[
								1070,
								1078
							],
							[
								1358,
								1368
							],
							[
								1634,
								1657
							],
							[
								2145,
								2168
							],
							[
								2912,
								2936
							],
							[
								3929,
								3944
							],
							[
								32580,
								32599
							],
							[
								32754,
								32774
							],
							[
								32775,
								32794
							],
							[
								33046,
								33069
							],
							[
								33515,
								33533
							],
							[
								34404,
								34414
							],
							[
								34708,
								34722
							]
						],
						"symlist":
						[
							"â€ƒâ’¡â€‚â€ƒlwsjs_log_callbackâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€”â’»â€“â€ƒcamelizeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒdecamelizeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_html_process_argsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_uri_toconnectinfoâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_connectinfo_to_uriâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_functionsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_callback_nameâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’¸â€“â€ƒlws_callback_reasonsâ€ƒ{â€‰â€¦â€‰}â€‰;â€ƒâ€”â€ƒtype",
							"â€”â’»â€“â€ƒlwsjs_callback_findâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_get_lws_callbacksâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_log_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_init_moduleâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAADbCAAA4pOCICBMV1NfUExVR0lOX1NUQVRJQyDigKYg4oCUIG1hY3JvIG9iamVjdArikqEgIHZob3N0X29wdGlvbnNfZnJvbSAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4pKhICB2aG9zdF9vcHRpb25zX2Zyb21mcmVlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgrikqEgIHZob3N0X29wdGlvbnNfZnJlZSAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4pOJICBIYW5kbGVyRnVuY3Rpb24gOyDigJQgdHlwZWRlZgrigJTikrvigJMgaW9oYW5kbGVyX2Z1bmN0aW9uICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgaW9oYW5kbGVyX2ZpbmQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBpb2hhbmRsZXJfYWRkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgaW9oYW5kbGVyX3JlbW92ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGlvaGFuZGxlcl9zZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBpb2hhbmRsZXJfY2xlYXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBpb2hhbmRsZXJfY2xlYW51cCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHByb3RvY29sX2hhbmRsZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwb2xsZmRfY2FsbGJhY2sgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB3c2lfdG9fanNfY3R4ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfY2FsbGJhY2sgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBodHRwX2NhbGxiYWNrICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgcHJvdG9jb2xfY2FsbGJhY2sgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBjX2NhbGxiYWNrICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfcHJvdG9jb2xfb2JqICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrjigJMgbHdzX3Byb3RvY29scyB7IOKApiB9IDsg4oCUIHR5cGUK4oCU4pK74oCTIHByb3RvY29sX2Zyb20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwcm90b2NvbF9mcmVlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgcHJvdG9jb2xzX2Zyb21hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHByb3RvY29sc19mcmVlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgaHR0cF9tb3VudF9mcm9tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgaHR0cF9tb3VudHNfZnJvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGh0dHBfbW91bnRzX2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2aG9zdF9vcHRpb25fZnJvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZob3N0X29wdGlvbnNfZnJvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZob3N0X29wdGlvbnNfZnJvbWZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2aG9zdF9vcHRpb25zX2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBjbGllbnRfY29ubmVjdF9pbmZvX2Zyb21vYmogKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBjbGllbnRfY29ubmVjdF9pbmZvX2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nqc19jb250ZXh0X2NyZWF0aW9uX2luZm9fZnJvbW9iaiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c2pzX2NvbnRleHRfY3JlYXRpb25faW5mb19mcmVlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgY29udGV4dF9uZXcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBjb250ZXh0X2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nqc19jb250ZXh0X2NvbnN0cnVjdG9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfY29udGV4dF9tZXRob2RzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfY29udGV4dF9nZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nqc19jb250ZXh0X2ZpbmFsaXplciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c2pzX2NvbnRleHRfaW5pdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24AAAAAAAAAAGACAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					128,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-sockets.c",
						"symkeys":
						[
							[
								1427,
								1447
							],
							[
								2207,
								2225
							],
							[
								2410,
								2434
							],
							[
								2508,
								2535
							],
							[
								4324,
								4354
							],
							[
								5806,
								5825
							],
							[
								7427,
								7445
							],
							[
								7549,
								7567
							],
							[
								7653,
								7678
							],
							[
								7816,
								7841
							],
							[
								8021,
								8035
							],
							[
								8155,
								8176
							],
							[
								8300,
								8317
							],
							[
								8434,
								8468
							],
							[
								8544,
								8569
							],
							[
								9055,
								9080
							]
						],
						"symlist":
						[
							"â€”â’»â€“â€ƒlws_send_pipe_chokedâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_poll_listen_fdâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_nonblockingâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_socket_optionsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_socket_options_ipâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_interface_to_saâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_inet_ntopâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_inet_ptonâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_ifname_to_hwaddrâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_rawudp_broadcastâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_if_upâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_BINDTODEVICEâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_ifconfigâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_vhost_tls_client_ctx_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_mbedtls_net_sendâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_mbedtls_net_recvâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAADmAgAA4pKhICBsd3Nqc19sb2dfY2FsbGJhY2sgKCApIDsg4oCUIGZ1bmN0aW9uIGRlY2xhcmF0aW9uCuKAlOKSu+KAkyBjYW1lbGl6ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGRlY2FtZWxpemUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nqc19odG1sX3Byb2Nlc3NfYXJncyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c2pzX3VyaV90b2Nvbm5lY3RpbmZvICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfY29ubmVjdGluZm9fdG9fdXJpICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfZnVuY3Rpb25zICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfY2FsbGJhY2tfbmFtZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK44oCTIGx3c19jYWxsYmFja19yZWFzb25zIHsg4oCmIH0gOyDigJQgdHlwZQrigJTikrvigJMgbHdzanNfY2FsbGJhY2tfZmluZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c2pzX2dldF9sd3NfY2FsbGJhY2tzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfbG9nX2NhbGxiYWNrICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfaW5pdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX2luaXRfbW9kdWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgAAAAAAAAAABwMAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					129,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-misc.c",
						"symkeys":
						[
							[
								1257,
								1268
							],
							[
								1498,
								1508
							],
							[
								1594,
								1607
							],
							[
								1981,
								1995
							],
							[
								2224,
								2240
							],
							[
								2581,
								2600
							],
							[
								2831,
								2860
							],
							[
								2950,
								2975
							]
						],
						"symlist":
						[
							"â€ƒâ“‚â€‚â€ƒ_GNU_SOURCEâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€”â’»â€“â€ƒlws_msleepâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_now_usecsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_get_randomâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsl_emit_syslogâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_write_certâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_recommended_rsa_bitsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_ntpclient_configâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACnAwAA4oCU4pK74oCTIGx3c19zZW5kX3BpcGVfY2hva2VkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BvbGxfbGlzdGVuX2ZkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfc2V0X25vbmJsb2NraW5nICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfc2V0X3NvY2tldF9vcHRpb25zICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfc2V0X3NvY2tldF9vcHRpb25zX2lwICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX2ludGVyZmFjZV90b19zYSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2luZXRfbnRvcCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2luZXRfcHRvbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2lmbmFtZV90b19od2FkZHIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9yYXd1ZHBfYnJvYWRjYXN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfaWZfdXAgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9CSU5EVE9ERVZJQ0UgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9pZmNvbmZpZyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X3Zob3N0X3Rsc19jbGllbnRfY3R4X2luaXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9tYmVkdGxzX25ldF9zZW5kICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfbWJlZHRsc19uZXRfcmVjdiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24AAAAAAAAAAFMBAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					130,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-sockets.c",
						"symkeys":
						[
							[
								1427,
								1447
							],
							[
								2207,
								2225
							],
							[
								2410,
								2434
							],
							[
								2508,
								2535
							],
							[
								4324,
								4354
							],
							[
								5806,
								5825
							],
							[
								7427,
								7445
							],
							[
								7549,
								7567
							],
							[
								7653,
								7678
							],
							[
								7816,
								7841
							],
							[
								8021,
								8035
							],
							[
								8155,
								8176
							],
							[
								8300,
								8317
							],
							[
								8434,
								8468
							],
							[
								8544,
								8569
							],
							[
								9055,
								9080
							]
						],
						"symlist":
						[
							"â€”â’»â€“â€ƒlws_send_pipe_chokedâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_poll_listen_fdâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_nonblockingâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_socket_optionsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_socket_options_ipâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_interface_to_saâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_inet_ntopâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_inet_ptonâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_ifname_to_hwaddrâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_rawudp_broadcastâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_if_upâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_BINDTODEVICEâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_ifconfigâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_vhost_tls_client_ctx_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_mbedtls_net_sendâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_mbedtls_net_recvâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACfAQAA4pOCICBfR05VX1NPVVJDRSDigKYg4oCUIG1hY3JvIG9iamVjdArigJTikrvigJMgbHdzX21zbGVlcCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19ub3dfdXNlY3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfZ2V0X3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c2xfZW1pdF9zeXNsb2cgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF93cml0ZV9jZXJ0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfcmVjb21tZW5kZWRfcnNhX2JpdHMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9udHBjbGllbnRfY29uZmlnICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgAAAAAAAAAABwMAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					131,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-misc.c",
						"symkeys":
						[
							[
								1257,
								1268
							],
							[
								1498,
								1508
							],
							[
								1594,
								1607
							],
							[
								1981,
								1995
							],
							[
								2224,
								2240
							],
							[
								2581,
								2600
							],
							[
								2831,
								2860
							],
							[
								2950,
								2975
							]
						],
						"symlist":
						[
							"â€ƒâ“‚â€‚â€ƒ_GNU_SOURCEâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€”â’»â€“â€ƒlws_msleepâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_now_usecsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_get_randomâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsl_emit_syslogâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_write_certâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_recommended_rsa_bitsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_ntpclient_configâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACnAwAA4oCU4pK74oCTIGx3c19zZW5kX3BpcGVfY2hva2VkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BvbGxfbGlzdGVuX2ZkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfc2V0X25vbmJsb2NraW5nICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfc2V0X3NvY2tldF9vcHRpb25zICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfc2V0X3NvY2tldF9vcHRpb25zX2lwICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX2ludGVyZmFjZV90b19zYSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2luZXRfbnRvcCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2luZXRfcHRvbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2lmbmFtZV90b19od2FkZHIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9yYXd1ZHBfYnJvYWRjYXN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfaWZfdXAgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9CSU5EVE9ERVZJQ0UgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9pZmNvbmZpZyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X3Zob3N0X3Rsc19jbGllbnRfY3R4X2luaXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9tYmVkdGxzX25ldF9zZW5kICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfbWJlZHRsc19uZXRfcmVjdiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24AAAAAAAAAAFMBAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					132,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-sockets.c",
						"symkeys":
						[
							[
								1427,
								1447
							],
							[
								2207,
								2225
							],
							[
								2410,
								2434
							],
							[
								2508,
								2535
							],
							[
								4324,
								4354
							],
							[
								5806,
								5825
							],
							[
								7427,
								7445
							],
							[
								7549,
								7567
							],
							[
								7653,
								7678
							],
							[
								7816,
								7841
							],
							[
								8021,
								8035
							],
							[
								8155,
								8176
							],
							[
								8300,
								8317
							],
							[
								8434,
								8468
							],
							[
								8544,
								8569
							],
							[
								9055,
								9080
							]
						],
						"symlist":
						[
							"â€”â’»â€“â€ƒlws_send_pipe_chokedâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_poll_listen_fdâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_nonblockingâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_socket_optionsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_socket_options_ipâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_interface_to_saâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_inet_ntopâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_inet_ptonâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_ifname_to_hwaddrâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_rawudp_broadcastâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_if_upâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_BINDTODEVICEâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_ifconfigâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_vhost_tls_client_ctx_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_mbedtls_net_sendâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_mbedtls_net_recvâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACfAQAA4pOCICBfR05VX1NPVVJDRSDigKYg4oCUIG1hY3JvIG9iamVjdArigJTikrvigJMgbHdzX21zbGVlcCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19ub3dfdXNlY3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfZ2V0X3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c2xfZW1pdF9zeXNsb2cgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF93cml0ZV9jZXJ0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfcmVjb21tZW5kZWRfcnNhX2JpdHMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9udHBjbGllbnRfY29uZmlnICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgAAAAAAAAAABwMAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					133,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-misc.c",
						"symkeys":
						[
							[
								1257,
								1268
							],
							[
								1498,
								1508
							],
							[
								1594,
								1607
							],
							[
								1981,
								1995
							],
							[
								2224,
								2240
							],
							[
								2581,
								2600
							],
							[
								2831,
								2860
							],
							[
								2950,
								2975
							]
						],
						"symlist":
						[
							"â€ƒâ“‚â€‚â€ƒ_GNU_SOURCEâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€”â’»â€“â€ƒlws_msleepâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_now_usecsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_get_randomâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsl_emit_syslogâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_write_certâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_recommended_rsa_bitsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_ntpclient_configâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACnAwAA4oCU4pK74oCTIGx3c19zZW5kX3BpcGVfY2hva2VkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BvbGxfbGlzdGVuX2ZkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfc2V0X25vbmJsb2NraW5nICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfc2V0X3NvY2tldF9vcHRpb25zICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfc2V0X3NvY2tldF9vcHRpb25zX2lwICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX2ludGVyZmFjZV90b19zYSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2luZXRfbnRvcCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2luZXRfcHRvbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2lmbmFtZV90b19od2FkZHIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9yYXd1ZHBfYnJvYWRjYXN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfaWZfdXAgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9CSU5EVE9ERVZJQ0UgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9pZmNvbmZpZyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X3Zob3N0X3Rsc19jbGllbnRfY3R4X2luaXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9tYmVkdGxzX25ldF9zZW5kICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfbWJlZHRsc19uZXRfcmVjdiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24AAAAAAAAAAFMBAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					134,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/lws-context.c",
						"symkeys":
						[
							[
								255,
								272
							],
							[
								1423,
								1441
							],
							[
								1511,
								1533
							],
							[
								1569,
								1587
							],
							[
								1706,
								1721
							],
							[
								1739,
								1757
							],
							[
								2062,
								2076
							],
							[
								2350,
								2363
							],
							[
								2735,
								2751
							],
							[
								3026,
								3039
							],
							[
								3595,
								3610
							],
							[
								3733,
								3750
							],
							[
								4070,
								4086
							],
							[
								4514,
								4529
							],
							[
								6154,
								6167
							],
							[
								6468,
								6479
							],
							[
								7779,
								7792
							],
							[
								8214,
								8231
							],
							[
								18681,
								18691
							],
							[
								19434,
								19452
							],
							[
								20278,
								20291
							],
							[
								20292,
								20305
							],
							[
								21507,
								21520
							],
							[
								21908,
								21927
							],
							[
								23563,
								23577
							],
							[
								23755,
								23770
							],
							[
								26545,
								26561
							],
							[
								27809,
								27825
							],
							[
								28934,
								28951
							],
							[
								30037,
								30055
							],
							[
								30925,
								30947
							],
							[
								31113,
								31131
							],
							[
								31496,
								31523
							],
							[
								33333,
								33357
							],
							[
								34081,
								34116
							],
							[
								38249,
								38281
							],
							[
								40821,
								40832
							],
							[
								40983,
								40995
							],
							[
								41349,
								41374
							],
							[
								42707,
								42728
							],
							[
								46659,
								46676
							],
							[
								47661,
								47684
							],
							[
								49342,
								49360
							]
						],
						"symlist":
						[
							"â€ƒâ“‚â€‚â€ƒLWS_PLUGIN_STATICâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€ƒâ’¡â€‚â€ƒvhost_options_fromâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ’¡â€‚â€ƒvhost_options_fromfreeâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ’¡â€‚â€ƒvhost_options_freeâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ“‰â€‚â€ƒHandlerFunctionâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€”â’»â€“â€ƒiohandler_functionâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_findâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_addâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_removeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_setâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_clearâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒiohandler_cleanupâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒprotocol_handlerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒpollfd_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒwsi_to_js_ctxâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhttp_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒprotocol_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒc_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_protocol_objâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’¸â€“â€ƒlws_protocolsâ€ƒ{â€‰â€¦â€‰}â€‰;â€ƒâ€”â€ƒtype",
							"â€”â’»â€“â€ƒprotocol_fromâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒprotocol_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒprotocols_fromarrayâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒprotocols_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhttp_mount_fromâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhttp_mounts_fromâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhttp_mounts_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒvhost_option_fromâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒvhost_options_fromâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒvhost_options_fromfreeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒvhost_options_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒclient_connect_info_fromobjâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒclient_connect_info_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_creation_info_fromobjâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_creation_info_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒcontext_newâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒcontext_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_constructorâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_methodsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_getâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_finalizerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_context_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACfAQAA4pOCICBfR05VX1NPVVJDRSDigKYg4oCUIG1hY3JvIG9iamVjdArigJTikrvigJMgbHdzX21zbGVlcCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19ub3dfdXNlY3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfZ2V0X3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c2xfZW1pdF9zeXNsb2cgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF93cml0ZV9jZXJ0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfcmVjb21tZW5kZWRfcnNhX2JpdHMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9udHBjbGllbnRfY29uZmlnICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgAAAAAAAAAASQcAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					135,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-misc.c",
						"symkeys":
						[
							[
								1257,
								1268
							],
							[
								1498,
								1508
							],
							[
								1594,
								1607
							],
							[
								1981,
								1995
							],
							[
								2224,
								2240
							],
							[
								2581,
								2600
							],
							[
								2831,
								2860
							],
							[
								2950,
								2975
							]
						],
						"symlist":
						[
							"â€ƒâ“‚â€‚â€ƒ_GNU_SOURCEâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€”â’»â€“â€ƒlws_msleepâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_now_usecsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_get_randomâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsl_emit_syslogâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_write_certâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_recommended_rsa_bitsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_ntpclient_configâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAADbCAAA4pOCICBMV1NfUExVR0lOX1NUQVRJQyDigKYg4oCUIG1hY3JvIG9iamVjdArikqEgIHZob3N0X29wdGlvbnNfZnJvbSAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4pKhICB2aG9zdF9vcHRpb25zX2Zyb21mcmVlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgrikqEgIHZob3N0X29wdGlvbnNfZnJlZSAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4pOJICBIYW5kbGVyRnVuY3Rpb24gOyDigJQgdHlwZWRlZgrigJTikrvigJMgaW9oYW5kbGVyX2Z1bmN0aW9uICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgaW9oYW5kbGVyX2ZpbmQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBpb2hhbmRsZXJfYWRkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgaW9oYW5kbGVyX3JlbW92ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGlvaGFuZGxlcl9zZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBpb2hhbmRsZXJfY2xlYXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBpb2hhbmRsZXJfY2xlYW51cCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHByb3RvY29sX2hhbmRsZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwb2xsZmRfY2FsbGJhY2sgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB3c2lfdG9fanNfY3R4ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfY2FsbGJhY2sgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBodHRwX2NhbGxiYWNrICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgcHJvdG9jb2xfY2FsbGJhY2sgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBjX2NhbGxiYWNrICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfcHJvdG9jb2xfb2JqICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrjigJMgbHdzX3Byb3RvY29scyB7IOKApiB9IDsg4oCUIHR5cGUK4oCU4pK74oCTIHByb3RvY29sX2Zyb20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwcm90b2NvbF9mcmVlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgcHJvdG9jb2xzX2Zyb21hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHByb3RvY29sc19mcmVlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgaHR0cF9tb3VudF9mcm9tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgaHR0cF9tb3VudHNfZnJvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGh0dHBfbW91bnRzX2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2aG9zdF9vcHRpb25fZnJvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZob3N0X29wdGlvbnNfZnJvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZob3N0X29wdGlvbnNfZnJvbWZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2aG9zdF9vcHRpb25zX2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBjbGllbnRfY29ubmVjdF9pbmZvX2Zyb21vYmogKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBjbGllbnRfY29ubmVjdF9pbmZvX2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nqc19jb250ZXh0X2NyZWF0aW9uX2luZm9fZnJvbW9iaiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c2pzX2NvbnRleHRfY3JlYXRpb25faW5mb19mcmVlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgY29udGV4dF9uZXcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBjb250ZXh0X2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nqc19jb250ZXh0X2NvbnN0cnVjdG9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfY29udGV4dF9tZXRob2RzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzanNfY29udGV4dF9nZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nqc19jb250ZXh0X2ZpbmFsaXplciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c2pzX2NvbnRleHRfaW5pdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24AAAAAAAAAAFMBAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					136,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/lws-socket.h",
						"symkeys":
						[
							[
								33,
								49
							],
							[
								176,
								189
							],
							[
								484,
								493
							],
							[
								541,
								553
							],
							[
								583,
								593
							],
							[
								623,
								635
							],
							[
								665,
								681
							],
							[
								702,
								722
							],
							[
								757,
								774
							],
							[
								808,
								827
							],
							[
								862,
								888
							],
							[
								923,
								943
							],
							[
								982,
								999
							],
							[
								1031,
								1049
							],
							[
								1083,
								1100
							],
							[
								1121,
								1134
							],
							[
								1195,
								1212
							],
							[
								1316,
								1334
							]
						],
						"symlist":
						[
							"â€ƒâ“‚â€‚â€ƒQJS_LWS_SOCKET_Hâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€ƒâ“‰â€‚â€ƒLWSSocketTypeâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€ƒâ“‰â€‚â€ƒLWSSocketâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€ƒâ’¡â€‚â€ƒsocket_getidâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ’¡â€‚â€ƒsocket_getâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ’¡â€‚â€ƒsocket_allocâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ’¡â€‚â€ƒlwsjs_socket_wsiâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ’¡â€‚â€ƒlwsjs_socket_destroyâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ’¡â€‚â€ƒlwsjs_socket_wrapâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ’¡â€‚â€ƒlwsjs_socket_createâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ’¡â€‚â€ƒlwsjs_socket_get_or_createâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ’¡â€‚â€ƒlwsjs_socket_headersâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ’¡â€‚â€ƒlwsjs_socket_initâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ’¡â€‚â€ƒlwsjs_method_indexâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ’¡â€‚â€ƒlwsjs_method_nameâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€ƒâ’¡â€‚â€ƒjs_socket_getâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration",
							"â€”â’»â€“â€ƒlwsjs_socket_dataâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_data2â€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACfAQAA4pOCICBfR05VX1NPVVJDRSDigKYg4oCUIG1hY3JvIG9iamVjdArigJTikrvigJMgbHdzX21zbGVlcCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19ub3dfdXNlY3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfZ2V0X3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c2xfZW1pdF9zeXNsb2cgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF93cml0ZV9jZXJ0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfcmVjb21tZW5kZWRfcnNhX2JpdHMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9udHBjbGllbnRfY29uZmlnICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgAAAAAAAAAANwMAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					137,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/state.c",
						"symkeys":
						[
							[
								1259,
								1281
							],
							[
								1424,
								1448
							],
							[
								1517,
								1544
							],
							[
								1811,
								1818
							],
							[
								2010,
								2017
							],
							[
								2638,
								2659
							],
							[
								3384,
								3410
							],
							[
								3831,
								3851
							]
						],
						"symlist":
						[
							"â€”â’»â€“â€ƒlws_state_reg_notifierâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_state_reg_deregisterâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_state_reg_notifier_listâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒ_systnmâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒ_reportâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒ_lws_state_transitionâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_state_transition_stepsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_state_transitionâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACNAwAA4pOCICBRSlNfTFdTX1NPQ0tFVF9IIOKApiDigJQgbWFjcm8gb2JqZWN0CuKTiSAgTFdTU29ja2V0VHlwZSA7IOKAlCB0eXBlZGVmCuKTiSAgTFdTU29ja2V0IDsg4oCUIHR5cGVkZWYK4pKhICBzb2NrZXRfZ2V0aWQgKCApIDsg4oCUIGZ1bmN0aW9uIGRlY2xhcmF0aW9uCuKSoSAgc29ja2V0X2dldCAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4pKhICBzb2NrZXRfYWxsb2MgKCApIDsg4oCUIGZ1bmN0aW9uIGRlY2xhcmF0aW9uCuKSoSAgbHdzanNfc29ja2V0X3dzaSAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4pKhICBsd3Nqc19zb2NrZXRfZGVzdHJveSAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4pKhICBsd3Nqc19zb2NrZXRfd3JhcCAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4pKhICBsd3Nqc19zb2NrZXRfY3JlYXRlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgrikqEgIGx3c2pzX3NvY2tldF9nZXRfb3JfY3JlYXRlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgrikqEgIGx3c2pzX3NvY2tldF9oZWFkZXJzICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgrikqEgIGx3c2pzX3NvY2tldF9pbml0ICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgrikqEgIGx3c2pzX21ldGhvZF9pbmRleCAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4pKhICBsd3Nqc19tZXRob2RfbmFtZSAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4pKhICBqc19zb2NrZXRfZ2V0ICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgrigJTikrvigJMgbHdzanNfc29ja2V0X2RhdGEgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nqc19zb2NrZXRfZGF0YTIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uAAAAAAAAAABpAQAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					138,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/output.c",
						"symkeys":
						[
							[
								1320,
								1333
							],
							[
								6211,
								6220
							],
							[
								6943,
								6970
							],
							[
								8212,
								8240
							],
							[
								9790,
								9812
							]
						],
						"symlist":
						[
							"â€”â’»â€“â€ƒlws_issue_rawâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_writeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_ssl_capable_read_no_sslâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_ssl_capable_write_no_sslâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_ssl_pending_no_sslâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAC5AQAA4oCU4pK74oCTIGx3c19zdGF0ZV9yZWdfbm90aWZpZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfc3RhdGVfcmVnX2RlcmVnaXN0ZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfc3RhdGVfcmVnX25vdGlmaWVyX2xpc3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBfc3lzdG5tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgX3JlcG9ydCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIF9sd3Nfc3RhdGVfdHJhbnNpdGlvbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19zdGF0ZV90cmFuc2l0aW9uX3N0ZXBzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3N0YXRlX3RyYW5zaXRpb24gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uAAAAAAAAAADkAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					139,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAWAQAA4oCU4pK74oCTIGx3c19pc3N1ZV9yYXcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfd3JpdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfc3NsX2NhcGFibGVfcmVhZF9ub19zc2wgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfc3NsX2NhcGFibGVfd3JpdGVfbm9fc3NsICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3NzbF9wZW5kaW5nX25vX3NzbCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24AAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					140,
					3,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					141,
					2,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					142,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/optee/network.c",
						"symkeys":
						[
							[
								1409,
								1429
							],
							[
								1467,
								1487
							],
							[
								1526,
								1545
							],
							[
								1572,
								1601
							],
							[
								1675,
								1695
							],
							[
								2266,
								2284
							],
							[
								2356,
								2377
							],
							[
								4480,
								4496
							],
							[
								4606,
								4633
							],
							[
								4702,
								4721
							],
							[
								4869,
								4888
							],
							[
								4989,
								5020
							],
							[
								5183,
								5214
							],
							[
								5368,
								5390
							],
							[
								5498,
								5516
							],
							[
								5647,
								5665
							],
							[
								5757,
								5787
							],
							[
								5853,
								5887
							],
							[
								5963,
								5988
							],
							[
								6474,
								6499
							]
						],
						"symlist":
						[
							"â€”â’»â€“â€ƒlws_plat_pipe_createâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_pipe_signalâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_pipe_closeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_pipe_is_fd_assocatedâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_send_pipe_chokedâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_poll_listen_fdâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒ_lws_plat_service_tsiâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_serviceâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_socket_optionsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_write_certâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_interface_to_saâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_insert_socket_into_fdsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_delete_socket_from_fdsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_change_pollfdâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_inet_ntopâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_inet_ptonâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_set_socket_options_ipâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_vhost_tls_client_ctx_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_mbedtls_net_sendâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_plat_mbedtls_net_recvâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AQAAAAAAAAAAAAAA1QMAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					143,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACdBAAA4oCU4pK74oCTIGx3c19wbGF0X3BpcGVfY3JlYXRlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfcGlwZV9zaWduYWwgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9waXBlX2Nsb3NlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfcGlwZV9pc19mZF9hc3NvY2F0ZWQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfc2VuZF9waXBlX2Nob2tlZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wb2xsX2xpc3Rlbl9mZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIF9sd3NfcGxhdF9zZXJ2aWNlX3RzaSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X3NlcnZpY2UgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9zZXRfc29ja2V0X29wdGlvbnMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF93cml0ZV9jZXJ0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX2ludGVyZmFjZV90b19zYSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2luc2VydF9zb2NrZXRfaW50b19mZHMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9kZWxldGVfc29ja2V0X2Zyb21fZmRzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfY2hhbmdlX3BvbGxmZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2luZXRfbnRvcCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X2luZXRfcHRvbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X3NldF9zb2NrZXRfb3B0aW9uc19pcCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wbGF0X3Zob3N0X3Rsc19jbGllbnRfY3R4X2luaXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfcGxhdF9tYmVkdGxzX25ldF9zZW5kICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3BsYXRfbWJlZHRsc19uZXRfcmVjdiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24AAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					144,
					2,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					145,
					4,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					146,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					147,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/h2/http2.c",
						"symkeys":
						[
							[
								3984,
								4004
							],
							[
								4075,
								4089
							],
							[
								4251,
								4262
							],
							[
								4378,
								4390
							],
							[
								4645,
								4672
							],
							[
								5605,
								5638
							],
							[
								5771,
								5805
							],
							[
								6019,
								6039
							],
							[
								9113,
								9129
							],
							[
								10740,
								10760
							],
							[
								11539,
								11555
							],
							[
								11966,
								11979
							],
							[
								12550,
								12567
							],
							[
								13237,
								13252
							]
						],
						"symlist":
						[
							"â€”â’»â€“â€ƒlws_h2_dump_settingsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_h2_new_ppsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_h2_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_h2_stateâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_h2_update_peer_txcreditâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_h2_get_peer_txcredit_estimateâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_h2_update_peer_txcredit_threshâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒ__lws_wsi_server_newâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_wsi_h2_adoptâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_h2_issue_prefaceâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_pps_scheduleâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_h2_goawayâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_h2_rst_streamâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_h2_settingsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AQAAAAAAAAAAAAAAdwIAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					148,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAADAwAA4oCU4pK74oCTIGx3c19oMl9kdW1wX3NldHRpbmdzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX2gyX25ld19wcHMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfaDJfaW5pdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19oMl9zdGF0ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19oMl91cGRhdGVfcGVlcl90eGNyZWRpdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19oMl9nZXRfcGVlcl90eGNyZWRpdF9lc3RpbWF0ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19oMl91cGRhdGVfcGVlcl90eGNyZWRpdF90aHJlc2ggKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBfX2x3c193c2lfc2VydmVyX25ldyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c193c2lfaDJfYWRvcHQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfaDJfaXNzdWVfcHJlZmFjZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wcHNfc2NoZWR1bGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfaDJfZ29hd2F5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX2gyX3JzdF9zdHJlYW0gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfaDJfc2V0dGluZ3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					149,
					2,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					150,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					151,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					152,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					153,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					154,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/output.c",
						"symkeys":
						[
							[
								1320,
								1333
							],
							[
								6211,
								6220
							],
							[
								6943,
								6970
							],
							[
								8212,
								8240
							],
							[
								9790,
								9812
							]
						],
						"symlist":
						[
							"â€”â’»â€“â€ƒlws_issue_rawâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_writeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_ssl_capable_read_no_sslâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_ssl_capable_write_no_sslâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_ssl_pending_no_sslâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AQAAAAAAAAAAAAAA5AAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					155,
					2,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AwAAAAAAAAAAAAAAAAAAAAAAAAAWAQAA4oCU4pK74oCTIGx3c19pc3N1ZV9yYXcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfd3JpdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfc3NsX2NhcGFibGVfcmVhZF9ub19zc2wgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfc3NsX2NhcGFibGVfd3JpdGVfbm9fc3NsICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3NzbF9wZW5kaW5nX25vX3NzbCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					156,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/output.c",
						"symkeys":
						[
							[
								1320,
								1333
							],
							[
								6211,
								6220
							],
							[
								6943,
								6970
							],
							[
								8212,
								8240
							],
							[
								9790,
								9812
							]
						],
						"symlist":
						[
							"â€”â’»â€“â€ƒlws_issue_rawâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_writeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_ssl_capable_read_no_sslâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_ssl_capable_write_no_sslâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_ssl_pending_no_sslâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AQAAAAAAAAAAAAAA5AAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					157,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAWAQAA4oCU4pK74oCTIGx3c19pc3N1ZV9yYXcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfd3JpdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfc3NsX2NhcGFibGVfcmVhZF9ub19zc2wgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfc3NsX2NhcGFibGVfd3JpdGVfbm9fc3NsICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3NzbF9wZW5kaW5nX25vX3NzbCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24AAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					158,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/output.c",
						"symkeys":
						[
							[
								1320,
								1333
							],
							[
								6211,
								6220
							],
							[
								6943,
								6970
							],
							[
								8212,
								8240
							],
							[
								9790,
								9812
							]
						],
						"symlist":
						[
							"â€”â’»â€“â€ƒlws_issue_rawâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_writeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_ssl_capable_read_no_sslâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_ssl_capable_write_no_sslâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_ssl_pending_no_sslâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AQAAAAAAAAAAAAAA5AAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					159,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAWAQAA4oCU4pK74oCTIGx3c19pc3N1ZV9yYXcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfd3JpdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfc3NsX2NhcGFibGVfcmVhZF9ub19zc2wgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfc3NsX2NhcGFibGVfd3JpdGVfbm9fc3NsICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3NzbF9wZW5kaW5nX25vX3NzbCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24AAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					160,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/output.c",
						"symkeys":
						[
							[
								1320,
								1333
							],
							[
								6211,
								6220
							],
							[
								6943,
								6970
							],
							[
								8212,
								8240
							],
							[
								9790,
								9812
							]
						],
						"symlist":
						[
							"â€”â’»â€“â€ƒlws_issue_rawâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_writeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_ssl_capable_read_no_sslâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_ssl_capable_write_no_sslâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_ssl_pending_no_sslâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AQAAAAAAAAAAAAAA5AAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					161,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAWAQAA4oCU4pK74oCTIGx3c19pc3N1ZV9yYXcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfd3JpdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfc3NsX2NhcGFibGVfcmVhZF9ub19zc2wgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3Nfc3NsX2NhcGFibGVfd3JpdGVfbm9fc3NsICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX3NzbF9wZW5kaW5nX25vX3NzbCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24AAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					162,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/h2/http2.c",
						"symkeys":
						[
							[
								3984,
								4004
							],
							[
								4075,
								4089
							],
							[
								4251,
								4262
							],
							[
								4378,
								4390
							],
							[
								4645,
								4672
							],
							[
								5605,
								5638
							],
							[
								5771,
								5805
							],
							[
								6019,
								6039
							],
							[
								9113,
								9129
							],
							[
								10740,
								10760
							],
							[
								11539,
								11555
							],
							[
								11966,
								11979
							],
							[
								12550,
								12567
							],
							[
								13237,
								13252
							]
						],
						"symlist":
						[
							"â€”â’»â€“â€ƒlws_h2_dump_settingsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_h2_new_ppsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_h2_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_h2_stateâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_h2_update_peer_txcreditâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_h2_get_peer_txcredit_estimateâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_h2_update_peer_txcredit_threshâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒ__lws_wsi_server_newâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_wsi_h2_adoptâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_h2_issue_prefaceâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_pps_scheduleâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_h2_goawayâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_h2_rst_streamâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlws_h2_settingsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AQAAAAAAAAAAAAAAdwIAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					1,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/lws-socket.c",
						"symkeys":
						[
							[
								1052,
								1058
							],
							[
								1227,
								1245
							],
							[
								1458,
								1475
							],
							[
								1599,
								1609
							],
							[
								1670,
								1682
							],
							[
								2127,
								2138
							],
							[
								2333,
								2345
							],
							[
								2471,
								2482
							],
							[
								2744,
								2754
							],
							[
								2920,
								2933
							],
							[
								3135,
								3151
							],
							[
								3366,
								3377
							],
							[
								3943,
								3956
							],
							[
								4403,
								4414
							],
							[
								4534,
								4550
							],
							[
								4679,
								4696
							],
							[
								4920,
								4939
							],
							[
								5148,
								5168
							],
							[
								5385,
								5411
							],
							[
								5938,
								5951
							],
							[
								5966,
								5978
							],
							[
								6230,
								6253
							],
							[
								7052,
								7072
							],
							[
								8231,
								8251
							],
							[
								17018,
								17040
							],
							[
								18131,
								18147
							],
							[
								18574,
								18590
							],
							[
								22869,
								22891
							],
							[
								25693,
								25710
							]
						],
						"symlist":
						[
							"â€”â’»â€“â€ƒis_uriâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_method_indexâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_method_nameâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsocket_dupâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsocket_allocâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsocket_typeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsocket_getidâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsocket_findâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsocket_getâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_socket_getâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsocket_get_by_idâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsocket_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsocket_deleteâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsocket_obj2â€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_wsiâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_wrapâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_createâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_destroyâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_get_or_createâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€ƒâ“‰â€‚â€ƒCustomHeadersâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€”â’»â€“â€ƒset_propertyâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒcustom_headers_callbackâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_headersâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_methodsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_functionsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_setâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_getâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_finalizerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒlwsjs_socket_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAADAwAA4oCU4pK74oCTIGx3c19oMl9kdW1wX3NldHRpbmdzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX2gyX25ld19wcHMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfaDJfaW5pdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19oMl9zdGF0ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19oMl91cGRhdGVfcGVlcl90eGNyZWRpdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19oMl9nZXRfcGVlcl90eGNyZWRpdF9lc3RpbWF0ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19oMl91cGRhdGVfcGVlcl90eGNyZWRpdF90aHJlc2ggKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBfX2x3c193c2lfc2VydmVyX25ldyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c193c2lfaDJfYWRvcHQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfaDJfaXNzdWVfcHJlZmFjZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGx3c19wcHNfc2NoZWR1bGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfaDJfZ29hd2F5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbHdzX2gyX3JzdF9zdHJlYW0gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBsd3NfaDJfc2V0dGluZ3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uAAAAAAAAAACpBAAAAAAAAAAAAAA",
					"AwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvw"
				],
				[
					2,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-write.h",
						"symkeys":
						[
							[
								1329,
								1342
							],
							[
								1365,
								1436
							],
							[
								1508,
								1526
							],
							[
								3641,
								3659
							],
							[
								4648,
								4666
							],
							[
								6639,
								6656
							],
							[
								8189,
								8198
							],
							[
								8343,
								8357
							],
							[
								8866,
								8884
							],
							[
								9573,
								9602
							]
						],
						"symlist":
						[
							"â€ƒâ“‚â€‚â€ƒLWS_WRITE_RAWâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€‚â€‚âœŽâ€‚â€ƒNOTE: These public enums are part of the abi.  If you want to add one,",
							"â€”â’¸â€“â€ƒlws_write_protocolâ€ƒ{â€‰â€¦â€‰}â€‰;â€ƒâ€”â€ƒtype",
							"â€”â’¸â€“â€ƒlws_write_passthruâ€ƒ{â€‰â€¦â€‰}â€‰;â€ƒâ€”â€ƒtype",
							"â€‚â€‚âœŽâ€‚â€ƒIMPORTANT NOTICE!",
							"===â€ƒ==========================================================",
							"â€”â’»â€“â€ƒlws_writeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â“‚â€“â€ƒlws_write_httpâ€‰(â€‰)â€ƒâ€¦â€ƒâ€”â€ƒmacro function",
							"â€”â’»â€“â€ƒlws_write_ws_flagsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€ƒâ’¡â€‚â€ƒlws_raw_transaction_completedâ€‰(â€‰)â€‰;â€ƒâ€”â€ƒfunction declaration"
						]
					},
					"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"
				]
			]
		},
		{
			"file": "libwebsockets/lib/plat/unix/unix-misc.c",
			"settings":
			{
				"buffer_size": 3400,
				"line_ending": "Unix"
			}
		},
		{
			"file": "libwebsockets/lib/core-net/state.c",
			"settings":
			{
				"buffer_size": 3971,
				"line_ending": "Unix"
			}
		},
		{
			"file": "lws-context.c",
			"settings":
			{
				"buffer_size": 49967,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					64,
					1,
					"insert",
					{
						"characters": "|"
					},
					"AQAAABp9AAAAAAAAG30AAAAAAAAAAAAA",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAABp9AAAAAAAAGn0AAAAAAAAAAAAAAADwvw"
				],
				[
					1,
					1,
					"revert",
					null,
					"BQAAAAAAAAAAAAAAAAAAAAAAAAAvwwAAI2luY2x1ZGUgPHF1aWNranMuaD4KI2luY2x1ZGUgPGN1dGlscy5oPgojaW5jbHVkZSA8bGlzdC5oPgojaW5jbHVkZSA8bGlid2Vic29ja2V0cy5oPgojaW5jbHVkZSA8bHdzX2NvbmZpZy5oPgojaW5jbHVkZSA8YXNzZXJ0Lmg+CiNpbmNsdWRlICJsd3Mtc29ja2V0LmgiCiNpbmNsdWRlICJsd3MtY29udGV4dC5oIgojaW5jbHVkZSAibHdzLXNvY2thZGRyNDYuaCIKI2luY2x1ZGUgImx3cy5oIgojaW5jbHVkZSAianMtdXRpbHMuaCIKCiNkZWZpbmUgTFdTX1BMVUdJTl9TVEFUSUMKCiNpZmRlZiBQTFVHSU5fUFJPVE9DT0xfREVBRERST1AKI2luY2x1ZGUgImxpYndlYnNvY2tldHMvcGx1Z2lucy9kZWFkZHJvcC9wcm90b2NvbF9sd3NfZGVhZGRyb3AuYyIKI2VuZGlmCiNpZmRlZiBQTFVHSU5fUFJPVE9DT0xfUkFXX1BST1hZCiNpbmNsdWRlICJsaWJ3ZWJzb2NrZXRzL3BsdWdpbnMvcmF3LXByb3h5L3Byb3RvY29sX2x3c19yYXdfcHJveHkuYyIKI2VuZGlmCiNpZmRlZiBQTFVHSU5fUFJPVE9DT0xfRlVMTFRFWFRfREVNTwojaW5jbHVkZSAibGlid2Vic29ja2V0cy9wbHVnaW5zL3Byb3RvY29sX2Z1bGx0ZXh0X2RlbW8uYyIKI2VuZGlmCiNpZmRlZiBQTFVHSU5fUFJPVE9DT0xfTFdTX1NUQVRVUwojaW5jbHVkZSAibGlid2Vic29ja2V0cy9wbHVnaW5zL3Byb3RvY29sX2x3c19zdGF0dXMuYyIKI2VuZGlmCiNpZmRlZiBQTFVHSU5fUFJPVE9DT0xfTFdTX0FDTUVfQ0xJRU5UCiNpbmNsdWRlICJsaWJ3ZWJzb2NrZXRzL3BsdWdpbnMvYWNtZS1jbGllbnQvcHJvdG9jb2xfbHdzX2FjbWVfY2xpZW50LmMiCiNlbmRpZgojaWZkZWYgUExVR0lOX1BST1RPQ09MX0xXU19TU0hEX0RFTU8KI2luY2x1ZGUgImxpYndlYnNvY2tldHMvcGx1Z2lucy9wcm90b2NvbF9sd3Nfc3NoZF9kZW1vLmMiCiNlbmRpZgojaWZkZWYgUExVR0lOX1BST1RPQ09MX0RVTUJfSU5DUkVNRU5UCiNpbmNsdWRlICJsaWJ3ZWJzb2NrZXRzL3BsdWdpbnMvcHJvdG9jb2xfZHVtYl9pbmNyZW1lbnQuYyIKI2VuZGlmCiNpZmRlZiBQTFVHSU5fUFJPVE9DT0xfTUlSUk9SCiNpbmNsdWRlICJsaWJ3ZWJzb2NrZXRzL3BsdWdpbnMvcHJvdG9jb2xfbHdzX21pcnJvci5jIgojZW5kaWYKI2lmZGVmIFBMVUdJTl9QUk9UT0NPTF9MV1NfUkFXX1NTSEQKI2luY2x1ZGUgImxpYndlYnNvY2tldHMvcGx1Z2lucy9zc2gtYmFzZS9zc2hkLmMiCiNlbmRpZgojaWZkZWYgUExVR0lOX1BST1RPQ09MX1JBV19URVNUCiNpbmNsdWRlICJsaWJ3ZWJzb2NrZXRzL3BsdWdpbnMvcHJvdG9jb2xfbHdzX3Jhd190ZXN0LmMiCiNlbmRpZgoKSlNDbGFzc0lEIGx3c2pzX2NvbnRleHRfY2xhc3NfaWQ7CnN0YXRpYyBKU1ZhbHVlIGx3c2pzX2NvbnRleHRfcHJvdG8sIGx3c2pzX2NvbnRleHRfY3RvcjsKCnN0YXRpYyBzdHJ1Y3QgbHdzX3Byb3RvY29sX3Zob3N0X29wdGlvbnMqIHZob3N0X29wdGlvbnNfZnJvbShKU0NvbnRleHQqLCBKU1ZhbHVlQ29uc3QpOwpzdGF0aWMgc3RydWN0IGx3c19wcm90b2NvbF92aG9zdF9vcHRpb25zKiB2aG9zdF9vcHRpb25zX2Zyb21mcmVlKEpTQ29udGV4dCosIEpTVmFsdWUpOwoKc3RhdGljIHZvaWQgdmhvc3Rfb3B0aW9uc19mcmVlKEpTUnVudGltZSosIHN0cnVjdCBsd3NfcHJvdG9jb2xfdmhvc3Rfb3B0aW9ucyopOwoKdHlwZWRlZiBzdHJ1Y3QgewogIHN0cnVjdCBsaXN0X2hlYWQgbGluazsKICBpbnQgZmQ7CiAgQk9PTCB3cml0ZTsKfSBIYW5kbGVyRnVuY3Rpb247CgpzdGF0aWMgSlNWYWx1ZQppb2hhbmRsZXJfZnVuY3Rpb24oSlNDb250ZXh0KiBjdHgsIEJPT0wgd3JpdGUpIHsKICBKU1ZhbHVlIGdsb2IgPSBKU19HZXRHbG9iYWxPYmplY3QoY3R4KTsKICBKU1ZhbHVlIG9zID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBnbG9iLCAib3MiKTsKICBKU19GcmVlVmFsdWUoY3R4LCBnbG9iKTsKICBKU1ZhbHVlIGZuID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvcywgd3JpdGUgPyAic2V0V3JpdGVIYW5kbGVyIiA6ICJzZXRSZWFkSGFuZGxlciIpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIG9zKTsKICByZXR1cm4gZm47Cn0KCnN0YXRpYyBIYW5kbGVyRnVuY3Rpb24qCmlvaGFuZGxlcl9maW5kKExXU0NvbnRleHQqIGxjLCBpbnQgZmQsIEJPT0wgd3JpdGUpIHsKICBzdHJ1Y3QgbGlzdF9oZWFkKiBlbDsKCiAgbGlzdF9mb3JfZWFjaChlbCwgJmxjLT5oYW5kbGVycykgewogICAgSGFuZGxlckZ1bmN0aW9uKiBoZiA9IGxpc3RfZW50cnkoZWwsIEhhbmRsZXJGdW5jdGlvbiwgbGluayk7CgogICAgaWYoaGYtPmZkID09IGZkICYmIGhmLT53cml0ZSA9PSB3cml0ZSkKICAgICAgcmV0dXJuIGhmOwogIH0KCiAgcmV0dXJuIE5VTEw7Cn0KCnN0YXRpYyBIYW5kbGVyRnVuY3Rpb24qCmlvaGFuZGxlcl9hZGQoTFdTQ29udGV4dCogbGMsIGludCBmZCwgQk9PTCB3cml0ZSkgewogIEhhbmRsZXJGdW5jdGlvbiogaGY7CgogIGlmKChoZiA9IGlvaGFuZGxlcl9maW5kKGxjLCBmZCwgd3JpdGUpKSkKICAgIHJldHVybiBoZjsKCiAgaWYoKGhmID0ganNfbWFsbG9jKGxjLT5qcywgc2l6ZW9mKEhhbmRsZXJGdW5jdGlvbikpKSkgewogICAgaGYtPmZkID0gZmQ7CiAgICBoZi0+d3JpdGUgPSB3cml0ZTsKCiAgICBERUJVRygiJXMgJWQgJXMiLCBfX2Z1bmNfXywgZmQsIHdyaXRlID8gIndyaXRlIiA6ICJyZWFkIik7CgogICAgbGlzdF9hZGQoJmhmLT5saW5rLCAmbGMtPmhhbmRsZXJzKTsKICAgIHJldHVybiBoZjsKICB9CgogIHJldHVybiAwOwp9CgpzdGF0aWMgQk9PTAppb2hhbmRsZXJfcmVtb3ZlKExXU0NvbnRleHQqIGxjLCBpbnQgZmQsIEJPT0wgd3JpdGUpIHsKICBIYW5kbGVyRnVuY3Rpb24qIGhmOwoKICBpZigoaGYgPSBpb2hhbmRsZXJfZmluZChsYywgZmQsIHdyaXRlKSkpIHsKICAgIERFQlVHKCIlcyAlZCAlcyIsIF9fZnVuY19fLCBmZCwgd3JpdGUgPyAid3JpdGUiIDogInJlYWQiKTsKCiAgICBsaXN0X2RlbCgmaGYtPmxpbmspOwogICAganNfZnJlZShsYy0+anMsIGhmKTsKICAgIHJldHVybiBUUlVFOwogIH0KCiAgcmV0dXJuIEZBTFNFOwp9CgpzdGF0aWMgdm9pZAppb2hhbmRsZXJfc2V0KExXU0NvbnRleHQqIGxjLCBpbnQgZmQsIEpTVmFsdWVDb25zdCBoYW5kbGVyLCBCT09MIHdyaXRlKSB7CiAgSlNWYWx1ZSBmbiA9IGlvaGFuZGxlcl9mdW5jdGlvbihsYy0+anMsIHdyaXRlKTsKICBKU1ZhbHVlIGFyZ3NbMl0gPSB7CiAgICAgIEpTX05ld0ludDMyKGxjLT5qcywgZmQpLAogICAgICBoYW5kbGVyLAogIH07CiAgQk9PTCBhZGQgPSBKU19Jc0Z1bmN0aW9uKGxjLT5qcywgaGFuZGxlcik7CgogIC8vIERFQlVHKCIlcyAlZCAlcyIsIHdyaXRlID8gIm9zLnNldFdyaXRlSGFuZGxlciIgOiAib3Muc2V0UmVhZEhhbmRsZXIiLCBmZCwgYWRkID8gIltmdW5jdGlvbl0iIDogIk5VTEwiKTsKCiAgaWYoYWRkKQogICAgaW9oYW5kbGVyX2FkZChsYywgZmQsIHdyaXRlKTsKICBlbHNlCiAgICBpb2hhbmRsZXJfcmVtb3ZlKGxjLCBmZCwgd3JpdGUpOwoKICBKU1ZhbHVlIHJldCA9IEpTX0NhbGwobGMtPmpzLCBmbiwgSlNfTlVMTCwgMiwgYXJncyk7CiAgSlNfRnJlZVZhbHVlKGxjLT5qcywgcmV0KTsKICBKU19GcmVlVmFsdWUobGMtPmpzLCBmbik7Cn0KCnN0YXRpYyB2b2lkCmlvaGFuZGxlcl9jbGVhcihMV1NDb250ZXh0KiBsYywgaW50IGZkKSB7CiAgaW9oYW5kbGVyX3NldChsYywgZmQsIEpTX05VTEwsIEZBTFNFKTsKICBpb2hhbmRsZXJfc2V0KGxjLCBmZCwgSlNfTlVMTCwgVFJVRSk7Cn0KCnN0YXRpYyB2b2lkCmlvaGFuZGxlcl9jbGVhbnVwKExXU0NvbnRleHQqIGxjKSB7CiAgc3RydWN0IGxpc3RfaGVhZCAqZWwsICpuZXh0OwoKICBsaXN0X2Zvcl9lYWNoX3NhZmUoZWwsIG5leHQsICZsYy0+aGFuZGxlcnMpIHsKICAgIEhhbmRsZXJGdW5jdGlvbiogaGYgPSBsaXN0X2VudHJ5KGVsLCBIYW5kbGVyRnVuY3Rpb24sIGxpbmspOwoKICAgIERFQlVHKCJkZWxldGUgaGFuZGxlciAoZmQgPSAlZCwgJXMpIiwgaGYtPmZkLCBoZi0+d3JpdGUgPyAid3JpdGUiIDogInJlYWQiKTsKCiAgICBpb2hhbmRsZXJfc2V0KGxjLCBoZi0+ZmQsIEpTX05VTEwsIGhmLT53cml0ZSk7CiAgfQp9CgpzdGF0aWMgSlNWYWx1ZQpwcm90b2NvbF9oYW5kbGVyKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QqIGFyZ3YsIGludCBtYWdpYywgSlNWYWx1ZUNvbnN0IGZ1bmNfZGF0YVtdKSB7CiAgdm9pZCogY3B0ciA9IHRvX3B0cihjdHgsIGZ1bmNfZGF0YVszXSk7CiAgc3RydWN0IGx3c19wb2xsZmQgbHBmZCA9IHsKICAgICAgLmZkID0gdG9faW50MzIoY3R4LCBmdW5jX2RhdGFbMF0pLAogICAgICAuZXZlbnRzID0gdG9faW50MzIoY3R4LCBmdW5jX2RhdGFbMV0pLAogICAgICAucmV2ZW50cyA9IEpTX1RvQm9vbChjdHgsIGZ1bmNfZGF0YVsyXSkgPyBQT0xMT1VUIDogUE9MTElOLAogIH07CgogIGx3c19zZXJ2aWNlX2ZkKChzdHJ1Y3QgbHdzX2NvbnRleHQqKWNwdHIsICZscGZkKTsKCiAgcmV0dXJuIEpTX1VOREVGSU5FRDsKfQoKc3RhdGljIGludApwb2xsZmRfY2FsbGJhY2soc3RydWN0IGx3cyogd3NpLCBlbnVtIGx3c19jYWxsYmFja19yZWFzb25zIHJlYXNvbiwgdm9pZCogdXNlciwgdm9pZCogaW4sIHNpemVfdCBsZW4pIHsKICBzdHJ1Y3QgbHdzX3Byb3RvY29scyBjb25zdCogcHJvID0gd3NpID8gbHdzX2dldF9wcm90b2NvbCh3c2kpIDogMDsKICBMV1NQcm90b2NvbCogY2xvc3VyZSA9IHBybyA/IHByby0+dXNlciA6IDA7CiAgTFdTQ29udGV4dCogbGMgPSB3c2kgPyBsd3Nqc19zb2NrZXRfY29udGV4dCh3c2kpIDogMDsKICBKU0NvbnRleHQqIGN0eCA9IGNsb3N1cmUgJiYgY2xvc3VyZS0+Y3R4ID8gY2xvc3VyZS0+Y3R4IDogbGMgPyBsYy0+anMgOiAwOwoKICBpZighY3R4ICYmIGxjICYmIGxjLT5jdHgpIHsKICAgIEpTT2JqZWN0KiBvYmogPSBsd3NfY29udGV4dF91c2VyKGxjLT5jdHgpOwogICAgTFdTQ29udGV4dCogbHdzY3R4OwoKICAgIGlmKChsd3NjdHggPSBKU19HZXRPcGFxdWUoSlNfTUtQVFIoSlNfVEFHX09CSkVDVCwgb2JqKSwgbHdzanNfY29udGV4dF9jbGFzc19pZCkpKQogICAgICBjdHggPSBsd3NjdHgtPmpzOwogIH0KCiAgc3dpdGNoKHJlYXNvbikgewogICAgY2FzZSBMV1NfQ0FMTEJBQ0tfTE9DS19QT0xMOgogICAgY2FzZSBMV1NfQ0FMTEJBQ0tfVU5MT0NLX1BPTEw6IHsKICAgICAgcmV0dXJuIDA7CiAgICB9CgogICAgY2FzZSBMV1NfQ0FMTEJBQ0tfREVMX1BPTExfRkQ6IHsKICAgICAgc3RydWN0IGx3c19wb2xsYXJncyogeCA9IGluOwoKICAgICAgaW9oYW5kbGVyX3NldChsYywgeC0+ZmQsIEpTX05VTEwsIDApOwogICAgICBpb2hhbmRsZXJfc2V0KGxjLCB4LT5mZCwgSlNfTlVMTCwgMSk7CiAgICAgIHJldHVybiAwOwogICAgfQoKICAgIGNhc2UgTFdTX0NBTExCQUNLX0FERF9QT0xMX0ZEOgogICAgY2FzZSBMV1NfQ0FMTEJBQ0tfQ0hBTkdFX01PREVfUE9MTF9GRDogewogICAgICBzdHJ1Y3QgbHdzX3BvbGxhcmdzKiB4ID0gaW47CgogICAgICBpZih4LT5ldmVudHMgPT0geC0+cHJldl9ldmVudHMpCiAgICAgICAgcmV0dXJuIDA7CgogICAgICBCT09MIHdyaXRlID0gISEoeC0+ZXZlbnRzICYgUE9MTE9VVCk7CiAgICAgIEpTVmFsdWVDb25zdCBkYXRhW10gPSB7CiAgICAgICAgICBKU19OZXdJbnQzMihjdHgsIHgtPmZkKSwKICAgICAgICAgIEpTX05ld0ludDMyKGN0eCwgeC0+ZXZlbnRzKSwKICAgICAgICAgIEpTX05ld0Jvb2woY3R4LCB3cml0ZSksCiAgICAgICAgICBKU19OZXdJbnQ2NChjdHgsIChpbnRwdHJfdClsd3NfZ2V0X2NvbnRleHQod3NpKSksCiAgICAgIH07CiAgICAgIEpTVmFsdWUgZm4gPSBKU19OZXdDRnVuY3Rpb25EYXRhKGN0eCwgcHJvdG9jb2xfaGFuZGxlciwgMCwgMCwgY291bnRvZihkYXRhKSwgZGF0YSk7CgogICAgICBpZihyZWFzb24gPT0gTFdTX0NBTExCQUNLX0NIQU5HRV9NT0RFX1BPTExfRkQpCiAgICAgICAgaW9oYW5kbGVyX3NldChsYywgeC0+ZmQsIEpTX05VTEwsICF3cml0ZSk7CgogICAgICBpb2hhbmRsZXJfc2V0KGxjLCB4LT5mZCwgZm4sIHdyaXRlKTsKCiAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGZuKTsKICAgICAgcmV0dXJuIDA7CiAgICB9CgogICAgZGVmYXVsdDogYnJlYWs7CiAgfQoKICByZXR1cm4gLTE7Cn0KCnN0YXRpYyBKU0NvbnRleHQqCndzaV90b19qc19jdHgoc3RydWN0IGx3cyogd3NpKSB7CiAgc3RydWN0IGx3c19wcm90b2NvbHMgY29uc3QqIHBybyA9IGx3c19nZXRfcHJvdG9jb2wod3NpKTsKICBMV1NQcm90b2NvbCogY2xvc3VyZSA9IHBybyA/IHByby0+dXNlciA6IDA7CiAgSlNDb250ZXh0KiBjdHggPSBjbG9zdXJlID8gY2xvc3VyZS0+Y3R4IDogMDsKCiAgaWYoIWN0eCkgewogICAgTFdTQ29udGV4dCogbGM7CgogICAgaWYoKGxjID0gbHdzanNfc29ja2V0X2NvbnRleHQod3NpKSkpCiAgICAgIGN0eCA9IGxjLT5qczsKICB9CgogIHJldHVybiBjdHg7Cn0KCnN0YXRpYyBpbnQKanNfY2FsbGJhY2soc3RydWN0IGx3cyogd3NpLCBlbnVtIGx3c19jYWxsYmFja19yZWFzb25zIHJlYXNvbiwgdm9pZCogdXNlciwgdm9pZCogaW4sIHNpemVfdCBsZW4pIHsKICBpZih3c2kpIHsKICAgIEpTVmFsdWUqIGpzdmFsID0gdXNlcjsKICAgIHN0cnVjdCBsd3NfcHJvdG9jb2xzIGNvbnN0KiBwcm8gPSBsd3NfZ2V0X3Byb3RvY29sKHdzaSk7CgogICAgaWYocmVhc29uID09IExXU19DQUxMQkFDS19XU0lfQ1JFQVRFIHx8IHJlYXNvbiA9PSBMV1NfQ0FMTEJBQ0tfSFRUUF9CSU5EX1BST1RPQ09MIHx8IHJlYXNvbiA9PSBMV1NfQ0FMTEJBQ0tfQ0xJRU5UX0hUVFBfQklORF9QUk9UT0NPTCB8fCByZWFzb24gPT0gTFdTX0NBTExCQUNLX1dTX1NFUlZFUl9CSU5EX1BST1RPQ09MIHx8CiAgICAgICByZWFzb24gPT0gTFdTX0NBTExCQUNLX1dTX0NMSUVOVF9CSU5EX1BST1RPQ09MIHx8IHJlYXNvbiA9PSBMV1NfQ0FMTEJBQ0tfUkFXX1BST1hZX0NMSV9CSU5EX1BST1RPQ09MIHx8IHJlYXNvbiA9PSBMV1NfQ0FMTEJBQ0tfUkFXX1BST1hZX1NSVl9CSU5EX1BST1RPQ09MIHx8CiAgICAgICByZWFzb24gPT0gTFdTX0NBTExCQUNLX1JBV19TS1RfQklORF9QUk9UT0NPTCB8fCByZWFzb24gPT0gTFdTX0NBTExCQUNLX1JBV19GSUxFX0JJTkRfUFJPVE9DT0wpIHsKICAgICAgaWYodXNlciAmJiBwcm8tPnBlcl9zZXNzaW9uX2RhdGFfc2l6ZSA9PSBzaXplb2YoSlNWYWx1ZSkpIHsKICAgICAgICBKU0NvbnRleHQqIGN0eCA9IHdzaV90b19qc19jdHgod3NpKTsKCiAgICAgICAgaWYoSlNfVkFMVUVfR0VUX1RBRygqanN2YWwpID09IDAgJiYgSlNfVkFMVUVfR0VUX1BUUigqanN2YWwpID09IDApCiAgICAgICAgICAqanN2YWwgPSBKU19OZXdPYmplY3RQcm90byhjdHgsIEpTX05VTEwpOwoKICAgICAgICByZXR1cm4gMDsKICAgICAgfQogICAgfQoKICAgIGlmKHJlYXNvbiA9PSBMV1NfQ0FMTEJBQ0tfV1NJX0RFU1RST1kpIHsKICAgICAgaWYodXNlciAmJiBwcm8tPnBlcl9zZXNzaW9uX2RhdGFfc2l6ZSA9PSBzaXplb2YoSlNWYWx1ZSkpIHsKICAgICAgICBKU0NvbnRleHQqIGN0eCA9IHdzaV90b19qc19jdHgod3NpKTsKCiAgICAgICAgaWYoSlNfSXNPYmplY3QoKmpzdmFsKSkgewogICAgICAgICAgSlNfRnJlZVZhbHVlKGN0eCwgKmpzdmFsKTsKICAgICAgICAgICpqc3ZhbCA9IEpTX01LUFRSKDAsIDApOwogICAgICAgIH0KCiAgICAgICAgbHdzanNfc29ja2V0X2Rlc3Ryb3koY3R4LCB3c2kpOwogICAgICAgIHJldHVybiAwOwogICAgICB9CiAgICB9CiAgfQoKICByZXR1cm4gLTE7Cn0KCnN0YXRpYyBpbnQKaHR0cF9jYWxsYmFjayhzdHJ1Y3QgbHdzKiB3c2ksIGVudW0gbHdzX2NhbGxiYWNrX3JlYXNvbnMgcmVhc29uLCB2b2lkKiB1c2VyLCB2b2lkKiBpbiwgc2l6ZV90IGxlbikgewogIGlmKGpzX2NhbGxiYWNrKHdzaSwgcmVhc29uLCB1c2VyLCBpbiwgbGVuKSAhPSAwKQogICAgaWYocG9sbGZkX2NhbGxiYWNrKHdzaSwgcmVhc29uLCB1c2VyLCBpbiwgbGVuKSA9PSAwKQogICAgICByZXR1cm4gMDsKCiAgTFdTU29ja2V0KiBzb2NrOwogIEJPT0wgY2xpZW50ID0gRkFMU0U7CgogIGlmKChzb2NrID0gc29ja2V0X2dldCh3c2kpKSkKICAgIGNsaWVudCA9IHNvY2stPmNsaWVudDsKCiAgaW50IHJldCA9IGNsaWVudCA/IDAgOiBsd3NfY2FsbGJhY2tfaHR0cF9kdW1teSh3c2ksIHJlYXNvbiwgdXNlciwgaW4sIGxlbik7CgogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbnQKcHJvdG9jb2xfY2FsbGJhY2soc3RydWN0IGx3cyogd3NpLCBlbnVtIGx3c19jYWxsYmFja19yZWFzb25zIHJlYXNvbiwgdm9pZCogdXNlciwgdm9pZCogaW4sIHNpemVfdCBsZW4pIHsKICBpZihyZWFzb24gPT0gTFdTX0NBTExCQUNLX09QRU5TU0xfTE9BRF9FWFRSQV9DTElFTlRfVkVSSUZZX0NFUlRTIHx8IHJlYXNvbiA9PSBMV1NfQ0FMTEJBQ0tfT1BFTlNTTF9MT0FEX0VYVFJBX1NFUlZFUl9WRVJJRllfQ0VSVFMpCiAgICByZXR1cm4gMDsKCiAgaWYoanNfY2FsbGJhY2sod3NpLCByZWFzb24sIHVzZXIsIGluLCBsZW4pICE9IDApCiAgICBpZihwb2xsZmRfY2FsbGJhY2sod3NpLCByZWFzb24sIHVzZXIsIGluLCBsZW4pID09IDApCiAgICAgIHJldHVybiAwOwoKICBzdHJ1Y3QgbHdzX3Byb3RvY29scyBjb25zdCogcHJvID0gd3NpID8gbHdzX2dldF9wcm90b2NvbCh3c2kpIDogMDsKICBMV1NQcm90b2NvbCogY2xvc3VyZSA9IHBybyA/IHByby0+dXNlciA6IDA7CiAgSlNWYWx1ZSogY2IgPSBjbG9zdXJlID8gJmNsb3N1cmUtPmNhbGxiYWNrIDogMDsKICBMV1NDb250ZXh0KiBsYyA9IHdzaSA/IGx3c2pzX3NvY2tldF9jb250ZXh0KHdzaSkgOiAwOwogIEpTQ29udGV4dCogY3R4ID0gbGMgJiYgbGMtPmpzID8gbGMtPmpzIDogd3NpID8gd3NpX3RvX2pzX2N0eCh3c2kpIDogMDsKICBpbnQzMl90IHJldCA9IDA7CiAgSlNWYWx1ZSoganN2YWwgPSB1c2VyICYmIHBybyAmJiBwcm8tPnBlcl9zZXNzaW9uX2RhdGFfc2l6ZSA9PSBzaXplb2YoSlNWYWx1ZSkgJiYgSlNfSXNPYmplY3QoKihKU1ZhbHVlKil1c2VyKSA/IHVzZXIgOiAwOwoKICBERUJVR19XU0kod3NpLCAiXHgxYlsxOzMzbSUtMjRzXHgxYlswbSAlcCAlcCAlenUiLCBsd3Nqc19jYWxsYmFja19uYW1lKHJlYXNvbiksIHVzZXIsIGluLCBsZW4pOwoKICBpZihjbG9zdXJlICYmIGNvdW50b2YoY2xvc3VyZS0+Y2FsbGJhY2tzKSA+IHJlYXNvbiAmJiAhaXNfbnVsbGlzaChjbG9zdXJlLT5jYWxsYmFja3NbcmVhc29uXSkpIHsKICAgIGNiID0gJmNsb3N1cmUtPmNhbGxiYWNrc1tyZWFzb25dOwogIH0gZWxzZQoKICAgIHN3aXRjaChyZWFzb24pIHsKICAgICAgLy8gY2FzZSBMV1NfQ0FMTEJBQ0tfRklMVEVSX05FVFdPUktfQ09OTkVDVElPTjoKICAgICAgY2FzZSBMV1NfQ0FMTEJBQ0tfTE9DS19QT0xMOgogICAgICBjYXNlIExXU19DQUxMQkFDS19VTkxPQ0tfUE9MTDogcmV0dXJuIDA7CgogICAgICBjYXNlIExXU19DQUxMQkFDS19ERUxfUE9MTF9GRDogewogICAgICAgIHN0cnVjdCBsd3NfcG9sbGFyZ3MqIHggPSBpbjsKCiAgICAgICAgaW9oYW5kbGVyX3NldChsYywgeC0+ZmQsIEpTX05VTEwsIDApOwogICAgICAgIGlvaGFuZGxlcl9zZXQobGMsIHgtPmZkLCBKU19OVUxMLCAxKTsKICAgICAgICByZXR1cm4gMDsKICAgICAgfQoKICAgICAgY2FzZSBMV1NfQ0FMTEJBQ0tfQUREX1BPTExfRkQ6CiAgICAgIGNhc2UgTFdTX0NBTExCQUNLX0NIQU5HRV9NT0RFX1BPTExfRkQ6IHsKICAgICAgICBzdHJ1Y3QgbHdzX3BvbGxhcmdzKiB4ID0gaW47CiAgICAgICAgQk9PTCB3cml0ZSA9ICEhKHgtPmV2ZW50cyAmIFBPTExPVVQpOwogICAgICAgIEpTVmFsdWVDb25zdCBkYXRhW10gPSB7CiAgICAgICAgICAgIEpTX05ld0ludDMyKGN0eCwgeC0+ZmQpLAogICAgICAgICAgICBKU19OZXdJbnQzMihjdHgsIHgtPmV2ZW50cyksCiAgICAgICAgICAgIEpTX05ld0Jvb2woY3R4LCB3cml0ZSksCiAgICAgICAgICAgIEpTX05ld0ludDY0KGN0eCwgKGludHB0cl90KWx3c19nZXRfY29udGV4dCh3c2kpKSwKICAgICAgICB9OwogICAgICAgIEpTVmFsdWUgZm4gPSBKU19OZXdDRnVuY3Rpb25EYXRhKGN0eCwgcHJvdG9jb2xfaGFuZGxlciwgMCwgMCwgY291bnRvZihkYXRhKSwgZGF0YSk7CgogICAgICAgIGlmKHJlYXNvbiA9PSBMV1NfQ0FMTEJBQ0tfQ0hBTkdFX01PREVfUE9MTF9GRCkKICAgICAgICAgIGlvaGFuZGxlcl9zZXQobGMsIHgtPmZkLCBKU19OVUxMLCAhd3JpdGUpOwoKICAgICAgICBpb2hhbmRsZXJfc2V0KGxjLCB4LT5mZCwgZm4sIHdyaXRlKTsKCiAgICAgICAgSlNfRnJlZVZhbHVlKGN0eCwgZm4pOwogICAgICAgIHJldHVybiAwOwogICAgICB9CgogICAgICBkZWZhdWx0OiBicmVhazsKICAgIH0KCiAgLyppZigoKGludDMyX3QqKXdzaSlbNThdICYgMikKICAgIHJldHVybiBsd3NfY2FsbGJhY2tfaHR0cF9kdW1teSh3c2ksIHJlYXNvbiwgdXNlciwgaW4sIGxlbik7Ki8KCiAgSlNWYWx1ZSBzb2NrID0gd3NpICYmIHJlYXNvbiAhPSBMV1NfQ0FMTEJBQ0tfQ0xJRU5UX0hUVFBfQklORF9QUk9UT0NPTCAmJiByZWFzb24gIT0gTFdTX0NBTExCQUNLX1BST1RPQ09MX0lOSVQgPyBsd3Nqc19zb2NrZXRfZ2V0X29yX2NyZWF0ZShjdHgsIHdzaSkgOiBKU19VTkRFRklORUQ7CiAgTFdTU29ja2V0KiBzID0gbHdzanNfc29ja2V0X2RhdGEoc29jayk7CgogIGlmKHJlYXNvbiA9PSBMV1NfQ0FMTEJBQ0tfSFRUUF9XUklURUFCTEUgfHwgcmVhc29uID09IExXU19DQUxMQkFDS19DTElFTlRfSFRUUF9XUklURUFCTEUgfHwgcmVhc29uID09IExXU19DQUxMQkFDS19TRVJWRVJfV1JJVEVBQkxFIHx8IHJlYXNvbiA9PSBMV1NfQ0FMTEJBQ0tfQ0xJRU5UX1dSSVRFQUJMRSB8fAogICAgIHJlYXNvbiA9PSBMV1NfQ0FMTEJBQ0tfUkFXX1BST1hZX0NMSV9XUklURUFCTEUgfHwgcmVhc29uID09IExXU19DQUxMQkFDS19SQVdfUFJPWFlfU1JWX1dSSVRFQUJMRSB8fCByZWFzb24gPT0gTFdTX0NBTExCQUNLX1JBV19XUklURUFCTEUgfHwgcmVhc29uID09IExXU19DQUxMQkFDS19SQVdfV1JJVEVBQkxFX0ZJTEUgfHwKICAgICByZWFzb24gPT0gTFdTX0NBTExCQUNLX01RVFRfQ0xJRU5UX1dSSVRFQUJMRSkgewogICAgaWYocyAmJiBzLT53YW50X3dyaXRlKSB7CiAgICAgIHMtPndhbnRfd3JpdGUgPSBGQUxTRTsKCiAgICAgIGlmKCFKU19Jc1VuZGVmaW5lZChzLT53cml0ZV9oYW5kbGVyKSkgewogICAgICAgIEpTVmFsdWUgZm4gPSBzLT53cml0ZV9oYW5kbGVyOwogICAgICAgIHMtPndyaXRlX2hhbmRsZXIgPSBKU19VTkRFRklORUQ7CiAgICAgICAgSlNWYWx1ZSByZXN1bHQgPSBKU19DYWxsKGN0eCwgZm4sIEpTX1VOREVGSU5FRCwgMSwgJnNvY2spOwogICAgICAgIHJldCA9IHRvX2ludDMyKGN0eCwgcmVzdWx0KTsKICAgICAgICBKU19GcmVlVmFsdWUoY3R4LCByZXN1bHQpOwogICAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGZuKTsKICAgICAgICBnb3RvIGVuZDsKICAgICAgfQogICAgfQoKICAgIGlmKHJlYXNvbiA9PSBMV1NfQ0FMTEJBQ0tfQ0xJRU5UX0FQUEVORF9IQU5EU0hBS0VfSEVBREVSKQogICAgICBzLT5yZWRpcmVjdGVkX3RvX2dldCA9IGx3c19odHRwX2lzX3JlZGlyZWN0ZWRfdG9fZ2V0KHdzaSk7CgogICAgaWYocmVhc29uID09IExXU19DQUxMQkFDS19DTElFTlRfSFRUUF9XUklURUFCTEUpCiAgICAgIGlmKHMtPnJlZGlyZWN0ZWRfdG9fZ2V0KQogICAgICAgIGdvdG8gZW5kOwogIH0KCiAgaWYocmVhc29uID09IExXU19DQUxMQkFDS19DTElFTlRfRklMVEVSX1BSRV9FU1RBQkxJU0ggfHwgcmVhc29uID09IExXU19DQUxMQkFDS19FU1RBQkxJU0hFRF9DTElFTlRfSFRUUCB8fCByZWFzb24gPT0gTFdTX0NBTExCQUNLX0ZJTFRFUl9IVFRQX0NPTk5FQ1RJT04gfHwgcmVhc29uID09IExXU19DQUxMQkFDS19IVFRQKSB7CiAgICBpZihzICYmIGlzX251bGxpc2gocy0+aGVhZGVycykpIHsKICAgICAgcy0+aGVhZGVycyA9IGx3c2pzX3NvY2tldF9oZWFkZXJzKGN0eCwgcy0+d3NpLCAmcy0+cHJvdG8pOwogICAgfQogIH0KCiAgaWYocmVhc29uID09IExXU19DQUxMQkFDS19IVFRQIHx8IHJlYXNvbiA9PSBMV1NfQ0FMTEJBQ0tfRklMVEVSX0hUVFBfQ09OTkVDVElPTiB8fCByZWFzb24gPT0gTFdTX0NBTExCQUNLX0NMSUVOVF9GSUxURVJfUFJFX0VTVEFCTElTSCkgewogICAgaWYocyAmJiAocy0+dXJpID09IDAgfHwgcy0+bWV0aG9kID09IC0xKSkgewogICAgICBjaGFyKiB1cmlfcHRyID0gMDsKICAgICAgaW50IHVyaV9sZW4gPSAwOwoKICAgICAgaW50IG1ldGhvZCA9IGx3c19odHRwX2dldF91cmlfYW5kX21ldGhvZChzLT53c2ksICZ1cmlfcHRyLCAmdXJpX2xlbik7CgogICAgICBpZih1cmlfcHRyICYmIHMtPnVyaSA9PSAwKQogICAgICAgIHMtPnVyaSA9IGpzX3N0cm5kdXAoY3R4LCB1cmlfcHRyLCB1cmlfbGVuKTsKCiAgICAgIGlmKG1ldGhvZCA+PSAwICYmIHMtPm1ldGhvZCA9PSAtMSkKICAgICAgICBzLT5tZXRob2QgPSBtZXRob2Q7CiAgICB9CiAgfQoKICBpZihjYiAmJiAhaXNfbnVsbGlzaCgqY2IpKSB7CiAgICBpbnQgYXJnaSA9IDEsIGJ1ZmZlcl9pbmRleCA9IC0xOwogICAgSlNWYWx1ZSBhcmd2WzVdID0gewogICAgICAgIEpTX0R1cFZhbHVlKGN0eCwgc29jayksCiAgICB9OwoKICAgIGlmKGNiID09ICZjbG9zdXJlLT5jYWxsYmFjaykKICAgICAgYXJndlthcmdpKytdID0gSlNfTmV3SW50MzIoY3R4LCByZWFzb24pOwoKICAgIC8qYXJndlthcmdpKytdID0gKHVzZXIgJiYgcHJvLT5wZXJfc2Vzc2lvbl9kYXRhX3NpemUgPT0gc2l6ZW9mKEpTVmFsdWUpICYmIChKU19WQUxVRV9HRVRfT0JKKCooSlNWYWx1ZSopdXNlcikgJiYgSlNfVkFMVUVfR0VUX1RBRygqKEpTVmFsdWUqKXVzZXIpID09IEpTX1RBR19PQkpFQ1QpKSA/ICooSlNWYWx1ZSopdXNlciA6IEpTX05VTEw7Ki8KCiAgICBpZihyZWFzb24gPT0gTFdTX0NBTExCQUNLX0hUVFBfQ09ORklSTV9VUEdSQURFKSB7CiAgICAgIGlmKHMgJiYgIXN0cmNtcChpbiwgIndlYnNvY2tldCIpKQogICAgICAgIHMtPnR5cGUgPSBTT0NLRVRfV1M7CiAgICB9CgogICAgaWYocmVhc29uID09IExXU19DQUxMQkFDS19GSUxURVJfSFRUUF9DT05ORUNUSU9OKSB7CiAgICAgIGlmKHMgJiYgIXN0cmNtcChpbiwgIndzIikpCiAgICAgICAgcy0+dHlwZSA9IFNPQ0tFVF9XUzsKICAgIH0KCiAgICBpZihyZWFzb24gPT0gTFdTX0NBTExCQUNLX0NMSUVOVF9FU1RBQkxJU0hFRCB8fCByZWFzb24gPT0gTFdTX0NBTExCQUNLX0ZJTFRFUl9QUk9UT0NPTF9DT05ORUNUSU9OKSB7CiAgICAgIGlmKHMpCiAgICAgICAgcy0+dHlwZSA9IFNPQ0tFVF9XUzsKICAgIH0KCiAgICBCT09MIHByb2Nlc3NfaHRtbF9hcmdzID0gcmVhc29uID09IExXU19DQUxMQkFDS19BRERfSEVBREVSUyB8fCByZWFzb24gPT0gTFdTX0NBTExCQUNLX0NIRUNLX0FDQ0VTU19SSUdIVFMgfHwgcmVhc29uID09IExXU19DQUxMQkFDS19QUk9DRVNTX0hUTUw7CgogICAgaWYocmVhc29uID09IExXU19DQUxMQkFDS19DTElFTlRfSFRUUF9SRURJUkVDVCkgewogICAgICBhcmd2W2FyZ2krK10gPSBKU19OZXdTdHJpbmcoY3R4LCBpbik7CiAgICAgIGFyZ3ZbYXJnaSsrXSA9IEpTX05ld0ludDMyKGN0eCwgbGVuKTsKICAgIH0gZWxzZSBpZihyZWFzb24gPT0gTFdTX0NBTExCQUNLX0NMSUVOVF9SRUNFSVZFICYmICgoKGNoYXIqKWluKVstMl0gJiAweDdmKSA9PSA4KSB7CiAgICAgIEJPT0wgaGFzX3JlYXNvbiA9IGNiID09ICZjbG9zdXJlLT5jYWxsYmFjazsKICAgICAgaW50IGNvZGUgPSAoaW50KSgoKHVpbnQ4X3QqKWluKVswXSkgPDwgOCB8ICgodWludDhfdCopaW4pWzFdOwoKICAgICAgcmVhc29uID0gTFdTX0NBTExCQUNLX1dTX1BFRVJfSU5JVElBVEVEX0NMT1NFOwogICAgICBjYiA9IGlzX251bGxpc2goY2xvc3VyZS0+Y2FsbGJhY2tzW3JlYXNvbl0pID8gJmNsb3N1cmUtPmNhbGxiYWNrIDogJmNsb3N1cmUtPmNhbGxiYWNrc1tyZWFzb25dOwoKICAgICAgaWYoIWhhc19yZWFzb24gJiYgY2IgPT0gJmNsb3N1cmUtPmNhbGxiYWNrKQogICAgICAgIGFyZ3ZbYXJnaSsrXSA9IEpTX05ld0ludDMyKGN0eCwgcmVhc29uKTsKCiAgICAgIGFyZ3ZbYXJnaSsrXSA9IEpTX05ld0ludDMyKGN0eCwgY29kZSk7CgogICAgICBpZihsZW4gPiAyKQogICAgICAgIGFyZ3ZbYXJnaSsrXSA9IEpTX05ld1N0cmluZ0xlbihjdHgsIChjaGFyKilpbiArIDIsIGxlbiAtIDIpOwogICAgfSBlbHNlIGlmKHByb2Nlc3NfaHRtbF9hcmdzKSB7CiAgICAgIHN0cnVjdCBsd3NfcHJvY2Vzc19odG1sX2FyZ3MqIHBoYSA9IChzdHJ1Y3QgbHdzX3Byb2Nlc3NfaHRtbF9hcmdzKilpbjsKCiAgICAgIGlmKHJlYXNvbiA9PSBMV1NfQ0FMTEJBQ0tfQUREX0hFQURFUlMpCiAgICAgICAgcGhhLT5sZW4gPSAwOwoKICAgICAgaWYocGhhLT5sZW4gPCBwaGEtPm1heF9sZW4pCiAgICAgICAgbWVtc2V0KCZwaGEtPnBbcGhhLT5sZW5dLCAwLCBwaGEtPm1heF9sZW4gLSBwaGEtPmxlbik7CgogICAgICBhcmd2W2J1ZmZlcl9pbmRleCA9IGFyZ2krK10gPSBKU19OZXdBcnJheUJ1ZmZlcihjdHgsICh1aW50OF90KilwaGEtPnAsIHBoYS0+bWF4X2xlbiwgMCwgMCwgRkFMU0UpOwogICAgICBhcmd2W2FyZ2ldID0gSlNfTmV3QXJyYXkoY3R4KTsKICAgICAgSlNfU2V0UHJvcGVydHlVaW50MzIoY3R4LCBhcmd2W2FyZ2ldLCAwLCBKU19OZXdVaW50MzIoY3R4LCBwaGEtPmxlbikpOwogICAgICBhcmdpKys7CiAgICB9IGVsc2UgaWYocmVhc29uID09IExXU19DQUxMQkFDS19FU1RBQkxJU0hFRCkgewogICAgICBhcmd2W2FyZ2krK10gPSBqc19mbXRfcG9pbnRlcihjdHgsIGluLCAiKFNTTCopIik7CiAgICAgIGFyZ3ZbYXJnaSsrXSA9IEpTX05ld0ludDMyKGN0eCwgbGVuKTsKICAgIH0gZWxzZSBpZihyZWFzb24gPT0gTFdTX0NBTExCQUNLX0NMSUVOVF9BUFBFTkRfSEFORFNIQUtFX0hFQURFUikgewogICAgICBtZW1zZXQoKih1aW50OF90KiopaW4sIDAsIGxlbik7CiAgICAgIGFyZ3ZbYnVmZmVyX2luZGV4ID0gYXJnaSsrXSA9IEpTX05ld0FycmF5QnVmZmVyKGN0eCwgKih1aW50OF90KiopaW4sIGxlbiwgMCwgMCwgRkFMU0UpOwogICAgICBhcmd2W2FyZ2ldID0gSlNfTmV3QXJyYXkoY3R4KTsKICAgICAgSlNfU2V0UHJvcGVydHlVaW50MzIoY3R4LCBhcmd2W2FyZ2ldLCAwLCBKU19OZXdVaW50MzIoY3R4LCAwKSk7CiAgICAgIGFyZ2krKzsKICAgIH0gZWxzZSBpZihyZWFzb24gPT0gTFdTX0NBTExCQUNLX09QRU5TU0xfUEVSRk9STV9TRVJWRVJfQ0VSVF9WRVJJRklDQVRJT04pIHsKICAgICAgYXJndlthcmdpKytdID0gSlNfTmV3SW50NjQoY3R4LCAoaW50NjRfdCkoaW50cHRyX3QpaW4pOwogICAgICBhcmd2W2FyZ2krK10gPSBKU19OZXdJbnQzMihjdHgsIGxlbik7CiAgICB9IGVsc2UgaWYocmVhc29uID09IExXU19DQUxMQkFDS19FU1RBQkxJU0hFRF9DTElFTlRfSFRUUCkgewogICAgICBpbnQgcmVzcG9uc2UgPSBsd3NfaHR0cF9jbGllbnRfaHR0cF9yZXNwb25zZSh3c2kpOwoKICAgICAgYXNzZXJ0KHMpOwogICAgICBzLT5yZXNwb25zZV9jb2RlID0gcmVzcG9uc2U7CgogICAgICBhcmd2W2FyZ2krK10gPSBKU19OZXdJbnQzMihjdHgsIHJlc3BvbnNlKTsKICAgIH0gZWxzZSBpZihyZWFzb24gPT0gTFdTX0NBTExCQUNLX0NPTk5FQ1RJTkcpIHsKICAgICAgYXJndlthcmdpKytdID0gSlNfTmV3SW50MzIoY3R4LCAoaW50MzJfdCkoaW50cHRyX3QpaW4pOwogICAgfSBlbHNlIGlmKHJlYXNvbiA9PSBMV1NfQ0FMTEJBQ0tfV1NfUEVFUl9JTklUSUFURURfQ0xPU0UpIHsKICAgICAgaWYobGVuID49IDIpCiAgICAgICAgYXJndlthcmdpKytdID0gSlNfTmV3SW50MzIoY3R4LCBudG9ocygqKHVpbnQxNl90KilpbikpOwoKICAgICAgaWYobGVuID4gMikKICAgICAgICBhcmd2W2FyZ2krK10gPSBKU19OZXdBcnJheUJ1ZmZlckNvcHkoY3R4LCAoY29uc3QgdWludDhfdCopaW4gKyAyLCBsZW4gLSAyKTsKCiAgICB9IGVsc2UgaWYoaW4gJiYgKGxlbiA+IDAgfHwgcmVhc29uID09IExXU19DQUxMQkFDS19BRERfSEVBREVSUykgJiYgcmVhc29uICE9IExXU19DQUxMQkFDS19GSUxURVJfSFRUUF9DT05ORUNUSU9OICYmIHJlYXNvbiAhPSBMV1NfQ0FMTEJBQ0tfQ0xJRU5UX0NPTk5FQ1RJT05fRVJST1IpIHsKICAgICAgQk9PTCBpc193cyA9IHJlYXNvbiA9PSBMV1NfQ0FMTEJBQ0tfQ0xJRU5UX1JFQ0VJVkUgfHwgcmVhc29uID09IExXU19DQUxMQkFDS19SRUNFSVZFOwoKICAgICAgYXJndlthcmdpKytdID0gaW4gPyAoKCFpc193cyB8fCBsd3NfZnJhbWVfaXNfYmluYXJ5KHdzaSkpKSA/IEpTX05ld0FycmF5QnVmZmVyQ29weShjdHgsIGluLCBsZW4pIDogSlNfTmV3U3RyaW5nTGVuKGN0eCwgaW4sIGxlbikgOiBKU19OVUxMOwogICAgICBhcmd2W2FyZ2krK10gPSBKU19OZXdJbnQ2NChjdHgsIGxlbik7CiAgICB9IGVsc2UgaWYoaW4gJiYgKGxlbiA9PSAwIHx8IHJlYXNvbiA9PSBMV1NfQ0FMTEJBQ0tfRklMVEVSX0hUVFBfQ09OTkVDVElPTiB8fCByZWFzb24gPT0gTFdTX0NBTExCQUNLX0NMSUVOVF9DT05ORUNUSU9OX0VSUk9SKSkgewogICAgICBhcmd2W2FyZ2krK10gPSBKU19OZXdTdHJpbmcoY3R4LCBpbik7CiAgICB9CgogICAgaWYocmVhc29uID09IExXU19DQUxMQkFDS19DTElFTlRfQ09OTkVDVElPTl9FUlJPUikgewogICAgICBhcmd2W2FyZ2krK10gPSBKU19OZXdJbnQzMihjdHgsIGVycm5vKTsKICAgIH0KCiAgICBpZihyZWFzb24gPT0gTFdTX0NBTExCQUNLX1JBV19DTE9TRSkgewogICAgICAvKkpTX0ZyZWVWYWx1ZShjdHgsIGFyZ3ZbLS1hcmdpXSk7CiAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGFyZ3ZbLS1hcmdpXSk7Ki8KCiAgICAgIGFyZ3ZbYXJnaSsrXSA9IEpTX05ld0ludDMyKGN0eCwgZXJybm8pOwogICAgfQoKICAgIEpTVmFsdWUgcmVzdWx0ID0gSlNfQ2FsbChjdHgsICpjYiwganN2YWwgPyAqanN2YWwgOiBKU19OVUxMLCBhcmdpLCBhcmd2KTsKCiAgICBpZihKU19Jc0V4Y2VwdGlvbihyZXN1bHQpKSB7CiAgICAgIEpTVmFsdWUgZXJyb3IgPSBKU19HZXRFeGNlcHRpb24oY3R4KTsKICAgICAganNfZXJyb3JfcHJpbnQoY3R4LCBlcnJvcik7CiAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGVycm9yKTsKICAgICAgLyogIHJldCA9IC0xOwogICAgICAgIGdvdG8gZW5kOyovCiAgICB9CgogICAgaWYocmVhc29uID09IExXU19DQUxMQkFDS19DTElFTlRfQVBQRU5EX0hBTkRTSEFLRV9IRUFERVIpIHsKICAgICAgaW50NjRfdCBuID0gdG9faW50NjQoY3R4LCBKU19HZXRQcm9wZXJ0eVVpbnQzMihjdHgsIGFyZ3ZbYXJnaSAtIDFdLCAwKSk7CgogICAgICAqKHVpbnQ4X3QqKilpbiArPSBNSU4oTUFYKDAsIG4pLCAoaW50NjRfdClsZW4pOwoKICAgIH0gZWxzZSBpZihwcm9jZXNzX2h0bWxfYXJncykgewogICAgICBzdHJ1Y3QgbHdzX3Byb2Nlc3NfaHRtbF9hcmdzKiBwaGEgPSAoc3RydWN0IGx3c19wcm9jZXNzX2h0bWxfYXJncyopaW47CiAgICAgIGludDY0X3QgbiA9IHRvX2ludDY0KGN0eCwgSlNfR2V0UHJvcGVydHlVaW50MzIoY3R4LCBhcmd2W2FyZ2kgLSAxXSwgMCkpOwoKICAgICAgcGhhLT5wICs9IE1JTihNQVgoMCwgbiksIChpbnQ2NF90KShwaGEtPm1heF9sZW4gLSBwaGEtPmxlbikpOwogICAgfQoKICAgIGZvcihpbnQgaiA9IDA7IGogPCBhcmdpOyBqKyspIHsKICAgICAgaWYoYnVmZmVyX2luZGV4ID09IGFyZ2kpCiAgICAgICAgSlNfRGV0YWNoQXJyYXlCdWZmZXIoY3R4LCBhcmd2W2pdKTsKICAgICAgSlNfRnJlZVZhbHVlKGN0eCwgYXJndltqXSk7CiAgICB9CgogICAgcmV0ID0gdG9faW50MzJmcmVlKGN0eCwgcmVzdWx0KTsKICB9CgogIGlmKHMgJiYgcy0+Y2xvc2VkKQogICAgcmV0ID0gLTE7CgogIC8qICBpZihyZWFzb24gPT0gTFdTX0NBTExCQUNLX0NMSUVOVF9BUFBFTkRfSEFORFNIQUtFX0hFQURFUikKICAgICAgaWYocyAmJiBzLT5tZXRob2QgPT0gV1NJX1RPS0VOX1BPU1RfVVJJKQogICAgICAgIGlmKCFsd3NfaHR0cF9pc19yZWRpcmVjdGVkX3RvX2dldCh3c2kpKSB7CiAgICAgICAgICBsd3NsX3VzZXIoIiVzOiBkb2luZyBQT1NUIGZsb3dcbiIsIF9fZnVuY19fKTsKICAgICAgICAgIGx3c19jbGllbnRfaHR0cF9ib2R5X3BlbmRpbmcod3NpLCAxKTsKICAgICAgICAgIGx3c19jYWxsYmFja19vbl93cml0YWJsZSh3c2kpOwogICAgICAgIH0qLwoKICBpZihyZWFzb24gIT0gTFdTX0NBTExCQUNLX1BST1RPQ09MX0lOSVQgJiYgcmVhc29uICE9IExXU19DQUxMQkFDS19IVFRQX0JJTkRfUFJPVE9DT0wpIHsKICAgIGlmKHMgJiYgcy0+Y29tcGxldGVkKQogICAgICByZXQgPSAtMTsKICB9CgogIGlmKHJldCAhPSAwKSB7CiAgICBpbnQgZmQgPSBsd3NfZ2V0X3NvY2tldF9mZCh3c2kpOwoKICAgIGlmKGZkICE9IC0xKQogICAgICBpb2hhbmRsZXJfY2xlYXIobGMsIGZkKTsKCiAgICBsd3Nfd3NpX2Nsb3NlKHdzaSwgTFdTX1RPX0tJTExfQVNZTkMpOwogICAgLy8gbHdzX2Nsb3NlX2ZyZWVfd3NpKHdzaSwgTFdTX0NMT1NFX1NUQVRVU19OT1NUQVRVUywgX19mdW5jX18pOwogIH0KCmVuZDoKICBKU19GcmVlVmFsdWUoY3R4LCBzb2NrKTsKCiAgLyppZihyZXQgPT0gMCkKICAgIHJldHVybiBsd3NfY2FsbGJhY2tfaHR0cF9kdW1teSh3c2ksIHJlYXNvbiwgdXNlciwgaW4sIGxlbik7Ki8KCiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIEpTVmFsdWUKY19jYWxsYmFjayhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSwgaW50IG1hZ2ljLCB2b2lkKiBjbG9zdXJlKSB7CiAgY29uc3Qgc3RydWN0IGx3c19wcm90b2NvbHMqIHByb3RvID0gY2xvc3VyZTsKICBzdHJ1Y3QgbHdzKiB3c2kgPSAwOwogIGludCByZWFzb24gPSAtMTsKICBjaGFyKiBzdHIgPSAwOwogIHZvaWQgKnVzZXIgPSAwLCAqaW4gPSAwOwogIHNpemVfdCBsZW4gPSAwOwoKICBpZihhcmdjID4gMCkKICAgIHdzaSA9IGx3c2pzX3NvY2tldF93c2koYXJndlswXSk7CgogIGlmKGFyZ2MgPiAxKQogICAgcmVhc29uID0gdG9faW50MzIoY3R4LCBhcmd2WzFdKTsKCiAgaWYoSlNfSXNPYmplY3QodGhpc192YWwpICYmICFKU19Jc051bGwodGhpc192YWwpKQogICAgdXNlciA9ICZ0aGlzX3ZhbDsKCiAgaWYoYXJnYyA+IDIpCiAgICBpZighKGluID0gSlNfR2V0QXJyYXlCdWZmZXIoY3R4LCAmbGVuLCBhcmd2WzJdKSkpCiAgICAgIGluID0gc3RyID0gdG9fc3RyaW5nbGVuKGN0eCwgJmxlbiwgYXJndlsyXSk7CgogIGlmKGFyZ2MgPiAzKQogICAgbGVuID0gdG9fdWludDMyKGN0eCwgYXJndlszXSk7CgogIEpTVmFsdWUgcmV0ID0gSlNfTmV3SW50MzIoY3R4LCBwcm90by0+Y2FsbGJhY2sod3NpLCByZWFzb24sIHVzZXIsIGluLCBsZW4pKTsKCiAgaWYoc3RyKQogICAganNfZnJlZShjdHgsIHN0cik7CgogIHJldHVybiByZXQ7Cn0KCkpTVmFsdWUKbHdzanNfcHJvdG9jb2xfb2JqKEpTQ29udGV4dCogY3R4LCBjb25zdCBzdHJ1Y3QgbHdzX3Byb3RvY29scyogcHJvdG8pIHsKICBKU1ZhbHVlIHJldCA9IEpTX1VOREVGSU5FRDsKCiAgLyppZihwcm90by0+dXNlcikKICAgIHJldHVybiBwdHJfb2JqKGN0eCwgKChMV1NQcm90b2NvbCopcHJvdG8tPnVzZXIpLT5vYmopOyovCgogIHJldCA9IEpTX05ld09iamVjdFByb3RvKGN0eCwgSlNfTlVMTCk7CgogIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAibmFtZSIsIEpTX05ld1N0cmluZyhjdHgsIHByb3RvLT5uYW1lKSk7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJwZXJTZXNzaW9uRGF0YVNpemUiLCBKU19OZXdVaW50MzIoY3R4LCBwcm90by0+cGVyX3Nlc3Npb25fZGF0YV9zaXplKSk7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJyeEJ1ZmZlclNpemUiLCBKU19OZXdVaW50MzIoY3R4LCBwcm90by0+cnhfYnVmZmVyX3NpemUpKTsKICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIHJldCwgImlkIiwgSlNfTmV3VWludDMyKGN0eCwgcHJvdG8tPmlkKSk7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJ0eFBhY2tldFNpemUiLCBKU19OZXdVaW50MzIoY3R4LCBwcm90by0+dHhfcGFja2V0X3NpemUpKTsKCiAgSlNWYWx1ZSBjYiA9IEpTX05VTEw7CgogIGlmKHByb3RvLT5jYWxsYmFjaykKICAgIGNiID0ganNfZnVuY3Rpb25fY2Nsb3N1cmUoY3R4LCBjX2NhbGxiYWNrLCA0LCAwLCAodm9pZCopcHJvdG8sIDApOwoKICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIHJldCwgImNhbGxiYWNrIiwgY2IpOwoKICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgc3RydWN0IGx3c19wcm90b2NvbHMKcHJvdG9jb2xfZnJvbShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaikgewogIHN0cnVjdCBsd3NfcHJvdG9jb2xzIHBybyA9IHswfTsKICBMV1NQcm90b2NvbCogY2xvc3VyZTsKCiAgaWYoIShjbG9zdXJlID0ganNfbWFsbG9jeihjdHgsIHNpemVvZihMV1NQcm90b2NvbCkpKSkKICAgIHJldHVybiBwcm87CgogIEJPT0wgaXNfYXJyYXkgPSBKU19Jc0FycmF5KGN0eCwgb2JqKTsKICBKU1ZhbHVlIHZhbHVlID0gaXNfYXJyYXkgPyBKU19HZXRQcm9wZXJ0eVVpbnQzMihjdHgsIG9iaiwgMCkgOiBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iaiwgIm5hbWUiKTsKICBwcm8ubmFtZSA9IHRvX3N0cmluZ2ZyZWUoY3R4LCB2YWx1ZSk7CgogIHZhbHVlID0gaXNfYXJyYXkgPyBKU19HZXRQcm9wZXJ0eVVpbnQzMihjdHgsIG9iaiwgMSkgOiBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iaiwgImNhbGxiYWNrIik7CgogIGNsb3N1cmUtPmN0eCA9IGN0eDsKICBjbG9zdXJlLT5jYWxsYmFjayA9IHZhbHVlOwogIGNsb3N1cmUtPm9iaiA9IG9ial9wdHIoY3R4LCBvYmopOwoKICBwcm8uY2FsbGJhY2sgPSBwcm90b2NvbF9jYWxsYmFjazsKICBwcm8udXNlciA9IGNsb3N1cmU7CgogIGx3c2pzX2dldF9sd3NfY2FsbGJhY2tzKGN0eCwgb2JqLCBjbG9zdXJlLT5jYWxsYmFja3MsIGNvdW50b2YoY2xvc3VyZS0+Y2FsbGJhY2tzKSk7CgogIHByby5wZXJfc2Vzc2lvbl9kYXRhX3NpemUgPSBzaXplb2YoSlNWYWx1ZSk7CgogIHZhbHVlID0gaXNfYXJyYXkgPyBKU19HZXRQcm9wZXJ0eVVpbnQzMihjdHgsIG9iaiwgMikgOiBqc19nZXRfcHJvcGVydHkoY3R4LCBvYmosICJyeF9idWZmZXJfc2l6ZSIpOwogIHByby5yeF9idWZmZXJfc2l6ZSA9IHRvX2ludGVnZXJmcmVlKGN0eCwgdmFsdWUpOwoKICB2YWx1ZSA9IGlzX2FycmF5ID8gSlNfR2V0UHJvcGVydHlVaW50MzIoY3R4LCBvYmosIDMpIDogSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmosICJpZCIpOwogIHByby5pZCA9IHRvX2ludGVnZXJmcmVlKGN0eCwgdmFsdWUpOwoKICB2YWx1ZSA9IGlzX2FycmF5ID8gSlNfR2V0UHJvcGVydHlVaW50MzIoY3R4LCBvYmosIDQpIDoganNfZ2V0X3Byb3BlcnR5KGN0eCwgb2JqLCAidHhfcGFja2V0X3NpemUiKTsKICBwcm8udHhfcGFja2V0X3NpemUgPSB0b19pbnRlZ2VyZnJlZShjdHgsIHZhbHVlKTsKCiAgcmV0dXJuIHBybzsKfQoKc3RhdGljIHZvaWQKcHJvdG9jb2xfZnJlZShKU1J1bnRpbWUqIHJ0LCBzdHJ1Y3QgbHdzX3Byb3RvY29scyogcHJvKSB7CiAgTFdTUHJvdG9jb2wqIGNsb3N1cmUgPSBwcm8tPnVzZXI7CgogIGlmKGNsb3N1cmUpIHsKICAgIEpTX0ZyZWVWYWx1ZVJUKHJ0LCBjbG9zdXJlLT5jYWxsYmFjayk7CgogICAgaWYoY2xvc3VyZS0+b2JqKQogICAgICBvYmpfZnJlZShydCwgY2xvc3VyZS0+b2JqKTsKCiAgICBqc19mcmVlX3J0KHJ0LCBjbG9zdXJlKTsKICB9CgogIHByby0+dXNlciA9IDA7CiAgcHJvLT5jYWxsYmFjayA9IDA7CgogIGlmKHByby0+bmFtZSkgewogICAganNfZnJlZV9ydChydCwgKGNoYXIqKXByby0+bmFtZSk7CiAgICBwcm8tPm5hbWUgPSAwOwogIH0KfQoKc3RhdGljIGNvbnN0IHN0cnVjdCBsd3NfcHJvdG9jb2xzKgpwcm90b2NvbHNfZnJvbWFycmF5KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBzaXplX3QgbGVuID0gMDsKICBKU1ZhbHVlKiB2YWx1ZXMgPSB0b192YWx1ZWFycmF5KGN0eCwgdmFsdWUsICZsZW4pOwogIHN0cnVjdCBsd3NfcHJvdG9jb2xzKiBwcm8gPSBqc19tYWxsb2N6KGN0eCwgKGxlbiArIDEzKSAqIHNpemVvZihzdHJ1Y3QgbHdzX3Byb3RvY29scykpOwogIHNpemVfdCBqID0gMDsKCiAgcHJvW2orK10gPSAoc3RydWN0IGx3c19wcm90b2NvbHMpewogICAgICAiaHR0cC1vbmx5IiwKICAgICAgaHR0cF9jYWxsYmFjaywKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgTlVMTCwKICAgICAgMCwKICB9OwoKICBmb3Ioc2l6ZV90IGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKICAgIHByb1tqKytdID0gcHJvdG9jb2xfZnJvbShjdHgsIHZhbHVlc1tpXSk7CgogICAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWVzW2ldKTsKICB9CgojaWZkZWYgUExVR0lOX1BST1RPQ09MX0RFQUREUk9QCiAgcHJvW2orK10gPSAoc3RydWN0IGx3c19wcm90b2NvbHMpTFdTX1BMVUdJTl9QUk9UT0NPTF9ERUFERFJPUDsKI2VuZGlmCiNpZmRlZiBQTFVHSU5fUFJPVE9DT0xfUkFXX1BST1hZCiAgcHJvW2orK10gPSAoc3RydWN0IGx3c19wcm90b2NvbHMpTFdTX1BMVUdJTl9QUk9UT0NPTF9SQVdfUFJPWFk7CiNlbmRpZgojaWZkZWYgUExVR0lOX1BST1RPQ09MX0ZVTExURVhUX0RFTU8KICBwcm9baisrXSA9IChzdHJ1Y3QgbHdzX3Byb3RvY29scylMV1NfUExVR0lOX1BST1RPQ09MX0ZVTExURVhUX0RFTU87CiNlbmRpZgojaWZkZWYgUExVR0lOX1BST1RPQ09MX0xXU19TVEFUVVMKICBwcm9baisrXSA9IChzdHJ1Y3QgbHdzX3Byb3RvY29scylMV1NfUExVR0lOX1BST1RPQ09MX0xXU19TVEFUVVM7CiNlbmRpZgojaWZkZWYgUExVR0lOX1BST1RPQ09MX0xXU19BQ01FX0NMSUVOVAogIHByb1tqKytdID0gKHN0cnVjdCBsd3NfcHJvdG9jb2xzKUxXU19QTFVHSU5fUFJPVE9DT0xfTFdTX0FDTUVfQ0xJRU5UOwojZW5kaWYKI2lmZGVmIFBMVUdJTl9QUk9UT0NPTF9MV1NfU1NIRF9ERU1PCiAgcHJvW2orK10gPSAoc3RydWN0IGx3c19wcm90b2NvbHMpTFdTX1BMVUdJTl9QUk9UT0NPTF9MV1NfU1NIRF9ERU1POwojZW5kaWYKI2lmZGVmIFBMVUdJTl9QUk9UT0NPTF9EVU1CX0lOQ1JFTUVOVAogIHByb1tqKytdID0gKHN0cnVjdCBsd3NfcHJvdG9jb2xzKUxXU19QTFVHSU5fUFJPVE9DT0xfRFVNQl9JTkNSRU1FTlQ7CiNlbmRpZgojaWZkZWYgUExVR0lOX1BST1RPQ09MX01JUlJPUgogIHByb1tqKytdID0gKHN0cnVjdCBsd3NfcHJvdG9jb2xzKUxXU19QTFVHSU5fUFJPVE9DT0xfTUlSUk9SOwojZW5kaWYKI2lmZGVmIFBMVUdJTl9QUk9UT0NPTF9MV1NfUkFXX1NTSEQKICBwcm9baisrXSA9IChzdHJ1Y3QgbHdzX3Byb3RvY29scylMV1NfUExVR0lOX1BST1RPQ09MX0xXU19SQVdfU1NIRDsKI2VuZGlmCiNpZmRlZiBQTFVHSU5fUFJPVE9DT0xfUkFXX1RFU1QKICBwcm9baisrXSA9IChzdHJ1Y3QgbHdzX3Byb3RvY29scylMV1NfUExVR0lOX1BST1RPQ09MX1JBV19URVNUOwojZW5kaWYKCiAgaWYodmFsdWVzKQogICAganNfZnJlZShjdHgsIHZhbHVlcyk7CgogIHJldHVybiBwcm87Cn0KCnN0YXRpYyB2b2lkCnByb3RvY29sc19mcmVlKEpTUnVudGltZSogcnQsIHN0cnVjdCBsd3NfcHJvdG9jb2xzKiBwcm8pIHsKICBzaXplX3QgaTsKCiAgZm9yKGkgPSAwOyBwcm9baV0ubmFtZTsgKytpKQogICAgcHJvdG9jb2xfZnJlZShydCwgJnByb1tpXSk7CgogIGpzX2ZyZWVfcnQocnQsIHBybyk7Cn0KCnN0YXRpYyBzdHJ1Y3QgbHdzX2h0dHBfbW91bnQqCmh0dHBfbW91bnRfZnJvbShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgY29uc3QgY2hhciogbmFtZSkgewogIHN0cnVjdCBsd3NfaHR0cF9tb3VudCogbW50OwogIEpTVmFsdWUgdmFsdWU7CgogIGlmKCEobW50ID0ganNfbWFsbG9jeihjdHgsIHNpemVvZihzdHJ1Y3QgbHdzX2h0dHBfbW91bnQpKSkpCiAgICByZXR1cm4gMDsKCiAgaWYobmFtZSkgewogICAgbW50LT5tb3VudHBvaW50ID0ganNfc3RyZHVwKGN0eCwgbmFtZSk7CiAgICBtbnQtPm1vdW50cG9pbnRfbGVuID0gc3RybGVuKG5hbWUpOwogIH0KCiAgaWYoSlNfSXNBcnJheShjdHgsIG9iaikpIHsKICAgIGludCBpID0gMDsKCiAgICBpZighbmFtZSkgewogICAgICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5VWludDMyKGN0eCwgb2JqLCBpKyspOwogICAgICBtbnQtPm1vdW50cG9pbnQgPSB0b19zdHJpbmdmcmVlKGN0eCwgdmFsdWUpOwogICAgICBtbnQtPm1vdW50cG9pbnRfbGVuID0gc3RybGVuKG1udC0+bW91bnRwb2ludCk7CiAgICB9CgogICAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVVpbnQzMihjdHgsIG9iaiwgaSsrKTsKICAgIG1udC0+b3JpZ2luID0gdG9fc3RyaW5nZnJlZShjdHgsIHZhbHVlKTsKCiAgICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5VWludDMyKGN0eCwgb2JqLCBpKyspOwogICAgbW50LT5kZWYgPSB0b19zdHJpbmdmcmVlKGN0eCwgdmFsdWUpOwoKICAgIHZhbHVlID0gSlNfR2V0UHJvcGVydHlVaW50MzIoY3R4LCBvYmosIGkrKyk7CiAgICBtbnQtPnByb3RvY29sID0gdG9fc3RyaW5nZnJlZShjdHgsIHZhbHVlKTsKCiAgICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5VWludDMyKGN0eCwgb2JqLCBpKyspOwogICAgbW50LT5iYXNpY19hdXRoX2xvZ2luX2ZpbGUgPSB0b19zdHJpbmdmcmVlKGN0eCwgdmFsdWUpOwoKICB9IGVsc2UgaWYoSlNfSXNPYmplY3Qob2JqKSkgewogICAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iaiwgIm1vdW50cG9pbnQiKTsKCiAgICBtbnQtPm1vdW50cG9pbnQgPSB0b19zdHJpbmdmcmVlKGN0eCwgdmFsdWUpOwogICAgbW50LT5tb3VudHBvaW50X2xlbiA9IHN0cmxlbihtbnQtPm1vdW50cG9pbnQpOwoKICAgIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmosICJvcmlnaW4iKTsKICAgIG1udC0+b3JpZ2luID0gdG9fc3RyaW5nZnJlZShjdHgsIHZhbHVlKTsKCiAgICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgb2JqLCAiZGVmIik7CiAgICBtbnQtPmRlZiA9IHRvX3N0cmluZ2ZyZWUoY3R4LCB2YWx1ZSk7CgogICAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iaiwgInByb3RvY29sIik7CiAgICBtbnQtPnByb3RvY29sID0gdG9fc3RyaW5nZnJlZShjdHgsIHZhbHVlKTsKCiAgICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgb2JqLCAiY2dpZW52Iik7CiAgICBtbnQtPmNnaWVudiA9IHZob3N0X29wdGlvbnNfZnJvbWZyZWUoY3R4LCB2YWx1ZSk7CgogICAgdmFsdWUgPSBqc19nZXRfcHJvcGVydHkoY3R4LCBvYmosICJleHRyYV9taW1ldHlwZXMiKTsKICAgIG1udC0+ZXh0cmFfbWltZXR5cGVzID0gdmhvc3Rfb3B0aW9uc19mcm9tZnJlZShjdHgsIHZhbHVlKTsKCiAgICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgb2JqLCAiaW50ZXJwcmV0Iik7CiAgICBtbnQtPmludGVycHJldCA9IHZob3N0X29wdGlvbnNfZnJvbWZyZWUoY3R4LCB2YWx1ZSk7CgogICAgdmFsdWUgPSBqc19nZXRfcHJvcGVydHkoY3R4LCBvYmosICJjZ2lfdGltZW91dCIpOwogICAgbW50LT5jZ2lfdGltZW91dCA9IHRvX2ludGVnZXJmcmVlKGN0eCwgdmFsdWUpOwoKICAgIHZhbHVlID0ganNfZ2V0X3Byb3BlcnR5KGN0eCwgb2JqLCAiY2FjaGVfbWF4X2FnZSIpOwogICAgbW50LT5jYWNoZV9tYXhfYWdlID0gdG9faW50ZWdlcmZyZWUoY3R4LCB2YWx1ZSk7CgogICAgdmFsdWUgPSBqc19nZXRfcHJvcGVydHkoY3R4LCBvYmosICJhdXRoX21hc2siKTsKICAgIG1udC0+YXV0aF9tYXNrID0gdG9faW50ZWdlcmZyZWUoY3R4LCB2YWx1ZSk7CgogICAgdmFsdWUgPSBqc19nZXRfcHJvcGVydHkoY3R4LCBvYmosICJjYWNoZV9yZXVzYWJsZSIpOwogICAgbW50LT5jYWNoZV9yZXVzYWJsZSA9IHRvX2Jvb2xmcmVlKGN0eCwgdmFsdWUpOwoKICAgIHZhbHVlID0ganNfZ2V0X3Byb3BlcnR5KGN0eCwgb2JqLCAiY2FjaGVfcmV2YWxpZGF0ZSIpOwogICAgbW50LT5jYWNoZV9yZXZhbGlkYXRlID0gdG9fYm9vbGZyZWUoY3R4LCB2YWx1ZSk7CgogICAgdmFsdWUgPSBqc19nZXRfcHJvcGVydHkoY3R4LCBvYmosICJjYWNoZV9pbnRlcm1lZGlhcmllcyIpOwogICAgbW50LT5jYWNoZV9pbnRlcm1lZGlhcmllcyA9IHRvX2Jvb2xmcmVlKGN0eCwgdmFsdWUpOwoKICAgIC8qdmFsdWUgPSBqc19nZXRfcHJvcGVydHkoY3R4LCBvYmosICJjYWNoZV9ubyIpOwogICAgbW50LT5jYWNoZV9ubyA9IHRvX2Jvb2xmcmVlKGN0eCwgdmFsdWUpOyovCgogICAgdmFsdWUgPSBqc19nZXRfcHJvcGVydHkoY3R4LCBvYmosICJvcmlnaW5fcHJvdG9jb2wiKTsKICAgIG1udC0+b3JpZ2luX3Byb3RvY29sID0gdG9faW50ZWdlcmZyZWUoY3R4LCB2YWx1ZSk7CgogICAgdmFsdWUgPSBqc19nZXRfcHJvcGVydHkoY3R4LCBvYmosICJiYXNpY19hdXRoX2xvZ2luX2ZpbGUiKTsKICAgIG1udC0+YmFzaWNfYXV0aF9sb2dpbl9maWxlID0gdG9fc3RyaW5nZnJlZShjdHgsIHZhbHVlKTsKICB9CgogIHJldHVybiBtbnQ7Cn0KCnN0YXRpYyBjb25zdCBzdHJ1Y3QgbHdzX2h0dHBfbW91bnQqCmh0dHBfbW91bnRzX2Zyb20oSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIGNvbnN0IHN0cnVjdCBsd3NfaHR0cF9tb3VudCAqbW50ID0gMCwgKipwdHIgPSAmbW50LCAqdG1wOwoKICBpZihKU19Jc0FycmF5KGN0eCwgdmFsdWUpKSB7CiAgICBpbnQzMl90IGxlbiA9IHRvX2ludDMyZnJlZShjdHgsIEpTX0dldFByb3BlcnR5U3RyKGN0eCwgdmFsdWUsICJsZW5ndGgiKSk7CgogICAgaWYobGVuID4gMCkgewogICAgICBtbnQgPSBqc19tYWxsb2MoY3R4LCBzaXplb2Yoc3RydWN0IGx3c19odHRwX21vdW50KSk7CgogICAgICBmb3IoaW50MzJfdCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgSlNWYWx1ZSBtb3VudCA9IEpTX0dldFByb3BlcnR5VWludDMyKGN0eCwgdmFsdWUsIGkpOwoKICAgICAgICBpZigoKnB0ciA9IHRtcCA9IGh0dHBfbW91bnRfZnJvbShjdHgsIG1vdW50LCAwKSkpCiAgICAgICAgICBwdHIgPSAoY29uc3Qgc3RydWN0IGx3c19odHRwX21vdW50KiopJigqcHRyKS0+bW91bnRfbmV4dDsKCiAgICAgICAgSlNfRnJlZVZhbHVlKGN0eCwgbW91bnQpOwoKICAgICAgICBpZighdG1wKQogICAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgIH0KICB9IGVsc2UgaWYoSlNfSXNPYmplY3QodmFsdWUpKSB7CiAgICBKU1Byb3BlcnR5RW51bSogdG1wX3RhYiA9IDA7CiAgICB1aW50MzJfdCBsZW47CgogICAgaWYoIUpTX0dldE93blByb3BlcnR5TmFtZXMoY3R4LCAmdG1wX3RhYiwgJmxlbiwgdmFsdWUsIEpTX0dQTl9TVFJJTkdfTUFTSyB8IEpTX0dQTl9TRVRfRU5VTSkpIHsKICAgICAgZm9yKHVpbnQzMl90IGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICBjb25zdCBjaGFyKiBuYW1lID0gSlNfQXRvbVRvQ1N0cmluZyhjdHgsIHRtcF90YWJbaV0uYXRvbSk7CiAgICAgICAgSlNWYWx1ZSBtb3VudCA9IEpTX0dldFByb3BlcnR5KGN0eCwgdmFsdWUsIHRtcF90YWJbaV0uYXRvbSk7CgogICAgICAgIGlmKCgqcHRyID0gdG1wID0gaHR0cF9tb3VudF9mcm9tKGN0eCwgbW91bnQsIG5hbWUpKSkKICAgICAgICAgIHB0ciA9IChjb25zdCBzdHJ1Y3QgbHdzX2h0dHBfbW91bnQqKikmKCpwdHIpLT5tb3VudF9uZXh0OwoKICAgICAgICBKU19GcmVlQ1N0cmluZyhjdHgsIG5hbWUpOwogICAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIG1vdW50KTsKCiAgICAgICAgaWYoIXRtcCkKICAgICAgICAgIGJyZWFrOwogICAgICB9CiAgICB9CiAgfQoKICByZXR1cm4gbW50Owp9CgpzdGF0aWMgdm9pZApodHRwX21vdW50c19mcmVlKEpTUnVudGltZSogcnQsIHN0cnVjdCBsd3NfaHR0cF9tb3VudCogbW50KSB7CiAgZm9yKDsgbW50OyBtbnQgPSAoc3RydWN0IGx3c19odHRwX21vdW50KiltbnQtPm1vdW50X25leHQpIHsKICAgIGlmKG1udC0+bW91bnRwb2ludCkgewogICAgICBqc19mcmVlX3J0KHJ0LCAoY2hhciopbW50LT5tb3VudHBvaW50KTsKICAgICAgbW50LT5tb3VudHBvaW50ID0gMDsKICAgIH0KCiAgICBpZihtbnQtPm9yaWdpbikgewogICAgICBqc19mcmVlX3J0KHJ0LCAoY2hhciopbW50LT5vcmlnaW4pOwogICAgICBtbnQtPm9yaWdpbiA9IDA7CiAgICB9CgogICAgaWYobW50LT5kZWYpIHsKICAgICAganNfZnJlZV9ydChydCwgKGNoYXIqKW1udC0+ZGVmKTsKICAgICAgbW50LT5kZWYgPSAwOwogICAgfQoKICAgIGlmKG1udC0+cHJvdG9jb2wpIHsKICAgICAganNfZnJlZV9ydChydCwgKGNoYXIqKW1udC0+cHJvdG9jb2wpOwogICAgICBtbnQtPnByb3RvY29sID0gMDsKICAgIH0KCiAgICBpZihtbnQtPmNnaWVudikgewogICAgICB2aG9zdF9vcHRpb25zX2ZyZWUocnQsIChzdHJ1Y3QgbHdzX3Byb3RvY29sX3Zob3N0X29wdGlvbnMqKW1udC0+Y2dpZW52KTsKICAgICAgbW50LT5jZ2llbnYgPSAwOwogICAgfQoKICAgIGlmKG1udC0+ZXh0cmFfbWltZXR5cGVzKSB7CiAgICAgIHZob3N0X29wdGlvbnNfZnJlZShydCwgKHN0cnVjdCBsd3NfcHJvdG9jb2xfdmhvc3Rfb3B0aW9ucyopbW50LT5leHRyYV9taW1ldHlwZXMpOwogICAgICBtbnQtPmV4dHJhX21pbWV0eXBlcyA9IDA7CiAgICB9CgogICAgaWYobW50LT5pbnRlcnByZXQpIHsKICAgICAgdmhvc3Rfb3B0aW9uc19mcmVlKHJ0LCAoc3RydWN0IGx3c19wcm90b2NvbF92aG9zdF9vcHRpb25zKiltbnQtPmludGVycHJldCk7CiAgICAgIG1udC0+aW50ZXJwcmV0ID0gMDsKICAgIH0KCiAgICBpZihtbnQtPmJhc2ljX2F1dGhfbG9naW5fZmlsZSkgewogICAgICBqc19mcmVlX3J0KHJ0LCAoY2hhciopbW50LT5iYXNpY19hdXRoX2xvZ2luX2ZpbGUpOwogICAgICBtbnQtPmJhc2ljX2F1dGhfbG9naW5fZmlsZSA9IDA7CiAgICB9CiAgfQp9CgpzdGF0aWMgc3RydWN0IGx3c19wcm90b2NvbF92aG9zdF9vcHRpb25zKgp2aG9zdF9vcHRpb25fZnJvbShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaikgewogIHN0cnVjdCBsd3NfcHJvdG9jb2xfdmhvc3Rfb3B0aW9ucyogdmhvOwogIEpTVmFsdWUgbmFtZSA9IEpTX1VOREVGSU5FRCwgdmFsdWUgPSBKU19VTkRFRklORUQsIG9wdGlvbnMgPSBKU19VTkRFRklORUQsIG5leHQgPSBKU19VTkRFRklORUQ7CgogIGlmKEpTX0lzQXJyYXkoY3R4LCBvYmopKSB7CiAgICBuYW1lID0gSlNfR2V0UHJvcGVydHlVaW50MzIoY3R4LCBvYmosIDApOwogICAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVVpbnQzMihjdHgsIG9iaiwgMSk7CiAgICBvcHRpb25zID0gSlNfR2V0UHJvcGVydHlVaW50MzIoY3R4LCBvYmosIDIpOwogIH0gZWxzZSBpZihKU19Jc09iamVjdChvYmopKSB7CiAgICBuYW1lID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmosICJuYW1lIik7CiAgICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgb2JqLCAidmFsdWUiKTsKICAgIG9wdGlvbnMgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iaiwgIm9wdGlvbnMiKTsKCiAgICBpZihqc19oYXNfcHJvcGVydHkoY3R4LCBvYmosICJuZXh0IikpCiAgICAgIG5leHQgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iaiwgIm5leHQiKTsKICB9CgogIGlmKCh2aG8gPSBqc19tYWxsb2N6KGN0eCwgc2l6ZW9mKHN0cnVjdCBsd3NfcHJvdG9jb2xfdmhvc3Rfb3B0aW9ucykpKSkgewogICAgdmhvLT5uYW1lID0gdG9fc3RyaW5nKGN0eCwgbmFtZSk7CiAgICB2aG8tPnZhbHVlID0gdG9fc3RyaW5nKGN0eCwgdmFsdWUpOwogICAgdmhvLT5vcHRpb25zID0gdmhvc3Rfb3B0aW9uc19mcm9tKGN0eCwgb3B0aW9ucyk7CiAgICB2aG8tPm5leHQgPSBKU19Jc09iamVjdChuZXh0KSA/IHZob3N0X29wdGlvbl9mcm9tKGN0eCwgbmV4dCkgOiBOVUxMOwogIH0KCiAgSlNfRnJlZVZhbHVlKGN0eCwgbmFtZSk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIG9wdGlvbnMpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIG5leHQpOwogIHJldHVybiB2aG87Cn0KCnN0YXRpYyBzdHJ1Y3QgbHdzX3Byb3RvY29sX3Zob3N0X29wdGlvbnMqCnZob3N0X29wdGlvbnNfZnJvbShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgc3RydWN0IGx3c19wcm90b2NvbF92aG9zdF9vcHRpb25zICp2aG8gPSAwLCAqKnB0ciA9ICZ2aG8sICp0bXA7CiAgSlNWYWx1ZSBmaXJzdCA9IEpTX1VOREVGSU5FRDsKCiAgaWYoSlNfSXNBcnJheShjdHgsIHZhbHVlKSAmJiAoKGZpcnN0ID0gSlNfR2V0UHJvcGVydHlVaW50MzIoY3R4LCB2YWx1ZSwgMCkpLCBKU19Jc09iamVjdChmaXJzdCkpKSB7CiAgICBpbnQzMl90IGxlbiA9IHRvX2ludDMyZnJlZShjdHgsIEpTX0dldFByb3BlcnR5U3RyKGN0eCwgdmFsdWUsICJsZW5ndGgiKSk7CgogICAgaWYobGVuID4gMCkgewogICAgICBmb3IoaW50MzJfdCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgSlNWYWx1ZSBvcHRpb24gPSBKU19HZXRQcm9wZXJ0eVVpbnQzMihjdHgsIHZhbHVlLCBpKTsKCiAgICAgICAgaWYoKCpwdHIgPSB0bXAgPSB2aG9zdF9vcHRpb25fZnJvbShjdHgsIG9wdGlvbikpKSB7CiAgICAgICAgICBkbwogICAgICAgICAgICBwdHIgPSAoc3RydWN0IGx3c19wcm90b2NvbF92aG9zdF9vcHRpb25zKiopJigqcHRyKS0+bmV4dDsKICAgICAgICAgIHdoaWxlKCpwdHIpOwogICAgICAgIH0KCiAgICAgICAgSlNfRnJlZVZhbHVlKGN0eCwgb3B0aW9uKTsKCiAgICAgICAgaWYoIXRtcCkKICAgICAgICAgIGJyZWFrOwogICAgICB9CiAgICB9CiAgfSBlbHNlIGlmKEpTX0lzT2JqZWN0KHZhbHVlKSkgewogICAgdmhvID0gdmhvc3Rfb3B0aW9uX2Zyb20oY3R4LCB2YWx1ZSk7CiAgfQoKICBKU19GcmVlVmFsdWUoY3R4LCBmaXJzdCk7CgogIHJldHVybiB2aG87Cn0KCnN0YXRpYyBzdHJ1Y3QgbHdzX3Byb3RvY29sX3Zob3N0X29wdGlvbnMqCnZob3N0X29wdGlvbnNfZnJvbWZyZWUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWUgdmFsdWUpIHsKICBzdHJ1Y3QgbHdzX3Byb3RvY29sX3Zob3N0X29wdGlvbnMqIHZobyA9IHZob3N0X29wdGlvbnNfZnJvbShjdHgsIHZhbHVlKTsKICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgcmV0dXJuIHZobzsKfQoKc3RhdGljIHZvaWQKdmhvc3Rfb3B0aW9uc19mcmVlKEpTUnVudGltZSogcnQsIHN0cnVjdCBsd3NfcHJvdG9jb2xfdmhvc3Rfb3B0aW9ucyogdmhvKSB7CiAgZG8gewogICAganNfZnJlZV9ydChydCwgKGNoYXIqKXZoby0+bmFtZSk7CiAgICB2aG8tPm5hbWUgPSAwOwoKICAgIGpzX2ZyZWVfcnQocnQsIChjaGFyKil2aG8tPnZhbHVlKTsKICAgIHZoby0+dmFsdWUgPSAwOwoKICAgIHZob3N0X29wdGlvbnNfZnJlZShydCwgKHN0cnVjdCBsd3NfcHJvdG9jb2xfdmhvc3Rfb3B0aW9ucyopdmhvLT5vcHRpb25zKTsKICAgIHZoby0+b3B0aW9ucyA9IDA7CgogIH0gd2hpbGUoKHZobyA9IChzdHJ1Y3QgbHdzX3Byb3RvY29sX3Zob3N0X29wdGlvbnMqKXZoby0+bmV4dCkpOwp9CgpzdGF0aWMgdm9pZApjbGllbnRfY29ubmVjdF9pbmZvX2Zyb21vYmooSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIHN0cnVjdCBsd3NfY2xpZW50X2Nvbm5lY3RfaW5mbyogY2kpIHsKICBKU1ZhbHVlIHZhbHVlOwoKICBpZihqc19oYXNfcHJvcGVydHkoY3R4LCBvYmosICJjb250ZXh0IikpIHsKICAgIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmosICJjb250ZXh0Iik7CiAgICBjaS0+Y29udGV4dCA9IGx3c19jb250ZXh0X2RhdGEodmFsdWUpOwogICAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwogIH0KCiAgc3RyX3Byb3BlcnR5KCZjaS0+YWRkcmVzcywgY3R4LCBvYmosICJhZGRyZXNzIik7CgogIGlmKGpzX2hhc19wcm9wZXJ0eShjdHgsIG9iaiwgInBvcnQiKSkKICAgIGNpLT5wb3J0ID0gdG9faW50ZWdlcmZyZWUoY3R4LCBqc19nZXRfcHJvcGVydHkoY3R4LCBvYmosICJwb3J0IikpOwoKICBpZihqc19oYXNfcHJvcGVydHkoY3R4LCBvYmosICJzc2xfY29ubmVjdGlvbiIpKQogICAgY2ktPnNzbF9jb25uZWN0aW9uIHw9IHRvX2ludGVnZXJmcmVlKGN0eCwganNfZ2V0X3Byb3BlcnR5KGN0eCwgb2JqLCAic3NsX2Nvbm5lY3Rpb24iKSk7CgogIGlmKGpzX2hhc19wcm9wZXJ0eShjdHgsIG9iaiwgInNzbCIpKSB7CiAgICB2YWx1ZSA9IGpzX2dldF9wcm9wZXJ0eShjdHgsIG9iaiwgInNzbCIpOwogICAgY2ktPnNzbF9jb25uZWN0aW9uIHw9ICFKU19Jc051bWJlcih2YWx1ZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoSlNfVG9Cb29sKGN0eCwgdmFsdWUpID8gTENDU0NGX1VTRV9TU0wgfCBMQ0NTQ0ZfQUxMT1dfU0VMRlNJR05FRCB8IExDQ1NDRl9BTExPV19JTlNFQ1VSRSB8IExDQ1NDRl9BTExPV19FWFBJUkVEIHwgTENDU0NGX1NLSVBfU0VSVkVSX0NFUlRfSE9TVE5BTUVfQ0hFQ0sgOiAwKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRvX3VpbnQzMihjdHgsIHZhbHVlKTsKICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICB9CgogIHN0cl9wcm9wZXJ0eSgmY2ktPnBhdGgsIGN0eCwgb2JqLCAicGF0aCIpOwogIHN0cl9wcm9wZXJ0eSgmY2ktPmhvc3QsIGN0eCwgb2JqLCAiaG9zdCIpOwogIHN0cl9wcm9wZXJ0eSgmY2ktPm9yaWdpbiwgY3R4LCBvYmosICJvcmlnaW4iKTsKICBzdHJfcHJvcGVydHkoJmNpLT5wcm90b2NvbCwgY3R4LCBvYmosICJwcm90b2NvbCIpOwogIHN0cl9wcm9wZXJ0eSgmY2ktPm1ldGhvZCwgY3R4LCBvYmosICJtZXRob2QiKTsKICBzdHJfcHJvcGVydHkoJmNpLT5pZmFjZSwgY3R4LCBvYmosICJpZmFjZSIpOwoKICBpZihqc19oYXNfcHJvcGVydHkoY3R4LCBvYmosICJsb2NhbF9wb3J0IikpCiAgICBjaS0+bG9jYWxfcG9ydCA9IHRvX2ludGVnZXJmcmVlKGN0eCwganNfZ2V0X3Byb3BlcnR5KGN0eCwgb2JqLCAibG9jYWxfcG9ydCIpKTsKCiAgc3RyX3Byb3BlcnR5KCZjaS0+bG9jYWxfcHJvdG9jb2xfbmFtZSwgY3R4LCBvYmosICJsb2NhbF9wcm90b2NvbF9uYW1lIik7CiAgc3RyX3Byb3BlcnR5KCZjaS0+YWxwbiwgY3R4LCBvYmosICJhbHBuIik7CgogIGlmKGpzX2hhc19wcm9wZXJ0eShjdHgsIG9iaiwgImtlZXBfd2FybV9zZWNzIikpCiAgICBjaS0+a2VlcF93YXJtX3NlY3MgPSB0b19pbnRlZ2VyZnJlZShjdHgsIGpzX2dldF9wcm9wZXJ0eShjdHgsIG9iaiwgImtlZXBfd2FybV9zZWNzIikpOwoKICBzdHJfcHJvcGVydHkoJmNpLT5hdXRoX3VzZXJuYW1lLCBjdHgsIG9iaiwgImF1dGhfdXNlcm5hbWUiKTsKICBzdHJfcHJvcGVydHkoJmNpLT5hdXRoX3Bhc3N3b3JkLCBjdHgsIG9iaiwgImF1dGhfcGFzc3dvcmQiKTsKfQoKc3RhdGljIHZvaWQKY2xpZW50X2Nvbm5lY3RfaW5mb19mcmVlKEpTUnVudGltZSogcnQsIHN0cnVjdCBsd3NfY2xpZW50X2Nvbm5lY3RfaW5mbyogY2kpIHsKICBpZihjaS0+YWRkcmVzcykKICAgIGpzX2ZyZWVfcnQocnQsIChjaGFyKiljaS0+YWRkcmVzcyk7CiAgaWYoY2ktPnBhdGgpCiAgICBqc19mcmVlX3J0KHJ0LCAoY2hhciopY2ktPnBhdGgpOwogIGlmKGNpLT5ob3N0KQogICAganNfZnJlZV9ydChydCwgKGNoYXIqKWNpLT5ob3N0KTsKICBpZihjaS0+b3JpZ2luKQogICAganNfZnJlZV9ydChydCwgKGNoYXIqKWNpLT5vcmlnaW4pOwogIGlmKGNpLT5wcm90b2NvbCkKICAgIGpzX2ZyZWVfcnQocnQsIChjaGFyKiljaS0+cHJvdG9jb2wpOwogIGlmKGNpLT5tZXRob2QpCiAgICBqc19mcmVlX3J0KHJ0LCAoY2hhciopY2ktPm1ldGhvZCk7CiAgaWYoY2ktPmlmYWNlKQogICAganNfZnJlZV9ydChydCwgKGNoYXIqKWNpLT5pZmFjZSk7CiAgaWYoY2ktPmxvY2FsX3Byb3RvY29sX25hbWUpCiAgICBqc19mcmVlX3J0KHJ0LCAoY2hhciopY2ktPmxvY2FsX3Byb3RvY29sX25hbWUpOwogIGlmKGNpLT5hbHBuKQogICAganNfZnJlZV9ydChydCwgKGNoYXIqKWNpLT5hbHBuKTsKICBpZihjaS0+YXV0aF91c2VybmFtZSkKICAgIGpzX2ZyZWVfcnQocnQsIChjaGFyKiljaS0+YXV0aF91c2VybmFtZSk7CiAgaWYoY2ktPmF1dGhfcGFzc3dvcmQpCiAgICBqc19mcmVlX3J0KHJ0LCAoY2hhciopY2ktPmF1dGhfcGFzc3dvcmQpOwp9Cgp2b2lkCmx3c2pzX2NvbnRleHRfY3JlYXRpb25faW5mb19mcm9tb2JqKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCBzdHJ1Y3QgbHdzX2NvbnRleHRfY3JlYXRpb25faW5mbyogY2kpIHsKICBKU1ZhbHVlIHZhbHVlOwoKICBzdHJfcHJvcGVydHkoJmNpLT5pZmFjZSwgY3R4LCBvYmosICJpZmFjZSIpOwogIHN0cl9wcm9wZXJ0eSgmY2ktPnZob3N0X25hbWUsIGN0eCwgb2JqLCAidmhvc3RfbmFtZSIpOwoKICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgb2JqLCAicHJvdG9jb2xzIik7CiAgY2ktPnByb3RvY29scyA9IHByb3RvY29sc19mcm9tYXJyYXkoY3R4LCB2YWx1ZSk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwoKI2lmZGVmIExXU19ST0xFX1dTCiAgc3RydWN0IGx3c19leHRlbnNpb24qIGV4dHM7CgogIGlmKChleHRzID0ganNfbWFsbG9jeihjdHgsIHNpemVvZihzdHJ1Y3QgbHdzX2V4dGVuc2lvbikgKiAyKSkpCiAgICBleHRzWzBdID0gKHN0cnVjdCBsd3NfZXh0ZW5zaW9uKXsKICAgICAgICAicGVybWVzc2FnZS1kZWZsYXRlIiwKICAgICAgICBsd3NfZXh0ZW5zaW9uX2NhbGxiYWNrX3BtX2RlZmxhdGUsCiAgICAgICAgInBlcm1lc3NhZ2UtZGVmbGF0ZTsgY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXI7IGNsaWVudF9tYXhfd2luZG93X2JpdHMiLAogICAgfTsKCiAgY2ktPmV4dGVuc2lvbnMgPSBleHRzOwojZW5kaWYKCiNpZiBkZWZpbmVkKExXU19ST0xFX0gxKSB8fCBkZWZpbmVkKExXU19ST0xFX0gyKQogIHN0cl9wcm9wZXJ0eSgmY2ktPmh0dHBfcHJveHlfYWRkcmVzcywgY3R4LCBvYmosICJodHRwX3Byb3h5X2FkZHJlc3MiKTsKCiAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iaiwgImhlYWRlcnMiKTsKICBjaS0+aGVhZGVycyA9IHZob3N0X29wdGlvbnNfZnJvbWZyZWUoY3R4LCB2YWx1ZSk7CgogIHZhbHVlID0ganNfZ2V0X3Byb3BlcnR5KGN0eCwgb2JqLCAicmVqZWN0X3NlcnZpY2Vfa2V5d29yZHMiKTsKICBjaS0+cmVqZWN0X3NlcnZpY2Vfa2V5d29yZHMgPSB2aG9zdF9vcHRpb25zX2Zyb20oY3R4LCB2YWx1ZSk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwoKICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgb2JqLCAicHZvIik7CiAgY2ktPnB2byA9IHZob3N0X29wdGlvbnNfZnJvbWZyZWUoY3R4LCB2YWx1ZSk7CgogIHN0cl9wcm9wZXJ0eSgmY2ktPmxvZ19maWxlcGF0aCwgY3R4LCBvYmosICJsb2dfZmlsZXBhdGgiKTsKCiAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iaiwgIm1vdW50cyIpOwogIGNpLT5tb3VudHMgPSBodHRwX21vdW50c19mcm9tKGN0eCwgdmFsdWUpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKCiAgc3RyX3Byb3BlcnR5KCZjaS0+c2VydmVyX3N0cmluZywgY3R4LCBvYmosICJzZXJ2ZXJfc3RyaW5nIik7CgogIHN0cl9wcm9wZXJ0eSgmY2ktPmVycm9yX2RvY3VtZW50XzQwNCwgY3R4LCBvYmosICJlcnJvcl9kb2N1bWVudF80MDQiKTsKCiAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iaiwgInBvcnQiKTsKICBjaS0+cG9ydCA9IHRvX2ludGVnZXJmcmVlKGN0eCwgdmFsdWUpOwoKICB2YWx1ZSA9IGpzX2dldF9wcm9wZXJ0eShjdHgsIG9iaiwgImh0dHBfcHJveHlfcG9ydCIpOwogIGNpLT5odHRwX3Byb3h5X3BvcnQgPSB0b19pbnRlZ2VyZnJlZShjdHgsIHZhbHVlKTsKCiAgdmFsdWUgPSBqc19nZXRfcHJvcGVydHkoY3R4LCBvYmosICJrZWVwYWxpdmVfdGltZW91dCIpOwogIGNpLT5rZWVwYWxpdmVfdGltZW91dCA9IHRvX2ludGVnZXJmcmVlKGN0eCwgdmFsdWUpOwojZW5kaWYKCiNpZmRlZiBMV1NfV0lUSF9TWVNfQVNZTkNfRE5TCiAgdmFsdWUgPSBqc19nZXRfcHJvcGVydHkoY3R4LCBvYmosICJhc3luY19kbnNfc2VydmVycyIpOwogIGNpLT5hc3luY19kbnNfc2VydmVycyA9IChjb25zdCBjaGFyKiopdG9fc3RyaW5nYXJyYXlmcmVlKGN0eCwgdmFsdWUpOwojZW5kaWYKCiNpZmRlZiBMV1NfV0lUSF9UTFMKICBzdHJfcHJvcGVydHkoJmNpLT5zc2xfcHJpdmF0ZV9rZXlfcGFzc3dvcmQsIGN0eCwgb2JqLCAic3NsX3ByaXZhdGVfa2V5X3Bhc3N3b3JkIik7CgogIHN0cl9vcl9idWZfcHJvcGVydHkoJmNpLT5zc2xfY2VydF9maWxlcGF0aCwgJmNpLT5zZXJ2ZXJfc3NsX2NlcnRfbWVtLCAmY2ktPnNlcnZlcl9zc2xfY2VydF9tZW1fbGVuLCBjdHgsIG9iaiwgInNlcnZlcl9zc2xfY2VydCIpOwogIHN0cl9vcl9idWZfcHJvcGVydHkoJmNpLT5zc2xfcHJpdmF0ZV9rZXlfZmlsZXBhdGgsICZjaS0+c2VydmVyX3NzbF9wcml2YXRlX2tleV9tZW0sICZjaS0+c2VydmVyX3NzbF9wcml2YXRlX2tleV9tZW1fbGVuLCBjdHgsIG9iaiwgInNlcnZlcl9zc2xfcHJpdmF0ZV9rZXkiKTsKICBzdHJfb3JfYnVmX3Byb3BlcnR5KCZjaS0+c3NsX2NhX2ZpbGVwYXRoLCAmY2ktPnNlcnZlcl9zc2xfY2FfbWVtLCAmY2ktPnNlcnZlcl9zc2xfY2FfbWVtX2xlbiwgY3R4LCBvYmosICJzZXJ2ZXJfc3NsX2NhIik7CgogIHN0cl9wcm9wZXJ0eSgmY2ktPnNzbF9jaXBoZXJfbGlzdCwgY3R4LCBvYmosICJzc2xfY2lwaGVyX2xpc3QiKTsKICBzdHJfcHJvcGVydHkoJmNpLT50bHMxXzNfcGx1c19jaXBoZXJfbGlzdCwgY3R4LCBvYmosICJ0bHMxXzNfcGx1c19jaXBoZXJfbGlzdCIpOwogIHN0cl9wcm9wZXJ0eSgmY2ktPmNsaWVudF9zc2xfcHJpdmF0ZV9rZXlfcGFzc3dvcmQsIGN0eCwgb2JqLCAiY2xpZW50X3NzbF9wcml2YXRlX2tleV9wYXNzd29yZCIpOwoKICBzdHJfb3JfYnVmX3Byb3BlcnR5KCZjaS0+Y2xpZW50X3NzbF9jZXJ0X2ZpbGVwYXRoLCAmY2ktPmNsaWVudF9zc2xfY2VydF9tZW0sICZjaS0+Y2xpZW50X3NzbF9jZXJ0X21lbV9sZW4sIGN0eCwgb2JqLCAiY2xpZW50X3NzbF9jZXJ0Iik7CiAgc3RyX29yX2J1Zl9wcm9wZXJ0eSgmY2ktPmNsaWVudF9zc2xfcHJpdmF0ZV9rZXlfZmlsZXBhdGgsICZjaS0+Y2xpZW50X3NzbF9rZXlfbWVtLCAmY2ktPmNsaWVudF9zc2xfa2V5X21lbV9sZW4sIGN0eCwgb2JqLCAiY2xpZW50X3NzbF9wcml2YXRlX2tleSIpOwogIHN0cl9vcl9idWZfcHJvcGVydHkoJmNpLT5jbGllbnRfc3NsX2NhX2ZpbGVwYXRoLCAmY2ktPmNsaWVudF9zc2xfY2FfbWVtLCAmY2ktPmNsaWVudF9zc2xfY2FfbWVtX2xlbiwgY3R4LCBvYmosICJjbGllbnRfc3NsX2NhIik7CgogIHN0cl9wcm9wZXJ0eSgmY2ktPmNsaWVudF9zc2xfY2lwaGVyX2xpc3QsIGN0eCwgb2JqLCAiY2xpZW50X3NzbF9jaXBoZXJfbGlzdCIpOwogIHN0cl9wcm9wZXJ0eSgmY2ktPmNsaWVudF90bHNfMV8zX3BsdXNfY2lwaGVyX2xpc3QsIGN0eCwgb2JqLCAiY2xpZW50X3Rsc18xXzNfcGx1c19jaXBoZXJfbGlzdCIpOwojZW5kaWYKCiNpZmRlZiBMV1NfV0lUSF9TT0NLUzUKICBzdHJfcHJvcGVydHkoJmNpLT5zb2Nrc19wcm94eV9hZGRyZXNzLCBjdHgsIG9iaiwgInNvY2tzX3Byb3h5X2FkZHJlc3MiKTsKCiAgdmFsdWUgPSBqc19nZXRfcHJvcGVydHkoY3R4LCBvYmosICJzb2Nrc19wcm94eV9wb3J0Iik7CiAgY2ktPnNvY2tzX3Byb3h5X3BvcnQgPSB0b19pbnRlZ2VyZnJlZShjdHgsIHZhbHVlKTsKI2VuZGlmCgogIHZhbHVlID0ganNfZ2V0X3Byb3BlcnR5KGN0eCwgb2JqLCAiZGVmYXVsdF9sb2dsZXZlbCIpOwogIGNpLT5kZWZhdWx0X2xvZ2xldmVsID0gdG9faW50ZWdlcmZyZWUoY3R4LCB2YWx1ZSk7CgogIHZhbHVlID0ganNfZ2V0X3Byb3BlcnR5KGN0eCwgb2JqLCAidmhfbGlzdGVuX3NvY2tmZCIpOwogIGNpLT52aF9saXN0ZW5fc29ja2ZkID0gdG9faW50ZWdlcmZyZWUoY3R4LCB2YWx1ZSk7CgogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmosICJvcHRpb25zIik7CiAgY2ktPm9wdGlvbnMgPSB0b19pbnRlZ2VyZnJlZShjdHgsIHZhbHVlKTsKCiAgaWYoY2ktPm9wdGlvbnMgJiBMV1NfU0VSVkVSX09QVElPTl9GQUxMQkFDS19UT19BUFBMWV9MSVNURU5fQUNDRVBUX0NPTkZJRykgewogICAgc3RyX3Byb3BlcnR5KCZjaS0+bGlzdGVuX2FjY2VwdF9yb2xlLCBjdHgsIG9iaiwgImxpc3Rlbl9hY2NlcHRfcm9sZSIpOwoKICAgIHN0cl9wcm9wZXJ0eSgmY2ktPmxpc3Rlbl9hY2NlcHRfcHJvdG9jb2wsIGN0eCwgb2JqLCAibGlzdGVuX2FjY2VwdF9wcm90b2NvbCIpOwogIH0KfQoKdm9pZApsd3Nqc19jb250ZXh0X2NyZWF0aW9uX2luZm9fZnJlZShKU1J1bnRpbWUqIHJ0LCBzdHJ1Y3QgbHdzX2NvbnRleHRfY3JlYXRpb25faW5mbyogY2kpIHsKICBpZihjaS0+aWZhY2UpCiAgICBqc19mcmVlX3J0KHJ0LCAoY2hhciopY2ktPmlmYWNlKTsKCiAgaWYoY2ktPnByb3RvY29scykKICAgIHByb3RvY29sc19mcmVlKHJ0LCAoc3RydWN0IGx3c19wcm90b2NvbHMqKWNpLT5wcm90b2NvbHMpOwoKICBpZihjaS0+aHR0cF9wcm94eV9hZGRyZXNzKQogICAganNfZnJlZV9ydChydCwgKGNoYXIqKWNpLT5odHRwX3Byb3h5X2FkZHJlc3MpOwoKICBpZihjaS0+aGVhZGVycykKICAgIHZob3N0X29wdGlvbnNfZnJlZShydCwgKHN0cnVjdCBsd3NfcHJvdG9jb2xfdmhvc3Rfb3B0aW9ucyopY2ktPmhlYWRlcnMpOwoKICBpZihjaS0+cmVqZWN0X3NlcnZpY2Vfa2V5d29yZHMpCiAgICB2aG9zdF9vcHRpb25zX2ZyZWUocnQsIChzdHJ1Y3QgbHdzX3Byb3RvY29sX3Zob3N0X29wdGlvbnMqKWNpLT5yZWplY3Rfc2VydmljZV9rZXl3b3Jkcyk7CgogIGlmKGNpLT5wdm8pCiAgICB2aG9zdF9vcHRpb25zX2ZyZWUocnQsIChzdHJ1Y3QgbHdzX3Byb3RvY29sX3Zob3N0X29wdGlvbnMqKWNpLT5wdm8pOwoKICBpZihjaS0+bG9nX2ZpbGVwYXRoKQogICAganNfZnJlZV9ydChydCwgKGNoYXIqKWNpLT5sb2dfZmlsZXBhdGgpOwoKICBpZihjaS0+bW91bnRzKQogICAgaHR0cF9tb3VudHNfZnJlZShydCwgKHN0cnVjdCBsd3NfaHR0cF9tb3VudCopY2ktPm1vdW50cyk7CgogIGlmKGNpLT5zZXJ2ZXJfc3RyaW5nKQogICAganNfZnJlZV9ydChydCwgKGNoYXIqKWNpLT5zZXJ2ZXJfc3RyaW5nKTsKCiAgaWYoY2ktPmVycm9yX2RvY3VtZW50XzQwNCkKICAgIGpzX2ZyZWVfcnQocnQsIChjaGFyKiljaS0+ZXJyb3JfZG9jdW1lbnRfNDA0KTsKCiNpZmRlZiBMV1NfV0lUSF9TWVNfQVNZTkNfRE5TCiAgaWYoY2ktPmFzeW5jX2Ruc19zZXJ2ZXJzKSB7CiAgICBmb3Ioc2l6ZV90IGkgPSAwOyBjaS0+YXN5bmNfZG5zX3NlcnZlcnNbaV07ICsraSkKICAgICAganNfZnJlZV9ydChydCwgKGNoYXIqKWNpLT5hc3luY19kbnNfc2VydmVyc1tpXSk7CiAgICBqc19mcmVlX3J0KHJ0LCBjaS0+YXN5bmNfZG5zX3NlcnZlcnMpOwogIH0KI2VuZGlmCgojaWZkZWYgTFdTX1dJVEhfVExTCiAgaWYoY2ktPnNzbF9wcml2YXRlX2tleV9wYXNzd29yZCkKICAgIGpzX2ZyZWVfcnQocnQsIChjaGFyKiljaS0+c3NsX3ByaXZhdGVfa2V5X3Bhc3N3b3JkKTsKCiAgaWYoY2ktPnNzbF9jZXJ0X2ZpbGVwYXRoKQogICAganNfZnJlZV9ydChydCwgKGNoYXIqKWNpLT5zc2xfY2VydF9maWxlcGF0aCk7CgogIGlmKGNpLT5zc2xfcHJpdmF0ZV9rZXlfZmlsZXBhdGgpCiAgICBqc19mcmVlX3J0KHJ0LCAoY2hhciopY2ktPnNzbF9wcml2YXRlX2tleV9maWxlcGF0aCk7CgogIGlmKGNpLT5zc2xfY2FfZmlsZXBhdGgpCiAgICBqc19mcmVlX3J0KHJ0LCAoY2hhciopY2ktPnNzbF9jYV9maWxlcGF0aCk7CgogIGlmKGNpLT5zc2xfY2lwaGVyX2xpc3QpCiAgICBqc19mcmVlX3J0KHJ0LCAoY2hhciopY2ktPnNzbF9jaXBoZXJfbGlzdCk7CgogIGlmKGNpLT50bHMxXzNfcGx1c19jaXBoZXJfbGlzdCkKICAgIGpzX2ZyZWVfcnQocnQsIChjaGFyKiljaS0+dGxzMV8zX3BsdXNfY2lwaGVyX2xpc3QpOwoKICBpZihjaS0+Y2xpZW50X3NzbF9wcml2YXRlX2tleV9wYXNzd29yZCkKICAgIGpzX2ZyZWVfcnQocnQsIChjaGFyKiljaS0+Y2xpZW50X3NzbF9wcml2YXRlX2tleV9wYXNzd29yZCk7CgogIGlmKGNpLT5jbGllbnRfc3NsX2NlcnRfZmlsZXBhdGgpCiAgICBqc19mcmVlX3J0KHJ0LCAoY2hhciopY2ktPmNsaWVudF9zc2xfY2VydF9maWxlcGF0aCk7CgogIGlmKGNpLT5jbGllbnRfc3NsX3ByaXZhdGVfa2V5X2ZpbGVwYXRoKQogICAganNfZnJlZV9ydChydCwgKGNoYXIqKWNpLT5jbGllbnRfc3NsX3ByaXZhdGVfa2V5X2ZpbGVwYXRoKTsKCiAgaWYoY2ktPmNsaWVudF9zc2xfY2FfZmlsZXBhdGgpCiAgICBqc19mcmVlX3J0KHJ0LCAoY2hhciopY2ktPmNsaWVudF9zc2xfY2FfZmlsZXBhdGgpOwoKICBpZihjaS0+Y2xpZW50X3NzbF9jaXBoZXJfbGlzdCkKICAgIGpzX2ZyZWVfcnQocnQsIChjaGFyKiljaS0+Y2xpZW50X3NzbF9jaXBoZXJfbGlzdCk7CgogIGlmKGNpLT5jbGllbnRfdGxzXzFfM19wbHVzX2NpcGhlcl9saXN0KQogICAganNfZnJlZV9ydChydCwgKGNoYXIqKWNpLT5jbGllbnRfdGxzXzFfM19wbHVzX2NpcGhlcl9saXN0KTsKI2VuZGlmCgojaWZkZWYgTFdTX1dJVEhfU09DS1M1CiAgaWYoY2ktPnNvY2tzX3Byb3h5X2FkZHJlc3MpCiAgICBqc19mcmVlX3J0KHJ0LCAoY2hhciopY2ktPnNvY2tzX3Byb3h5X2FkZHJlc3MpOwojZW5kaWYKCiAgaWYoY2ktPmxpc3Rlbl9hY2NlcHRfcm9sZSkKICAgIGpzX2ZyZWVfcnQocnQsIChjaGFyKiljaS0+bGlzdGVuX2FjY2VwdF9yb2xlKTsKCiAgaWYoY2ktPmxpc3Rlbl9hY2NlcHRfcHJvdG9jb2wpCiAgICBqc19mcmVlX3J0KHJ0LCAoY2hhciopY2ktPmxpc3Rlbl9hY2NlcHRfcHJvdG9jb2wpOwp9CgpzdGF0aWMgTFdTQ29udGV4dCoKY29udGV4dF9uZXcoSlNDb250ZXh0KiBjdHgpIHsKICBMV1NDb250ZXh0KiBsYzsKCiAgaWYoKGxjID0ganNfbWFsbG9jeihjdHgsIHNpemVvZihMV1NDb250ZXh0KSkpKQogICAgaW5pdF9saXN0X2hlYWQoJmxjLT5oYW5kbGVycyk7CgogIHJldHVybiBsYzsKfQoKc3RhdGljIHZvaWQKY29udGV4dF9mcmVlKEpTUnVudGltZSogcnQsIExXU0NvbnRleHQqIGxjKSB7CiAgaWYobGMtPmpzKSB7CiAgICBKU19GcmVlQ29udGV4dChsYy0+anMpOwogICAgbGMtPmpzID0gTlVMTDsKICB9CgogIGlmKGxjLT5pbmZvLnVzZXIpIHsKICAgIG9ial9mcmVlKHJ0LCBsYy0+aW5mby51c2VyKTsKICAgIGxjLT5pbmZvLnVzZXIgPSBOVUxMOwogIH0KCiAgaWYobGMtPmN0eCkgewogICAgbHdzX2NvbnRleHRfZGVzdHJveShsYy0+Y3R4KTsKICAgIGxjLT5jdHggPSBOVUxMOwogIH0KCiAgbHdzanNfY29udGV4dF9jcmVhdGlvbl9pbmZvX2ZyZWUocnQsICZsYy0+aW5mbyk7CgogIGpzX2ZyZWVfcnQocnQsIGxjKTsKfQoKc3RhdGljIEpTVmFsdWUKbHdzanNfY29udGV4dF9jb25zdHJ1Y3RvcihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG5ld190YXJnZXQsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKSB7CiAgTFdTQ29udGV4dCogbGM7CgogIGlmKCEobGMgPSBjb250ZXh0X25ldyhjdHgpKSkKICAgIHJldHVybiBKU19FWENFUFRJT047CgogIC8qIHVzaW5nIG5ld190YXJnZXQgdG8gZ2V0IHRoZSBwcm90b3R5cGUgaXMgbmVjZXNzYXJ5IHdoZW4gdGhlIGNsYXNzIGlzIGV4dGVuZGVkLiAqLwogIEpTVmFsdWUgcHJvdG8gPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG5ld190YXJnZXQsICJwcm90b3R5cGUiKTsKICBpZihKU19Jc0V4Y2VwdGlvbihwcm90bykpCiAgICBwcm90byA9IEpTX0R1cFZhbHVlKGN0eCwgbHdzanNfY29udGV4dF9wcm90byk7CgogIEpTVmFsdWUgb2JqID0gSlNfTmV3T2JqZWN0UHJvdG9DbGFzcyhjdHgsIHByb3RvLCBsd3Nqc19jb250ZXh0X2NsYXNzX2lkKTsKICBKU19GcmVlVmFsdWUoY3R4LCBwcm90byk7CiAgaWYoSlNfSXNFeGNlcHRpb24ob2JqKSkKICAgIGdvdG8gZmFpbDsKCiAgaWYoSlNfSXNPYmplY3QoYXJndlswXSkpCiAgICBsd3Nqc19jb250ZXh0X2NyZWF0aW9uX2luZm9fZnJvbW9iaihjdHgsIGFyZ3ZbMF0sICZsYy0+aW5mbyk7CgogIEpTX1NldE9wYXF1ZShvYmosIGxjKTsKCiAgbGMtPmpzID0gSlNfRHVwQ29udGV4dChjdHgpOwogIGxjLT5pbmZvLnVzZXIgPSBvYmpfcHRyKGN0eCwgb2JqKTsKCiAgaWYoIWpzX2hhc19wcm9wZXJ0eShjdHgsIGFyZ3ZbMF0sICJwb3J0IikpCiAgICBsYy0+aW5mby5wb3J0ID0gQ09OVEVYVF9QT1JUX05PX0xJU1RFTjsKCiAgLyogVGhpcyBtdXN0IGJlIGNhbGxlZCBsYXN0LCBiZWNhdXNlIGl0IGNhbiB0cmlnZ2VyIGNhbGxiYWNrcyBhbHJlYWR5ICovCiAgbGMtPmN0eCA9IGx3c19jcmVhdGVfY29udGV4dCgmbGMtPmluZm8pOwoKICBKU19EZWZpbmVQcm9wZXJ0eVZhbHVlU3RyKGN0eCwgb2JqLCAiaW5mbyIsIEpTX0R1cFZhbHVlKGN0eCwgYXJndlswXSksIEpTX1BST1BfQ09ORklHVVJBQkxFKTsKCiAgcmV0dXJuIG9iajsKCmZhaWw6CiAganNfZnJlZShjdHgsIGxjKTsKICBKU19GcmVlVmFsdWUoY3R4LCBvYmopOwogIHJldHVybiBKU19FWENFUFRJT047Cn0KCmVudW0gewogIERFU1RST1ksCiAgR0VUX1ZIT1NUX0JZX05BTUUsCiAgQURPUFRfU09DS0VULAogIEFET1BUX1NPQ0tFVF9SRUFEQlVGLAogIENBTkNFTF9TRVJWSUNFLAogIENMSUVOVF9DT05ORUNULAogIEdFVF9SQU5ET00sCiAgQVNZTkNfRE5TX1NFUlZFUl9BREQsCiAgQVNZTkNfRE5TX1NFUlZFUl9SRU1PVkUsCiAgV1NJX0ZST01fRkQsCn07CgpzdGF0aWMgSlNWYWx1ZQpsd3Nqc19jb250ZXh0X21ldGhvZHMoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IGFyZ2MsIEpTVmFsdWVDb25zdCBhcmd2W10sIGludCBtYWdpYykgewogIExXU0NvbnRleHQqIGxjOwogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwoKICBpZighKGxjID0gbHdzanNfY29udGV4dF9kYXRhMihjdHgsIHRoaXNfdmFsKSkpCiAgICByZXR1cm4gSlNfRVhDRVBUSU9OOwoKICBzd2l0Y2gobWFnaWMpIHsKICAgIGNhc2UgREVTVFJPWTogewogICAgICBpZihsYy0+Y3R4KSB7CiAgICAgICAgbHdzX2NvbnRleHRfZGVzdHJveShsYy0+Y3R4KTsKICAgICAgICBsYy0+Y3R4ID0gTlVMTDsKICAgICAgICByZXQgPSBKU19UUlVFOwogICAgICB9CgogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIEdFVF9WSE9TVF9CWV9OQU1FOiB7CiAgICAgIGNvbnN0IGNoYXIqIG5hbWU7CgogICAgICBpZigobmFtZSA9IEpTX1RvQ1N0cmluZyhjdHgsIGFyZ3ZbMF0pKSkgewogICAgICAgIHN0cnVjdCBsd3Nfdmhvc3QqIHZobzsKCiAgICAgICAgaWYoKHZobyA9IGx3c19nZXRfdmhvc3RfYnlfbmFtZShsYy0+Y3R4LCBuYW1lKSkpCiAgICAgICAgICByZXQgPSBwdHJfb2JqKGN0eCwgbHdzX2dldF92aG9zdF91c2VyKHZobykpOwoKICAgICAgICBKU19GcmVlQ1N0cmluZyhjdHgsIG5hbWUpOwogICAgICB9CgogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIEFET1BUX1NPQ0tFVDogewogICAgICBpbnQzMl90IGFyZyA9IHRvX2ludDMyKGN0eCwgYXJndlswXSk7CiAgICAgIHN0cnVjdCBsd3MqIHdzaTsKCiAgICAgIGlmKHdzaV9mcm9tX2ZkKGxjLT5jdHgsIGFyZykpCiAgICAgICAgcmV0dXJuIEpTX1Rocm93SW50ZXJuYWxFcnJvcihjdHgsICJzb2NrZXQgJSIgUFJJaTMyICIgYWxyZWFkeSBhZG9wdGVkIiwgYXJnKTsKCiAgICAgIGlmKCh3c2kgPSBsd3NfYWRvcHRfc29ja2V0KGxjLT5jdHgsIGFyZykpKQogICAgICAgIHJldCA9IGx3c2pzX3NvY2tldF9jcmVhdGUoY3R4LCB3c2kpOwoKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBBRE9QVF9TT0NLRVRfUkVBREJVRjogewogICAgICBpbnQzMl90IGFyZyA9IHRvX2ludDMyKGN0eCwgYXJndlswXSk7CiAgICAgIHN0cnVjdCBsd3MqIHdzaTsKICAgICAgc2l6ZV90IGxlbjsKICAgICAgdWludDhfdCogYnVmOwoKICAgICAgaWYod3NpX2Zyb21fZmQobGMtPmN0eCwgYXJnKSkKICAgICAgICByZXR1cm4gSlNfVGhyb3dJbnRlcm5hbEVycm9yKGN0eCwgInNvY2tldCAlIiBQUklpMzIgIiBhbHJlYWR5IGFkb3B0ZWQiLCBhcmcpOwoKICAgICAgaWYoIShidWYgPSBnZXRfYnVmZmVyKGN0eCwgYXJnYyAtIDEsIGFyZ3YgKyAxLCAmbGVuKSkpCiAgICAgICAgcmV0dXJuIEpTX1Rocm93VHlwZUVycm9yKGN0eCwgImFyZ3VtZW50IDIgbXVzdCBiZSBhbiBhcnJheWJ1ZmZlciIpOwoKICAgICAgaWYoKHdzaSA9IGx3c19hZG9wdF9zb2NrZXRfcmVhZGJ1ZihsYy0+Y3R4LCBhcmcsIChjb25zdCBjaGFyKilidWYsIGxlbikpKQogICAgICAgIHJldCA9IGx3c2pzX3NvY2tldF9jcmVhdGUoY3R4LCB3c2kpOwoKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBDQU5DRUxfU0VSVklDRTogewogICAgICBsd3NfY2FuY2VsX3NlcnZpY2UobGMtPmN0eCk7CgogICAgICBpb2hhbmRsZXJfY2xlYW51cChsYyk7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgQ0xJRU5UX0NPTk5FQ1Q6IHsKICAgICAgc3RydWN0IGx3c19jbGllbnRfY29ubmVjdF9pbmZvIGluZm8gPSB7MH07CiAgICAgIGNoYXIqIHVyaSA9IDA7CiAgICAgIEpTVmFsdWUgb2JqID0gSlNfSXNTdHJpbmcoYXJndlswXSkgPyAoYXJnYyA+IDEgJiYgSlNfSXNPYmplY3QoYXJndlsxXSkgPyBKU19EdXBWYWx1ZShjdHgsIGFyZ3ZbMV0pIDogSlNfTmV3T2JqZWN0KGN0eCkpIDogSlNfRHVwVmFsdWUoY3R4LCBhcmd2WzBdKTsKCiAgICAgIGlmKGFyZ2MgPiAwICYmIEpTX0lzU3RyaW5nKGFyZ3ZbMF0pKSB7CiAgICAgICAgY2hhciogdG1wOwoKICAgICAgICBpZigodG1wID0gdG9fc3RyaW5nKGN0eCwgYXJndlswXSkpKSB7CiAgICAgICAgICB1cmkgPSBqc19zdHJkdXAoY3R4LCB0bXApOwogICAgICAgICAgbHdzanNfdXJpX3RvY29ubmVjdGluZm8oY3R4LCB0bXAsICZpbmZvKTsKICAgICAgICAgIGpzX2ZyZWUoY3R4LCB0bXApOwogICAgICAgIH0KICAgICAgfQoKICAgICAgY2xpZW50X2Nvbm5lY3RfaW5mb19mcm9tb2JqKGN0eCwgb2JqLCAmaW5mbyk7CgogICAgICBMV1NTb2NrZXQqIHNvY2sgPSBzb2NrZXRfYWxsb2MoY3R4KTsKCiAgICAgIHNvY2stPmNsaWVudCA9IFRSVUU7CiAgICAgIHNvY2stPnR5cGUgPSBpbmZvLm1ldGhvZCA/IFNPQ0tFVF9IVFRQIDogU09DS0VUX1dTOwogICAgICBzb2NrLT5tZXRob2QgPSBpbmZvLm1ldGhvZCA/IGx3c2pzX21ldGhvZF9pbmRleChpbmZvLm1ldGhvZCkgOiAwOwoKICAgICAgcmV0ID0gbHdzanNfc29ja2V0X3dyYXAoY3R4LCBzb2NrKTsKCiAgICAgIGluZm8uY29udGV4dCA9IGxjLT5jdHg7CiAgICAgIGluZm8ucHdzaSA9ICZzb2NrLT53c2k7CiAgICAgIGluZm8ub3BhcXVlX3VzZXJfZGF0YSA9IG9ial9wdHIoY3R4LCByZXQpOwoKICAgICAgaWYoaW5mby5hZGRyZXNzID09IDAgJiYgaW5mby5ob3N0KQogICAgICAgIGluZm8uYWRkcmVzcyA9IGpzX3N0cmR1cChjdHgsIGluZm8uaG9zdCk7CgogICAgICBpZighdXJpKQogICAgICAgIHVyaSA9IGx3c2pzX2Nvbm5lY3RpbmZvX3RvX3VyaShjdHgsICZpbmZvKTsKCiAgICAgIHNvY2stPnVyaSA9IHVyaTsKCiAgICAgIGx3c19jbGllbnRfY29ubmVjdF92aWFfaW5mbygmaW5mbyk7CgogICAgICBjbGllbnRfY29ubmVjdF9pbmZvX2ZyZWUoSlNfR2V0UnVudGltZShjdHgpLCAmaW5mbyk7CiAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIG9iaik7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgR0VUX1JBTkRPTTogewogICAgICBzaXplX3QgbjsKICAgICAgdWludDhfdCogcDsKCiAgICAgIGlmKChwID0gZ2V0X2J1ZmZlcihjdHgsIGFyZ2MsIGFyZ3YsICZuKSkpCiAgICAgICAgbHdzX2dldF9yYW5kb20obGMtPmN0eCwgcCwgbik7CgogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIEFTWU5DX0ROU19TRVJWRVJfQUREOiB7CiAgICAgIEpTVmFsdWUgYWRkciA9IGx3c2pzX3NvY2thZGRyNDZfdmFsdWUoY3R4LCBhcmd2WzBdKTsKICAgICAgbHdzX3NvY2thZGRyNDYqIHNhNDYgPSBsd3Nqc19zb2NrYWRkcjQ2X2RhdGEoY3R4LCBhZGRyKTsKCiAgICAgIHJldCA9IEpTX05ld0ludDMyKGN0eCwgbHdzX2FzeW5jX2Ruc19zZXJ2ZXJfYWRkKGxjLT5jdHgsIHNhNDYpKTsKCiAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGFkZHIpOwogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgQVNZTkNfRE5TX1NFUlZFUl9SRU1PVkU6IHsKICAgICAgSlNWYWx1ZSBhZGRyID0gbHdzanNfc29ja2FkZHI0Nl92YWx1ZShjdHgsIGFyZ3ZbMF0pOwogICAgICBsd3Nfc29ja2FkZHI0Niogc2E0NiA9IGx3c2pzX3NvY2thZGRyNDZfZGF0YShjdHgsIGFkZHIpOwoKICAgICAgbHdzX2FzeW5jX2Ruc19zZXJ2ZXJfcmVtb3ZlKGxjLT5jdHgsIHNhNDYpOwoKICAgICAgSlNfRnJlZVZhbHVlKGN0eCwgYWRkcik7CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBXU0lfRlJPTV9GRDogewogICAgICBzdHJ1Y3QgbHdzKiB3c2k7CgogICAgICBpZigod3NpID0gd3NpX2Zyb21fZmQobGMtPmN0eCwgdG9faW50MzIoY3R4LCBhcmd2WzBdKSkpKQogICAgICAgIHJldCA9IGpzX3NvY2tldF9nZXQoY3R4LCB3c2kpOwogICAgICBicmVhazsKICAgIH0KICB9CgogIHJldHVybiByZXQ7Cn0KCmVudW0gewogIFBST1BfSE9TVE5BTUUgPSAwLAogIFBST1BfREVQUkVDQVRFRCwKICBQUk9QX0VVSUQsCiAgUFJPUF9FR0lELAogIFBST1BfUFJPVE9DT0xTLAp9OwoKc3RhdGljIEpTVmFsdWUKbHdzanNfY29udGV4dF9nZXQoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IG1hZ2ljKSB7CiAgTFdTQ29udGV4dCogbGM7CiAgSlNWYWx1ZSByZXQgPSBKU19VTkRFRklORUQ7CgogIGlmKCEobGMgPSBsd3Nqc19jb250ZXh0X2RhdGEyKGN0eCwgdGhpc192YWwpKSkKICAgIHJldHVybiBKU19FWENFUFRJT047CgogIHN3aXRjaChtYWdpYykgewogICAgY2FzZSBQUk9QX0hPU1ROQU1FOiB7CiAgICAgIGNvbnN0IGNoYXIqIHM7CgogICAgICBpZigocyA9IGx3c19jYW5vbmljYWxfaG9zdG5hbWUobGMtPmN0eCkpKQogICAgICAgIHJldCA9IEpTX05ld1N0cmluZyhjdHgsIHMpOwoKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBQUk9QX0RFUFJFQ0FURUQ6IHsKICAgICAgcmV0ID0gSlNfTmV3Qm9vbChjdHgsIGx3c19jb250ZXh0X2lzX2RlcHJlY2F0ZWQobGMtPmN0eCkpOwogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIFBST1BfRVVJRDoKICAgIGNhc2UgUFJPUF9FR0lEOiB7CiAgICAgIHVpZF90IHVpZDsKICAgICAgZ2lkX3QgZ2lkOwogICAgICBsd3NfZ2V0X2VmZmVjdGl2ZV91aWRfZ2lkKGxjLT5jdHgsICZ1aWQsICZnaWQpOwoKICAgICAgcmV0ID0gSlNfTmV3SW50MzIoY3R4LCBtYWdpYyA9PSBQUk9QX0VVSUQgPyB1aWQgOiBnaWQpOwoKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBQUk9QX1BST1RPQ09MUzogewogICAgICByZXQgPSBKU19OZXdBcnJheShjdHgpOwoKICAgICAgZm9yKHVpbnQzMl90IGkgPSAwOyBsYy0+aW5mby5wcm90b2NvbHNbaV0ubmFtZTsgaSsrKSB7CiAgICAgICAgSlNWYWx1ZSBwcm90b2NvbCA9IGx3c2pzX3Byb3RvY29sX29iaihjdHgsICZsYy0+aW5mby5wcm90b2NvbHNbaV0pOwogICAgICAgIEpTX1NldFByb3BlcnR5VWludDMyKGN0eCwgcmV0LCBpLCBwcm90b2NvbCk7CiAgICAgIH0KCiAgICAgIGJyZWFrOwogICAgfQogIH0KCiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIHZvaWQKbHdzanNfY29udGV4dF9maW5hbGl6ZXIoSlNSdW50aW1lKiBydCwgSlNWYWx1ZSB2YWwpIHsKICBMV1NDb250ZXh0KiBsYzsKCiAgaWYoKGxjID0gbHdzanNfY29udGV4dF9kYXRhKHZhbCkpKQogICAgY29udGV4dF9mcmVlKHJ0LCBsYyk7Cn0KCnN0YXRpYyBjb25zdCBKU0NsYXNzRGVmIGx3c19jb250ZXh0X2NsYXNzID0gewogICAgIkxXU0NvbnRleHQiLAogICAgLmZpbmFsaXplciA9IGx3c2pzX2NvbnRleHRfZmluYWxpemVyLAp9OwoKc3RhdGljIGNvbnN0IEpTQ0Z1bmN0aW9uTGlzdEVudHJ5IGx3c19jb250ZXh0X3Byb3RvX2Z1bmNzW10gPSB7CiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImRlc3Ryb3kiLCAwLCBsd3Nqc19jb250ZXh0X21ldGhvZHMsIERFU1RST1kpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXRWaG9zdEJ5TmFtZSIsIDEsIGx3c2pzX2NvbnRleHRfbWV0aG9kcywgR0VUX1ZIT1NUX0JZX05BTUUpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJhZG9wdFNvY2tldCIsIDEsIGx3c2pzX2NvbnRleHRfbWV0aG9kcywgQURPUFRfU09DS0VUKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiYWRvcHRTb2NrZXRSZWFkYnVmIiwgMiwgbHdzanNfY29udGV4dF9tZXRob2RzLCBBRE9QVF9TT0NLRVRfUkVBREJVRiksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImNhbmNlbFNlcnZpY2UiLCAwLCBsd3Nqc19jb250ZXh0X21ldGhvZHMsIENBTkNFTF9TRVJWSUNFKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiY2xpZW50Q29ubmVjdCIsIDEsIGx3c2pzX2NvbnRleHRfbWV0aG9kcywgQ0xJRU5UX0NPTk5FQ1QpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXRSYW5kb20iLCAxLCBsd3Nqc19jb250ZXh0X21ldGhvZHMsIEdFVF9SQU5ET00pLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJhc3luY0Ruc1NlcnZlckFkZCIsIDEsIGx3c2pzX2NvbnRleHRfbWV0aG9kcywgQVNZTkNfRE5TX1NFUlZFUl9BREQpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJhc3luY0Ruc1NlcnZlclJlbW92ZSIsIDEsIGx3c2pzX2NvbnRleHRfbWV0aG9kcywgQVNZTkNfRE5TX1NFUlZFUl9SRU1PVkUpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJ3c2lGcm9tRmQiLCAxLCBsd3Nqc19jb250ZXh0X21ldGhvZHMsIFdTSV9GUk9NX0ZEKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJob3N0bmFtZSIsIGx3c2pzX2NvbnRleHRfZ2V0LCAwLCBQUk9QX0hPU1ROQU1FKSwKICAgIC8vIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJ2aG9zdCIsIGx3c2pzX2NvbnRleHRfZ2V0LCAwLCBQUk9QX1ZIT1NUKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJkZXByZWNhdGVkIiwgbHdzanNfY29udGV4dF9nZXQsIDAsIFBST1BfREVQUkVDQVRFRCksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigiZXVpZCIsIGx3c2pzX2NvbnRleHRfZ2V0LCAwLCBQUk9QX0VVSUQpLAogICAgSlNfQ0dFVFNFVF9NQUdJQ19ERUYoImVnaWQiLCBsd3Nqc19jb250ZXh0X2dldCwgMCwgUFJPUF9FR0lEKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJwcm90b2NvbHMiLCBsd3Nqc19jb250ZXh0X2dldCwgMCwgUFJPUF9QUk9UT0NPTFMpLAogICAgSlNfUFJPUF9TVFJJTkdfREVGKCJbU3ltYm9sLnRvU3RyaW5nVGFnXSIsICJMV1NDb250ZXh0IiwgSlNfUFJPUF9DT05GSUdVUkFCTEUpLAp9OwoKaW50Cmx3c2pzX2NvbnRleHRfaW5pdChKU0NvbnRleHQqIGN0eCwgSlNNb2R1bGVEZWYqIG0pIHsKICBKU19OZXdDbGFzc0lEKCZsd3Nqc19jb250ZXh0X2NsYXNzX2lkKTsKICBKU19OZXdDbGFzcyhKU19HZXRSdW50aW1lKGN0eCksIGx3c2pzX2NvbnRleHRfY2xhc3NfaWQsICZsd3NfY29udGV4dF9jbGFzcyk7CiAgbHdzanNfY29udGV4dF9wcm90byA9IEpTX05ld09iamVjdFByb3RvKGN0eCwgSlNfTlVMTCk7CiAgSlNfU2V0UHJvcGVydHlGdW5jdGlvbkxpc3QoY3R4LCBsd3Nqc19jb250ZXh0X3Byb3RvLCBsd3NfY29udGV4dF9wcm90b19mdW5jcywgY291bnRvZihsd3NfY29udGV4dF9wcm90b19mdW5jcykpOwoKICBsd3Nqc19jb250ZXh0X2N0b3IgPSBKU19OZXdDRnVuY3Rpb24yKGN0eCwgbHdzanNfY29udGV4dF9jb25zdHJ1Y3RvciwgIkxXU0NvbnRleHQiLCAxLCBKU19DRlVOQ19jb25zdHJ1Y3RvciwgMCk7CiAgSlNfU2V0Q29uc3RydWN0b3IoY3R4LCBsd3Nqc19jb250ZXh0X2N0b3IsIGx3c2pzX2NvbnRleHRfcHJvdG8pOwoKICBpZihtKSB7CiAgICBKU19TZXRNb2R1bGVFeHBvcnQoY3R4LCBtLCAiTFdTQ29udGV4dCIsIGx3c2pzX2NvbnRleHRfY3Rvcik7CiAgfQoKICByZXR1cm4gMDsKfQoAAAAAAAAAAC/DAAAAAAAAAAAAAAAAAAAAAAAAL8MAAAAAAAAAAAAAAAAAAAAAAAAvwwAAAAAAAAAAAAAAAAAAAAAAAC/DAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAj7IAAAAAAACPsgAAAAAAAAAAAAAAAPC/"
				]
			]
		},
		{
			"file": "libwebsockets/lib/plat/freertos/freertos-sockets.c",
			"settings":
			{
				"buffer_size": 9580,
				"line_ending": "Unix"
			}
		},
		{
			"file": "libwebsockets/lib/plat/optee/network.c",
			"settings":
			{
				"buffer_size": 6989,
				"line_ending": "Unix"
			}
		},
		{
			"file": "libwebsockets/lib/core-net/output.c",
			"settings":
			{
				"buffer_size": 9914,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 681 files for \"\\b(read|recv|write|send)(|to)\" (regex, case sensitive)\n\n~/Projects/plot-cv/quickjs/qjs-lws/lws-context.c:\n   55    struct list_head link;\n   56    int fd;\n   57:   BOOL write;\n   58  } HandlerFunction;\n   59  \n   60  static JSValue\n   61: iohandler_function(JSContext* ctx, BOOL write) {\n   62    JSValue glob = JS_GetGlobalObject(ctx);\n   63    JSValue os = JS_GetPropertyStr(ctx, glob, \"os\");\n   64    JS_FreeValue(ctx, glob);\n   65:   JSValue fn = JS_GetPropertyStr(ctx, os, write ? \"setWriteHandler\" : \"setReadHandler\");\n   66    JS_FreeValue(ctx, os);\n   67    return fn;\n   ..\n   69  \n   70  static HandlerFunction*\n   71: iohandler_find(LWSContext* lc, int fd, BOOL write) {\n   72    struct list_head* el;\n   73  \n   ..\n   75      HandlerFunction* hf = list_entry(el, HandlerFunction, link);\n   76  \n   77:     if(hf->fd == fd && hf->write == write)\n   78        return hf;\n   79    }\n   ..\n   83  \n   84  static HandlerFunction*\n   85: iohandler_add(LWSContext* lc, int fd, BOOL write) {\n   86    HandlerFunction* hf;\n   87  \n   88:   if((hf = iohandler_find(lc, fd, write)))\n   89      return hf;\n   90  \n   91    if((hf = js_malloc(lc->js, sizeof(HandlerFunction)))) {\n   92      hf->fd = fd;\n   93:     hf->write = write;\n   94  \n   95:     DEBUG(\"%s %d %s\", __func__, fd, write ? \"write\" : \"read\");\n   96  \n   97      list_add(&hf->link, &lc->handlers);\n   ..\n  103  \n  104  static BOOL\n  105: iohandler_remove(LWSContext* lc, int fd, BOOL write) {\n  106    HandlerFunction* hf;\n  107  \n  108:   if((hf = iohandler_find(lc, fd, write))) {\n  109:     DEBUG(\"%s %d %s\", __func__, fd, write ? \"write\" : \"read\");\n  110  \n  111      list_del(&hf->link);\n  ...\n  118  \n  119  static void\n  120: iohandler_set(LWSContext* lc, int fd, JSValueConst handler, BOOL write) {\n  121:   JSValue fn = iohandler_function(lc->js, write);\n  122    JSValue args[2] = {\n  123        JS_NewInt32(lc->js, fd),\n  ...\n  126    BOOL add = JS_IsFunction(lc->js, handler);\n  127  \n  128:   // DEBUG(\"%s %d %s\", write ? \"os.setWriteHandler\" : \"os.setReadHandler\", fd, add ? \"[function]\" : \"NULL\");\n  129  \n  130    if(add)\n  131:     iohandler_add(lc, fd, write);\n  132    else\n  133:     iohandler_remove(lc, fd, write);\n  134  \n  135    JSValue ret = JS_Call(lc->js, fn, JS_NULL, 2, args);\n  ...\n  151      HandlerFunction* hf = list_entry(el, HandlerFunction, link);\n  152  \n  153:     DEBUG(\"delete handler (fd = %d, %s)\", hf->fd, hf->write ? \"write\" : \"read\");\n  154  \n  155:     iohandler_set(lc, hf->fd, JS_NULL, hf->write);\n  156    }\n  157  }\n  ...\n  207          return 0;\n  208  \n  209:       BOOL write = !!(x->events & POLLOUT);\n  210        JSValueConst data[] = {\n  211            JS_NewInt32(ctx, x->fd),\n  212            JS_NewInt32(ctx, x->events),\n  213:           JS_NewBool(ctx, write),\n  214            JS_NewInt64(ctx, (intptr_t)lws_get_context(wsi)),\n  215        };\n  ...\n  217  \n  218        if(reason == LWS_CALLBACK_CHANGE_MODE_POLL_FD)\n  219:         iohandler_set(lc, x->fd, JS_NULL, !write);\n  220  \n  221:       iohandler_set(lc, x->fd, fn, write);\n  222  \n  223        JS_FreeValue(ctx, fn);\n  ...\n  340        case LWS_CALLBACK_CHANGE_MODE_POLL_FD: {\n  341          struct lws_pollargs* x = in;\n  342:         BOOL write = !!(x->events & POLLOUT);\n  343          JSValueConst data[] = {\n  344              JS_NewInt32(ctx, x->fd),\n  345              JS_NewInt32(ctx, x->events),\n  346:             JS_NewBool(ctx, write),\n  347              JS_NewInt64(ctx, (intptr_t)lws_get_context(wsi)),\n  348          };\n  ...\n  350  \n  351          if(reason == LWS_CALLBACK_CHANGE_MODE_POLL_FD)\n  352:           iohandler_set(lc, x->fd, JS_NULL, !write);\n  353  \n  354:         iohandler_set(lc, x->fd, fn, write);\n  355  \n  356          JS_FreeValue(ctx, fn);\n  ...\n  373        s->want_write = FALSE;\n  374  \n  375:       if(!JS_IsUndefined(s->write_handler)) {\n  376:         JSValue fn = s->write_handler;\n  377:         s->write_handler = JS_UNDEFINED;\n  378          JSValue result = JS_Call(ctx, fn, JS_UNDEFINED, 1, &sock);\n  379          ret = to_int32(ctx, result);\n\n~/Projects/plot-cv/quickjs/qjs-lws/test-client.js:\n   28        },\n   29        onRawWriteable(wsi) {\n   30:         wsi.write(toArrayBuffer('GET / HTTP/1.0\\r\\n\\r\\n'));\n   31        },\n   32        onRawRx(wsi, data) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/lws-socket.h:\n   21    JSObject* obj;\n   22    BOOL client, want_write, redirected_to_get, completed, closed;\n   23:   JSValue headers, write_handler;\n   24    int response_code, body_pending, method;\n   25  } LWSSocket;\n\n~/Projects/plot-cv/quickjs/qjs-lws/lws-socket.c:\n   97    sock->ref_count = 1;\n   98    sock->headers = JS_UNDEFINED;\n   99:   sock->write_handler = JS_UNDEFINED;\n  100    sock->id = ++socket_id;\n  101    sock->method = -1;\n  ...\n  180    DEBUG(\"free LWSSocket: %p (ref_count = %d)\", sock, sock->ref_count);\n  181    if(--sock->ref_count == 0) {\n  182:     if(!JS_IsUndefined(sock->write_handler)) {\n  183:       JS_FreeValueRT(rt, sock->write_handler);\n  184:       sock->write_handler = JS_UNDEFINED;\n  185      }\n  186  \n  ...\n  413  \n  414          if(argc > 0) {\n  415:           JS_FreeValue(ctx, s->write_handler);\n  416:           s->write_handler = JS_DupValue(ctx, argv[0]);\n  417          }\n  418        }\n  ...\n  430  \n  431        /*if(!lws_send_pipe_choked(s->wsi)) {\n  432:         ret = JS_ThrowInternalError(ctx, \"I/O error: send pipe choked lws_write()\");\n  433          break;\n  434        }*/\n  ...\n  464                s->completed = TRUE;\n  465  \n  466:         DEBUG_WSI(s->wsi, \"send pipe choked: %d partially buffered: %d\", lws_send_pipe_choked(s->wsi), lws_partial_buffered(s->wsi));\n  467        }\n  468  \n  ...\n  988  static const JSCFunctionListEntry lws_socket_proto_funcs[] = {\n  989      JS_CFUNC_MAGIC_DEF(\"wantWrite\", 0, lwsjs_socket_methods, METHOD_WANT_WRITE),\n  990:     JS_CFUNC_MAGIC_DEF(\"write\", 1, lwsjs_socket_methods, METHOD_WRITE),\n  991      JS_CFUNC_MAGIC_DEF(\"respond\", 1, lwsjs_socket_methods, METHOD_RESPOND),\n  992      JS_CFUNC_MAGIC_DEF(\"close\", 0, lwsjs_socket_methods, METHOD_CLOSE),\n\n~/Projects/plot-cv/quickjs/qjs-lws/test.js:\n   50  \n   51          verbose('onReceive', wsi, data, len);\n   52:         wsi.write(data);\n   53        },\n   54        onFilterHttpConnection(wsi, url) {\n   ..\n   85  \n   86            wsi.respond(200, { 'content-type': 'text/html', test: 'blah' }, b.byteLength);\n   87:           wsi.write(b, LWS_WRITE_HTTP_FINAL);\n   88  \n   89            return -1;\n   ..\n  108          }\n  109  \n  110:         wsi.write(obj.lines[obj.index] + '\\n', obj.lines[++obj.index] ? LWS_WRITE_HTTP : LWS_WRITE_HTTP_FINAL);\n  111  \n  112          if(obj.lines[obj.index]) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/lws.c:\n  512      JS_CFUNC_MAGIC_DEF(\"toArrayBuffer\", 1, lwsjs_functions, FUNCTION_TO_ARRAYBUFFER),\n  513      JS_CFUNC_MAGIC_DEF(\"toPointer\", 1, lwsjs_functions, FUNCTION_TO_POINTER),\n  514:     JS_CFUNC_MAGIC_DEF(\"write\", 2, lwsjs_functions, FUNCTION_WRITE),\n  515      JS_CFUNC_MAGIC_DEF(\"parseMac\", 1, lwsjs_functions, FUNCTION_PARSE_MAC),\n  516      JS_CFUNC_MAGIC_DEF(\"parseNumericAddress\", 1, lwsjs_functions, FUNCTION_PARSE_NUMERIC_ADDRESS),\n  517:     JS_CFUNC_MAGIC_DEF(\"writeNumericAddress\", 1, lwsjs_functions, FUNCTION_WRITE_NUMERIC_ADDRESS),\n  518      JS_CFUNC_MAGIC_DEF(\"interfaceToSa\", 1, lwsjs_functions, FUNCTION_INTERFACE_TO_SA),\n  519      JS_PROP_INT32_DEF(\"LWSMPRO_HTTP\", LWSMPRO_HTTP, 0),\n\n~/Projects/plot-cv/quickjs/qjs-lws/out/web.js:\n  602    var start = original === null || original === void 0 ? void 0 : original.start;\n  603    var type = original === null || original === void 0 ? void 0 : original.type;\n  604:   var write = original === null || original === void 0 ? void 0 : original.write;\n  605    return {\n  606      abort: abort === undefined ? undefined : convertUnderlyingSinkAbortCallback(abort, original, ''.concat(context, \" has member 'abort' that\")),\n  607      close: close === undefined ? undefined : convertUnderlyingSinkCloseCallback(close, original, ''.concat(context, \" has member 'close' that\")),\n  608      start: start === undefined ? undefined : convertUnderlyingSinkStartCallback(start, original, ''.concat(context, \" has member 'start' that\")),\n  609:     write: write === undefined ? undefined : convertUnderlyingSinkWriteCallback(write, original, ''.concat(context, \" has member 'write' that\")),\n  610      type: type,\n  611    };\n  ...\n  677          var reason = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : undefined;\n  678          if(!IsWritableStream(this)) return promiseRejectedWith(streamBrandCheckException('abort'));\n  679:         if(IsWritableStreamLocked(this)) return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n  680          return WritableStreamAbort(this, reason);\n  681        },\n  ...\n  685        value: function close() {\n  686          if(!IsWritableStream(this)) return promiseRejectedWith(streamBrandCheckException('close'));\n  687:         if(IsWritableStreamLocked(this)) return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n  688          if(WritableStreamCloseQueuedOrInFlight(this)) return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n  689          return WritableStreamClose(this);\n  ...\n  728    return new WritableStreamDefaultWriter(stream);\n  729  }\n  730: function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm) {\n  731    var highWaterMark = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1,\n  732      sizeAlgorithm =\n  ...\n  740    InitializeWritableStream(stream);\n  741    var controller = Object.create(WritableStreamDefaultController.prototype);\n  742:   SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n  743    return stream;\n  744  }\n  ...\n  804      stream._closeRequest = closeRequest;\n  805    });\n  806:   var writer = stream._writer;\n  807:   if(writer !== undefined && stream._backpressure && state === 'writable') defaultWriterReadyPromiseResolve(writer);\n  808    WritableStreamDefaultControllerClose(stream._writableStreamController);\n  809    return promise;\n  ...\n  813    assert(stream._state === 'writable');\n  814    var promise = newPromise(function (resolve, reject) {\n  815:     var writeRequest = {\n  816        _resolve: resolve,\n  817        _reject: reject,\n  818      };\n  819:     stream._writeRequests.push(writeRequest);\n  820    });\n  821    return promise;\n  ...\n  837    stream._state = 'erroring';\n  838    stream._storedError = reason;\n  839:   var writer = stream._writer;\n  840:   if(writer !== undefined) WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  841    if(!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) WritableStreamFinishErroring(stream);\n  842  }\n  ...\n  847    stream._writableStreamController[ErrorSteps]();\n  848    var storedError = stream._storedError;\n  849:   stream._writeRequests.forEach(function (writeRequest) {\n  850:     writeRequest._reject(storedError);\n  851    });\n  852    stream._writeRequests = new SimpleQueue();\n  ...\n  903    }\n  904    stream._state = 'closed';\n  905:   var writer = stream._writer;\n  906:   if(writer !== undefined) defaultWriterClosedPromiseResolve(writer);\n  907    assert(stream._pendingAbortRequest === undefined);\n  908    assert(stream._storedError === undefined);\n  ...\n  945      stream._closeRequest = undefined;\n  946    }\n  947:   var writer = stream._writer;\n  948:   if(writer !== undefined) defaultWriterClosedPromiseReject(writer, stream._storedError);\n  949  }\n  950  function WritableStreamUpdateBackpressure(stream, backpressure) {\n  951    assert(stream._state === 'writable');\n  952    assert(!WritableStreamCloseQueuedOrInFlight(stream));\n  953:   var writer = stream._writer;\n  954:   if(writer !== undefined && backpressure !== stream._backpressure) {\n  955:     if(backpressure) defaultWriterReadyPromiseReset(writer);\n  956      else {\n  957        assert(!backpressure);\n  958:       defaultWriterReadyPromiseResolve(writer);\n  959      }\n  960    }\n  ...\n  967      assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');\n  968      assertWritableStream(stream, 'First parameter');\n  969: <skipped 29 characters> ...(stream)) throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n  970      this._ownerWritableStream = stream;\n  971      stream._writer = this;\n  ...\n 1005      },\n 1006      {\n 1007:       key: 'ready',\n 1008        get: function get() {\n 1009:         if(!IsWritableStreamDefaultWriter(this)) return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n 1010          return this._readyPromise;\n 1011        },\n ....\n 1041      },\n 1042      {\n 1043:       key: 'write',\n 1044:       value: function write() {\n 1045          var chunk = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : undefined;\n 1046:         if(!IsWritableStreamDefaultWriter(this)) return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n 1047:         if(this._ownerWritableStream === undefined) return promiseRejectedWith(defaultWriterLockException('write to'));\n 1048          return WritableStreamDefaultWriterWrite(this, chunk);\n 1049        },\n ....\n 1062      enumerable: true,\n 1063    },\n 1064:   write: {\n 1065      enumerable: true,\n 1066    },\n ....\n 1071      enumerable: true,\n 1072    },\n 1073:   ready: {\n 1074      enumerable: true,\n 1075    },\n ....\n 1078  setFunctionName(WritableStreamDefaultWriter.prototype.close, 'close');\n 1079  setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, 'releaseLock');\n 1080: setFunctionName(WritableStreamDefaultWriter.prototype.write, 'write');\n 1081  if(_type_of(Symbol.toStringTag) === 'symbol')\n 1082    Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {\n ....\n 1089    return _instanceof(x, WritableStreamDefaultWriter);\n 1090  }\n 1091: function WritableStreamDefaultWriterAbort(writer, reason) {\n 1092:   var stream = writer._ownerWritableStream;\n 1093    assert(stream !== undefined);\n 1094    return WritableStreamAbort(stream, reason);\n 1095  }\n 1096: function WritableStreamDefaultWriterClose(writer) {\n 1097:   var stream = writer._ownerWritableStream;\n 1098    assert(stream !== undefined);\n 1099    return WritableStreamClose(stream);\n 1100  }\n 1101: function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n 1102:   var stream = writer._ownerWritableStream;\n 1103    assert(stream !== undefined);\n 1104    var state = stream._state;\n ....\n 1106    if(state === 'errored') return promiseRejectedWith(stream._storedError);\n 1107    assert(state === 'writable' || state === 'erroring');\n 1108:   return WritableStreamDefaultWriterClose(writer);\n 1109  }\n 1110: function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n 1111:   if(writer._closedPromiseState === 'pending') defaultWriterClosedPromiseReject(writer, error);\n 1112:   else defaultWriterClosedPromiseResetToRejected(writer, error);\n 1113  }\n 1114: function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n 1115:   if(writer._readyPromiseState === 'pending') defaultWriterReadyPromiseReject(writer, error);\n 1116:   else defaultWriterReadyPromiseResetToRejected(writer, error);\n 1117  }\n 1118: function WritableStreamDefaultWriterGetDesiredSize(writer) {\n 1119:   var stream = writer._ownerWritableStream;\n 1120    var state = stream._state;\n 1121    if(state === 'errored' || state === 'erroring') return null;\n ....\n 1123    return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n 1124  }\n 1125: function WritableStreamDefaultWriterRelease(writer) {\n 1126:   var stream = writer._ownerWritableStream;\n 1127    assert(stream !== undefined);\n 1128:   assert(stream._writer === writer);\n 1129    var releasedError = new TypeError(\"Writer was released and can no longer be used to monitor the stream's closedness\");\n 1130:   WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n 1131:   WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n 1132    stream._writer = undefined;\n 1133:   writer._ownerWritableStream = undefined;\n 1134  }\n 1135: function WritableStreamDefaultWriterWrite(writer, chunk) {\n 1136:   var stream = writer._ownerWritableStream;\n 1137    assert(stream !== undefined);\n 1138    var controller = stream._writableStreamController;\n 1139    var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n 1140:   if(stream !== writer._ownerWritableStream) return promiseRejectedWith(defaultWriterLockException('write to'));\n 1141    var state = stream._state;\n 1142    if(state === 'errored') return promiseRejectedWith(stream._storedError);\n ....\n 1219    return _instanceof(x, WritableStreamDefaultController);\n 1220  }\n 1221: function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n 1222    assert(IsWritableStream(stream));\n 1223    assert(stream._writableStreamController === undefined);\n ....\n 1232    controller._strategySizeAlgorithm = sizeAlgorithm;\n 1233    controller._strategyHWM = highWaterMark;\n 1234:   controller._writeAlgorithm = writeAlgorithm;\n 1235    controller._closeAlgorithm = closeAlgorithm;\n 1236    controller._abortAlgorithm = abortAlgorithm;\n ....\n 1258    var controller = Object.create(WritableStreamDefaultController.prototype);\n 1259    var startAlgorithm;\n 1260:   var writeAlgorithm;\n 1261    var closeAlgorithm;\n 1262    var abortAlgorithm;\n ....\n 1269        return undefined;\n 1270      };\n 1271:   if(underlyingSink.write !== undefined)\n 1272:     writeAlgorithm = function(chunk) {\n 1273:       return underlyingSink.write(chunk, controller);\n 1274      };\n 1275    else\n 1276:     writeAlgorithm = function() {\n 1277        return promiseResolvedWith(undefined);\n 1278      };\n ....\n 1293        return promiseResolvedWith(undefined);\n 1294      };\n 1295:   SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n 1296  }\n 1297  function WritableStreamDefaultControllerClearAlgorithms(controller) {\n ....\n 1416  }\n 1417  function defaultWriterLockException(name) {\n 1418:   return new TypeError('Cannot ' + name + ' a stream using a released writer');\n 1419  }\n 1420: function defaultWriterClosedPromiseInitialize(writer) {\n 1421:   writer._closedPromise = newPromise(function (resolve, reject) {\n 1422:     writer._closedPromise_resolve = resolve;\n 1423:     writer._closedPromise_reject = reject;\n 1424:     writer._closedPromiseState = 'pending';\n 1425    });\n 1426  }\n 1427: function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n 1428:   defaultWriterClosedPromiseInitialize(writer);\n 1429:   defaultWriterClosedPromiseReject(writer, reason);\n 1430  }\n 1431: function defaultWriterClosedPromiseInitializeAsResolved(writer) {\n 1432:   defaultWriterClosedPromiseInitialize(writer);\n 1433:   defaultWriterClosedPromiseResolve(writer);\n 1434  }\n 1435: function defaultWriterClosedPromiseReject(writer, reason) {\n 1436:   if(writer._closedPromise_reject === undefined) return;\n 1437:   assert(writer._closedPromiseState === 'pending');\n 1438:   setPromiseIsHandledToTrue(writer._closedPromise);\n 1439:   writer._closedPromise_reject(reason);\n 1440:   writer._closedPromise_resolve = undefined;\n 1441:   writer._closedPromise_reject = undefined;\n 1442:   writer._closedPromiseState = 'rejected';\n 1443  }\n 1444: function defaultWriterClosedPromiseResetToRejected(writer, reason) {\n 1445:   assert(writer._closedPromise_resolve === undefined);\n 1446:   assert(writer._closedPromise_reject === undefined);\n 1447:   assert(writer._closedPromiseState !== 'pending');\n 1448:   defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n 1449  }\n 1450: function defaultWriterClosedPromiseResolve(writer) {\n 1451:   if(writer._closedPromise_resolve === undefined) return;\n 1452:   assert(writer._closedPromiseState === 'pending');\n 1453:   writer._closedPromise_resolve(undefined);\n 1454:   writer._closedPromise_resolve = undefined;\n 1455:   writer._closedPromise_reject = undefined;\n 1456:   writer._closedPromiseState = 'resolved';\n 1457  }\n 1458: function defaultWriterReadyPromiseInitialize(writer) {\n 1459:   writer._readyPromise = newPromise(function (resolve, reject) {\n 1460:     writer._readyPromise_resolve = resolve;\n 1461:     writer._readyPromise_reject = reject;\n 1462    });\n 1463:   writer._readyPromiseState = 'pending';\n 1464  }\n 1465: function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n 1466:   defaultWriterReadyPromiseInitialize(writer);\n 1467:   defaultWriterReadyPromiseReject(writer, reason);\n 1468  }\n 1469: function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n 1470:   defaultWriterReadyPromiseInitialize(writer);\n 1471:   defaultWriterReadyPromiseResolve(writer);\n 1472  }\n 1473: function defaultWriterReadyPromiseReject(writer, reason) {\n 1474:   if(writer._readyPromise_reject === undefined) return;\n 1475:   setPromiseIsHandledToTrue(writer._readyPromise);\n 1476:   writer._readyPromise_reject(reason);\n 1477:   writer._readyPromise_resolve = undefined;\n 1478:   writer._readyPromise_reject = undefined;\n 1479:   writer._readyPromiseState = 'rejected';\n 1480  }\n 1481: function defaultWriterReadyPromiseReset(writer) {\n 1482:   assert(writer._readyPromise_resolve === undefined);\n 1483:   assert(writer._readyPromise_reject === undefined);\n 1484:   defaultWriterReadyPromiseInitialize(writer);\n 1485  }\n 1486: function defaultWriterReadyPromiseResetToRejected(writer, reason) {\n 1487:   assert(writer._readyPromise_resolve === undefined);\n 1488:   assert(writer._readyPromise_reject === undefined);\n 1489:   defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n 1490  }\n 1491: function defaultWriterReadyPromiseResolve(writer) {\n 1492:   if(writer._readyPromise_resolve === undefined) return;\n 1493:   writer._readyPromise_resolve(undefined);\n 1494:   writer._readyPromise_resolve = undefined;\n 1495:   writer._readyPromise_reject = undefined;\n 1496:   writer._readyPromiseState = 'fulfilled';\n 1497  }\n 1498  var NumberIsInteger =\n ....\n 1697    return new ReadableStreamDefaultReader(stream);\n 1698  }\n 1699: function ReadableStreamAddReadRequest(stream, readRequest) {\n 1700    assert(IsReadableStreamDefaultReader(stream._reader));\n 1701:   assert(stream._state === 'readable');\n 1702:   stream._reader._readRequests.push(readRequest);\n 1703  }\n 1704  function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n 1705:   var reader = stream._reader;\n 1706:   assert(reader._readRequests.length > 0);\n 1707:   var readRequest = reader._readRequests.shift();\n 1708:   if(done) readRequest._closeSteps();\n 1709:   else readRequest._chunkSteps(chunk);\n 1710  }\n 1711  function ReadableStreamGetNumReadRequests(stream) {\n ....\n 1713  }\n 1714  function ReadableStreamHasDefaultReader(stream) {\n 1715:   var reader = stream._reader;\n 1716:   if(reader === undefined) return false;\n 1717:   if(!IsReadableStreamDefaultReader(reader)) return false;\n 1718    return true;\n 1719  }\n ....\n 1745          if(this._closeRequested) throw new TypeError('The stream has already been closed; do not close it again!');\n 1746          var state = this._controlledReadableByteStream._state;\n 1747:         if(state !== 'readable') throw new TypeError('The stream (in '.concat(state, ' state) is not in the readable state and cannot be closed'));\n 1748          ReadableByteStreamControllerClose(this);\n 1749        },\n ....\n 1759          if(this._closeRequested) throw new TypeError('stream is closed or draining');\n 1760          var state = this._controlledReadableByteStream._state;\n 1761:         if(state !== 'readable') throw new TypeError('The stream (in '.concat(state, ' state) is not in the readable state and cannot be enqueued to'));\n 1762          ReadableByteStreamControllerEnqueue(this, chunk);\n 1763        },\n ....\n 1783      {\n 1784        key: PullSteps,\n 1785:       value: function value(readRequest) {\n 1786          var stream = this._controlledReadableByteStream;\n 1787          assert(ReadableStreamHasDefaultReader(stream));\n 1788          if(this._queueTotalSize > 0) {\n 1789            assert(ReadableStreamGetNumReadRequests(stream) === 0);\n 1790:           ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);\n 1791            return;\n 1792          }\n ....\n 1797              buffer = new ArrayBuffer(autoAllocateChunkSize);\n 1798            } catch(bufferE) {\n 1799:             readRequest._errorSteps(bufferE);\n 1800              return;\n 1801            }\n ....\n 1809              elementSize: 1,\n 1810              viewConstructor: Uint8Array,\n 1811:             readerType: 'default',\n 1812            };\n 1813            this._pendingPullIntos.push(pullIntoDescriptor);\n 1814          }\n 1815:         ReadableStreamAddReadRequest(stream, readRequest);\n 1816          ReadableByteStreamControllerCallPullIfNeeded(this);\n 1817        },\n ....\n 1822          if(this._pendingPullIntos.length > 0) {\n 1823            var firstPullInto = this._pendingPullIntos.peek();\n 1824:           firstPullInto.readerType = 'none';\n 1825            this._pendingPullIntos = new SimpleQueue();\n 1826            this._pendingPullIntos.push(firstPullInto);\n ....\n 1899    return new ReadableStreamBYOBReader(stream);\n 1900  }\n 1901: function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n 1902    assert(IsReadableStreamBYOBReader(stream._reader));\n 1903:   assert(stream._state === 'readable' || stream._state === 'closed');\n 1904:   stream._reader._readIntoRequests.push(readIntoRequest);\n 1905  }\n 1906  function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n 1907:   var reader = stream._reader;\n 1908:   assert(reader._readIntoRequests.length > 0);\n 1909:   var readIntoRequest = reader._readIntoRequests.shift();\n 1910:   if(done) readIntoRequest._closeSteps(chunk);\n 1911:   else readIntoRequest._chunkSteps(chunk);\n 1912  }\n 1913  function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n 1914    assert(stream._state !== 'errored');\n 1915:   assert(pullIntoDescriptor.readerType !== 'none');\n 1916    var done = false;\n 1917    if(stream._state === 'closed') {\n ....\n 1920    }\n 1921    var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n 1922:   if(pullIntoDescriptor.readerType === 'default') ReadableStreamFulfillReadRequest(stream, filledView, done);\n 1923    else {\n 1924:     assert(pullIntoDescriptor.readerType === 'byob');\n 1925      ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n 1926    }\n ....\n 1955  }\n 1956  function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {\n 1957:   assert(firstDescriptor.readerType === 'none');\n 1958    if(firstDescriptor.bytesFilled > 0) ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);\n 1959    ReadableByteStreamControllerShiftPendingPullInto(controller);\n ....\n 1963    var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n 1964    var totalBytesToCopyRemaining = maxBytesToCopy;\n 1965:   var ready = false;\n 1966    assert(!IsDetachedBuffer(pullIntoDescriptor.buffer));\n 1967    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n ....\n 1970    if(maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n 1971      totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n 1972:     ready = true;\n 1973    }\n 1974    var queue = controller._queue;\n ....\n 1988      totalBytesToCopyRemaining -= bytesToCopy;\n 1989    }\n 1990:   if(!ready) {\n 1991      assert(controller._queueTotalSize === 0);\n 1992      assert(pullIntoDescriptor.bytesFilled > 0);\n 1993      assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n 1994    }\n 1995:   return ready;\n 1996  }\n 1997  function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n ....\n 2001  }\n 2002  function ReadableByteStreamControllerHandleQueueDrain(controller) {\n 2003:   assert(controller._controlledReadableByteStream._state === 'readable');\n 2004    if(controller._queueTotalSize === 0 && controller._closeRequested) {\n 2005      ReadableByteStreamControllerClearAlgorithms(controller);\n ....\n 2019      if(controller._queueTotalSize === 0) break;\n 2020      var pullIntoDescriptor = controller._pendingPullIntos.peek();\n 2021:     assert(pullIntoDescriptor.readerType !== 'none');\n 2022      if(ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n 2023        ReadableByteStreamControllerShiftPendingPullInto(controller);\n ....\n 2028  }\n 2029  function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller) {\n 2030:   var reader = controller._controlledReadableByteStream._reader;\n 2031:   assert(IsReadableStreamDefaultReader(reader));\n 2032:   while(reader._readRequests.length > 0) {\n 2033      if(controller._queueTotalSize === 0) return;\n 2034:     var readRequest = reader._readRequests.shift();\n 2035:     ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);\n 2036    }\n 2037  }\n 2038: function ReadableByteStreamControllerPullInto(controller, view, min, readIntoRequest) {\n 2039    var stream = controller._controlledReadableByteStream;\n 2040    var ctor = view.constructor;\n ....\n 2049      buffer = TransferArrayBuffer(view.buffer);\n 2050    } catch(e) {\n 2051:     readIntoRequest._errorSteps(e);\n 2052      return;\n 2053    }\n ....\n 2061      elementSize: elementSize,\n 2062      viewConstructor: ctor,\n 2063:     readerType: 'byob',\n 2064    };\n 2065    if(controller._pendingPullIntos.length > 0) {\n 2066      controller._pendingPullIntos.push(pullIntoDescriptor);\n 2067:     ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n 2068      return;\n 2069    }\n 2070    if(stream._state === 'closed') {\n 2071      var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n 2072:     readIntoRequest._closeSteps(emptyView);\n 2073      return;\n 2074    }\n ....\n 2077        var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n 2078        ReadableByteStreamControllerHandleQueueDrain(controller);\n 2079:       readIntoRequest._chunkSteps(filledView);\n 2080        return;\n 2081      }\n ....\n 2083        var _$e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n 2084        ReadableByteStreamControllerError(controller, _$e);\n 2085:       readIntoRequest._errorSteps(_$e);\n 2086        return;\n 2087      }\n 2088    }\n 2089    controller._pendingPullIntos.push(pullIntoDescriptor);\n 2090:   ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n 2091    ReadableByteStreamControllerCallPullIfNeeded(controller);\n 2092  }\n ....\n 2095  }\n 2096  function ReadableStreamHasBYOBReader(stream) {\n 2097:   var reader = stream._reader;\n 2098:   if(reader === undefined) return false;\n 2099:   if(!IsReadableStreamBYOBReader(reader)) return false;\n 2100    return true;\n 2101  }\n 2102  function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n 2103    assert(firstDescriptor.bytesFilled % firstDescriptor.elementSize === 0);\n 2104:   if(firstDescriptor.readerType === 'none') ReadableByteStreamControllerShiftPendingPullInto(controller);\n 2105    var stream = controller._controlledReadableByteStream;\n 2106    if(ReadableStreamHasBYOBReader(stream)) {\n ....\n 2113    assert(pullIntoDescriptor.bytesFilled + bytesWritten <= pullIntoDescriptor.byteLength);\n 2114    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n 2115:   if(pullIntoDescriptor.readerType === 'none') {\n 2116      ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);\n 2117      var filledPullIntos = ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n ....\n 2140      ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n 2141    } else {\n 2142:     assert(state === 'readable');\n 2143      assert(bytesWritten > 0);\n 2144      ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n ....\n 2153  function ReadableByteStreamControllerShouldCallPull(controller) {\n 2154    var stream = controller._controlledReadableByteStream;\n 2155:   if(stream._state !== 'readable') return false;\n 2156    if(controller._closeRequested) return false;\n 2157    if(!controller._started) return false;\n ....\n 2169  function ReadableByteStreamControllerClose(controller) {\n 2170    var stream = controller._controlledReadableByteStream;\n 2171:   if(controller._closeRequested || stream._state !== 'readable') return;\n 2172    if(controller._queueTotalSize > 0) {\n 2173      controller._closeRequested = true;\n ....\n 2187  function ReadableByteStreamControllerEnqueue(controller, chunk) {\n 2188    var stream = controller._controlledReadableByteStream;\n 2189:   if(controller._closeRequested || stream._state !== 'readable') return;\n 2190    var buffer = chunk.buffer,\n 2191      byteOffset = chunk.byteOffset,\n ....\n 2198      ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n 2199      firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n 2200:     if(firstPendingPullInto.readerType === 'none') ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);\n 2201    }\n 2202    if(ReadableStreamHasDefaultReader(stream)) {\n ....\n 2208        assert(controller._queue.length === 0);\n 2209        if(controller._pendingPullIntos.length > 0) {\n 2210:         assert(controller._pendingPullIntos.peek().readerType === 'default');\n 2211          ReadableByteStreamControllerShiftPendingPullInto(controller);\n 2212        }\n ....\n 2226  function ReadableByteStreamControllerError(controller, e) {\n 2227    var stream = controller._controlledReadableByteStream;\n 2228:   if(stream._state !== 'readable') return;\n 2229    ReadableByteStreamControllerClearPendingPullIntos(controller);\n 2230    ResetQueue(controller);\n ....\n 2232    ReadableStreamError(stream, e);\n 2233  }\n 2234: function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {\n 2235    assert(controller._queueTotalSize > 0);\n 2236    var entry = controller._queue.shift();\n ....\n 2238    ReadableByteStreamControllerHandleQueueDrain(controller);\n 2239    var view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n 2240:   readRequest._chunkSteps(view);\n 2241  }\n 2242  function ReadableByteStreamControllerGetBYOBRequest(controller) {\n ....\n 2263      if(bytesWritten !== 0) throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n 2264    } else {\n 2265:     assert(state === 'readable');\n 2266:     if(bytesWritten === 0) throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');\n 2267      if(firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) throw new RangeError('bytesWritten out of range');\n 2268    }\n ....\n 2278      if(view.byteLength !== 0) throw new TypeError(\"The view's length must be 0 when calling respondWithNewView() on a closed stream\");\n 2279    } else {\n 2280:     assert(state === 'readable');\n 2281: <skipped 31 characters> ...hrow new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");\n 2282    }\n 2283    if(firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) throw new RangeError('The region specified by view does not match byobRequest');\n ....\n 2357    SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n 2358  }\n 2359: function ReadableStreamReaderGenericInitialize(reader, stream) {\n 2360:   reader._ownerReadableStream = stream;\n 2361:   stream._reader = reader;\n 2362:   if(stream._state === 'readable') defaultReaderClosedPromiseInitialize(reader);\n 2363:   else if(stream._state === 'closed') defaultReaderClosedPromiseInitializeAsResolved(reader);\n 2364    else {\n 2365      assert(stream._state === 'errored');\n 2366:     defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n 2367    }\n 2368  }\n 2369: function ReadableStreamReaderGenericRelease(reader) {\n 2370:   var stream = reader._ownerReadableStream;\n 2371    assert(stream !== undefined);\n 2372:   assert(stream._reader === reader);\n 2373:   if(stream._state === 'readable') defaultReaderClosedPromiseReject(reader, new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\"));\n 2374:   else defaultReaderClosedPromiseResetToRejected(reader, new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\"));\n 2375    stream._readableStreamController[ReleaseSteps]();\n 2376    stream._reader = undefined;\n 2377:   reader._ownerReadableStream = undefined;\n 2378  }\n 2379  function assertReadableStream(x, context) {\n ....\n 2381  }\n 2382  function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n 2383:   var reader = AcquireReadableStreamDefaultReader(stream);\n 2384:   var impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n 2385    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n 2386    iterator._asyncIteratorImpl = impl;\n ....\n 2428            var reason = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : undefined;\n 2429            if(!IsReadableStream(this)) return promiseRejectedWith(streamBrandCheckException1('cancel'));\n 2430:           if(IsReadableStreamLocked(this)) return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n 2431            return ReadableStreamCancel(this, reason);\n 2432          },\n ....\n 2455            var promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n 2456            setPromiseIsHandledToTrue(promise);\n 2457:           return transform.readable;\n 2458          },\n 2459        },\n ....\n 2579  }\n 2580  function InitializeReadableStream(stream) {\n 2581:   stream._state = 'readable';\n 2582    stream._reader = undefined;\n 2583    stream._storedError = undefined;\n ....\n 2599    if(stream._state === 'errored') return promiseRejectedWith(stream._storedError);\n 2600    ReadableStreamClose(stream);\n 2601:   var reader = stream._reader;\n 2602:   if(reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n 2603:     var readIntoRequests = reader._readIntoRequests;\n 2604:     reader._readIntoRequests = new SimpleQueue();\n 2605:     readIntoRequests.forEach(function (readIntoRequest) {\n 2606:       readIntoRequest._closeSteps(undefined);\n 2607      });\n 2608    }\n ....\n 2610    return transformPromiseWith(sourceCancelPromise, noop);\n 2611  }\n 2612: function ReadableStreamReaderGenericCancel(reader, reason) {\n 2613:   var stream = reader._ownerReadableStream;\n 2614    assert(stream !== undefined);\n 2615    return ReadableStreamCancel(stream, reason);\n 2616  }\n 2617: function readerLockException(name) {\n 2618:   return new TypeError('Cannot ' + name + ' a stream using a released reader');\n 2619  }\n 2620  var ReadableStreamDefaultReader = /*#__PURE__*/ (function () {\n ....\n 2624      assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');\n 2625      assertReadableStream(stream, 'First parameter');\n 2626:     if(IsReadableStreamLocked(stream)) throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n 2627      ReadableStreamReaderGenericInitialize(this, stream);\n 2628      this._readRequests = new SimpleQueue();\n ....\n 2641          var reason = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : undefined;\n 2642          if(!IsReadableStreamDefaultReader(this)) return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n 2643:         if(this._ownerReadableStream === undefined) return promiseRejectedWith(readerLockException('cancel'));\n 2644          return ReadableStreamReaderGenericCancel(this, reason);\n 2645        },\n 2646      },\n 2647      {\n 2648:       key: 'read',\n 2649:       value: function read() {\n 2650:         if(!IsReadableStreamDefaultReader(this)) return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n 2651:         if(this._ownerReadableStream === undefined) return promiseRejectedWith(readerLockException('read from'));\n 2652          var resolvePromise;\n 2653          var rejectPromise;\n ....\n 2656            rejectPromise = reject;\n 2657          });\n 2658:         var readRequest = {\n 2659            _chunkSteps: function(chunk) {\n 2660              return resolvePromise({\n ....\n 2673            },\n 2674          };\n 2675:         ReadableStreamDefaultReaderRead(this, readRequest);\n 2676          return promise;\n 2677        },\n ....\n 2692      enumerable: true,\n 2693    },\n 2694:   read: {\n 2695      enumerable: true,\n 2696    },\n ....\n 2703  });\n 2704  setFunctionName(ReadableStreamDefaultReader.prototype.cancel, 'cancel');\n 2705: setFunctionName(ReadableStreamDefaultReader.prototype.read, 'read');\n 2706  setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, 'releaseLock');\n 2707  if(_type_of(Symbol.toStringTag) === 'symbol')\n ....\n 2715    return _instanceof(x, ReadableStreamDefaultReader);\n 2716  }\n 2717: function ReadableStreamDefaultReaderRead(reader, readRequest) {\n 2718:   var stream = reader._ownerReadableStream;\n 2719    assert(stream !== undefined);\n 2720    stream._disturbed = true;\n 2721:   if(stream._state === 'closed') readRequest._closeSteps();\n 2722:   else if(stream._state === 'errored') readRequest._errorSteps(stream._storedError);\n 2723    else {\n 2724:     assert(stream._state === 'readable');\n 2725:     stream._readableStreamController[PullSteps](readRequest);\n 2726    }\n 2727  }\n 2728  var ReadableStreamAsyncIteratorImpl = /*#__PURE__*/ (function () {\n 2729    'use strict';\n 2730:   function ReadableStreamAsyncIteratorImpl(reader, preventCancel) {\n 2731      _class_call_check(this, ReadableStreamAsyncIteratorImpl);\n 2732      this._ongoingPromise = undefined;\n 2733      this._isFinished = false;\n 2734:     this._reader = reader;\n 2735      this._preventCancel = preventCancel;\n 2736    }\n ....\n 2767              done: true,\n 2768            });\n 2769:         var reader = this._reader;\n 2770:         assert(reader._ownerReadableStream !== undefined);\n 2771          var resolvePromise;\n 2772          var rejectPromise;\n ....\n 2775            rejectPromise = reject;\n 2776          });\n 2777:         var readRequest = {\n 2778            _chunkSteps: function(chunk) {\n 2779              _this._ongoingPromise = undefined;\n ....\n 2788              _this._ongoingPromise = undefined;\n 2789              _this._isFinished = true;\n 2790:             ReadableStreamReaderGenericRelease(reader);\n 2791              resolvePromise({\n 2792                value: undefined,\n ....\n 2797              _this._ongoingPromise = undefined;\n 2798              _this._isFinished = true;\n 2799:             ReadableStreamReaderGenericRelease(reader);\n 2800              rejectPromise(reason);\n 2801            },\n 2802          };\n 2803:         ReadableStreamDefaultReaderRead(reader, readRequest);\n 2804          return promise;\n 2805        },\n ....\n 2814            });\n 2815          this._isFinished = true;\n 2816:         var reader = this._reader;\n 2817:         assert(reader._ownerReadableStream !== undefined);\n 2818:         assert(reader._readRequests.length === 0);\n 2819          if(!this._preventCancel) {\n 2820:           var result = ReadableStreamReaderGenericCancel(reader, value);\n 2821:           ReadableStreamReaderGenericRelease(reader);\n 2822            return transformPromiseWith(result, function() {\n 2823              return {\n ....\n 2827            });\n 2828          }\n 2829:         ReadableStreamReaderGenericRelease(reader);\n 2830          return promiseResolvedWith({\n 2831            value: value,\n ....\n 2856    enumerable: false,\n 2857  });\n 2858: function defaultReaderClosedPromiseInitialize(reader) {\n 2859:   reader._closedPromise = newPromise(function (resolve, reject) {\n 2860:     reader._closedPromise_resolve = resolve;\n 2861:     reader._closedPromise_reject = reject;\n 2862    });\n 2863  }\n 2864: function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n 2865:   defaultReaderClosedPromiseInitialize(reader);\n 2866:   defaultReaderClosedPromiseReject(reader, reason);\n 2867  }\n 2868: function defaultReaderClosedPromiseInitializeAsResolved(reader) {\n 2869:   defaultReaderClosedPromiseInitialize(reader);\n 2870:   defaultReaderClosedPromiseResolve(reader);\n 2871  }\n 2872: function defaultReaderClosedPromiseReject(reader, reason) {\n 2873:   if(reader._closedPromise_reject === undefined) return;\n 2874:   setPromiseIsHandledToTrue(reader._closedPromise);\n 2875:   reader._closedPromise_reject(reason);\n 2876:   reader._closedPromise_resolve = undefined;\n 2877:   reader._closedPromise_reject = undefined;\n 2878  }\n 2879: function defaultReaderClosedPromiseResetToRejected(reader, reason) {\n 2880:   assert(reader._closedPromise_resolve === undefined);\n 2881:   assert(reader._closedPromise_reject === undefined);\n 2882:   defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n 2883  }\n 2884: function defaultReaderClosedPromiseResolve(reader) {\n 2885:   if(reader._closedPromise_resolve === undefined) return;\n 2886:   reader._closedPromise_resolve(undefined);\n 2887:   reader._closedPromise_resolve = undefined;\n 2888:   reader._closedPromise_reject = undefined;\n 2889  }\n 2890  function ReadableStreamClose(stream) {\n 2891:   assert(stream._state === 'readable');\n 2892    stream._state = 'closed';\n 2893:   var reader = stream._reader;\n 2894:   if(reader === undefined) return;\n 2895:   defaultReaderClosedPromiseResolve(reader);\n 2896:   if(IsReadableStreamDefaultReader(reader)) {\n 2897:     var readRequests = reader._readRequests;\n 2898:     reader._readRequests = new SimpleQueue();\n 2899:     readRequests.forEach(function (readRequest) {\n 2900:       readRequest._closeSteps();\n 2901      });\n 2902    }\n ....\n 2952      {\n 2953        key: PullSteps,\n 2954:       value: function value(readRequest) {\n 2955          var stream = this._controlledReadableStream;\n 2956          if(this._queue.length > 0) {\n ....\n 2960              ReadableStreamClose(stream);\n 2961            } else ReadableStreamDefaultControllerCallPullIfNeeded(this);\n 2962:           readRequest._chunkSteps(chunk);\n 2963          } else {\n 2964:           ReadableStreamAddReadRequest(stream, readRequest);\n 2965            ReadableStreamDefaultControllerCallPullIfNeeded(this);\n 2966          }\n ....\n 3074  function ReadableStreamDefaultControllerError(controller, e) {\n 3075    var stream = controller._controlledReadableStream;\n 3076:   if(stream._state !== 'readable') return;\n 3077    ResetQueue(controller);\n 3078    ReadableStreamDefaultControllerClearAlgorithms(controller);\n ....\n 3091  function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n 3092    var state = controller._controlledReadableStream._state;\n 3093:   if(!controller._closeRequested && state === 'readable') return true;\n 3094    return false;\n 3095  }\n ....\n 3158  function convertReadableWritablePair(pair, context) {\n 3159    assertDictionary(pair, context);\n 3160:   var readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n 3161:   assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n 3162:   assertReadableStream(readable, ''.concat(context, \" has member 'readable' that\"));\n 3163    var writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n 3164    assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n 3165    assertWritableStream(writable, ''.concat(context, \" has member 'writable' that\"));\n 3166    return {\n 3167:     readable: readable,\n 3168      writable: writable,\n 3169    };\n ....\n 3178    assert(!IsReadableStreamLocked(source));\n 3179    assert(!IsWritableStreamLocked(dest));\n 3180:   var reader = AcquireReadableStreamDefaultReader(source);\n 3181:   var writer = AcquireWritableStreamDefaultWriter(dest);\n 3182    source._disturbed = true;\n 3183    var shuttingDown = false;\n ....\n 3195      var pipeStep = function pipeStep() {\n 3196        if(shuttingDown) return promiseResolvedWith(true);\n 3197:       return PerformPromiseThen(writer._readyPromise, function() {\n 3198          return newPromise(function (resolveRead, rejectRead) {\n 3199:           ReadableStreamDefaultReaderRead(reader, {\n 3200              _chunkSteps: function(chunk) {\n 3201:               currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n 3202                resolveRead(false);\n 3203              },\n ....\n 3246      };\n 3247      var finalize = function finalize(isError, error) {\n 3248:       WritableStreamDefaultWriterRelease(writer);\n 3249:       ReadableStreamReaderGenericRelease(reader);\n 3250        if(signal !== undefined) signal.removeEventListener('abort', abortAlgorithm);\n 3251        if(isError) reject(error);\n ....\n 3265          if(!preventCancel)\n 3266            actions.push(function () {\n 3267:             if(source._state === 'readable') return ReadableStreamCancel(source, error);\n 3268              return promiseResolvedWith(undefined);\n 3269            });\n ....\n 3286        signal.addEventListener('abort', abortAlgorithm);\n 3287      }\n 3288:     isOrBecomesErrored(source, reader._closedPromise, function(storedError) {\n 3289        if(!preventAbort)\n 3290          shutdownWithAction(\n ....\n 3298        return null;\n 3299      });\n 3300:     isOrBecomesErrored(dest, writer._closedPromise, function(storedError) {\n 3301        if(!preventCancel)\n 3302          shutdownWithAction(\n ....\n 3310        return null;\n 3311      });\n 3312:     isOrBecomesClosed(source, reader._closedPromise, function() {\n 3313        if(!preventClose)\n 3314          shutdownWithAction(function () {\n 3315:           return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);\n 3316          });\n 3317        else shutdown();\n ....\n 3345    return ReadableStreamDefaultTee(stream, cloneForBranch2);\n 3346  }\n 3347: function ReadableStreamDefaultReaderRelease(reader) {\n 3348:   ReadableStreamReaderGenericRelease(reader);\n 3349    var e = new TypeError('Reader was released');\n 3350:   ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n 3351  }\n 3352: function ReadableStreamDefaultReaderErrorReadRequests(reader, e) {\n 3353:   var readRequests = reader._readRequests;\n 3354:   reader._readRequests = new SimpleQueue();\n 3355:   readRequests.forEach(function (readRequest) {\n 3356:     readRequest._errorSteps(e);\n 3357    });\n 3358  }\n ....\n 3363      assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');\n 3364      assertReadableStream(stream, 'First parameter');\n 3365:     if(IsReadableStreamLocked(stream)) throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n 3366      if(!IsReadableByteStreamController(stream._readableStreamController)) throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source');\n 3367      ReadableStreamReaderGenericInitialize(this, stream);\n ....\n 3381          var reason = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : undefined;\n 3382          if(!IsReadableStreamBYOBReader(this)) return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n 3383:         if(this._ownerReadableStream === undefined) return promiseRejectedWith(readerLockException('cancel'));\n 3384          return ReadableStreamReaderGenericCancel(this, reason);\n 3385        },\n 3386      },\n 3387      {\n 3388:       key: 'read',\n 3389:       value: function read(view) {\n 3390          var rawOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n 3391:         if(!IsReadableStreamBYOBReader(this)) return promiseRejectedWith(byobReaderBrandCheckException('read'));\n 3392          if(!ArrayBuffer.isView(view)) return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n 3393          if(view.byteLength === 0) return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n ....\n 3405            if(min > view.length) return promiseRejectedWith(new RangeError(\"options.min must be less than or equal to view's length\"));\n 3406          } else if(min > view.byteLength) return promiseRejectedWith(new RangeError(\"options.min must be less than or equal to view's byteLength\"));\n 3407:         if(this._ownerReadableStream === undefined) return promiseRejectedWith(readerLockException('read from'));\n 3408          var resolvePromise;\n 3409          var rejectPromise;\n ....\n 3412            rejectPromise = reject;\n 3413          });\n 3414:         var readIntoRequest = {\n 3415            _chunkSteps: function(chunk) {\n 3416              return resolvePromise({\n ....\n 3429            },\n 3430          };\n 3431:         ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);\n 3432          return promise;\n 3433        },\n ....\n 3448      enumerable: true,\n 3449    },\n 3450:   read: {\n 3451      enumerable: true,\n 3452    },\n ....\n 3459  });\n 3460  setFunctionName(ReadableStreamBYOBReader.prototype.cancel, 'cancel');\n 3461: setFunctionName(ReadableStreamBYOBReader.prototype.read, 'read');\n 3462  setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, 'releaseLock');\n 3463  if(_type_of(Symbol.toStringTag) === 'symbol')\n ....\n 3471    return _instanceof(x, ReadableStreamBYOBReader);\n 3472  }\n 3473: function ReadableStreamBYOBReaderRead(reader, view, min, readIntoRequest) {\n 3474:   var stream = reader._ownerReadableStream;\n 3475    assert(stream !== undefined);\n 3476    stream._disturbed = true;\n 3477:   if(stream._state === 'errored') readIntoRequest._errorSteps(stream._storedError);\n 3478:   else ReadableByteStreamControllerPullInto(stream._readableStreamController, view, min, readIntoRequest);\n 3479  }\n 3480: function ReadableStreamBYOBReaderRelease(reader) {\n 3481:   ReadableStreamReaderGenericRelease(reader);\n 3482    var e = new TypeError('Reader was released');\n 3483:   ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n 3484  }\n 3485: function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e) {\n 3486:   var readIntoRequests = reader._readIntoRequests;\n 3487:   reader._readIntoRequests = new SimpleQueue();\n 3488:   readIntoRequests.forEach(function (readIntoRequest) {\n 3489:     readIntoRequest._errorSteps(e);\n 3490    });\n 3491  }\n 3492  function ReadableStreamError(stream, e) {\n 3493    assert(IsReadableStream(stream));\n 3494:   assert(stream._state === 'readable');\n 3495    stream._state = 'errored';\n 3496    stream._storedError = e;\n 3497:   var reader = stream._reader;\n 3498:   if(reader === undefined) return;\n 3499:   defaultReaderClosedPromiseReject(reader, e);\n 3500:   if(IsReadableStreamDefaultReader(reader)) ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n 3501    else {\n 3502:     assert(IsReadableStreamBYOBReader(reader));\n 3503:     ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n 3504    }\n 3505  }\n ....\n 3528    assert(IsReadableStream(stream));\n 3529    assert(typeof cloneForBranch2 === 'boolean');\n 3530:   var reader = AcquireReadableStreamDefaultReader(stream);\n 3531:   var reading = false;\n 3532:   var readAgain = false;\n 3533    var canceled1 = false;\n 3534    var canceled2 = false;\n ....\n 3542    });\n 3543    function pullAlgorithm() {\n 3544:     if(reading) {\n 3545:       readAgain = true;\n 3546        return promiseResolvedWith(undefined);\n 3547      }\n 3548:     reading = true;\n 3549:     var readRequest = {\n 3550        _chunkSteps: function(chunk) {\n 3551          _queueMicrotask(function () {\n 3552:           readAgain = false;\n 3553            var chunk1 = chunk;\n 3554            var chunk2 = chunk;\n 3555            if(!canceled1) ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);\n 3556            if(!canceled2) ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n 3557:           reading = false;\n 3558:           if(readAgain) pullAlgorithm();\n 3559          });\n 3560        },\n 3561        _closeSteps: function() {\n 3562:         reading = false;\n 3563          if(!canceled1) ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n 3564          if(!canceled2) ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n ....\n 3566        },\n 3567        _errorSteps: function() {\n 3568:         reading = false;\n 3569        },\n 3570      };\n 3571:     ReadableStreamDefaultReaderRead(reader, readRequest);\n 3572      return promiseResolvedWith(undefined);\n 3573    }\n ....\n 3595    branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n 3596    branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n 3597:   uponRejection(reader._closedPromise, function(r) {\n 3598      ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n 3599      ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n ....\n 3606    assert(IsReadableStream(stream));\n 3607    assert(IsReadableByteStreamController(stream._readableStreamController));\n 3608:   var reader = AcquireReadableStreamDefaultReader(stream);\n 3609:   var reading = false;\n 3610:   var readAgainForBranch1 = false;\n 3611:   var readAgainForBranch2 = false;\n 3612    var canceled1 = false;\n 3613    var canceled2 = false;\n ....\n 3622    function forwardReaderError(thisReader) {\n 3623      uponRejection(thisReader._closedPromise, function(r) {\n 3624:       if(thisReader !== reader) return null;\n 3625        ReadableByteStreamControllerError(branch1._readableStreamController, r);\n 3626        ReadableByteStreamControllerError(branch2._readableStreamController, r);\n ....\n 3630    }\n 3631    function pullWithDefaultReader() {\n 3632:     if(IsReadableStreamBYOBReader(reader)) {\n 3633:       assert(reader._readIntoRequests.length === 0);\n 3634:       ReadableStreamReaderGenericRelease(reader);\n 3635:       reader = AcquireReadableStreamDefaultReader(stream);\n 3636:       forwardReaderError(reader);\n 3637      }\n 3638:     var readRequest = {\n 3639        _chunkSteps: function(chunk) {\n 3640          _queueMicrotask(function () {\n 3641:           readAgainForBranch1 = false;\n 3642:           readAgainForBranch2 = false;\n 3643            var chunk1 = chunk;\n 3644            var chunk2 = chunk;\n ....\n 3654            if(!canceled1) ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n 3655            if(!canceled2) ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n 3656:           reading = false;\n 3657:           if(readAgainForBranch1) pull1Algorithm();\n 3658:           else if(readAgainForBranch2) pull2Algorithm();\n 3659          });\n 3660        },\n 3661        _closeSteps: function() {\n 3662:         reading = false;\n 3663          if(!canceled1) ReadableByteStreamControllerClose(branch1._readableStreamController);\n 3664          if(!canceled2) ReadableByteStreamControllerClose(branch2._readableStreamController);\n ....\n 3668        },\n 3669        _errorSteps: function() {\n 3670:         reading = false;\n 3671        },\n 3672      };\n 3673:     ReadableStreamDefaultReaderRead(reader, readRequest);\n 3674    }\n 3675    function pullWithBYOBReader(view, forBranch2) {\n 3676:     if(IsReadableStreamDefaultReader(reader)) {\n 3677:       assert(reader._readRequests.length === 0);\n 3678:       ReadableStreamReaderGenericRelease(reader);\n 3679:       reader = AcquireReadableStreamBYOBReader(stream);\n 3680:       forwardReaderError(reader);\n 3681      }\n 3682      var byobBranch = forBranch2 ? branch2 : branch1;\n 3683      var otherBranch = forBranch2 ? branch1 : branch2;\n 3684:     var readIntoRequest = {\n 3685        _chunkSteps: function(chunk) {\n 3686          _queueMicrotask(function () {\n 3687:           readAgainForBranch1 = false;\n 3688:           readAgainForBranch2 = false;\n 3689            var byobCanceled = forBranch2 ? canceled2 : canceled1;\n 3690            var otherCanceled = forBranch2 ? canceled1 : canceled2;\n ....\n 3702              ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n 3703            } else if(!byobCanceled) ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n 3704:           reading = false;\n 3705:           if(readAgainForBranch1) pull1Algorithm();\n 3706:           else if(readAgainForBranch2) pull2Algorithm();\n 3707          });\n 3708        },\n 3709        _closeSteps: function(chunk) {\n 3710:         reading = false;\n 3711          var byobCanceled = forBranch2 ? canceled2 : canceled1;\n 3712          var otherCanceled = forBranch2 ? canceled1 : canceled2;\n ....\n 3721        },\n 3722        _errorSteps: function() {\n 3723:         reading = false;\n 3724        },\n 3725      };\n 3726:     ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);\n 3727    }\n 3728    function pull1Algorithm() {\n 3729:     if(reading) {\n 3730:       readAgainForBranch1 = true;\n 3731        return promiseResolvedWith(undefined);\n 3732      }\n 3733:     reading = true;\n 3734      var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n 3735      if(byobRequest === null) pullWithDefaultReader();\n ....\n 3738    }\n 3739    function pull2Algorithm() {\n 3740:     if(reading) {\n 3741:       readAgainForBranch2 = true;\n 3742        return promiseResolvedWith(undefined);\n 3743      }\n 3744:     reading = true;\n 3745      var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n 3746      if(byobRequest === null) pullWithDefaultReader();\n ....\n 3773    branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n 3774    branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n 3775:   forwardReaderError(reader);\n 3776    return [branch1, branch2];\n 3777  }\n ....\n 3816    return stream;\n 3817  }\n 3818: function ReadableStreamFromDefaultReader(reader) {\n 3819    var stream;\n 3820    var startAlgorithm = noop;\n 3821    function pullAlgorithm() {\n 3822:     var readPromise;\n 3823      try {\n 3824:       readPromise = reader.read();\n 3825      } catch(e) {\n 3826        return promiseRejectedWith(e);\n 3827      }\n 3828:     return transformPromiseWith(readPromise, function(readResult) {\n 3829:       if(!typeIsObject(readResult)) throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\n 3830:       if(readResult.done) ReadableStreamDefaultControllerClose(stream._readableStreamController);\n 3831        else {\n 3832:         var value = readResult.value;\n 3833          ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\n 3834        }\n ....\n 3837    function cancelAlgorithm(reason) {\n 3838      try {\n 3839:       return promiseResolvedWith(reader.cancel(reason));\n 3840      } catch(e) {\n 3841        return promiseRejectedWith(e);\n ....\n 3976    var cancel = original === null || original === void 0 ? void 0 : original.cancel;\n 3977    var flush = original === null || original === void 0 ? void 0 : original.flush;\n 3978:   var readableType = original === null || original === void 0 ? void 0 : original.readableType;\n 3979    var start = original === null || original === void 0 ? void 0 : original.start;\n 3980    var transform = original === null || original === void 0 ? void 0 : original.transform;\n ....\n 3983      cancel: cancel === undefined ? undefined : convertTransformerCancelCallback(cancel, original, ''.concat(context, \" has member 'cancel' that\")),\n 3984      flush: flush === undefined ? undefined : convertTransformerFlushCallback(flush, original, ''.concat(context, \" has member 'flush' that\")),\n 3985:     readableType: readableType,\n 3986      start: start === undefined ? undefined : convertTransformerStartCallback(start, original, ''.concat(context, \" has member 'start' that\")),\n 3987      transform: transform === undefined ? undefined : convertTransformerTransformCallback(transform, original, ''.concat(context, \" has member 'transform' that\")),\n ....\n 4022      if(rawTransformer === undefined) rawTransformer = null;\n 4023      var writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n 4024:     var readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n 4025      var transformer = convertTransformer(rawTransformer, 'First parameter');\n 4026:     if(transformer.readableType !== undefined) throw new RangeError('Invalid readableType specified');\n 4027      if(transformer.writableType !== undefined) throw new RangeError('Invalid writableType specified');\n 4028:     var readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n 4029:     var readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n 4030      var writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n 4031      var writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n ....\n 4034        startPromise_resolve = resolve;\n 4035      });\n 4036:     InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n 4037      SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n 4038      if(transformer.start !== undefined) startPromise_resolve(transformer.start(this._transformStreamController));\n ....\n 4041    _create_class(TransformStream, [\n 4042      {\n 4043:       key: 'readable',\n 4044        get: function get() {\n 4045:         if(!IsTransformStream(this)) throw streamBrandCheckException2('readable');\n 4046          return this._readable;\n 4047        },\n ....\n 4058  })();\n 4059  Object.defineProperties(TransformStream.prototype, {\n 4060:   readable: {\n 4061      enumerable: true,\n 4062    },\n ....\n 4070      configurable: true,\n 4071    });\n 4072: function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n 4073    function startAlgorithm() {\n 4074      return startPromise;\n 4075    }\n 4076:   function writeAlgorithm(chunk) {\n 4077      return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n 4078    }\n ....\n 4083      return TransformStreamDefaultSinkCloseAlgorithm(stream);\n 4084    }\n 4085:   stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n 4086    function pullAlgorithm() {\n 4087      return TransformStreamDefaultSourcePullAlgorithm(stream);\n ....\n 4090      return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);\n 4091    }\n 4092:   stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n 4093    stream._backpressure = undefined;\n 4094    stream._backpressureChangePromise = undefined;\n ....\n 4133        get: function get() {\n 4134          if(!IsTransformStreamDefaultController(this)) throw defaultControllerBrandCheckException2('desiredSize');\n 4135:         var readableController = this._controlledTransformStream._readable._readableStreamController;\n 4136:         return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n 4137        },\n 4138      },\n ....\n 4245  function TransformStreamDefaultControllerEnqueue(controller, chunk) {\n 4246    var stream = controller._controlledTransformStream;\n 4247:   var readableController = stream._readable._readableStreamController;\n 4248:   if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) throw new TypeError('Readable side is not in a state that permits enqueue');\n 4249    try {\n 4250:     ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n 4251    } catch(e) {\n 4252      TransformStreamErrorWritableAndUnblockWrite(stream, e);\n 4253      throw stream._readable._storedError;\n 4254    }\n 4255:   var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n 4256    if(backpressure !== stream._backpressure) {\n 4257      assert(backpressure);\n ....\n 4271  function TransformStreamDefaultControllerTerminate(controller) {\n 4272    var stream = controller._controlledTransformStream;\n 4273:   var readableController = stream._readable._readableStreamController;\n 4274:   ReadableStreamDefaultControllerClose(readableController);\n 4275    var error = new TypeError('TransformStream terminated');\n 4276    TransformStreamErrorWritableAndUnblockWrite(stream, error);\n ....\n 4295    var controller = stream._transformStreamController;\n 4296    if(controller._finishPromise !== undefined) return controller._finishPromise;\n 4297:   var readable = stream._readable;\n 4298    controller._finishPromise = newPromise(function (resolve, reject) {\n 4299      controller._finishPromise_resolve = resolve;\n ....\n 4305      cancelPromise,\n 4306      function() {\n 4307:       if(readable._state === 'errored') defaultControllerFinishPromiseReject(controller, readable._storedError);\n 4308        else {\n 4309:         ReadableStreamDefaultControllerError(readable._readableStreamController, reason);\n 4310          defaultControllerFinishPromiseResolve(controller);\n 4311        }\n ....\n 4313      },\n 4314      function(r) {\n 4315:       ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n 4316        defaultControllerFinishPromiseReject(controller, r);\n 4317        return null;\n ....\n 4323    var controller = stream._transformStreamController;\n 4324    if(controller._finishPromise !== undefined) return controller._finishPromise;\n 4325:   var readable = stream._readable;\n 4326    controller._finishPromise = newPromise(function (resolve, reject) {\n 4327      controller._finishPromise_resolve = resolve;\n ....\n 4333      flushPromise,\n 4334      function() {\n 4335:       if(readable._state === 'errored') defaultControllerFinishPromiseReject(controller, readable._storedError);\n 4336        else {\n 4337:         ReadableStreamDefaultControllerClose(readable._readableStreamController);\n 4338          defaultControllerFinishPromiseResolve(controller);\n 4339        }\n ....\n 4341      },\n 4342      function(r) {\n 4343:       ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n 4344        defaultControllerFinishPromiseReject(controller, r);\n 4345        return null;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets.h:\n  478  #endif\n  479  \n  480: ssize_t recv(int sockfd, void *buf, size_t len, int flags);\n  481: ssize_t send(int sockfd, const void *buf, size_t len, int flags);\n  482: ssize_t read(int fd, void *buf, size_t count);\n  483  int getsockopt(int sockfd, int level, int optname,\n  484                        void *optval, socklen_t *optlen);\n  ...\n  733  #if defined(LWS_WITH_NETWORK)\n  734  #include <libwebsockets/lws-service.h>\n  735: #include <libwebsockets/lws-write.h>\n  736: #include <libwebsockets/lws-writeable.h>\n  737  #endif\n  738  #include <libwebsockets/lws-ring.h>\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-jrpc.h:\n   45   *\n   46   *  - No support for batch.  Batching is not widely used because it doesn't\n   47:  *    add anything for the vast bulk of cases compared to sending n requests.\n   48   *\n   49   * This handles client and server RX and transaction state, creating a callback\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-system.h:\n  180  \t *\n  181  \t * If \\p get is non-NULL, look for the first listed item on the pt whose\n  182: \t * state situation is ready, and set *get to point to it.  If no items,\n  183  \t * or none where the system state is right, set *get to NULL.\n  184  \t *\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-secure-streams.h:\n  219  \t/**< callback with rx payload for this stream */\n  220  \tlws_sscb_tx tx;\n  221: \t/**< callback to send payload on this stream... 0 = send as set in\n  222: \t * len and flags, 1 = do not send anything (ie, not even 0 len frame) */\n  223  \tlws_sscb_state state;\n  224  \t/**< advisory cb about state of stream and QoS status if applicable...\n  ...\n  330   * \\param pss: pointer to lws_ss_t representing stream that wants to transmit\n  331   *\n  332:  * Schedules a write on the stream represented by \\p pss.  When it's possible to\n  333:  * write on this stream, the \\p *tx callback will occur with an empty buffer for\n  334   * the stream owner to fill in.\n  335   *\n  ...\n  343   *\n  344   * \\param pss: pointer to lws_ss_t representing stream that wants to transmit\n  345:  * \\param len: the length of the write in bytes\n  346   *\n  347:  * Schedules a write on the stream represented by \\p pss.  When it's possible to\n  348:  * write on this stream, the \\p *tx callback will occur with an empty buffer for\n  349   * the stream owner to fill in.\n  350   *\n  ...\n  565   * For SERVER secure streams\n  566   *\n  567:  * Depending on the protocol, the server sending us something may be\n  568:  * transactional, ie, built into it sending something is the idea we will\n  569   * respond somehow out-of-band; HTTP is like this with, eg, 200 response code.\n  570   *\n  ...\n  645   * Based on what credit we gave it, and what we have received, report our\n  646   * estimate of peer's tx credit usable to transmit to us.  This may be outdated\n  647:  * in that some or all of its credit may already have been expended by sending\n  648   * stuff to us that is in flight already.\n  649   */\n  ...\n  687  \n  688  /**\n  689:  * lws_aws_filesystem_credentials_helper() - read aws credentials from file\n  690   *\n  691:  * \\param path: path to read, ~ at start is converted to $HOME contents if any\n  692   * \\param kid: eg, \"aws_access_key_id\"\n  693   * \\param ak: eg, \"aws_secret_access_key\"\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-secure-streams-serialization.h:\n   59  \t *   -  1: 2 byte MSB-first rest-of-frame length\n   60  \t *   -  3: 4-byte MSB-first flags\n   61: \t *   -  7: 4-byte MSB-first us between inbound read and wrote to client\n   62  \t *   - 11: 8-byte MSB-first us resolution unix time proxy wrote to client\n   63  \t *   - 17: (rideshare name len + rideshare name if flags &\n   ..\n  152  \t *   -  1: 2 byte MSB-first rest-of-frame length\n  153  \t *   -  3: 4-byte MSB-first flags\n  154: \t *   -  7: 4-byte MSB-first us between client requested write and wrote\n  155  \t *   \t\t\t    to proxy\n  156  \t *   - 11: 8-byte MSB-first us resolution unix time client wrote to proxy\n  ...\n  201  \n  202   typedef enum {\n  203:  \tLPCSPROX_WAIT_INITIAL_TX = 1, /* after connect, must send streamtype */\n  204   \tLPCSPROX_REPORTING_FAIL, /* stream creation failed, wait to to tell */\n  205   \tLPCSPROX_REPORTING_OK, /* stream creation succeeded, wait to to tell */\n  206:  \tLPCSPROX_OPERATIONAL, /* ready for payloads */\n  207   \tLPCSPROX_DESTROYED,\n  208  \n  209:  \tLPCSCLI_SENDING_INITIAL_TX,  /* after connect, must send streamtype */\n  210   \tLPCSCLI_WAITING_CREATE_RESULT,   /* wait to hear if proxy ss create OK */\n  211   \tLPCSCLI_LOCAL_CONNECTED,\t      /* we are in touch with the proxy */\n  212   \tLPCSCLI_ONWARD_CONNECT,\t      /* request onward ss connection */\n  213:  \tLPCSCLI_OPERATIONAL, /* ready for payloads */\n  214  \n  215   } lws_ss_conn_states_t;\n  ...\n  221    *\n  222    *  - open and close channels asynchronously\n  223:   *  - send and receive transport-level (not mux channel) timed PINGs / PONGs\n  224:   *  - send and receive data bound to an open mux channel\n  225    *\n  226    *  PONGs are produced and sent automatically on recipt of a PING from the peer\n  227:   *  The peer sends a PONGACK so the single transaction can validate connection\n  228    *  viability in both directions.\n  229    */\n  ...\n  293  \t LWSSSS_LLM_PONGACK,\n  294  \t /**<\n  295: \t  * When the original PING sender receives a PONG, it immediately sends\n  296  \t  * a PINGACK, which is not replied to.  This allows the other side to\n  297  \t  * also know the connection is valid in both directions, with only one\n  ...\n  363   \t/**< Connection attempt result, disposition 9 = success, else failed */\n  364   \tvoid (*req_write)(lws_transport_priv_t priv);\n  365:  \t/**< Request a write to the proxy on this channel */\n  366   \tint (*_write)(lws_transport_priv_t priv, uint8_t *buf, size_t len);\n  367   \t/**< Write the requested data on the channel to the proxy *** MUST have\n  ...\n  380  \tlws_ss_state_return_t (*event_can_write)(struct lws_sspc_handle *h,\n  381  \t\t\t\t\t\t size_t metadata_limit);\n  382: \t/**< Called when possible to write on the transport, after req_write */\n  383  \tlws_ss_state_return_t (*event_closed)(lws_transport_priv_t priv /*struct lws_sspc_handle *h */);\n  384  \t/**< we notice an onward proxy connection had closed */\n  ...\n  415  \t/**< Called when the proxy creates an onward SS for a client channel */\n  416   \tvoid (*proxy_req_write)(lws_transport_priv_t priv);\n  417:  \t/**< Request a write to the proxy on this channel */\n  418  \tlws_ss_state_return_t (*event_proxy_can_write)(\n  419  \t\t\tlws_transport_priv_t priv\n  ...\n  425   \tint (*proxy_write)(lws_transport_priv_t priv, uint8_t *buf, size_t *len);\n  426   \t/**< Write the requested data on the channel to the proxy *** MUST have\n  427:  \t * LWS_PRE usable behind buf.  May do partial writes, len is set on return\n  428   \t * to actual length written*/\n  429  \tlws_ss_state_return_t (*event_close_conn)(\n  ...\n  441  \t/**< Called when the proxy has accepted a new client conn */\n  442  \tint (*proxy_check_write_more)(lws_transport_priv_t priv);\n  443: \t/**< optional, allows checking if we can write again */\n  444  \tuint32_t\t\t\tflags; /* dsh flags */\n  445  } lws_transport_proxy_ops_t;\n  ...\n  467  enum {\n  468  \t/* lws_transport_mux_ch_t created */\n  469: \tLWSTMC_PENDING_CREATE_CHANNEL,\t    /* waiting to send create channel */\n  470  \tLWSTMC_AWAITING_CREATE_CHANNEL_ACK, /* sent create ch, awaiting ack */\n  471: \tLWSTMC_PENDING_CREATE_CHANNEL_NACK, /* waiting to send create ch ack */\n  472: \tLWSTMC_PENDING_CREATE_CHANNEL_ACK,  /* waiting to send create ch ack */\n  473  \tLWSTMC_OPERATIONAL,\t\t    /* had ack, we are operational */\n  474: \tLWSTMC_PENDING_CLOSE_CHANNEL,\t    /* waiting to send close channel */\n  475  \tLWSTMC_AWAITING_CLOSE_CHANNEL_ACK,  /* sent close ch, awaiting ack */\n  476: \tLWSTMC_PENDING_CLOSE_CHANNEL_ACK,   /* waiting to send close ch ack */\n  477  \t/* lws_transport_mux_ch_t destroyed */\n  478  };\n  ...\n  504  typedef struct lws_transport_info {\n  505  \tuint32_t\t\t\t\tping_interval_us;\n  506: \t/**< us inbetween transport mux sending pings on transport */\n  507  \tuint32_t\t\t\t\tpong_grace_us;\n  508  \t/**< us we should wait for pong before assuming transport down */\n  ...\n  584  \t\t\t   size_t len, const lws_txp_mux_parse_cbs_t *cbs);\n  585  \n  586: int /* nonzero if the transport mux has filled buf and wants to write it */\n  587  lws_transport_mux_pending(lws_transport_mux_t *tm, uint8_t *buf, size_t *len,\n  588  \t\t\t  const lws_txp_mux_parse_cbs_t *cbs);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-conmon.h:\n  111  \tlws_conmon_interval_us_t\t\tciu_txn_resp;\n  112  \t/**< 0, or if the protocol supports transactions, the interval between\n  113: \t * sending the initial transaction request and starting to receive the\n  114  \t * response */\n  115  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-ws-ext.h:\n  102   *\tLWS_EXT_CB_CONSTRUCT:  called when the server has decided to\n  103   *\t\tselect this extension from the list provided by the client,\n  104:  *\t\tjust before the server will send back the handshake accepting\n  105   *\t\tthe connection with this extension active.  This gives the\n  106   *\t\textension a chance to initialize its connection context found\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-jose.h:\n   34  \tLJJHI_TYP,\t/* Optional: string: media type */\n   35  \tLJJHI_CTY,\t/* Optional: string: content media type */\n   36: \tLJJHI_CRIT,\t/* Optional for send, REQUIRED: array of strings:\n   37  \t\t\t * mustn't contain standardized strings or null set */\n   38  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-jwk.h:\n  125   * \\param jwk: the JWK object to export\n  126   * \\param flags: control export options\n  127:  * \\param p: the buffer to write the exported JWK to\n  128   * \\param len: the length of the buffer \\p p in bytes... reduced by used amount\n  129   *\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-context-vhost.h:\n  181  #define LWS_SERVER_OPTION_HTTP_HEADERS_SECURITY_BEST_PRACTICES_ENFORCE (1ll << 28)\n  182  \t/**< (VH) Send lws default HTTP headers recommended by Mozilla\n  183: \t * Observatory for security.  This is a helper option that sends canned\n  184  \t * headers on each http response enabling a VERY strict Content Security\n  185  \t * Policy.  The policy is so strict, for example it won't let the page\n  ...\n  192  \t * the complete strictness, in which case don't use this flag: use the\n  193  \t * .headers member in the vhost init described in struct\n  194: \t * lws_context_creation_info instead to send the adapted headers\n  195  \t * yourself.\n  196  \t */\n  ...\n  668  \t * various service related features including file serving, it\n  669  \t * defines the max chunk of file that can be sent at once.\n  670: \t * At the risk of lws having to buffer failed large sends, it\n  671  \t * can be increased to, eg, 128KiB to improve throughput. */\n  672  #if defined(LWS_WITH_FILE_OPS)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-cgi.h:\n  102  \n  103  /**\n  104:  * lws_cgi_write_split_stdout_headers: write cgi output accounting for header part\n  105   *\n  106   * \\param wsi: connection to own the process\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-lecp.h:\n  230  \tuint32_t\t\tordinal;\n  231  \tuint8_t\t\t\topcode;\n  232: \tuint8_t\t\t\tsend_new_array_item;\n  233  \tuint8_t\t\t\tbarrier;\n  234  };\n  ...\n  365   *\n  366   * Prepares a cbor writing context so that les_lec_printf can be used to\n  367:  * write into it.\n  368   */\n  369  LWS_VISIBLE LWS_EXTERN void\n  ...\n  378   *\n  379   * Leaves the cbor writing context state as it is, but resets the output buffer\n  380:  * it writes into as given in \\p buf and \\p len\n  381   */\n  382  LWS_VISIBLE LWS_EXTERN void\n  ...\n  384  \n  385  /*\n  386:  * lws_lec_vsprintf() - write into a cbor writing context\n  387   *\n  388   * \\param ctx: the cbor writing context to prepare\n  ...\n  436  \n  437  /*\n  438:  * lws_lec_printf() - write into a cbor writing context\n  439   *\n  440   * \\param ctx: the cbor writing context to prepare\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-settings.h:\n   56  \n   57  /**\n   58:  * lws_settings_plat_get() - read a named blob from a settings instance\n   59   *\n   60   * \\param si: the settings instance\n   ..\n   63   * \\param max_actual: point to size of dest, or zero; actual blob size on exit\n   64   *\n   65:  * If the named blob doesn't exist in the si, or can't read, returns nonzero.\n   66   * Otherwise, returns 0 and sets *max_actual to the true blob size.  If dest is\n   67   * non-NULL, as much of the blob as will fit in the amount specified by\n   ..\n   73  \n   74  /**\n   75:  * lws_settings_plat_get() - read a named blob from a settings instance\n   76   *\n   77   * \\param si: the settings instance\n   ..\n   88  \n   89  /**\n   90:  * lws_settings_plat_printf() - read a named blob from a settings instance\n   91   *\n   92   * \\param si: the settings instance\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-cache-ttl.h:\n   59   * \\param specific_key: a key string that identifies the item in the cache\n   60   * \\param source: optional payload for the cached item, NULL means caller will\n   61:  *\t\t  write the payload\n   62   * \\param size: the size of the object to allocate\n   63   * \\param expiry: the usec time that the object will autodestroy\n   ..\n  267  \n  268  \tint\n  269: \t(*write)(struct lws_cache_ttl_lru *cache, const char *specific_key,\n  270  \t\t const uint8_t *source, size_t size, lws_usec_t expiry,\n  271  \t\t void **ppvoid);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-fts.h:\n   86   * lws_fts_create() - Create a new index file\n   87   *\n   88:  * \\param fd: The fd opened for write\n   89   *\n   90   * Inits a new index file, returning a struct lws_fts to represent it\n   ..\n  139   * The trie is held in memory where it can be added to... after all the input\n  140   * filepaths and data have been processed, this is called to serialize /\n  141:  * write the trie data into the index file.\n  142   */\n  143  LWS_VISIBLE LWS_EXTERN int\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-i2c.h:\n   36  \tint  (*start)(const struct lws_i2c_ops *ctx);\n   37  \tvoid (*stop)(const struct lws_i2c_ops *ctx);\n   38: \tint  (*write)(const struct lws_i2c_ops *ctx, uint8_t data);\n   39: \tint  (*read)(const struct lws_i2c_ops *ctx);\n   40  \tvoid (*set_ack)(const struct lws_i2c_ops *octx, int ack);\n   41  } lws_i2c_ops_t;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-secure-streams-client.h:\n  219   * \\param pss: pointer to lws_ss_t representing stream that wants to transmit\n  220   *\n  221:  * Schedules a write on the stream represented by \\p pss.  When it's possible to\n  222:  * write on this stream, the *tx callback will occur with an empty buffer for\n  223   * the stream owner to fill in.\n  224   */\n  ...\n  230   *\n  231   * \\param h: pointer to handle representing stream that wants to transmit\n  232:  * \\param len: the length of the write in bytes\n  233   *\n  234:  * Schedules a write on the stream represented by \\p pss.  When it's possible to\n  235:  * write on this stream, the *tx callback will occur with an empty buffer for\n  236   * the stream owner to fill in.\n  237   *\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-ota.h:\n   43  typedef enum {\n   44  \tLWSOTARET_OK,\n   45: \tLWSOTARET_ONGOING, /* result not ready to read yet */\n   46  \tLWSOTARET_REJECTED,\n   47  \tLWSOTARET_NOSLOT,\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-gpio.h:\n   52  typedef struct lws_gpio_ops {\n   53  \tvoid (*mode)(_lws_plat_gpio_t gpio, int flags);\n   54: \tint (*read)(_lws_plat_gpio_t gpio);\n   55  \tvoid (*set)(_lws_plat_gpio_t gpio, int val);\n   56  \tint (*irq_mode)(_lws_plat_gpio_t gpio, lws_gpio_irq_t irq,\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-cose.h:\n  491   * output context, and the inline payload length.\n  492   *\n  493:  * Returns NULL on failure or the created signing context ready to add alg(s)\n  494   * to.\n  495   */\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-tokenize.h:\n  241   * \\p olen: the length of the output buffer in bytes\n  242   *\n  243:  * Provides a new output buffer for lws_strexp_expand() to continue to write\n  244   * into.  It can be the same as the old one if it has been copied out or used.\n  245:  * The position of the next write will be reset to the start of the given buf.\n  246   *\n  247   * If \\p out is NULL, substitution proceeds normally, but no output is produced,\n  ...\n  259   * \\p in: the start of the next input data\n  260   * \\p len: the length of the input data\n  261:  * \\p pused_in: pointer to write the amount of input used\n  262:  * \\p pused_out: pointer to write the amount of output used\n  263   *\n  264   * Copies in to the output buffer set in exp, expanding any ${name} tokens using\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-ring.h:\n   59   *  - lws_ring_bump_head()\n   60   *\n   61:  *  which let you, eg, read() directly into the ringbuffer without needing\n   62   *  an intermediate bounce buffer.\n   63   *\n   ..\n  179   *\n  180   * Points to the next element that tail would consume, directly in the\n  181:  * ringbuffer.  This lets you write() or otherwise use the element without\n  182   * having to copy it out somewhere first.\n  183   *\n  ...\n  216  \n  217  /**\n  218:  * lws_ring_next_linear_insert_range():  used to write directly into the ring\n  219   *\n  220   * \\param ring: the struct lws_ring to report on\n  ...\n  227   * The api reports the position and length of the next linear range that can\n  228   * be written in the ringbuffer, ie, up to the point it would wrap, and sets\n  229:  * *start and *bytes accordingly.  You can then, eg, directly read() into\n  230   * *start for up to *bytes, and use lws_ring_bump_head() to update the lws_ring\n  231   * with what you have done.\n  ...\n  238  \n  239  /**\n  240:  * lws_ring_bump_head():  used to write directly into the ring\n  241   *\n  242   * \\param ring: the struct lws_ring to operate on\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-retry.h:\n   86   * lws_retry_sul_schedule.\n   87   *\n   88:  * Since a udp connection can have many writes in flight, the retry count and\n   89   * the sul used to track each thing that wants to be written have to be handled\n   90   * individually, not the wsi.  But the retry policy and the other things can\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-secure-streams-policy.h:\n   81  enum {\n   82  \tLWSSSPOLF_OPPORTUNISTIC\t\t\t\t\t= (1 << 0),\n   83: \t/**< the connection doesn't exist unless client asks to write */\n   84  \tLWSSSPOLF_NAILED_UP\t\t\t\t\t= (1 << 1),\n   85  \t/**< the connection tries to be connected the whole life of the ss */\n   ..\n  138  \t/**< Record http cookies and pass them back on future requests */\n  139  \tLWSSSPOLF_PRIORITIZE_READS\t\t\t\t= (1 << 25),\n  140: \t/**< prioritize clearing reads at expense of writes */\n  141  \n  142  };\n  ...\n  285  \n  286  \t\tstruct {\n  287: \t\t\tconst char\t*topic;\t    /* stream sends on this topic */\n  288  \t\t\tconst char\t*subscribe; /* stream subscribes to this topic */\n  289  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-logs.h:\n  740  \n  741  /**\n  742:  * lwsl_emit_syslog() - helper log emit function writes to system log\n  743   *\n  744   * \\param level: one of LLL_ log level indexes\n  ...\n  752  \n  753  /**\n  754:  * lwsl_emit_stderr() - helper log emit function writes to stderr\n  755   *\n  756   * \\param level: one of LLL_ log level indexes\n  ...\n  768  \n  769  /**\n  770:  * lwsl_emit_stderr_notimestamp() - helper log emit function writes to stderr\n  771   *\n  772   * \\param level: one of LLL_ log level indexes\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-callbacks.h:\n  219  \t * asking to upgrade the connection to a websocket\n  220  \t * one.  This is a chance to serve http content,\n  221: \t * for example, to send a script to the client\n  222  \t * which will then open the websockets connection.\n  223  \t * in points to the URI path requested and\n  224  \t * lws_serve_http_file() makes it very\n  225: \t * simple to send back a file to the client.\n  226: \t * Normally after sending the file you are done\n  227  \t * with the http connection, since the rest of the\n  228  \t * activity will come by websockets from the script\n  ...\n  241  \n  242  \tLWS_CALLBACK_HTTP_WRITEABLE\t\t\t\t= 16,\n  243: \t/**< you can write more down the http protocol link now. */\n  244  \n  245  \tLWS_CALLBACK_CLOSED_HTTP\t\t\t\t=  5,\n  ...\n  255  \t * lws_hdr_total_length() / lws_hdr_copy() to access all of the\n  256  \t * headers using the header enums lws_token_indexes from\n  257: \t * libwebsockets.h to check for and read the supported header\n  258  \t * presence and content before deciding to allow the http\n  259  \t * connection to proceed or to kill the connection. */\n  ...\n  366  \t * Failure to deal with it as in the minimal examples may cause spinning\n  367  \t * around the event loop as it's continuously signalled the same data\n  368: \t * is available for read.  The related minimal examples show how to\n  369  \t * handle it.\n  370  \t *\n  ...\n  387  \t * lws_client_http_body_pending(wsi, 1) from\n  388  \t * LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER to get these callbacks\n  389: \t * sending the HTTP headers.\n  390  \t *\n  391  \t * From this callback, when you have sent everything, you should let\n  ...\n  429  \t * len are the optional close code (first 2 bytes, network\n  430  \t * order) and the optional additional information which is not\n  431: \t * defined in the standard, and may be a string or non human-readable\n  432  \t * data.\n  433  \t * If you return 0 lws will echo the close and then close the\n  ...\n  444  \t * lws_hdr_total_length() / lws_hdr_copy() to access all of the\n  445  \t * headers using the header enums lws_token_indexes from\n  446: \t * libwebsockets.h to check for and read the supported header\n  447  \t * presence and content before deciding to allow the handshake\n  448  \t * to proceed or to kill the connection. */\n  ...\n  481  \t *     \t\"lws_ssl_client_connect2 failed\"\n  482  \t *     \t\"Peer hung up\"\n  483: \t *     \t\"read failed\"\n  484  \t *     \t\"HS: URI missing\"\n  485  \t *     \t\"HS: Redirect code but no Location\"\n  ...\n  555  \t/**<  If you call lws_callback_on_writable() on a connection, you will\n  556  \t * get one of these callbacks coming when the connection socket\n  557: \t * is able to accept another write packet without blocking.\n  558  \t * If it already was able to take another packet without blocking,\n  559  \t * you'll get this callback at the next call to the service loop\n  ...\n  595  \t * wsi still pointing to the main server socket.\n  596  \t *\n  597: \t * Return non-zero to terminate the connection before sending or\n  598  \t * receiving anything. Because this happens immediately after the\n  599  \t * network connection from the client, there's no websocket protocol\n  ...\n  780  \n  781  \tLWS_CALLBACK_RAW_RX_FILE\t\t\t\t= 64,\n  782: \t/**< This is the indication the RAW mode file has something to read.\n  783: \t *   This doesn't actually do the read of the file and len is always\n  784: \t *   0... your code should do the read having been informed there is\n  785: \t *   something to read now. */\n  786  \n  787  \tLWS_CALLBACK_RAW_WRITEABLE_FILE\t\t\t\t= 65,\n  788: \t/**< RAW mode file is writeable */\n  789  \n  790  \tLWS_CALLBACK_RAW_CLOSE_FILE\t\t\t\t= 66,\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-ws-state.h:\n   33   * \\param wsi: lws connection\n   34   *\n   35:  * Allows you to check if you can write more on the socket\n   36   */\n   37  LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT\n   ..\n   69  \n   70  /**\n   71:  * lws_partial_buffered() - find out if lws buffered the last write\n   72   * \\param wsi:\twebsocket connection to check\n   73   *\n   74   * Returns 1 if you cannot use lws_write because the last\n   75:  * write on this connection is still buffered, and can't be cleared without\n   76   * returning to the service loop and waiting for the connection to be\n   77:  * writeable again.\n   78   *\n   79   * If you will try to do >1 lws_write call inside a single\n   80:  * WRITEABLE callback, you must check this after every write and bail if\n   81:  * set, ask for a new writeable callback and continue writing from there.\n   82   *\n   83:  * This is never set at the start of a writeable callback, but any write\n   84   * may set it.\n   85   */\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-adopt.h:\n   43   * returns NULL, having cleaned up any new wsi pieces.\n   44   *\n   45:  * LWS adopts the socket in http serving mode, it's ready to accept an upgrade\n   46   * to ws or just serve http.\n   47   */\n   ..\n   59   * returns NULL, having cleaned up any new wsi pieces.\n   60   *\n   61:  * LWS adopts the socket in http serving mode, it's ready to accept an upgrade\n   62   * to ws or just serve http.\n   63   */\n   ..\n  137  *\n  138  * If LWS_ADOPT_SOCKET is set, LWS adopts the socket in http serving mode, it's\n  139: * ready to accept an upgrade to ws or just serve http.\n  140  *\n  141  * parent may be NULL, if given it should be an existing wsi that will become the\n  ...\n  181  *\n  182  * If LWS_ADOPT_SOCKET is set, LWS adopts the socket in http serving mode, it's\n  183: * ready to accept an upgrade to ws or just serve http.\n  184  *\n  185  * parent may be NULL, if given it should be an existing wsi that will become the\n  ...\n  194   * \\param context:\tlws context\n  195   * \\param accept_fd:\tfd of already-accepted socket to adopt\n  196:  * \\param readbuf:\tNULL or pointer to data that must be drained before reading from\n  197   *\t\taccept_fd\n  198:  * \\param len:\tThe length of the data held at \\p readbuf\n  199   *\n  200   * Either returns new wsi bound to accept_fd, or closes accept_fd and\n  201   * returns NULL, having cleaned up any new wsi pieces.\n  202   *\n  203:  * LWS adopts the socket in http serving mode, it's ready to accept an upgrade\n  204   * to ws or just serve http.\n  205   *\n  206:  * If your external code did not already read from the socket, you can use\n  207   * lws_adopt_socket() instead.\n  208   *\n  209:  * This api is guaranteed to use the data at \\p readbuf first, before reading from\n  210   * the socket.\n  211   *\n  212:  * \\p readbuf is limited to the size of the ah rx buf, currently 2048 bytes.\n  213   */\n  214  LWS_VISIBLE LWS_EXTERN struct lws *\n  215  lws_adopt_socket_readbuf(struct lws_context *context, lws_sockfd_type accept_fd,\n  216:                          const char *readbuf, size_t len);\n  217  /**\n  218   * lws_adopt_socket_vhost_readbuf() - adopt foreign socket and first rx as if listen socket\n  ...\n  220   * \\param vhost:\tlws vhost\n  221   * \\param accept_fd:\tfd of already-accepted socket to adopt\n  222:  * \\param readbuf:\tNULL or pointer to data that must be drained before reading from accept_fd\n  223:  * \\param len:\t\tThe length of the data held at \\p readbuf\n  224   *\n  225   * Either returns new wsi bound to accept_fd, or closes accept_fd and\n  226   * returns NULL, having cleaned up any new wsi pieces.\n  227   *\n  228:  * LWS adopts the socket in http serving mode, it's ready to accept an upgrade\n  229   * to ws or just serve http.\n  230   *\n  231:  * If your external code did not already read from the socket, you can use\n  232   * lws_adopt_socket() instead.\n  233   *\n  234:  * This api is guaranteed to use the data at \\p readbuf first, before reading from\n  235   * the socket.\n  236   *\n  237:  * \\p readbuf is limited to the size of the ah rx buf, currently 2048 bytes.\n  238   */\n  239  LWS_VISIBLE LWS_EXTERN struct lws *\n  240  lws_adopt_socket_vhost_readbuf(struct lws_vhost *vhost,\n  241: \t\t\t       lws_sockfd_type accept_fd, const char *readbuf,\n  242  \t\t\t       size_t len);\n  243  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-bb-i2c.h:\n   43  \t\t.start = lws_bb_i2c_start, \\\n   44  \t\t.stop = lws_bb_i2c_stop, \\\n   45: \t\t.write = lws_bb_i2c_write, \\\n   46: \t\t.read = lws_bb_i2c_read, \\\n   47  \t\t.set_ack = lws_bb_i2c_set_ack, \\\n   48  \t}\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-vfs.h:\n   57  #define LWS_FOP_CLOSE\t\tclose\n   58  #define LWS_FOP_SEEK_CUR\tseek_cur\n   59: #define LWS_FOP_READ\t\tread\n   60: #define LWS_FOP_WRITE\t\twrite\n   61  #endif\n   62  \n   ..\n  118  \tint (*LWS_FOP_READ)(lws_fop_fd_t fop_fd, lws_filepos_t *amount,\n  119  \t\t\t    uint8_t *buf, lws_filepos_t len);\n  120: \t/**< Read from file, on exit *amount is set to amount actually read */\n  121  \tint (*LWS_FOP_WRITE)(lws_fop_fd_t fop_fd, lws_filepos_t *amount,\n  122  \t\t\t     uint8_t *buf, lws_filepos_t len);\n  ...\n  232  }\n  233  /**\n  234:  * lws_plat_file_read() - read from file\n  235   *\n  236   * \\param fop_fd: file handle\n  237:  * \\param amount: how much to read (rewritten by call)\n  238:  * \\param buf: buffer to write to\n  239   * \\param len: max length\n  240   */\n  ...\n  246  }\n  247  /**\n  248:  * lws_plat_file_write() - write from file\n  249   *\n  250   * \\param fop_fd: file handle\n  251:  * \\param amount: how much to write (rewritten by call)\n  252:  * \\param buf: buffer to read from\n  253   * \\param len: max length\n  254   */\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-write.h:\n   23   */\n   24  \n   25: /*! \\defgroup sending-data Sending data\n   26  \n   27      APIs related to writing data on a connection\n   ..\n   55  \tLWS_WRITE_PONG\t\t\t\t\t\t= 6,\n   56  \n   57: \t/* Same as write_http but we know this write ends the transaction */\n   58  \tLWS_WRITE_HTTP_FINAL\t\t\t\t\t= 7,\n   59  \n   ..\n   75  \n   76  \tLWS_WRITE_BUFLIST = 0x20,\n   77: \t/**< Don't actually write it... stick it on the output buflist and\n   78: \t *   write it as soon as possible.  Useful if you learn you have to\n   79: \t *   write something, have the data to write to hand but the timing is\n   80  \t *   unrelated as to whether the connection is writable or not, and were\n   81: \t *   otherwise going to have to allocate a temp buffer and write it\n   82  \t *   later anyway */\n   83  \n   ..\n  107  \n  108  /**\n  109:  * lws_write() - Apply protocol then write data to client\n  110   *\n  111   * \\param wsi:\tWebsocket instance (available from user callback)\n  112:  * \\param buf:\tThe data to send.  For data being sent on a websocket\n  113   *\t\tconnection (ie, not default http), this buffer MUST have\n  114   *\t\tLWS_PRE bytes valid BEFORE the pointer.\n  ...\n  116   * \\param len:\tCount of the data bytes in the payload starting from buf\n  117   * \\param protocol:\tUse LWS_WRITE_HTTP to reply to an http connection, and one\n  118:  *\t\tof LWS_WRITE_BINARY or LWS_WRITE_TEXT to send appropriate\n  119   *\t\tdata on a websockets connection.  Remember to allow the extra\n  120   *\t\tbytes before and after buf if LWS_WRITE_BINARY or LWS_WRITE_TEXT\n  ...\n  127   * IMPORTANT NOTICE!\n  128   *\n  129:  * When sending with ws protocol\n  130   *\n  131   * LWS_WRITE_TEXT,\n  ...\n  135   * LWS_WRITE_PONG,\n  136   *\n  137:  * or sending on http/2... the send buffer has to have LWS_PRE bytes valid\n  138   * BEFORE the buffer pointer you pass to lws_write().  Since you'll probably\n  139   * want to use http/2 before too long, it's wise to just always do this with\n  ...\n  147   *              (for lws use)      [====== user buffer ======]\n  148   *\n  149:  * This allows us to add protocol info before the data, and send as one packet\n  150   * on the network without payload copying, for maximum efficiency.\n  151   *\n  ...\n  168   * (LWS_SEND_BUFFER_POST_PADDING is deprecated, it's now 0 and can be left off.)\n  169   *\n  170:  * Return may be -1 is the write failed in a way indicating that the connection\n  171   * has ended already, in which case you can close your side, or a positive\n  172:  * number that is at least the number of bytes requested to send (under some\n  173   * encapsulation scenarios, it can indicate more than you asked was sent).\n  174   *\n  ...\n  179   * ================\n  180   *\n  181:  * The OS may not accept everything you asked to write on the connection.\n  182   *\n  183   * Posix defines POLLOUT indication from poll() to show that the connection\n  184:  * will accept more write data, but it doesn't specifiy how much.  It may just\n  185:  * accept one byte of whatever you wanted to send.\n  186   *\n  187:  * LWS will buffer the remainder automatically, and send it out autonomously.\n  188   *\n  189   * During that time, WRITABLE callbacks to user code will be suppressed and\n  190:  * instead used internally.  After it completes, it will send an extra WRITEABLE\n  191   * callback to the user code, in case any request was missed.  So it is possible\n  192   * to receive unasked-for WRITEABLE callbacks, the user code should have enough\n  193:  * state to know if it wants to write anything and just return if not.\n  194   *\n  195   * This is to handle corner cases where unexpectedly the OS refuses what we\n  196   * usually expect it to accept.  It's not recommended as the way to randomly\n  197:  * send huge payloads, since it is being copied on to heap and is inefficient.\n  198   *\n  199   * Huge payloads should instead be sent in fragments that are around 2 x mtu,\n  ...\n  202   * selecting the correct flags to give lws_write() for each fragment.\n  203   *\n  204:  * In the case of RFC8441 ws-over-h2, you cannot send ws fragments larger than\n  205   * the max h2 frame size, typically 16KB, but should further restrict it to\n  206   * the same ~2 x mtu limit mentioned above.\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-http.h:\n   36   * \\ingroup http\n   37  \n   38:     APIs for sending local files in response to HTTP requests\n   39  */\n   40  //@{\n   ..\n  162  //@}\n  163  \n  164: /** \\defgroup HTTP-headers-read HTTP headers: read\n  165   * \\ingroup http\n  166   *\n  ...\n  668   *\n  669   * Terminates the headers correctly accoring to the protocol in use (h1 / h2)\n  670:  * and writes the headers.  Returns nonzero for error.\n  671   */\n  672  LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT\n  ...\n  837   * \\param wsi:\t\tWebsocket instance (available from user callback)\n  838   * \\param code:\t\tStatus index, eg, 404\n  839:  * \\param html_body:\t\tUser-readable HTML description < 1KB, or NULL\n  840   *\n  841   *\tHelper to report HTTP errors back to the client cleanly and\n  ...\n  847  \n  848  /**\n  849:  * lws_http_redirect() - write http redirect out on wsi\n  850   *\n  851   * \\param wsi:\twebsocket connection\n  ...\n  853   * \\param loc:\twhere to redirect to\n  854   * \\param len:\tlength of loc\n  855:  * \\param p:\tpointer current position in buffer (updated as we write)\n  856   * \\param end:\tpointer to end of buffer\n  857   *\n  858:  * Returns amount written, or < 0 indicating fatal write failure.\n  859   */\n  860  LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT\n  ...\n  895  \n  896  /**\n  897:  * lws_h2_client_stream_long_poll_rxonly() - h2 stream to immortal read-only\n  898   *\n  899   * \\param wsi: h2 stream client wsi\n  ...\n  904   *\n  905   * Used if the remote server supports immortal long poll to put the stream into\n  906:  * a read-only state where it can wait as long as needed for rx.\n  907   *\n  908   * Returns 0 if the process (which happens asynchronously) started or non-zero\n  ...\n  990   *\n  991   * In conjunction with LCCSCF_H2_MANUAL_RXFLOW flag, allows the user code to\n  992:  * selectively starve the remote peer of the ability to send us data on a client\n  993   * connection.\n  994   *\n  995:  * Normally lws sends an initial window size for the peer to send to it of 0,\n  996:  * but during the header phase it sends a WINDOW_UPDATE to increase the amount\n  997   * available.  LCCSCF_H2_MANUAL_RXFLOW restricts this initial increase in tx\n  998:  * credit for the stream, before it has been asked to send us anything, to the\n  999   * amount specified in the client info .manual_initial_tx_credit member, and\n 1000:  * this api can be called to send the other side permission to send us up to\n 1001   * \\p bump additional bytes.\n 1002   *\n ....\n 1018   *\n 1019   * Returns the estimated amount of tx credit at the peer, in other words the\n 1020:  * number of bytes the peer is authorized to send to us.\n 1021   *\n 1022   * It's an 'estimate' because we don't know how much is already in flight\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-smd.h:\n   87  \n   88  /**\n   89:  * lws_smd_msg_free() - abandon a previously allocated message before sending\n   90   *\n   91   * \\param payload: pointer the previously-allocated message payload\n   92   *\n   93   * Destroys a previously-allocated opaque message object and the requested\n   94:  * buffer space, in the case that between allocating it and sending it, some\n   95   * condition was met that means it can no longer be sent, eg, an error\n   96   * generating the content.  Otherwise there is no need to destroy allocated\n   ..\n  122   *\n  123   * For string-based messages, eg, JSON, allows formatted creating of the payload\n  124:  * size discovery, allocation and message send all in one step.\n  125   *\n  126   * Unlike lws_smd_msg_alloc() you do not need to know the length beforehand as\n  ...\n  216   * \\param pr: the handle returned from the registration\n  217   *\n  218:  * Destroys the registration of the callback for messages and ability to send\n  219   * messages.\n  220   *\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-backtrace.h:\n  114   * \\param bits: the number of bits to bring out into _v\n  115   *\n  116:  * This reads the compression stream and creates a bitfield from it in \\p _v.\n  117   *\n  118   * Returns 0 for success (with \\p _v set to the value), or nonzero if ran out\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-ws-close.h:\n   27   * ##Websocket close frame control\n   28   *\n   29:  * When we close a ws connection, we can send a reason code and a short\n   30   * UTF-8 description back with the close packet.\n   31   */\n   ..\n   51  \t/**< 1003 indicates that an endpoint is terminating the connection\n   52        because it has received a type of data it cannot accept (e.g., an\n   53:       endpoint that understands only text data MAY send this if it\n   54        receives a binary message). */\n   55  \tLWS_CLOSE_STATUS_RESERVED\t\t\t\t= 1004,\n   ..\n   64        Close control frame by an endpoint.  It is designated for use in\n   65        applications expecting a status code to indicate that the\n   66:       connection was closed abnormally, e.g., without sending or\n   67        receiving a Close control frame. */\n   68  \tLWS_CLOSE_STATUS_INVALID_PAYLOAD\t\t\t= 1007,\n   ..\n  108  \n  109  /**\n  110:  * lws_close_reason - Set reason and aux data to send with Close packet\n  111   *\t\tIf you are going to return nonzero from the callback\n  112   *\t\trequesting the connection to close, you can optionally\n  ...\n  117   * \\param status:\tA valid close status from websocket standard\n  118   * \\param buf:\tNULL or buffer containing up to 124 bytes of auxiliary data\n  119:  * \\param len:\tLength of data in \\p buf to send\n  120   */\n  121  LWS_VISIBLE LWS_EXTERN void\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-writeable.h:\n   23   */\n   24  \n   25: /** \\defgroup callback-when-writeable Callback when writeable\n   26   *\n   27   * ##Callback When Writeable\n   28   *\n   29:  * lws can only write data on a connection when it is able to accept more\n   30   * data without blocking.\n   31   *\n   32   * So a basic requirement is we should only use the lws_write() apis when the\n   33:  * connection we want to write on says that he can accept more data.\n   34   *\n   35:  * When lws cannot complete your send at the time, it will buffer the data\n   36:  * and send it in the background, suppressing any further WRITEABLE callbacks\n   37:  * on that connection until it completes.  So it is important to write new\n   38:  * things in a new writeable callback.\n   39   *\n   40   * These apis reflect the various ways we can indicate we would like to be\n   41:  * called back when one or more connections is writeable.\n   42   */\n   43  ///@{\n   ..\n   51   *\n   52   * - Which:  only this wsi\n   53:  * - When:   when the individual connection becomes writeable\n   54   * - What: LWS_CALLBACK_*_WRITEABLE\n   55   */\n   ..\n   60   * lws_callback_on_writable_all_protocol() - Request a callback for all\n   61   *\t\t\tconnections using the given protocol when it\n   62:  *\t\t\tbecomes possible to write to each socket without\n   63   *\t\t\tblocking in turn.\n   64   *\n   ..\n   67   *\n   68   * - Which:  connections using this protocol on ANY VHOST\n   69:  * - When:   when the individual connection becomes writeable\n   70   * - What: LWS_CALLBACK_*_WRITEABLE\n   71   */\n   ..\n   77   * lws_callback_on_writable_all_protocol_vhost() - Request a callback for\n   78   *\t\t\tall connections on same vhost using the given protocol\n   79:  *\t\t\twhen it becomes possible to write to each socket without\n   80   *\t\t\tblocking in turn.\n   81   *\n   ..\n   84   *\n   85   * - Which:  connections using this protocol on GIVEN VHOST ONLY\n   86:  * - When:   when the individual connection becomes writeable\n   87   * - What: LWS_CALLBACK_*_WRITEABLE\n   88   */\n   ..\n  194   * lws_get_socket_fd() - returns the socket file descriptor\n  195   *\n  196:  * This is needed to use sendto() on UDP raw sockets\n  197   *\n  198   * \\param wsi:\tWebsocket connection instance\n  ...\n  202  \n  203  /**\n  204:  * lws_get_peer_write_allowance() - get the amount of data writeable to peer\n  205   * \t\t\t\t\tif known\n  206   *\n  ...\n  208   *\n  209   * if the protocol does not have any guidance, returns -1.  Currently only\n  210:  * http2 connections get send window information from this API.  But your code\n  211   * should use it so it can work properly with any protocol.\n  212   *\n  213   * If nonzero return is the amount of payload data the peer or intermediary has\n  214   * reported it has buffer space for.  That has NO relationship with the amount\n  215:  * of buffer space your OS can accept on this connection for a write action.\n  216   *\n  217:  * This number represents the maximum you could send to the peer or intermediary\n  218   * on this connection right now without the protocol complaining.\n  219   *\n  220:  * lws manages accounting for send window updates and payload writes\n  221   * automatically, so this number reflects the situation at the peer or\n  222   * intermediary dynamically.\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-metrics.h:\n  130   * period covered, in two different ways\n  131   *\n  132:  * 1) aggregation by sum or mean, to absorb multiple scalar readings\n  133   *\n  134   *  - go / no-go ratio counting\n  ...\n  271   * \\param len: available length of \\p buf\n  272   *\n  273:  * Helper for describing the state of a metrics object as a human-readable\n  274   * string, accounting for how its flags indicate what it contains.  This is not\n  275   * how you would report metrics, but during development it can be useful to\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-x509.h:\n  102   * Parses PEM certificates in memory into a native x509 representation for the\n  103   * TLS library.  If there are multiple PEM certs concatenated, they are all\n  104:  * read into the same object and exist as a \"chain\".\n  105   *\n  106   * IMPORTANT for compatibility with mbedtls, the last used byte of \\p pem\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-threadpool.h:\n   53  \t/** Still work to do, enter cond_wait until service thread syncs.  This\n   54  \t * is used if you have filled your buffer(s) of data to the service\n   55: \t * thread and are blocked until the service thread completes sending at\n   56  \t * least one.\n   57  \t */\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-client.h:\n   76  \tLCCSCF_PRIORITIZE_READS\t\t\t= (1 << 20),\n   77  \t/**<\n   78: \t * Normally lws balances reads and writes on all connections, so both\n   79  \t * are possible even on busy connections, and we go around the event\n   80  \t * loop more often to facilitate that, even if there is pending data.\n   81  \t *\n   82: \t * This flag indicates that you want to handle any pending reads on this\n   83  \t * connection without yielding the service loop for anything else.  This\n   84  \t * means you may block other connection processing in favour of incoming\n   ..\n  318   * This is called when the user code is notified client http data has arrived.\n  319   * The user code may choose to delay calling it to consume the data, for example\n  320:  * waiting until an onward connection is writeable.\n  321   *\n  322   * For non-chunked connections, up to len bytes of buf are filled with the\n  ...\n  363  \n  364  /**\n  365:  * lws_client_http_body_pending() - control if client connection needs to send body\n  366   *\n  367   * \\param wsi: client connection\n  368:  * \\param something_left_to_send: nonzero if need to send more body, 0 (default)\n  369:  * \t\t\t\tif nothing more to send\n  370   *\n  371:  * If you will send payload data with your HTTP client connection, eg, for POST,\n  372   * when you set the related http headers in\n  373   * LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER callback you should also call\n  ...\n  375   * lws_callback_on_writable(wsi);\n  376   *\n  377:  * After sending the headers, lws will call your callback with\n  378:  * LWS_CALLBACK_CLIENT_HTTP_WRITEABLE reason when writable.  You can send the\n  379   * next part of the http body payload, calling lws_callback_on_writable(wsi);\n  380   * if there is more to come, or lws_client_http_body_pending(wsi, 0); to\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-mqtt.h:\n  319   * \\param wsi: the mqtt child wsi\n  320   * \\param pub: additional information on what we're publishing\n  321:  * \\param buf: payload to send\n  322   * \\param len: length of data in buf\n  323   * \\param final: flag indicating this is the last part\n  ...\n  335   * and latency to start any new frame (even, eg, related to ping / pong).\n  336   *\n  337:  * If you're sending large frames, the OS will typically not allow the data to\n  338   * be sent all at once to kernel side.  So you should ideally cut the payload\n  339:  * up into 1 or 2- mtu sized chunks and send that.\n  340   *\n  341   * Final should be set when you're calling with the last part of the payload.\n  ...\n  351   * \\param sub: which topic(s) we want to subscribe to\n  352   *\n  353:  * For topics other child streams have not already subscribed to, send a packet\n  354   * to the server asking to subscribe to them.  If all topics listed are already\n  355   * subscribed to be the shared network connection, just trigger the\n  ...\n  367   * \\param sub: which topic(s) we want to unsubscribe from\n  368   *\n  369:  * For topics other child streams are not subscribed to, send a packet\n  370   * to the server asking to unsubscribe from them.  If all topics\n  371   * listed are already subscribed by other child streams on the shared\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-misc.h:\n  183   * Optional helpers for closely-managed stream flow control.  These are useful\n  184   * when there is no memory for large rx buffers and instead tx credit is being\n  185:  * used to regulate the server sending data.\n  186   *\n  187   * When combined with stateful consumption-on-demand, this can be very effective\n  ...\n  219  \n  220  /**\n  221:  * lws_flow_feed() - consume waiting data if ready for it\n  222   *\n  223   * \\param flow: pointer to the flow struct managing waiting data\n  ...\n  234   *\n  235   * When the estimated remote tx credit is below flow->window, accounting for\n  236:  * what is in the buflist, add to the peer tx credit so it can send us more.\n  237   */\n  238  LWS_VISIBLE LWS_EXTERN lws_stateful_ret_t\n  ...\n  450   * lws_daemonize(): make current process run in the background\n  451   *\n  452:  * \\param _lock_path: the filepath to write the lock file\n  453   *\n  454   * Spawn lws as a background process, taking care of various things\n  ...\n  721   *\n  722   * \\param wsi:\tWebsocket connection instance to get callback for\n  723:  * \\param enable:\t0 = disable read servicing for this connection, 1 = enable\n  724   *\n  725   * If you need more than one additive reason for rxflow control, you can give\n  ...\n  757   *\n  758   * If the message was in a single fragment, and there is no compression, this\n  759:  * is the same as \"how much data is left to read for this message\".\n  760   *\n  761   * However, if the message is being sent in multiple fragments, this will\n  ...\n  816   * \\param lde: lws_dir info on the file or directory we are at\n  817   *\n  818:  * This is a readymade rm -rf callback for use with lws_dir.  It recursively\n  819   * removes everything below the starting dir and then the starting dir itself.\n  820   * Works on linux, OSX and Windows at least.\n  ...\n  972  \n  973  /**\n  974:  * lws_humanize() - Convert possibly large number to human-readable uints\n  975   *\n  976   * \\param buf: result string buffer\n  ...\n  986   * represents as, eg, \"  22.130Gi\" or \" 128      \"; humanize_schema_si_bytes\n  987   * which is the same but shows, eg, \"  22.130GiB\", and humanize_schema_us,\n  988:  * which represents a count of us as a human-readable time like \"  14.350min\",\n  989   * or \"  1.500d\".\n  990   *\n  ...\n 1153   *\n 1154   * \\p lsp: the opaque pointer returned from lws_spawn()\n 1155:  * \\p std_idx: 0 (stdin write side), 1 (stdout read side), 2 (stderr read side)\n 1156   *\n 1157:  * Lets you get the fd for writing to the spawned process stdin, or reading from\n 1158   * the spawned process stdout and stderr.\n 1159   */\n ....\n 1173   * After this has been called successfully, the process can drop privileges\n 1174   * to a non-root user, and subsequent calls to lws_spawn_piped() with a\n 1175:  * cgroup_name_suffix will succeed as long as that user has write permission\n 1176   * in the master cgroup directory (which can be arranged via chown).\n 1177   *\n ....\n 1223   *\n 1224   * Overlayfs merges the union of all the contributing layers at the mountpoint,\n 1225:  * the mount is writeable but the layer themselves are immutable, all additions\n 1226   * and changes are stored in\n 1227   *\n ....\n 1296   *\n 1297   * \\p ctx: The lws context\n 1298:  * \\p ip_or_NULL: The IP address to bind to at the client side, to send the\n 1299   *                magic packet on.  If NULL, the system chooses, probably the\n 1300   *                interface with the default route.\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-async-dns.h:\n   41  } lws_async_dns_retcode_t;\n   42  \n   43: #define LWS_ADNS_SYNTHETIC\t0x10000\t/* don't send, synthetic response will\n   44  \t\t\t\t\t * be injected for testing */\n   45  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-protocols-plugins.h:\n   74  \t\t\there it can later access from the protocol callback */\n   75  \tsize_t tx_packet_size;\n   76: \t/**< 0 indicates restrict send() size to .rx_buffer_size for backwards-\n   77  \t * compatibility.\n   78: \t * If greater than zero, a single send() is restricted to this amount\n   79  \t * and any remainder is buffered by lws and sent afterwards also in\n   80  \t * these size chunks.  Since that is expensive, it's preferable\n   81: \t * to restrict one fragment you are trying to send to match this\n   82  \t * size.\n   83  \t */\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/sorted-usec-list.c:\n   91   * own points to the first in an array of length own_len\n   92   *\n   93:  * While any sul list owner has a \"ripe\", ie, ready to handle sul we do them\n   94   * strictly in order of sul time.  When nobody has a ripe sul we return 0, if\n   95   * actually nobody has any sul, or the interval between usnow and the next\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/wsi.c:\n  544  \t\treturn 0;\n  545  \n  546: \t/* stuff is still buffered, not ready to really accept new input */\n  547  \tif (lws_buflist_next_segment_len(&wsi->buflist, NULL)) {\n  548  \t\t/* get ourselves called back to deal with stashed buffer */\n  ...\n 1212  \tif (lws_has_buffered_out(wsi)) {\n 1213  \t\t/*\n 1214: \t\t * ...so he tried to send something large, but it went out\n 1215  \t\t * as a partial, but he immediately called us to say he wants\n 1216  \t\t * to close the connection.\n ....\n 1599  \tif (txc->tx_cr <= 0) {\n 1600  \t\t/*\n 1601: \t\t * If other side is not able to cope with us sending any DATA\n 1602  \t\t * so no matter if we have POLLOUT on our side if it's DATA we\n 1603: \t\t * want to send.\n 1604  \t\t */\n 1605  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/wol.c:\n   83  \n   84  \t/* arg2 is normally const void *, on mingw it's const char * */\n   85:         if (sendto(fd, (const char *)pkt, sizeof(pkt), 0, (struct sockaddr *)&addr,\n   86                          sizeof(addr)) < 0) {\n   87:                 lwsl_cx_err(cx, \"failed to sendto broadcast ads, errno %d\\n\",\n   88                                   errno);\n   89                  goto bail;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/dummy-callback.c:\n  366  \t\t\t\t\t\t   LWS_WRITE_HTTP_FINAL);\n  367  \n  368: \t\t\t/* always close after sending it */\n  369  \t\t\tif (lws_http_transaction_completed(wsi))\n  370  \t\t\t\treturn -1;\n  ...\n  407  \n  408  \t\t\t/*\n  409: \t\t\t * our sink is writeable and our source has something\n  410: \t\t\t * to read.  So read a lump of source material of\n  411: \t\t\t * suitable size to send or what's available, whichever\n  412  \t\t\t * is the smaller.\n  413  \t\t\t */\n  ...\n  589  \t\t * so at this point, the onward client connection can bear\n  590  \t\t * traffic.  We might be doing a POST and have pending cached\n  591: \t\t * inbound stuff to send, it can go now.\n  592  \t\t */\n  593  \n  ...\n  654  \t *\n  655  \t *  - POST data goes on subprocess stdin\n  656: \t *  - subprocess stdout goes on http via writeable callback\n  657  \t *  - subprocess stderr goes to the logs\n  658  \t */\n  ...\n  665  \t\tcase LWS_STDOUT:\n  666  \t\t\tif (args->stdwsi[LWS_STDOUT])\n  667: \t\t\t\t/* quench POLLIN on STDOUT until MASTER got writeable */\n  668  \t\t\t\tlws_rx_flow_control(args->stdwsi[LWS_STDOUT], 0);\n  669  \t\t\twsi->reason_bf |= LWS_CB_REASON_AUX_BF__CGI;\n  ...\n  675  \t\t\tif (n < 0)\n  676  \t\t\t\tbreak;\n  677: \t\t\tn = (int)read(n, buf, sizeof(buf) - 2);\n  678  \t\t\tif (n > 0) {\n  679  \t\t\t\tif (buf[n - 1] != '\\n')\n  ...\n  693  \t\t\tif (!(wsi->http.cgi->explicitly_chunked && wsi->mux_substream) &&\n  694  \t\t\t    !wsi->http.cgi->content_length) {\n  695: \t\t\t\t/* send terminating chunk */\n  696  \t\t\t\tlwsl_wsi_debug(wsi, \"LWS_CALLBACK_CGI_TERMINATED: ending\");\n  697  \t\t\t\twsi->reason_bf |= LWS_CB_REASON_AUX_BF__CGI_CHUNK_END;\n  ...\n  766  \t\t\t\t\tint written;\n  767  \n  768: \t\t\t\t\twritten = (int)write(args->stdwsi[LWS_STDIN]->desc.filefd,\n  769  \t\t\t\t\t\twsi->http.cgi->inflate_buf,\n  770  \t\t\t\t\t\tsizeof(wsi->http.cgi->inflate_buf) -\n  ...\n  800  #endif /* WITH_ZLIB */\n  801  \n  802: \t\tn = (int)write(n, args->data, (unsigned int)args->len);\n  803  //\t\tlwsl_hexdump_notice(args->data, args->len);\n  804  \t\tif (n < args->len)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/private-lib-core-net.h:\n  794  \tunsigned int\t\t\tcache_no:1;\n  795  \tunsigned int\t\t\tfavoured_pollin:1;\n  796: \tunsigned int\t\t\tsending_chunked:1;\n  797  \tunsigned int\t\t\tinterpreting:1;\n  798  \tunsigned int\t\t\talready_did_cce:1;\n  ...\n  821  \tunsigned int\t\t\tmount_hit:1;\n  822  \n  823: \tunsigned int\t\t\tcould_have_pending:1; /* detect back-to-back writes */\n  824  \tunsigned int\t\t\touter_will_close:1;\n  825  \tunsigned int\t\t\tshadow:1; /* we do not control fd lifecycle at all */\n  ...\n  893  \tuint8_t\t\taf;\n  894  #if defined(LWS_WITH_CGI) || defined(LWS_WITH_CLIENT)\n  895: \tchar reason_bf; /* internal writeable callback reason bitfield */\n  896  #endif\n  897  #if defined(LWS_WITH_NETLINK)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/service.c:\n   51  \tint n, m;\n   52  \n   53: \tn = wsi->role_ops->writeable_cb[lwsi_role_server(wsi)];\n   54  \tm = user_callback_handle_rxflow(wsi->a.protocol->callback,\n   55  \t\t\t\t\twsi, (enum lws_callback_reasons) n,\n   ..\n   76  \t * If we are going to disable POLLOUT, we will check that first.\n   77  \t */\n   78: \twsi->could_have_pending = 0; /* clear back-to-back write detection */\n   79  \n   80  \t/*\n   ..\n   82  \t * actually, since other pending things cannot be disordered\n   83  \t *\n   84: \t * Priority 1: pending truncated sends are incomplete ws fragments\n   85  \t *\t       If anything else sent first the protocol would be\n   86  \t *\t       corrupted.\n   ..\n  115  \t\tif (lws_rops_fidx(wsi->role_ops, LWS_ROPS_write_role_protocol) &&\n  116  \t\t    lws_rops_func_fidx(wsi->role_ops, LWS_ROPS_write_role_protocol).\n  117: \t\t\t\t\twrite_role_protocol(wsi, NULL, 0, &wp) < 0) {\n  118  \t\t\tlwsl_wsi_info(wsi, \"signalling to close\");\n  119  \t\t\tgoto bail_die;\n  ...\n  254  \tint ret = LWSRXFC_CACHED, m;\n  255  \n  256: \t/* his RX is flowcontrolled, don't send remaining now */\n  257  \tblen = lws_buflist_next_segment_len(&wsi->buflist, &buffered);\n  258  \tif (blen) {\n  ...\n  378  \n  379  /*\n  380:  * POLLIN said there is something... we must read it, and either use it; or\n  381   * if other material already in the buflist append it and return the buflist\n  382   * head material.\n  ...\n  402  \tep = ebuf->token;\n  403  \n  404: \t/* h2 or muxed stream... must force the read due to HOL blocking */\n  405  \n  406  \tif (wsi->mux_substream)\n  ...\n  415  \t\tgoto buflist_material;\n  416  \n  417: \t/* we're going to read something */\n  418  \n  419  \tebuf->token = ep;\n  ...\n  430  \tif (n <= 0 && bns)\n  431  \t\t/*\n  432: \t\t * There wasn't anything to read yet, but there's something\n  433  \t\t * on the buflist to give him\n  434  \t\t */\n  435  \t\tgoto buflist_material;\n  436  \n  437: \t/* we read something */\n  438  \n  439  \tif (fr && bns) {\n  440  \t\t/*\n  441: \t\t * Stash what we read, since there's earlier buflist material\n  442  \t\t */\n  443  \n  ...\n  453  \n  454  \t/*\n  455: \t * directly return what we read\n  456  \t */\n  457  \n  ...\n  602  #if defined(LWS_WITH_TLS)\n  603  \t/*\n  604: \t * 2) For all guys with buffered SSL read data already saved up, if they\n  605  \t * are not flowcontrolled, fake their POLLIN status so they'll get\n  606  \t * service to use up the buffered incoming data, even though their\n  ...\n  683  \n  684  \t/*\n  685: \t * Whatever the situation with buffered rx packets, or explicitly read-\n  686  \t * and-buffered rx going to be handled before we want to acknowledge the\n  687  \t * socket is gone, any sign of HUP always immediately means no more tx\n  ...\n  743  \t\t/*\n  744  \t\t * If this wsi has a pending WANT_WRITE from SSL_read(), it has\n  745: \t\t * asked for a callback on writeable so it can retry the read.\n  746  \t\t *\n  747  \t\t *  Let's consume the POLLOUT by turning it into a POLLIIN, and\n  748: \t\t *  setting a flag to request a new writeable\n  749  \t\t */\n  750  \t\twsi->tls_read_wanted_write = 0;\n  ...\n  754  \t}\n  755  \n  756: \twsi->could_have_pending = 0; /* clear back-to-back write detection */\n  757  \tpt->inside_lws_service = 1;\n  758  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/transport-mux-client.c:\n  140  \n  141  \tlws_transport_mux_client_request_tx(tm);\n  142: \t/* we want to write inside the channel, so register ch as pending */\n  143  \tif (lws_dll2_is_detached(&tmc->list_pending_tx))\n  144  \t\tlws_dll2_add_tail(&tmc->list_pending_tx, &tm->pending_tx);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/transport-mux-proxy.c:\n  335  \ttm->info.txp_ppath.ops_onw->proxy_req_write(tm->info.txp_ppath.priv_onw);\n  336  }\n  337: /**< Get the proxy to write to out on the onward (back to client) transport on this channel */\n  338  int\n  339  lws_transport_mux_proxy_write(lws_transport_priv_t priv, uint8_t *buf, size_t *len)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/close.c:\n  559  \t/*\n  560  \t * signal we are closing, lws_write will\n  561: \t * add any necessary version-specific stuff.  If the write fails,\n  562  \t * no worries we are closing anyway.  If we didn't initiate this\n  563  \t * close, then our state has been changed to\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/output.c:\n   42  \t * There's also a corresponding lws_ssl_capable_read() in those files\n   43  \t * where you can enable a dump of decrypted data as soon as it was\n   44: \t * read.\n   45  \t */\n   46  \n   47: \t/* just ignore sends after we cleared the truncation buffer */\n   48  \tif (lwsi_state(wsi) == LRS_FLUSHING_BEFORE_CLOSE &&\n   49  \t    !lws_has_buffered_out(wsi)\n   ..\n   86  \t\tlwsl_wsi_err(wsi, \"invalid sock\");\n   87  \n   88: \t/* limit sending */\n   89  \tif (wsi->a.protocol->tx_packet_size)\n   90  \t\tn = (unsigned int)wsi->a.protocol->tx_packet_size;\n   ..\n   98  \t\tn = (unsigned int)len;\n   99  \n  100: \t/* nope, send it on the socket directly */\n  101  \n  102: \tif (lws_fi(&wsi->fic, \"sendfail\"))\n  103  \t\tm = (unsigned int)LWS_SSL_CAPABLE_ERROR;\n  104  \telse\n  ...\n  112  \tswitch ((int)m) {\n  113  \tcase LWS_SSL_CAPABLE_ERROR:\n  114: \t\t/* we're going to close, let close know sends aren't possible */\n  115  \t\twsi->socket_is_permanently_unusable = 1;\n  116  \t\treturn -1;\n  ...\n  118  \t\t/*\n  119  \t\t * nothing got sent, not fatal.  Retry the whole thing later,\n  120: \t\t * ie, implying treat it was a truncated send so it gets\n  121  \t\t * retried\n  122  \t\t */\n  ...\n  129  \n  130  \t/*\n  131: \t * we were sending this from buflist_out?  Then not sending everything\n  132  \t * is a small matter of advancing ourselves only by the amount we did\n  133: \t * send in the buflist.\n  134  \t */\n  135  \tif (lws_has_buffered_out(wsi)) {\n  ...\n  171  #endif\n  172  \t\t}\n  173: \t\t/* always callback on writeable */\n  174  \t\tlws_callback_on_writable(wsi);\n  175  \n  ...\n  187  \n  188  \t/*\n  189: \t * We were not able to send everything... and we were not sending from\n  190  \t * an existing buflist_out.  So we are starting a fresh buflist_out, by\n  191  \t * buffering the unsent remainder on it.\n  ...\n  205  #endif\n  206  \n  207: \t/* since something buffered, force it to get another chance to send */\n  208  \tlws_callback_on_writable(wsi);\n  209  \n  ...\n  233  \telse\n  234  \t\tm = lws_rops_func_fidx(wsi->role_ops, LWS_ROPS_write_role_protocol).\n  235: \t\t\t\twrite_role_protocol(wsi, buf, len, &wp);\n  236  \n  237  #if defined(LWS_WITH_SYS_METRICS)\n  ...\n  254  \t\tsocklen_t slt = sizeof(wsi->udp->sa46);\n  255  \n  256: \t\tn = (int)recvfrom(wsi->desc.sockfd, (char *)buf,\n  257  #if defined(WIN32)\n  258  \t\t\t\t(int)\n  ...\n  262  \t} else\n  263  #endif\n  264: \t\tn = (int)recv(wsi->desc.sockfd, (char *)buf,\n  265  #if defined(WIN32)\n  266  \t\t\t\t(int)\n  ...\n  300  #endif\n  301  \n  302: \tlwsl_wsi_info(wsi, \"error on reading from skt : %d, errno %d\", n, en);\n  303  \n  304  \treturn LWS_SSL_CAPABLE_ERROR;\n  ...\n  310  \tint n = 0;\n  311  #if defined(LWS_PLAT_OPTEE)\n  312: \tssize_t send(int sockfd, const void *buf, size_t len, int flags);\n  313  #endif\n  314  \n  ...\n  323  \n  324  \t\tif (lws_has_buffered_out(wsi))\n  325: \t\t\tn = (int)sendto(wsi->desc.sockfd, (const char *)buf,\n  326  #if defined(WIN32)\n  327  \t\t\t\t(int)\n  ...\n  330  \t\t\t\t   sa46_socklen(&wsi->udp->sa46_pending));\n  331  \t\telse\n  332: \t\t\tn = (int)sendto(wsi->desc.sockfd, (const char *)buf,\n  333  #if defined(WIN32)\n  334  \t\t\t\t(int)\n  ...\n  339  #endif\n  340  \t\tif (wsi->role_ops->file_handle)\n  341: \t\t\tn = (int)write((int)(lws_intptr_t)wsi->desc.filefd, buf,\n  342  #if defined(WIN32)\n  343  \t\t\t\t(int)\n  ...\n  345  \t\t\t\t\tlen);\n  346  \t\telse\n  347: \t\t\tn = (int)send(wsi->desc.sockfd, (char *)buf,\n  348  #if defined(WIN32)\n  349  \t\t\t\t(int)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/adopt.c:\n  585  }\n  586  \n  587: /* Common read-buffer adoption for lws_adopt_*_readbuf */\n  588  static struct lws*\n  589: adopt_socket_readbuf(struct lws *wsi, const char *readbuf, size_t len)\n  590  {\n  591  \tstruct lws_context_per_thread *pt;\n  ...\n  596  \t\treturn NULL;\n  597  \n  598: \tif (!readbuf || len == 0)\n  599  \t\treturn wsi;\n  600  \n  ...\n  604  \tpt = &wsi->a.context->pt[(int)wsi->tsi];\n  605  \n  606: \tn = lws_buflist_append_segment(&wsi->buflist, (const uint8_t *)readbuf,\n  607  \t\t\t\t       len);\n  608  \tif (n < 0)\n  ...\n  612  \n  613  \t/*\n  614: \t * we can't process the initial read data until we can attach an ah.\n  615  \t *\n  616  \t * if one is available, get it and place the data in his ah rxbuf...\n  ...\n  618  \t *\n  619  \t * no autoservice because we didn't get a chance to attach the\n  620: \t * readbuf data to wsi or ah yet, and we will do it next if we get\n  621  \t * the ah.\n  622  \t */\n  623  \tif (wsi->http.ah || !lws_header_table_attach(wsi, 0)) {\n  624  \n  625: \t\tlwsl_notice(\"%s: calling service on readbuf ah\\n\", __func__);\n  626  \n  627  \t\t/*\n  ...\n  646  bail:\n  647  \tlws_close_free_wsi(wsi, LWS_CLOSE_STATUS_NOSTATUS,\n  648: \t\t\t   \"adopt skt readbuf fail\");\n  649  \n  650  \treturn NULL;\n  ...\n  951  struct lws *\n  952  lws_adopt_socket_readbuf(struct lws_context *context, lws_sockfd_type accept_fd,\n  953: \t\t\t const char *readbuf, size_t len)\n  954  {\n  955          return adopt_socket_readbuf(lws_adopt_socket(context, accept_fd),\n  956: \t\t\t\t    readbuf, len);\n  957  }\n  958  \n  ...\n  960  lws_adopt_socket_vhost_readbuf(struct lws_vhost *vhost,\n  961  \t\t\t       lws_sockfd_type accept_fd,\n  962: \t\t\t       const char *readbuf, size_t len)\n  963  {\n  964          return adopt_socket_readbuf(lws_adopt_socket_vhost(vhost, accept_fd),\n  965: \t\t\t\t    readbuf, len);\n  966  }\n  967  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/transport-mux-common.c:\n  131  \t * Some interval expired on the transport...\n  132  \t *\n  133: \t * ...because we need to send a ping now?\n  134  \t */\n  135  \n  136  \tif (!tm->awaiting_pong) {\n  137  \t\t/*\n  138: \t\t * We start the pong timer when we decided we wanted to send\n  139: \t\t * it, not when we sent it, so we can catch unable to send\n  140  \t\t */\n  141  \t\tlwsl_notice(\"%s: issuing ping\\n\", __func__);\n  ...\n  209   * If the mux channel wants to do something, pack together as much as will\n  210   * fit and return nonzero to announce that the mux layer has commandeered this\n  211:  * write opportunity\n  212   *\n  213   * Caution, this is called by both client and proxy mux sides\n  ...\n  228  \tif (tm->issue_ping) {\n  229  \t\tif (tm->link_state == LWSTM_TRANSPORT_DOWN) {\n  230: \t\t\tlwsl_info(\"%s: send RESET_TRANSPORT\\n\", __func__);\n  231  \t\t\t*p++ = LWSSSS_LLM_RESET_TRANSPORT;\n  232  \t\t}\n  ...\n  309  \t\t\tlws_dll2_remove(&mc->list_pending_tx);\n  310  \n  311: \t\t/* he wants to write something... let's see how he is */\n  312  \n  313  \t\tswitch (mc->state) {\n  ...\n  360  \t} lws_end_foreach_dll_safe(d, d1);\n  361  \n  362: \t/* if none, do the first OPERATIONAL that wants to write */\n  363  \n  364  \tif (buf == p) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/socks5-client.c:\n  236  \t}\n  237  \t// lwsl_hexdump_notice(pt->serv_buf, plen);\n  238: \tn = (int)send(wsi->desc.sockfd, (char *)pt->serv_buf, (size_t)plen,\n  239  \t\t      MSG_NOSIGNAL);\n  240  \tif (n < 0) {\n  241  \t\tlwsl_wsi_debug(wsi, \"ERROR writing socks greeting\");\n  242: \t\t*pcce = \"socks write failed\";\n  243  \t\treturn -1;\n  244  \t}\n  ...\n  269  \t}\n  270  \n  271: \tn = (int)recv(wsi->desc.sockfd, (void *)pt->serv_buf,\n  272  \t\t wsi->a.context->pt_serv_buf_size, 0);\n  273  \tif (n < 0) {\n  274  \t\tif (LWS_ERRNO == LWS_EAGAIN) {\n  275: \t\t\tlwsl_wsi_debug(wsi, \"SOCKS read EAGAIN, retrying\");\n  276  \t\t\treturn LW5CHS_RET_RET0;\n  277  \t\t}\n  278: \t\tlwsl_wsi_err(wsi, \"ERROR reading from SOCKS socket\");\n  279: \t\t*pcce = \"socks recv fail\";\n  280  \t\treturn LW5CHS_RET_BAIL3;\n  281  \t}\n  ...\n  321  \t\t\tgoto socks_reply_fail;\n  322  \n  323: \t\tlwsl_wsi_client(wsi, \"SOCKS password OK, sending connect\");\n  324  \t\tif (lws_socks5c_generate_msg(wsi, SOCKS_MSG_CONNECT, &len)) {\n  325  socks_send_msg_fail:\n  ...\n  332  socks_send:\n  333  \t\t// lwsl_hexdump_notice(pt->serv_buf, len);\n  334: \t\tn = (int)send(wsi->desc.sockfd, (char *)pt->serv_buf,\n  335  \t\t\t      (size_t)len, MSG_NOSIGNAL);\n  336  \t\tif (n < 0) {\n  337  \t\t\tlwsl_wsi_debug(wsi, \"ERROR writing to socks proxy\");\n  338: \t\t\t*pcce = \"socks write fail\";\n  339  \t\t\treturn LW5CHS_RET_BAIL3;\n  340  \t\t}\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/client/connect4.c:\n   48  \n   49  \tif (wsi_piggyback)\n   50: \t\tgoto send_hs;\n   51  \n   52  #if defined(LWS_CLIENT_HTTP_PROXYING)\n   ..\n   96  \t\twsi->c_port = (uint16_t)wsi->a.vhost->http.http_proxy_port;\n   97  \n   98: \t\tn = (int)send(wsi->desc.sockfd, (char *)pt->serv_buf,\n   99  \t\t\t      (unsigned int)plen,\n  100  \t\t\t MSG_NOSIGNAL);\n  101  \t\tif (n < 0) {\n  102  \t\t\tlwsl_wsi_debug(wsi, \"ERROR writing to proxy socket\");\n  103: \t\t\tcce = \"proxy write failed\";\n  104  \t\t\tgoto failed;\n  105  \t\t}\n  ...\n  133  \n  134  #if defined(LWS_ROLE_H1) || defined(LWS_ROLE_H2)\n  135: send_hs:\n  136  \n  137  \tif (wsi_piggyback &&\n  ...\n  142  \t\t *\n  143  \t\t * Set these queued guys to a state where they won't actually\n  144: \t\t * send their headers until we decide later.\n  145  \t\t */\n  146  \n  ...\n  148  \n  149  \t\t/*\n  150: \t\t * we can't send our headers directly, because they have to\n  151: \t\t * be sent when the parent is writeable.  The parent will check\n  152  \t\t * for anybody on his client transaction queue that is in\n  153: \t\t * LRS_H1C_ISSUE_HANDSHAKE2, and let them write.\n  154  \t\t *\n  155  \t\t * If we are trying to do this too early, before the network\n  156  \t\t * connection has written his own headers, then it will just\n  157: \t\t * wait in the queue until it's possible to send them.\n  158  \t\t */\n  159  \t\tlws_callback_on_writable(wsi_piggyback);\n  160  \n  161: \t\tlwsl_wsi_info(wsi, \"waiting to send hdrs (par state 0x%x)\",\n  162  \t\t\t      lwsi_state(wsi_piggyback));\n  163  \t} else {\n  ...\n  211  \t\t\t\t * We succeeded to negotiate a new client tls\n  212  \t\t\t\t * tunnel.  If it's h2 alpn, we have arranged\n  213: \t\t\t\t * to send the h2 prefix and set our state to\n  214  \t\t\t\t * LRS_H2_WAITING_TO_SEND_HEADERS already.\n  215  \t\t\t\t */\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/client/sort-dns.c:\n  315  \t/*\n  316  \t * Rule 5: Prefer outgoing interface.\n  317: \t * If SA is assigned to the interface that will be used to send to D\n  318  \t * and SB is assigned to a different interface, then prefer SA.\n  319  \t * Similarly, if SB is assigned to the interface that will be used\n  320: \t * to send to D and SA is assigned to a different interface, then\n  321  \t * prefer SB.\n  322  \t */\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/client/connect3.c:\n  110  \n  111  \t/*\n  112: \t * This resets SO_ERROR after reading it.  If there's an error\n  113  \t * condition, the connect definitively failed.\n  114  \t */\n  ...\n  133  \t}\n  134  #else\n  135: \tfd_set write_set, except_set;\n  136  \tstruct timeval tv;\n  137  \tint ret;\n  138  \n  139: \tFD_ZERO(&write_set);\n  140  \tFD_ZERO(&except_set);\n  141: \tFD_SET(wsi->desc.sockfd, &write_set);\n  142  \tFD_SET(wsi->desc.sockfd, &except_set);\n  143  \n  ...\n  145  \ttv.tv_usec = 0;\n  146  \n  147: \tret = select((int)wsi->desc.sockfd + 1, NULL, &write_set, &except_set, &tv);\n  148: \tif (FD_ISSET(wsi->desc.sockfd, &write_set)) {\n  149  \t\t/* actually connected */\n  150: \t\tlwsl_wsi_debug(wsi, \"select write fd set, conn OK\");\n  151  \t\treturn LCCCR_CONNECTED;\n  152  \t}\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core/lws_dll2.c:\n  301  \t\tuint8_t *ref = ((uint8_t *)p) - dll2_ofs;\n  302  \t\t/*\n  303: \t\t * We have to read the const char * at the computed place and\n  304  \t\t * the string is where that points\n  305  \t\t */\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core/libwebsockets.c:\n 1968  \n 1969  \tt = (int32_t)(_c1 % LWS_FX_FRACTION_MSD);\n 1970: \tr->whole = w; /* don't need a,b any further... now we can write to r */\n 1971  \tif (neg ^ !!(t < 0))\n 1972  \t\tr->frac = -t;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core/context.c:\n 1012  \t/*\n 1013  \t * If asked, try to set the rlimit / ulimit for process sockets / files.\n 1014: \t * We read the effective limit in a moment, so we will find out the\n 1015  \t * real limit according to system constraints then.\n 1016  \t */\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core/logs.c:\n  132   * Normally we want to set the tag one time at creation.  But sometimes we\n  133   * don't have enough information at that point to give it a meaningful tag, eg,\n  134:  * it's an accepted, served connection but we haven't read data from it yet\n  135   * to find out what it wants to be.\n  136   *\n  ...\n  326  \n  327  \tif (fd >= 0)\n  328: \t\tif (write(fd, line, (unsigned int)len) != (ssize_t)len)\n  329: \t\t\tfprintf(stderr, \"Unable to write log to file\\n\");\n  330  }\n  331  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core/private-lib-core.h:\n  232  \n  233  struct lws_tx_credit {\n  234: \tint32_t\t\t\ttx_cr;\t\t/* our credit to write peer */\n  235: \tint32_t\t\t\tpeer_tx_cr_est; /* peer's credit to write us */\n  236  \n  237  \tint32_t\t\t\tmanual_initial_tx_credit;\n  238  \n  239: \tuint8_t\t\t\tskint; /* unable to write anything */\n  240  \tuint8_t\t\t\tmanual;\n  241  };\n  ...\n  984  \tunsigned int\t\ttreepos;\n  985  \n  986: \tunsigned int\t\tread_bits_shifter;\n  987: \tunsigned int\t\tread_bits_limit;\n  988: \tunsigned int \t\tread_bits_i;\n  989  \n  990  \tunsigned int\t\tinfo_size;\n  ...\n  996  \tuint8_t\t\t\tgz_flags;\n  997  \n  998: \tchar\t\t\tread_bits_ongoing;\n  999  } inflator_ctx_t;\n 1000  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/tls-jit-trust.c:\n   67   * We have the SKID and AKID for every peer cert captured, but they may be\n   68   * in any order, and eg, falsely have sent the root CA, or an attacker may\n   69:  * send unresolveable self-referencing loops of KIDs.\n   70   *\n   71   * Let's sort them into the SKID -> AKID hierarchy, so the last entry is the\n   ..\n   74   * root CA cert we would need to trust to validate the chain.\n   75   *\n   76:  * It's not unknown the server is misconfigured to also send the root CA, if so\n   77   * the top slot's AKID is empty and we should look for its SKID in the trust\n   78   * blob.\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/tls.c:\n   52  \t/* the first item in the chunk */\n   53  \tif (!strncmp(line, \"SERVER_HANDSHAKE_TRAFFIC_SECRET\", 31)) {\n   54: \t\tw += (size_t)write(fd, \"\\n# \", 3);\n   55  \t\twx += 3;\n   56  \t\tt = lwsl_timestamp(LLL_WARN, ts, sizeof(ts));\n   57  \t\twx += (size_t)t;\n   58: \t\tw += (size_t)write(fd, ts, (size_t)t);\n   59  \n   60  \t\tt = lws_snprintf(hdr, sizeof(hdr), \"%s\\n\", wsi->lc.gutag);\n   61: \t\tw += (size_t)write(fd, hdr, (size_t)t);\n   62  \t\twx += (size_t)t;\n   63  \n   ..\n   66  \n   67  \twx += strlen(line) + 1;\n   68: \tw += (size_t)write(fd, line, \n   69  #if defined(WIN32)\n   70  \t\t\t(unsigned int)\n   71  #endif\n   72  \t\t\tstrlen(line));\n   73: \tw += (size_t)write(fd, \"\\n\", 1);\n   74  \tclose(fd);\n   75  \n   76  \tif (w != wx) {\n   77: \t\tlwsl_vhost_warn(wsi->a.vhost, \"Failed to write %s\", path);\n   78  \t\treturn;\n   79  \t}\n   ..\n  303  \t(*buf)[s] = '\\0';\n  304  \n  305: \tlwsl_notice(\"%s: nvs: read %s, %d bytes\\n\", __func__, filename, (int)s);\n  306  \n  307  bail:\n  ...\n  456  \t\tgoto bail;\n  457  \n  458: \t/* we can't write into the input buffer for mem, since it may be in RO\n  459  \t * const segment\n  460  \t */\n  ...\n  501  \t\treturn 1;\n  502  \n  503: \t/* and we can read at least one byte out of it */\n  504: \tn = read(fd, buf, 1);\n  505  \tclose(fd);\n  506  \n  ...\n  509  #endif\n  510  /*\n  511:  * Returns 0 if the filepath \"name\" exists and can be read from.\n  512   *\n  513   * In addition, if \"name\".upd exists, backup \"name\" to \"name.old.1\"\n  ...\n  526   *\n  527   * 3) LWS_TLS_EXTANT_ALTERNATIVE: There are provisioned certs written (xxx.upd)\n  528:  *    but we no longer have the privs needed to read or rename them.  In this\n  529   *    case, indicate that the caller should use temp copies if any we do have\n  530   *    rights to access.  This is normal after we have updated the cert.\n  ...\n  535   *\n  536   * 4) LWS_TLS_EXTANT_YES: The certs are present with the correct name and we\n  537:  *    have the rights to read them.\n  538   */\n  539  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/tls-server.c:\n  189  \t\t\t/*\n  190  \t\t\t * We came here by POLLIN, so there is supposed to be\n  191: \t\t\t * something to read...\n  192  \t\t\t */\n  193  \n  194: \t\t\ts = recv(wsi->desc.sockfd, (char *)pt->serv_buf,\n  195  \t\t\t\t context->pt_serv_buf_size, MSG_PEEK);\n  196  \t\t\t/*\n  ...\n  264  \t\t\t\t}\n  265  \n  266: \t\t\t\tlwsl_notice(\"%s: client did not send a valid \"\n  267  \t\t\t\t\t    \"tls hello (default vhost %s)\\n\",\n  268  \t\t\t\t\t    __func__, wsi->a.vhost->name);\n  ...\n  271  \t\t\tif (!s) {\n  272  \t\t\t\t/*\n  273: \t\t\t\t * POLLIN but nothing to read is supposed to\n  274  \t\t\t\t * mean the connection is gone, we should\n  275  \t\t\t\t * fail out...\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/mbedtls/mbedtls-ssl.c:\n  126  \n  127  \t/*\n  128: \t * if it was our buffer that limited what we read,\n  129  \t * check if SSL has additional data pending inside SSL buffers.\n  130  \t *\n  ...\n  168  \t/*\n  169  \t * If using mbedtls type tls library, this is the last point for all\n  170: \t * paths before sending data into the tls tunnel, where you can dump it\n  171  \t * and see what is being sent.\n  172  \t */\n  ...\n  191  \tif (m != SSL_ERROR_SYSCALL) {\n  192  \t\tif (m == SSL_ERROR_WANT_READ || SSL_want_read(wsi->tls.ssl)) {\n  193: \t\t\tlwsl_notice(\"%s: want read\\n\", __func__);\n  194  \n  195  \t\t\treturn LWS_SSL_CAPABLE_MORE_SERVICE;\n  ...\n  198  \t\tif (m == SSL_ERROR_WANT_WRITE || SSL_want_write(wsi->tls.ssl)) {\n  199  \t\t\tlws_set_blocking_send(wsi);\n  200: \t\t\tlwsl_debug(\"%s: want write\\n\", __func__);\n  201  \n  202  \t\t\treturn LWS_SSL_CAPABLE_MORE_SERVICE;\n  ...\n  331  \t\tif (n != SSL_ERROR_SYSCALL && n != SSL_ERROR_SSL) {\n  332  \t\t\tif (SSL_want_read(wsi->tls.ssl)) {\n  333: \t\t\t\tlwsl_debug(\"(wants read)\\n\");\n  334  \t\t\t\t__lws_change_pollfd(wsi, 0, LWS_POLLIN);\n  335  \t\t\t\treturn LWS_SSL_CAPABLE_MORE_SERVICE_READ;\n  336  \t\t\t}\n  337  \t\t\tif (SSL_want_write(wsi->tls.ssl)) {\n  338: \t\t\t\tlwsl_debug(\"(wants write)\\n\");\n  339  \t\t\t\t__lws_change_pollfd(wsi, 0, LWS_POLLOUT);\n  340  \t\t\t\treturn LWS_SSL_CAPABLE_MORE_SERVICE_WRITE;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/mbedtls/mbedtls-server.c:\n  124  \n  125  \t/*\n  126: \t * we can't read the root-privs files.  But if mem_cert is provided,\n  127  \t * we should use that.\n  128  \t */\n  ...\n  136  \t\t/*\n  137  \t\t * Although we have prepared update certs, we no longer have\n  138: \t\t * the rights to read our own cert + key we saved.\n  139  \t\t *\n  140  \t\t * If we were passed copies in memory buffers, use those\n  ...\n  662  \tn = mbedtls_x509write_csr_der(&csr, buf, (size_t)buf_size, _rngf, context);\n  663  \tif (n < 0) {\n  664: \t\tlwsl_notice(\"%s: write csr der failed\\n\", __func__);\n  665  \t\tgoto fail1;\n  666  \t}\n  ...\n  680  \n  681  \tif (mbedtls_pk_write_key_pem(&mpk, buf, (size_t)buf_size)) {\n  682: \t\tlwsl_notice(\"write key pem failed\\n\");\n  683  \t\tgoto fail1;\n  684  \t}\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/mbedtls/mbedtls-client.c:\n   34   * later at verification result time if it failed.\n   35   *\n   36:  * None of these should be trusted, even if a misconfigured server sends us\n   37   * his root CA.\n   38   */\n   ..\n  141  \t\t\t\t\t       sizeof(protos.data) - 1);\n  142  \n  143: \tlwsl_info(\"%s: %s: client conn sending ALPN list '%s' (protos.len %d)\\n\",\n  144  \t\t  __func__, lws_wsi_tag(wsi), alpn_comma, protos.len);\n  145  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/mbedtls/wrapper/include/internal/ssl_code.h:\n   34  \n   35  /*\n   36:  * The following 3 states are kept in ssl->rlayer.rstate when reads fail, you\n   37   * should not need these\n   38   */\n   ..\n   69      /* We are about to renegotiate */\n   70      MSG_FLOW_RENEGOTIATE,\n   71:     /* We are reading messages */\n   72      MSG_FLOW_READING,\n   73      /* We are writing messages */\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/mbedtls/wrapper/include/internal/ssl_types.h:\n  145      int rstate;\n  146  \n  147:     int read_ahead;\n  148  };\n  149  \n  ...\n  192      long session_timeout;\n  193  \n  194:     int read_ahead;\n  195  \n  196:     int read_buffer_len;\n  197  \n  198      X509_VERIFY_PARAM param;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/mbedtls/wrapper/include/internal/ssl_methods.h:\n   28                      new, free, \\\n   29                      handshake, shutdown, clear, \\\n   30:                     read, send, pending, \\\n   31                      set_fd, get_fd, \\\n   32                      set_bufflen, \\\n   ..\n   39                  shutdown, \\\n   40                  clear, \\\n   41:                 read, \\\n   42:                 send, \\\n   43                  pending, \\\n   44                  set_fd, \\\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/mbedtls/wrapper/include/openssl/ssl.h:\n  113  \n  114  /**\n  115:  * @brief read data from to remote\n  116   *\n  117   * @param ssl    - the SSL point which has been connected\n  ...\n  127  \n  128  /**\n  129:  * @brief send the data to remote\n  130   *\n  131   * @param ssl    - the SSL point which has been connected\n  132:  * @param buffer - the send data buffer point\n  133:  * @param len    - the send data length\n  134   *\n  135   * @return result\n  ...\n  403  \n  404  /**\n  405:  * @brief generates a human-readable string representing the error code e\n  406   *        and store it into the \"ret\" point memory\n  407   *\n  ...\n  473  \n  474  /**\n  475:  * @brief get the bytes numbers which are to be read\n  476   *\n  477   * @param ssl  - SSL point\n  ...\n  493  \n  494  /**\n  495:  * @brief check if SSL want to read\n  496   *\n  497   * @param ssl - SSL point\n  ...\n  504  \n  505  /**\n  506:  * @brief check if SSL want to write\n  507   *\n  508   * @param ssl - SSL point\n  ...\n  644  \n  645  /**\n  646:  * @brief set the SSL context read buffer length\n  647   *\n  648   * @param ctx - SSL context point\n  649:  * @param len - read buffer length\n  650   *\n  651   * @return none\n  ...\n  654  \n  655  /**\n  656:  * @brief set the SSL read buffer length\n  657   *\n  658   * @param ssl - SSL point\n  659:  * @param len - read buffer length\n  660   *\n  661   * @return none\n  ...\n  874  \n  875  /**\n  876:  * @brief get the read only socket handle of the SSL\n  877   *\n  878   * @param ssl - SSL point\n  ...\n  885  \n  886  /**\n  887:  * @brief get the write only socket handle of the SSL\n  888   *\n  889   * @param ssl - SSL point\n  ...\n  896  \n  897  /**\n  898:  * @brief set the SSL if we can read as many as data\n  899   *\n  900   * @param ssl - SSL point\n  ...\n  906  \n  907  /**\n  908:  * @brief set the SSL context if we can read as many as data\n  909   *\n  910   * @param ctx - SSL context point\n  ...\n  916  \n  917  /**\n  918:  * @brief get the SSL ahead signal if we can read as many as data\n  919   *\n  920   * @param ssl - SSL point\n  ...\n  925  \n  926  /**\n  927:  * @brief get the SSL context ahead signal if we can read as many as data\n  928   *\n  929   * @param ctx - SSL context point\n  ...\n  934  \n  935  /**\n  936:  * @brief check if some data can be read\n  937   *\n  938   * @param ssl - SSL point\n  939   *\n  940   * @return\n  941:  *         1 : there are bytes to be read\n  942   *         0 : no data\n  943   */\n  ...\n 1151  \n 1152  /**\n 1153:  * @brief check if the SSL context can read as many as data\n 1154   *\n 1155   * @param ctx - SSL context point\n ....\n 1227  \n 1228  /**\n 1229:  * @brief set the SSL context if we can read as many as data\n 1230   *\n 1231   * @param ctx - SSL context point\n ....\n 1484  \n 1485  /**\n 1486:  * @brief get SSL read only IO handle\n 1487   *\n 1488   * @param ssl - SSL point\n ....\n 1587  \n 1588  /**\n 1589:  * @brief get SSL write only IO handle\n 1590   *\n 1591   * @param ssl - SSL point\n ....\n 1616  \n 1617  /**\n 1618:  * @brief read and put data into buf, but not clear the SSL low-level storage\n 1619   *\n 1620   * @param ssl - SSL point\n ....\n 1623   *\n 1624   * @return result\n 1625:  *     > 0 : OK, and return read bytes\n 1626   *     = 0 : connect is closed\n 1627   *     < 0 : a error catch\n ....\n 1641  \n 1642  /**\n 1643:  * @brief get the state string where SSL is reading\n 1644   *\n 1645   * @param ssl - SSL point\n ....\n 1650  \n 1651  /**\n 1652:  * @brief get the statement long string where SSL is reading\n 1653   *\n 1654   * @param ssl - SSL point\n ....\n 1681   *\n 1682   * @param ssl  - SSL point\n 1683:  * @param rbio - read only IO\n 1684:  * @param wbio - write only IO\n 1685   *\n 1686   * @return none\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/mbedtls/wrapper/library/ssl_lib.c:\n  101  \n  102  /**\n  103:  * @brief check if SSL want to read\n  104   */\n  105  int SSL_want_read(const SSL *ssl)\n  ...\n  114  \n  115  /**\n  116:  * @brief check if SSL want to write\n  117   */\n  118  int SSL_want_write(const SSL *ssl)\n  ...\n  478  \n  479  /**\n  480:  * @brief read data from to remote\n  481   */\n  482  int SSL_read(SSL *ssl, void *buffer, int len)\n  ...\n  490      ssl->rwstate = SSL_READING;\n  491  \n  492:     ret = SSL_METHOD_CALL(read, ssl, buffer, len);\n  493  \n  494      if (ret == len)\n  ...\n  499  \n  500  /**\n  501:  * @brief send the data to remote\n  502   */\n  503  int SSL_write(SSL *ssl, const void *buffer, int len)\n  504  {\n  505      int ret;\n  506:     int send_bytes, bytes;\n  507      const unsigned char *pbuf;\n  508  \n  ...\n  513      ssl->rwstate = SSL_WRITING;\n  514  \n  515:     send_bytes = len;\n  516      pbuf = (const unsigned char *)buffer;\n  517  \n  518      do {\n  519:         if (send_bytes > SSL_SEND_DATA_MAX_LENGTH)\n  520              bytes = SSL_SEND_DATA_MAX_LENGTH;\n  521          else\n  522:             bytes = send_bytes;\n  523  \n  524  \tif (ssl->interrupted_remaining_write) {\n  ...\n  527  \t}\n  528  \n  529:         ret = SSL_METHOD_CALL(send, ssl, pbuf, bytes);\n  530: \t//printf(\"%s: ssl_pm said %d for %d requested (cum %d)\\n\", __func__, ret, bytes, len -send_bytes);\n  531          /* the return is a NEGATIVE OpenSSL error code, or the length sent */\n  532          if (ret > 0) {\n  533              pbuf += ret;\n  534:             send_bytes -= ret;\n  535          } else\n  536  \t\tssl->interrupted_remaining_write = bytes;\n  537:     } while (ret > 0 && send_bytes && ret == bytes);\n  538  \n  539      if (ret >= 0) {\n  540:         ret = len - send_bytes;\n  541  \tif (!ret)\n  542  \t        ssl->rwstate = SSL_NOTHING;\n  543      } else {\n  544: \t    if (send_bytes == len)\n  545  \t\tret = -1;\n  546  \t    else\n  547: \t\t    ret = len - send_bytes;\n  548      }\n  549  \n  ...\n  631  \n  632  /**\n  633:  * @brief get the number of the bytes to be read\n  634   */\n  635  int SSL_pending(const SSL *ssl)\n  ...\n  645  \n  646  /**\n  647:  * @brief check if some data can be read\n  648   */\n  649  int SSL_has_pending(const SSL *ssl)\n  ...\n  736  \n  737  /**\n  738:  * @brief get the read only socket handle of the SSL\n  739   */\n  740  int SSL_get_rfd(const SSL *ssl)\n  ...\n  750  \n  751  /**\n  752:  * @brief get the write only socket handle of the SSL\n  753   */\n  754  int SSL_get_wfd(const SSL *ssl)\n  ...\n  777  \n  778  /**\n  779:  * @brief bind the read only socket file description into the SSL\n  780   */\n  781  int SSL_set_rfd(SSL *ssl, int fd)\n  ...\n  790  \n  791  /**\n  792:  * @brief bind the write only socket file description into the SSL\n  793   */\n  794  int SSL_set_wfd(SSL *ssl, int fd)\n  ...\n  867  \n  868  /**\n  869:  * @brief set the SSL context read buffer length\n  870   */\n  871  void SSL_CTX_set_default_read_buffer_len(SSL_CTX *ctx, size_t len)\n  ...\n  873      SSL_ASSERT3(ctx);\n  874  \n  875:     ctx->read_buffer_len = (int)len;\n  876  }\n  877  \n  878  /**\n  879:  * @brief set the SSL read buffer length\n  880   */\n  881  void SSL_set_default_read_buffer_len(SSL *ssl, size_t len)\n  ...\n  968  \n  969  /**\n  970:  * @brief set the SSL if we can read as many as data\n  971   */\n  972  void SSL_set_read_ahead(SSL *ssl, int yes)\n  ...\n  974      SSL_ASSERT3(ssl);\n  975  \n  976:     ssl->rlayer.read_ahead = yes;\n  977  }\n  978  \n  979  /**\n  980:  * @brief set the SSL context if we can read as many as data\n  981   */\n  982  void SSL_CTX_set_read_ahead(SSL_CTX *ctx, int yes)\n  ...\n  984      SSL_ASSERT3(ctx);\n  985  \n  986:     ctx->read_ahead = yes;\n  987  }\n  988  \n  989  /**\n  990:  * @brief get the SSL ahead signal if we can read as many as data\n  991   */\n  992  int SSL_get_read_ahead(const SSL *ssl)\n  ...\n  994      SSL_ASSERT1(ssl);\n  995  \n  996:     return ssl->rlayer.read_ahead;\n  997  }\n  998  \n  999  /**\n 1000:  * @brief get the SSL context ahead signal if we can read as many as data\n 1001   */\n 1002  long SSL_CTX_get_read_ahead(SSL_CTX *ctx)\n ....\n 1004      SSL_ASSERT1(ctx);\n 1005  \n 1006:     return ctx->read_ahead;\n 1007  }\n 1008  \n 1009  /**\n 1010:  * @brief check if the SSL context can read as many as data\n 1011   */\n 1012  long SSL_CTX_get_default_read_ahead(SSL_CTX *ctx)\n ....\n 1014      SSL_ASSERT1(ctx);\n 1015  \n 1016:     return ctx->read_ahead;\n 1017  }\n 1018  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/mbedtls/wrapper/platform/ssl_pm.c:\n  133      ssl_pm->owner = ssl;\n  134  \n  135:     if (!ssl->ctx->read_buffer_len)\n  136: \t    ssl->ctx->read_buffer_len = 2048;\n  137  \n  138:     max_content_len = (unsigned int)ssl->ctx->read_buffer_len;\n  139:     // printf(\"ssl->ctx->read_buffer_len = %d ++++++++++++++++++++\\n\", ssl->ctx->read_buffer_len);\n  140  \n  141      mbedtls_net_init(&ssl_pm->fd);\n  ...\n  471      /*\n  472       * We can get a positive number, which may be less than len... that\n  473:      * much was sent successfully and you can call again to send more.\n  474       *\n  475       * We can get a negative mbedtls error code... if WANT_WRITE or WANT_READ,\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/openssl/openssl-ssl.c:\n  250  \t *  - If you get back SSL_ERROR_RETURN_ZERO then you know the connection\n  251  \t *    has been cleanly shutdown by the peer. To fully close the\n  252: \t *    connection you may choose to call SSL_shutdown() to send a\n  253  \t *    close_notify back.\n  254  \t *\n  ...\n  324  \n  325  \t/*\n  326: \t * if it was our buffer that limited what we read,\n  327  \t * check if SSL has additional data pending inside SSL buffers.\n  328  \t *\n  ...\n  367  \t/*\n  368  \t * If using OpenSSL type tls library, this is the last point for all\n  369: \t * paths before sending data into the tls tunnel, where you can dump it\n  370  \t * and see what is being sent.\n  371  \t */\n  ...\n  392  \tif (m != SSL_ERROR_SYSCALL) {\n  393  \t\tif (m == SSL_ERROR_WANT_READ || SSL_want_read(wsi->tls.ssl)) {\n  394: \t\t\tlwsl_notice(\"%s: want read\\n\", __func__);\n  395  \n  396  \t\t\treturn LWS_SSL_CAPABLE_MORE_SERVICE;\n  ...\n  400  \t\t\tlws_set_blocking_send(wsi);\n  401  \n  402: \t\t\tlwsl_debug(\"%s: want write\\n\", __func__);\n  403  \n  404  \t\t\treturn LWS_SSL_CAPABLE_MORE_SERVICE;\n  ...\n  580  \t\tif (n != SSL_ERROR_SYSCALL && n != SSL_ERROR_SSL) {\n  581  \t\t\tif (SSL_want_read(wsi->tls.ssl)) {\n  582: \t\t\t\tlwsl_debug(\"(wants read)\\n\");\n  583  \t\t\t\t__lws_change_pollfd(wsi, 0, LWS_POLLIN);\n  584  \t\t\t\treturn LWS_SSL_CAPABLE_MORE_SERVICE_READ;\n  585  \t\t\t}\n  586  \t\t\tif (SSL_want_write(wsi->tls.ssl)) {\n  587: \t\t\t\tlwsl_debug(\"(wants write)\\n\");\n  588  \t\t\t\t__lws_change_pollfd(wsi, 0, LWS_POLLOUT);\n  589  \t\t\t\treturn LWS_SSL_CAPABLE_MORE_SERVICE_WRITE;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/openssl/openssl-x509.c:\n  608  \n  609  #if defined(LWS_HAVE_RSA_SET0_KEY)\n  610: \t\t/* we don't need d... but the api wants to write it */\n  611  \t\tRSA_get0_key(rsapub,\n  612  \t\t\t    (const BIGNUM **)&mpi[LWS_GENCRYPTO_RSA_KEYEL_N],\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/openssl/openssl-server.c:\n  197  \t\t/*\n  198  \t\t * Although we have prepared update certs, we no longer have\n  199: \t\t * the rights to read our own cert + key we saved.\n  200  \t\t *\n  201  \t\t * If we were passed copies in memory buffers, use those\n  ...\n  249  \tif (lws_tls_alloc_pem_to_der_file(vhost->context, cert, mem_cert,\n  250  \t\t\t\t\t  mem_cert_len, &p, &flen)) {\n  251: \t\tlwsl_err(\"%s: couldn't read cert file\\n\", __func__);\n  252  \n  253  \t\treturn 1;\n  ...\n  308  \t\t/*\n  309  \t\t * Although we have prepared update certs, we no longer have\n  310: \t\t * the rights to read our own cert + key we saved.\n  311  \t\t *\n  312  \t\t * If we were passed copies in memory buffers, use those\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/openssl/openssl-client.c:\n 1016  \t\tif (lws_tls_alloc_pem_to_der_file(vh->context, NULL, cert_mem,\n 1017  \t\t\t\t\t\t  cert_mem_len, &p, &flen)) {\n 1018: \t\t\tlwsl_err(\"%s: couldn't read cert file\\n\", __func__);\n 1019  \n 1020  \t\t\treturn 1;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/jose/jws/jws.c:\n 1085  \tif (!info->jose_hdr) {\n 1086  \n 1087: \t\t/* get algorithm from 'alg' string and write minimal JOSE header */\n 1088  \t\tif (lws_gencrypto_jws_alg_to_definition(info->alg, &jose.alg)) {\n 1089  \t\t\tlwsl_err(\"%s: unknown alg %s\\n\", __func__, info->alg);\n ....\n 1295  \t * that was accessing the site when the links were generated.  And it\n 1296  \t * leaves an attacker not knowing what links to synthesize unless he\n 1297: \t * can read the token or pages generated with it.\n 1298  \t *\n 1299  \t * Using this is very good for security, but it implies you must refresh\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/jose/jws/jose.c:\n  249  \t/* array of strings */\n  250  \n  251: \tcase LJJHI_CRIT: /* Optional for send, REQUIRED: array of strings:\n  252  \t\t\t  * mustn't contain standardized strings or null set */\n  253  \t\tbreak;\n  ...\n  564  \t\t\tbreak;\n  565  \n  566: \t\tcase LJJHI_CRIT:/* Optional for send, REQUIRED: array of strings:\n  567  \t\t\t\t * mustn't contain standardized strings or null set */\n  568  \t\t\tif (!jose->e[n].buf)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/jose/jwe/jwe-rsa-aescbc.c:\n   80  \t/*\n   81  \t * Without changing the unencrypted CEK in EKEY, reallocate enough\n   82: \t * space to write the RSA-encrypted version in-situ.\n   83  \t */\n   84  \tif (lws_jws_dup_element(&jwe->jws.map, LJWE_EKEY, temp + (ot - *temp_len),\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/windows/windows-pipe.c:\n   43  \t/*\n   44  \t * Non-WSA HANDLEs can't join the WSAPoll() wait... use a UDP socket\n   45: \t * listening on 127.0.0.1:xxxx and send a byte to it from a second UDP\n   46  \t * socket to cancel the wait.\n   47  \t *\n   ..\n   60  \t/*\n   61  \t * No need for memset since it's in zalloc'd context... it's in the\n   62: \t * context so we can reuse the prepared sockaddr to send tp fd[0] whem\n   63  \t * we want to cancel the wait\n   64  \t */\n   ..\n  114  \t */\n  115  \n  116: \tn = sendto(fd[1], &u, 1, 0, (struct sockaddr *)si, sizeof(*si));\n  117  \n  118  \treturn n != 1;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/windows/windows-sockets.c:\n   46  \twsi_eff = wsi;\n   47  #endif\n   48: \t/* the fact we checked implies we avoided back-to-back writes */\n   49  \twsi_eff->could_have_pending = 0;\n   50  \n   51: \t/* treat the fact we got a truncated send pending as if we're choked */\n   52  \tif (lws_has_buffered_out(wsi_eff)\n   53  #if defined(LWS_WITH_HTTP_STREAM_COMPRESSION)\n   ..\n   64  lws_poll_listen_fd(struct lws_pollfd *fd)\n   65  {\n   66: \tfd_set readfds;\n   67  \tstruct timeval tv = { 0, 0 };\n   68  \n   69  \tassert((fd->events & LWS_POLLIN) == LWS_POLLIN);\n   70  \n   71: \tFD_ZERO(&readfds);\n   72: \tFD_SET(fd->fd, &readfds);\n   73  \n   74: \treturn select(((int)fd->fd) + 1, &readfds, NULL, NULL, &tv);\n   75  }\n   76  \n   ..\n  618  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  619  \n  620: \tret = send(fd, (const char *)buf, (unsigned int)len, 0);\n  621  \tif (ret >= 0)\n  622  \t\treturn ret;\n  ...\n  643  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  644  \n  645: \tret = (int)recv(fd, (char *)buf, (unsigned int)len, 0);\n  646  \tif (ret >= 0)\n  647  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/windows/windows-file.c:\n  160  \tint n;\n  161  \n  162: \tn = (int)write(fd, buf, (unsigned int)len);\n  163  \n  164  \tlseek(fd, 0, SEEK_SET);\n  ...\n  177  \t\treturn -1;\n  178  \n  179: \tm = (int)write(fd, buf, (unsigned int)len);\n  180  \tclose(fd);\n  181  \n  ...\n  190  \t\treturn -1;\n  191  \n  192: \tn = (int)read(fd, buf, (unsigned int)len);\n  193  \tclose(fd);\n  194  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/windows/windows-spawn.c:\n  436  #if 0\n  437  \n  438: \t\t/* read side is 0, stdin we want the write side, others read */\n  439  \n  440  \t\tlsp->stdwsi[n]->desc.filefd = lsp->pipe_fds[n][!!(n == 0)];\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-pipe.c:\n   74  \tint n;\n   75  \n   76: \tn = (int)write(pt->dummy_pipe_fds[1], &buf, 1);\n   77  \n   78  \treturn n != 1;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-misc.c:\n   68  #else\n   69  \t/* coverity[tainted_scalar] */\n   70: \treturn (size_t)read(context->fd_random, (char *)buf, len);\n   71  #endif\n   72  }\n   ..\n  100  \tssize_t n;\n  101  \n  102: \tn = write(fd, buf, len);\n  103  \n  104  \tif (n < 0 || fsync(fd))\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-sockets.c:\n   70  #endif\n   71  \n   72: \t/* the fact we checked implies we avoided back-to-back writes */\n   73  \twsi_eff->could_have_pending = 0;\n   74  \n   75: \t/* treat the fact we got a truncated send pending as if we're choked */\n   76  \tif (lws_has_buffered_out(wsi_eff)\n   77  #if defined(LWS_WITH_HTTP_STREAM_COMPRESSION)\n   ..\n   92  \t\treturn 1;\n   93  \n   94: \t/* okay to send another packet without blocking */\n   95  \n   96  \treturn 0;\n   ..\n  500  \tmemset(sll.sll_addr, 0xff, 6);\n  501  \n  502: \treturn (int)sendto(fd, p, n, 0, (struct sockaddr *)&sll, sizeof(sll));\n  503  #else\n  504  \tlwsl_err(\"%s: UNIMPLEMENTED on this platform\\n\", __func__);\n  ...\n  643  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  644  \n  645: \tret = (int)write(fd, buf, len);\n  646  \tif (ret >= 0)\n  647  \t\treturn ret;\n  ...\n  668  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  669  \n  670: \tret = (int)read(fd, buf, len);\n  671  \tif (ret >= 0)\n  672  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-spawn.c:\n  354  \t}\n  355  \n  356: \tr = read(fd, s, sizeof(s) - 1);\n  357  \tclose(fd);\n  358  \tif (r < 0) {\n  359: \t\tlwsl_err(\"%s: unable to read from /proc/self/cgroup\\n\", __func__);\n  360  \n  361  \t\treturn 1;\n  ...\n  475  \t\t\t   lsp->pipe_fds[n][n != 0]);\n  476  \n  477: \t\t/* read side is 0, stdin we want the write side, others read */\n  478  \n  479  \t\tlsp->stdwsi[n]->desc.sockfd = lsp->pipe_fds[n][n == 0];\n  ...\n  547  \t\t\t\tcfd = lws_open(pth, LWS_O_WRONLY);\n  548  \t\t\t\tif (cfd >= 0) {\n  549: \t\t\t\t\tif (write(cfd, \"threaded\", 8) != 8)\n  550: \t\t\t\t\t\tlwsl_warn(\"%s: failed to write threaded\\n\", __func__);\n  551  \n  552  \t\t\t\t\tclose(cfd);\n  ...\n  558  \t\t\t\tcfd = lws_open(pth, LWS_O_WRONLY);\n  559  \t\t\t\tif (cfd >= 0) {\n  560: \t\t\t\t\tif (write(cfd, \"max\", 3) != 3)\n  561: \t\t\t\t\t\tlwsl_warn(\"%s: failed to write max\\n\", __func__);\n  562  \n  563  \t\t\t\t\tclose(cfd);\n  ...\n  575  #endif\n  576  \n  577: \t/* we are ready with the redirection pipes... do the (v)fork */\n  578  #if defined(__sun) || !defined(LWS_HAVE_VFORK) || !defined(LWS_HAVE_EXECVPE)\n  579  \tlsp->child_pid = fork();\n  ...\n  652  \t\tif (fd >= 0) {\n  653  \t\t\tlen = lws_snprintf(pid_str, sizeof(pid_str) - 1, \"%d\", (int)getpid());\n  654: \t\t\tif (write(fd, pid_str, (size_t)len) != (ssize_t)len) {\n  655  \t\t\t\t/*\n  656  \t\t\t\t * using lwsl_err here is unsafe in vfork()\n  ...\n  675  \t\tlwsl_notice(\"%s: Failed to cd to /\\n\", __func__);\n  676  \n  677: \t/* cwd: somewhere we can at least read things and enter it */\n  678  \n  679  \twd = i->wd;\n  ...\n  817  \t}\n  818  \n  819: \tif (write(fd, \"+cpu +memory +pids +io\", 22) != 22)\n  820  \t\t/* ignore, may be there already or fail due to perms */\n  821  \t\tlwsl_debug(\"%s: setting admin cgroup options failed\\n\", __func__);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-resolv.c:\n   45  \t\treturn LADNS_CONF_SERVER_UNKNOWN;\n   46  \n   47: \tn = read(fd, r, context->pt_serv_buf_size - 1);\n   48  \tclose(fd);\n   49  \tif (n < 0)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-file.c:\n   55  \t\treturn 1;\n   56  \n   57: \tm = write(fd, buf, len);\n   58  \tclose(fd);\n   59  \n   ..\n   73  \t\treturn -1;\n   74  \n   75: \tn = read(fd, buf, len);\n   76  \tclose(fd);\n   77  \n   ..\n  152  \tssize_t n;\n  153  \n  154: \tn = read((int)fop_fd->fd, buf, (size_t)len);\n  155  \tif (n == -1l) {\n  156  \t\t*amount = 0;\n  ...\n  158  \t}\n  159  \tfop_fd->pos = (lws_filepos_t)(fop_fd->pos + (lws_filepos_t)n);\n  160: \tlwsl_debug(\"%s: read %ld of req %ld, pos %ld, len %ld\\n\", __func__,\n  161  \t\t\t(long)n, (long)len, (long)fop_fd->pos,\n  162  \t\t\t(long)fop_fd->len);\n  ...\n  172  \tssize_t n;\n  173  \n  174: \tn = write((int)fop_fd->fd, buf, (size_t)len);\n  175  \tif (n == -1) {\n  176  \t\t*amount = 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-service.c:\n  124  \t//\tn = poll(pt->fds, pt->fds_count, timeout_ms);\n  125  \t\t{\n  126: \t\t\tfd_set readfds, writefds, errfds;\n  127  \t\t\tstruct timeval tv = { timeout_us / LWS_US_PER_SEC,\n  128  \t\t\t\t\t      timeout_us % LWS_US_PER_SEC }, *ptv = &tv;\n  129  \t\t\tint max_fd = 0;\n  130: \t\t\tFD_ZERO(&readfds);\n  131: \t\t\tFD_ZERO(&writefds);\n  132  \t\t\tFD_ZERO(&errfds);\n  133  \n  ...\n  137  \t\t\t\t\tmax_fd = pt->fds[n].fd;\n  138  \t\t\t\tif (pt->fds[n].events & LWS_POLLIN)\n  139: \t\t\t\t\tFD_SET(pt->fds[n].fd, &readfds);\n  140  \t\t\t\tif (pt->fds[n].events & LWS_POLLOUT)\n  141: \t\t\t\t\tFD_SET(pt->fds[n].fd, &writefds);\n  142  \t\t\t\tFD_SET(pt->fds[n].fd, &errfds);\n  143  \t\t\t}\n  ...\n  145  \t\t\tvpt->inside_poll = 1;\n  146  \t\t\tlws_memory_barrier();\n  147: \t\t\tn = select(max_fd + 1, &readfds, &writefds, &errfds, ptv);\n  148  \t\t\tvpt->inside_poll = 0;\n  149  \t\t\tlws_memory_barrier();\n  ...\n  152  \t\t\tfor (m = 0; m < (int)pt->fds_count; m++) {\n  153  \t\t\t\tc = 0;\n  154: \t\t\t\tif (FD_ISSET(pt->fds[m].fd, &readfds)) {\n  155  \t\t\t\t\tpt->fds[m].revents |= LWS_POLLIN;\n  156  \t\t\t\t\tc = 1;\n  157  \t\t\t\t}\n  158: \t\t\t\tif (FD_ISSET(pt->fds[m].fd, &writefds)) {\n  159  \t\t\t\t\tpt->fds[m].revents |= LWS_POLLOUT;\n  160  \t\t\t\t\tc = 1;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-file.c:\n   88  \tlong n;\n   89  \n   90: \tn = read(fops_fd->fd, buf, len);\n   91  \tif (n == -1) {\n   92  \t\t*amount = 0;\n   ..\n  105  \tlong n;\n  106  \n  107: \tn = write(fops_fd->fd, buf, len);\n  108  \tif (n == -1) {\n  109  \t\t*amount = 0;\n  ...\n  177  }\n  178  \n  179: /* we write vhostname.cert.pem and vhostname.key.pem, 0 return means OK */\n  180  \n  181  int\n  ...\n  213  \tnvs_close(nvh);\n  214  \n  215: \tlwsl_notice(\"%s: read %s (%d)\\n\", __func__, filename, (int)s);\n  216  \n  217  \tif (n)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-pipe.c:\n   37  \t/*\n   38  \t * There's no pipe abstraction on lwip / freertos... use a UDP socket\n   39: \t * listening on 127.0.0.1:xxxx and send a byte to it from a second UDP\n   40  \t * socket to cancel the wait.\n   41  \t *\n   ..\n   54  \t/*\n   55  \t * No need for memset since it's in zalloc'd context... it's in the\n   56: \t * context so we can reuse the prepared sockaddr to send tp fd[0] whem\n   57  \t * we want to cancel the wait\n   58  \t */\n   ..\n  105  \t * Send a single UDP byte payload to the listening socket fd[0], forcing\n  106  \t * the event loop wait to wake.  fd[1] and context->frt_pipe_si are\n  107: \t * set at context creation and are static, the UDP sendto is supposed to\n  108  \t * be threadsafe for lwip:\n  109  \t *\n  ...\n  111  \t *\n  112  \t * Sockets generally can't be used by more than one application thread\n  113: \t * (on udp/raw netconn, doing a sendto/recv is currently possible).\n  114  \t */\n  115  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-sockets.c:\n   37  {\n   38  \tstruct lws *wsi_eff = wsi;\n   39: \tfd_set writefds;\n   40  \tstruct timeval tv = { 0, 0 };\n   41  \tint n;\n   ..\n   44  #endif\n   45  \n   46: \t/* the fact we checked implies we avoided back-to-back writes */\n   47  \twsi_eff->could_have_pending = 0;\n   48  \n   49: \t/* treat the fact we got a truncated send pending as if we're choked */\n   50  \tif (lws_has_buffered_out(wsi)\n   51  #if defined(LWS_WITH_HTTP_STREAM_COMPRESSION)\n   ..\n   56  \t\treturn 1;\n   57  \n   58: \tFD_ZERO(&writefds);\n   59: \tFD_SET(wsi_eff->desc.sockfd, &writefds);\n   60  \n   61: \tn = select(wsi_eff->desc.sockfd + 1, NULL, &writefds, NULL, &tv);\n   62  \tif (n < 0)\n   63  \t\treturn 1; /* choked */\n   ..\n   69  lws_poll_listen_fd(struct lws_pollfd *fd)\n   70  {\n   71: \tfd_set readfds;\n   72  \tstruct timeval tv = { 0, 0 };\n   73  \n   74: \tFD_ZERO(&readfds);\n   75: \tFD_SET(fd->fd, &readfds);\n   76  \n   77: \treturn select(fd->fd + 1, &readfds, NULL, NULL, &tv);\n   78  }\n   79  \n   ..\n  355  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  356  \n  357: \tret = write(fd, buf, len);\n  358  \tif (ret >= 0)\n  359  \t\treturn ret;\n  ...\n  380  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  381  \n  382: \tret = (int)read(fd, buf, len);\n  383  \tif (ret >= 0)\n  384  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/esp32/drivers/gpio-esp32.c:\n   32  \tswitch (flags & (LWSGGPIO_FL_READ | LWSGGPIO_FL_WRITE)) {\n   33  \tdefault:\n   34: \t\tlwsl_err(\"%s: neither read nor write\\n\", __func__);\n   35  \t\treturn;\n   36  \tcase LWSGGPIO_FL_READ:\n   ..\n   91  const lws_gpio_ops_t lws_gpio_plat = {\n   92  \t.mode\t\t\t= lws_gpio_esp32_mode,\n   93: \t.read\t\t\t= lws_gpio_esp32_read,\n   94  \t.set\t\t\t= lws_gpio_esp32_set,\n   95  \t.irq_mode\t\t= lws_gpio_esp32_irq_mode,\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/optee/network.c:\n   67  #endif\n   68  \n   69: \t/* the fact we checked implies we avoided back-to-back writes */\n   70  \twsi_eff->could_have_pending = 0;\n   71  \n   72: \t/* treat the fact we got a truncated send pending as if we're choked */\n   73  \tif (lws_has_buffered_out(wsi_eff)\n   74  #if defined(LWS_WITH_HTTP_STREAM_COMPRESSION)\n   ..\n   79  \t\treturn 1;\n   80  \n   81: \t/* okay to send another packet without blocking */\n   82  \n   83  \treturn 0;\n   ..\n  176  #if 0\n  177  \t\tif (pt->fds[n].fd == pt->dummy_pipe_fds[0]) {\n  178: \t\t\tif (read(pt->fds[n].fd, &buf, 1) != 1)\n  179: \t\t\t\tlwsl_err(\"Cannot read from dummy pipe.\");\n  180  \t\t\tcontinue;\n  181  \t\t}\n  ...\n  285  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  286  \n  287: \tret = write(fd, buf, len);\n  288  \tif (ret >= 0)\n  289  \t\treturn ret;\n  ...\n  310  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  311  \n  312: \tret = (int)read(fd, buf, len);\n  313  \tif (ret >= 0)\n  314  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/drivers/spi/bitbang/lws-bb-spi.c:\n   83  \t\tfor (n = 0; n < 8; n++) {\n   84  \t\t\tctx->gpio->set(ctx->clk, inv);\n   85: \t\t\tu = (u << 1) | !!ctx->gpio->read(ctx->miso);\n   86  \t\t\tctx->gpio->set(ctx->mosi, !!(u & 0x80));\n   87  \t\t\tctx->gpio->set(ctx->clk, !inv);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/drivers/i2c/lws-i2c.c:\n   35  \t\treturn 1;\n   36  \n   37: \tif (ctx->write(ctx, ads7 << 1)) {\n   38  \t\tctx->stop(ctx);\n   39  \n   ..\n   41  \t}\n   42  \n   43: \tctx->write(ctx, 0);\n   44: \tctx->write(ctx, c);\n   45  \tctx->stop(ctx);\n   46  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/drivers/i2c/bitbang/lws-bb-i2c.c:\n   47  \tctx->delay();\n   48  \n   49: \tif (!ctx->gpio->read(ctx->sda))\n   50  \t\treturn 1;\n   51  \n   ..\n   66  \tctx->delay();\n   67  \n   68: \twhile (!ctx->gpio->read(ctx->scl))\n   69  \t\t;\n   70  \n   ..\n   92  \tctx->gpio->set(ctx->scl, 1);\n   93  \tctx->delay();\n   94: \tn = ctx->gpio->read(ctx->sda);\n   95  \tctx->gpio->set(ctx->scl, 0);\n   96  \tctx->delay();\n   ..\n  112  \t\tctx->gpio->set(ctx->scl, 1);\n  113  \t\tctx->delay();\n  114: \t\tif (ctx->gpio->read(ctx->sda))\n  115  \t\t\tr |= 1 << n;\n  116  \t}\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/drivers/display/spd1656-spi.c:\n  121  \tconst lws_display_spd1656_spi_t *ea = lds_to_disp(priv->lds);\n  122  \n  123: \tif (ea->gpio->read(ea->busy_gpio) == level)\n  124  \t\treturn 0; /* good */\n  125  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/drivers/display/uc8176-spi.c:\n   31   * sequentially, ie, you must issue the whole frame of b0 and then the whole\n   32   * frame of b1s, you can't interleave them.  So we must create a private,\n   33:  * ephemeral side buffer for b1 data and send it afterwards (15KB heap during\n   34   * display update for 400 x 300)\n   35   *\n   ..\n  387  \tconst lws_display_uc8176_spi_t *ea = lds_to_disp(priv->lds);\n  388  \n  389: \tif (ea->gpio->read(ea->busy_gpio) == level)\n  390  \t\treturn 0; /* good */\n  391  \n  ...\n  546  \n  547  \t\t/*\n  548: \t\t * Finalize the write of the planes, LUT set then REFRESH\n  549  \t\t */\n  550  \n  ...\n  680  \t\t * line buffers for DMA ping-pong.\n  681  \t\t *\n  682: \t\t * Because it's planar in the two-plane case, we have to send\n  683  \t\t * plane 1 linewise, but buffer plane 2 into DMA-capable memory\n  684: \t\t * and send it after all of plane 1.\n  685  \t\t */\n  686  \n  ...\n  855  \t\t * If partial, we should only hear about lines within the region\n  856  \t\t * although the rasterizer may choose to rasterize from the top\n  857: \t\t * and skip sending us the lines above the partial in order to\n  858  \t\t * know what to put there.  It can end rasterization below the\n  859  \t\t * partial region.\n  860  \t\t *\n  861  \t\t * The renderer must apply any x offset to the line buffer\n  862: \t\t * before sending, this is so it's possible for renderers to\n  863  \t\t * ONLY prepare the partial region.\n  864  \t\t *\n  ...\n  973  \t\t\tlwsl_user(\"%s: sent partial start %u\\n\", __func__, desc.count_write);\n  974  \n  975: \t\t\t/* ... let that send while we start producing lines... */\n  976  \n  977  \t\t\tpriv->partbuf_pos = 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/drivers/display/ssd1675b-spi.c:\n  193  \tconst lws_display_ssd1675b_spi_t *ea = lds_to_disp(priv->lds);\n  194  \n  195: \tif (ea->gpio->read(ea->busy_gpio) == level)\n  196  \t\treturn 0; /* good */\n  197  \n  ...\n  281  \n  282  \t\t/*\n  283: \t\t * Finalize the write of the planes, LUT set then REFRESH\n  284  \t\t */\n  285  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/drivers/button/lws-button.c:\n  186  \t\t * done that, we can't tell if it's from before or after the\n  187  \t\t * mode change... ie, we don't know what the interrupt was\n  188: \t\t * telling us.  We can't trust the gpio state if we read it now\n  189  \t\t * to be related to what the irq from some time before was\n  190  \t\t * trying to tell us.  So always set it back to the same mode\n  ...\n  230  \t\t\t\tLWS_BUTTON_MON_TIMER_MS;\n  231  \n  232: \t\tactive = bc->gpio_ops->read(bc->button_map[n].gpio) ^\n  233  \t\t\t       (!(bc->active_state_bitmap & (1 << n)));\n  234  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/private-lib-roles.h:\n  229  /* perform user pollout */\n  230  typedef int (*lws_rops_perform_user_POLLOUT_t)(struct lws *wsi);\n  231: /* do effective callback on writeable */\n  232  typedef int (*lws_rops_callback_on_writable_t)(struct lws *wsi);\n  233  /* connection-specific tx credit in bytes */\n  234  typedef int (*lws_rops_tx_credit_t)(struct lws *wsi, char peer_to_us, int add);\n  235: /* role-specific write formatting */\n  236  typedef int (*lws_rops_write_role_protocol_t)(struct lws *wsi,\n  237  \t\t\t\t\t      unsigned char *buf, size_t len,\n  ...\n  283  \tlws_rops_callback_on_writable_t\t\tcallback_on_writable;\n  284  \tlws_rops_tx_credit_t\t\t\ttx_credit;\n  285: \tlws_rops_write_role_protocol_t\t\twrite_role_protocol;\n  286  \tlws_rops_encapsulation_parent_t\t\tencapsulation_parent;\n  287  \tlws_rops_alpn_negotiated_t\t\talpn_negotiated;\n  ...\n  343  \t * (just client applies if no concept of client or server)\n  344  \t */\n  345: \tuint8_t\t\t\twriteable_cb[2];\n  346  \t/*\n  347  \t * the callback reasons for CLOSE for client, server\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/ws/client-ws.c:\n  138  \t */\n  139  \tif (lws_get_random(wsi->a.context, hash, 16) != 16) {\n  140: \t\tlwsl_wsi_err(wsi, \"Unable to read from random dev %s\",\n  141  \t\t\t SYSTEM_RANDOM_FILEPATH);\n  142  \t\treturn NULL;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/ws/private-lib-roles-ws.h:\n  113  \tunsigned int all_zero_nonce:1;\n  114  \tunsigned int this_frame_masked:1;\n  115: \tunsigned int inside_frame:1; /* next write will be more of frame */\n  116  \tunsigned int clean_buffer:1; /* buffer not rewritten by extension */\n  117  \tunsigned int payload_is_close:1; /* process as PONG, but it is close */\n  ...\n  122  \tunsigned int defeat_check_utf8:1;\n  123  \tunsigned int stashed_write_pending:1;\n  124: \tunsigned int send_check_ping:1;\n  125  \tunsigned int first_fragment:1;\n  126  \tunsigned int peer_has_sent_close:1;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/ws/server-ws.c:\n  179  \n  180  \t\t\t/*\n  181: \t\t\t * The client may send a bunch of different option\n  182  \t\t\t * sets for the same extension, we are supposed to\n  183  \t\t\t * pick one we like the look of.  The option sets are\n  ...\n  548  \t\tint n = wsi->a.vhost->default_protocol_index;\n  549  \t\t/*\n  550: \t\t * Some clients only have one protocol and do not send the\n  551  \t\t * protocol list header... allow it and match to the vhost's\n  552  \t\t * default protocol (which itself defaults to zero).\n  ...\n  747  \t * enable on this connection, and give him back the list.\n  748  \t *\n  749: \t * Give him a limited write bugdet.\n  750  \t *\n  751  \t * This appends a closing CRLF before returning, if h1\n  ...\n  769  \tLWS_CPYAPP(p, \"\\x0d\\x0a\");\n  770  \n  771: \t/* okay send the handshake response accepting the connection */\n  772  \n  773  \tlwsl_parser(\"issuing resp pkt %d len\\n\",\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/ws/ops-ws.c:\n  465  \t\t\t}\n  466  \t\t\tif (lwsi_state(wsi) == LRS_RETURNED_CLOSE)\n  467: \t\t\t\t/* if he sends us 2 CLOSE, kill him */\n  468  \t\t\t\tgoto ret_asking_close;\n  469  \n  ...\n  512  \n  513  \t\tcase LWSWSOPC_PING:\n  514: \t\t\tlwsl_info(\"received %d byte ping, sending pong\\n\",\n  515  \t\t\t\t\t\t (int)wsi->ws->rx_ubuf_head);\n  516  \n  ...\n  644  #if !defined(LWS_WITHOUT_EXTENSIONS)\n  645  \t\t\tif (rx_draining_ext && !pmdrx.eb_out.len) {\n  646: \t\t\t\tlwsl_debug(\"   --- ending drain on 0 read\\n\");\n  647  \t\t\t\tgoto already_done;\n  648  \t\t\t}\n  ...\n  825  \tn = lws_get_random(lws_get_context(wsi), wsi->ws->mask, 4);\n  826  \tif (n != 4) {\n  827: \t\tlwsl_parser(\"Unable to read from random device %s %d\\n\",\n  828  \t\t\t    SYSTEM_RANDOM_FILEPATH, (int)n);\n  829  \t\treturn 1;\n  ...\n  860  \twsi->ws->rx_ubuf_alloc = (uint32_t)n;\n  861  \n  862: \t/* notify user code that we're ready to roll */\n  863  \n  864  \tif (wsi->a.protocol->callback)\n  ...\n 1005  \t}\n 1006  \n 1007: \t/* 1: something requested a callback when it was OK to write */\n 1008  \n 1009  \tif ((pollfd->revents & LWS_POLLOUT) &&\n ....\n 1065  \t\tif (wsi1 && lws_has_buffered_out(wsi1))\n 1066  \t\t\t/* We cannot deal with any kind of new RX\n 1067: \t\t\t * because we are dealing with a partial send\n 1068  \t\t\t * (new RX may trigger new http_action() that\n 1069: \t\t\t * expect to be able to send)\n 1070  \t\t\t */\n 1071  \t\t\treturn LWS_HPI_RET_HANDLED;\n ....\n 1103  \t/* 3: buflist needs to be drained\n 1104  \t */\n 1105: read:\n 1106  \t//lws_buflist_describe(&wsi->buflist, wsi, __func__);\n 1107  \tebuf.len = (int)lws_buflist_next_segment_len(&wsi->buflist,\n ....\n 1128  \t\t/*\n 1129  \t\t * In case we are going to react to this rx by scheduling\n 1130: \t\t * writes, we need to restrict the amount of rx to the size\n 1131  \t\t * the protocol reported for rx buffer.\n 1132  \t\t *\n 1133  \t\t * Otherwise we get a situation we have to absorb possibly a\n 1134: \t\t * lot of reads before we get a chance to drain them by writing\n 1135  \t\t * them, eg, with echo type tests in autobahn.\n 1136  \t\t */\n ....\n 1154  \t\tswitch (ebuf.len) {\n 1155  \t\tcase 0:\n 1156: \t\t\tlwsl_info(\"%s: zero length read\\n\",\n 1157  \t\t\t\t  __func__);\n 1158  \t\t\treturn LWS_HPI_RET_PLEASE_CLOSE_ME;\n ....\n 1167  \n 1168  \t\t/*\n 1169: \t\t * coverity thinks ssl_capable_read() may read over\n 1170  \t\t * 2GB.  Dissuade it...\n 1171  \t\t */\n ....\n 1245  #if !defined(LWS_WITHOUT_EXTENSIONS)\n 1246  \t\t\twhile (wsi->ws->rx_draining_ext) {\n 1247: \t\t\t\t// RX Extension needs to be drained before next read\n 1248  \t\t\t\tif (lws_ws_rx_sm(wsi, ALREADY_PROCESSED_IGNORE_CHAR, 0) ==\n 1249  \t\t\t\t\t\t\tLWS_HPI_RET_PLEASE_CLOSE_ME)\n ....\n 1251  \t\t\t}\n 1252  #endif\n 1253: \t\t\tgoto read;\n 1254  \t\t}\n 1255  \t\telse\n ....\n 1280  rops_handle_POLLOUT_ws(struct lws *wsi)\n 1281  {\n 1282: \tint write_type = LWS_WRITE_PONG;\n 1283  #if !defined(LWS_WITHOUT_EXTENSIONS)\n 1284  \tstruct lws_ext_pm_deflate_rx_ebufs pmdrx;\n ....\n 1298  \n 1299  \tif (lwsi_state(wsi) == LRS_WAITING_TO_SEND_CLOSE) {\n 1300: \t\tlwsl_debug(\"sending close packet\\n\");\n 1301  \t\tlwsl_hexdump_debug(&wsi->ws->ping_payload_buf[LWS_PRE],\n 1302  \t\t\t\t   wsi->ws->close_in_ping_buffer_len);\n ....\n 1321  \t}\n 1322  \n 1323: \t/* else, the send failed and we should just hang up */\n 1324  \n 1325  \tif ((lwsi_role_ws(wsi) && wsi->ws->pong_pending_flag) ||\n ....\n 1328  \n 1329  \t\tif (wsi->ws->payload_is_close)\n 1330: \t\t\twrite_type = LWS_WRITE_CLOSE;\n 1331  \t\telse {\n 1332  \t\t\tif (wsi->wsistate_pre_close) {\n ....\n 1340  \n 1341  \t\tn = lws_write(wsi, &wsi->ws->pong_payload_buf[LWS_PRE],\n 1342: \t\t\t      wsi->ws->pong_payload_len, (enum lws_write_protocol)write_type);\n 1343  \t\tif (n < 0)\n 1344  \t\t\treturn LWS_HP_RET_BAIL_DIE;\n ....\n 1357  \n 1358  \tif (!wsi->socket_is_permanently_unusable &&\n 1359: \t    wsi->ws->send_check_ping) {\n 1360  \n 1361  \t\tlwsl_info(\"%s: issuing ping on wsi %s: %s %s h2: %d\\n\", __func__,\n ....\n 1363  \t\t\t\twsi->role_ops->name, wsi->a.protocol->name,\n 1364  \t\t\t\twsi->mux_substream);\n 1365: \t\twsi->ws->send_check_ping = 0;\n 1366  \t\tn = lws_write(wsi, &wsi->ws->ping_payload_buf[LWS_PRE],\n 1367  \t\t\t      0, LWS_WRITE_PING);\n ....\n 1372  \t}\n 1373  \n 1374: \t/* Priority 4: if we are closing, not allowed to send more data frags\n 1375  \t *\t       which means user callback or tx ext flush banned now\n 1376  \t */\n ....\n 1379  \n 1380  #if !defined(LWS_WITHOUT_EXTENSIONS)\n 1381: \t/* Priority 5: Tx path extension with more to send\n 1382  \t *\n 1383  \t *\t       These are handled as new fragments each time around\n 1384: \t *\t       So while we must block new writeable callback to enforce\n 1385  \t *\t       payload ordering, but since they are always complete\n 1386  \t *\t       fragments control packets can interleave OK.\n ....\n 1440  \t\t\tret = 1;\n 1441  \n 1442: \t\t/* assuming they gave us something to send, send it */\n 1443  \n 1444  \t\tif (pmdrx.eb_in.len) {\n ....\n 1534  \t\treturn 0;\n 1535  \n 1536: \tlwsl_debug(\"%s: sending close indication...\\n\", __func__);\n 1537  \n 1538  \t/* if no prepared close reason, use 1000 and no aux data */\n ....\n 1662  \t    ((*wp) & 0x1f) == LWS_WRITE_HTTP_HEADERS_CONTINUATION ||\n 1663  \t    ((*wp) & 0x1f) == LWS_WRITE_HTTP_HEADERS)\n 1664: \t\tgoto send_raw;\n 1665  \n 1666  \n ....\n 1681  \t * something, it will be a complete fragment of the length known at\n 1682  \t * the time (just the fragment length known), and if he has\n 1683: \t * more we will come back next time he is writeable and allow him to\n 1684  \t * produce more fragments until he's drained.\n 1685  \t *\n 1686: \t * This allows what is sent each time it is writeable to be limited to\n 1687: \t * a size that can be sent without partial sends or blocking, allows\n 1688  \t * interleaving of control frames and other connection service.\n 1689  \t */\n ....\n 1711  \n 1712  \t\tif (n == PMDR_HAS_PENDING) {\n 1713: \t\t\tlwsl_ext(\"%s: HAS PENDING: write drain len %d \"\n 1714  \t\t\t\t    \"(wp 0x%x) SETTING tx_draining_ext \"\n 1715  \t\t\t\t    \"(remaining in %d)\\n\", __func__,\n ....\n 1724  \t\t\tlws_callback_on_writable(wsi);\n 1725  \t\t\t/*\n 1726: \t\t\t * keep a copy of the write type for the overall\n 1727  \t\t\t * action that has provoked generation of these\n 1728  \t\t\t * fragments, so the last guy can use its FIN state.\n ....\n 1757  \t\t * ext might eat it, but not have anything to issue yet.\n 1758  \t\t * In that case we have to follow his lead, but stash and\n 1759: \t\t * replace the write type that was lost here the first time.\n 1760  \t\t */\n 1761  \t\tif (len && !pmdrx.eb_out.len) {\n ....\n 1810  \t\t\tbreak;\n 1811  \t\tdefault:\n 1812: \t\t\tlwsl_warn(\"lws_write: unknown write opc / wp\\n\");\n 1813  \t\t\treturn -1;\n 1814  \t\t}\n ....\n 1886  \t\treturn lws_rops_func_fidx(encap->role_ops,\n 1887  \t\t\t\t   LWS_ROPS_write_role_protocol).\n 1888: \t\t\t\t\twrite_role_protocol(wsi, buf - pre,\n 1889  \t\t\t\t\t\t\t    len + (unsigned int)pre, wp);\n 1890  \t}\n ....\n 1898  \t\t\t/*\n 1899  \t\t\t * give any active extensions a chance to munge the\n 1900: \t\t\t * buffer before send.  We pass in a pointer to an\n 1901  \t\t\t * lws_tokens struct prepared with the default buffer\n 1902  \t\t\t * and content length that's in there.  Rather than\n ....\n 1911  \t\t\t * buffers\n 1912  \t\t\t *\n 1913: \t\t\t * This takes care of holding the buffer if send is\n 1914  \t\t\t * incomplete, ie, if wsi->ws->clean_buffer is 0\n 1915  \t\t\t * (meaning an extension meddled with the buffer).  If\n ....\n 1945  \t}\n 1946  \n 1947: send_raw:\n 1948  \treturn lws_issue_raw(wsi, (unsigned char *)buf - pre, len + (unsigned int)pre);\n 1949  }\n ....\n 2091  \t\tus = (uint64_t)lws_now_usecs();\n 2092  \t\tmemcpy(&wsi->ws->ping_payload_buf[LWS_PRE], &us, 8);\n 2093: \t\twsi->ws->send_check_ping = 1;\n 2094  \t\tlws_callback_on_writable(wsi);\n 2095  \t}\n ....\n 2105  \t/*  5 */ { .handle_POLLOUT\t    = rops_handle_POLLOUT_ws },\n 2106  \t/*  6 */ { .callback_on_writable    = rops_callback_on_writable_ws },\n 2107: \t/*  7 */ { .write_role_protocol\t    = rops_write_role_protocol_ws },\n 2108  \t/*  8 */ { .close_via_role_protocol = rops_close_via_role_protocol_ws },\n 2109  \t/*  9 */ { .close_role\t\t    = rops_close_role_ws },\n ....\n 2145  \t/* rx_cb clnt, srv */\t\t{ LWS_CALLBACK_CLIENT_RECEIVE,\n 2146  \t\t\t\t\t  LWS_CALLBACK_RECEIVE },\n 2147: \t/* writeable cb clnt, srv */\t{ LWS_CALLBACK_CLIENT_WRITEABLE,\n 2148  \t\t\t\t\t  LWS_CALLBACK_SERVER_WRITEABLE },\n 2149  \t/* close cb clnt, srv */\t{ LWS_CALLBACK_CLIENT_CLOSED,\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/ws/client-parser-ws.c:\n  575  \n  576  \t\tcase LWSWSOPC_PING:\n  577: \t\t\tlwsl_wsi_info(wsi, \"received %d byte ping, sending pong\",\n  578  \t\t\t\t  (int)wsi->ws->rx_ubuf_head);\n  579  \n  ...\n  692  #if !defined(LWS_WITHOUT_EXTENSIONS)\n  693  \t\t\tif (rx_draining_ext && !pmdrx.eb_out.len) {\n  694: \t\t\t\tlwsl_wsi_debug(wsi, \"   --- ending drain on 0 read result\");\n  695  \t\t\t\tgoto already_done;\n  696  \t\t\t}\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/ws/ext/extension.c:\n  280  \t\t\twsi->ws->clean_buffer = 0;\n  281  \n  282: \t\t/* assuming they left us something to send, send it */\n  283  \n  284  \t\tif (ebuf.len) {\n  ...\n  319  \t\t/*\n  320  \t\t * Yes, he's choked.  Don't spill the rest now get a callback\n  321: \t\t * when he is ready to send and take care of it there\n  322  \t\t */\n  323  \t\tlws_callback_on_writable(wsi);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/ws/ext/extension-permessage-deflate.c:\n  270  \t\t *  - we used everything that could be drained on the input side\n  271  \t\t *\n  272: \t\t * ...then put back the 00 00 FF FF the sender stripped as our\n  273  \t\t * input to zlib\n  274  \t\t */\n  ...\n  483  \t\t    !pen &&\n  484  \t\t    pmdrx->eb_out.len >= 4) {\n  485: \t\t\t// lwsl_wsi_err(wsi, \"Trimming 4 from end of write\");\n  486  \t\t\tpriv->tx.next_out -= 4;\n  487  \t\t\tpriv->tx.avail_out += 4;\n  ...\n  526  \t\t/*\n  527  \t\t * we may have not produced any output for the actual \"first\"\n  528: \t\t * write... in that case, we need to fix up the inappropriate\n  529: \t\t * use of CONTINUATION when the first real write does come.\n  530  \t\t */\n  531  \t\tif (priv->tx_first_frame_type & 0xf) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/netlink/ops-netlink.c:\n   88  \tmsg.msg_iovlen\t\t= 1;\n   89  \n   90: \tn = (unsigned int)recvmsg(wsi->desc.sockfd, &msg, 0);\n   91  \tif ((int)n < 0) {\n   92: \t\tlwsl_cx_notice(cx, \"recvmsg failed\");\n   93  \t\treturn LWS_HPI_RET_PLEASE_CLOSE_ME;\n   94  \t}\n   ..\n   98  \th = (struct nlmsghdr *)s;\n   99  \n  100: \t/* we can get a bunch of messages coalesced in one read*/\n  101  \n  102  \tfor ( ; NLMSG_OK(h, n); h = NLMSG_NEXT(h, n)) {\n  ...\n  649  \tmsg.msg_namelen\t\t= sizeof(sanl);\n  650  \n  651: \tn = (int)sendmsg(wsi->desc.sockfd, (struct msghdr *)&msg, 0);\n  652  \tif (n < 0) {\n  653  \t\tlwsl_cx_notice(context, \"rt dump req failed... permissions? errno %d\",\n  ...\n  711  \t/* adoption_cb clnt, srv */\t{ 0, 0 },\n  712  \t/* rx_cb clnt, srv */\t\t{ 0, 0 },\n  713: \t/* writeable cb clnt, srv */\t{ 0, 0 },\n  714  \t/* close cb clnt, srv */\t{ 0, 0 },\n  715  \t/* protocol_bind_cb c,s */\t{ 0, 0 },\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/dbus/dbus.c:\n  566  \t/* adoption_cb clnt, srv */\t{ 0, 0 },\n  567  \t/* rx_cb clnt, srv */\t\t{ 0, 0 },\n  568: \t/* writeable cb clnt, srv */\t{ 0, 0 },\n  569  \t/* close cb clnt, srv */\t{ 0, 0 },\n  570  \t/* protocol_bind_cb c,s */\t{ 0, 0 },\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/h1/ops-h1.c:\n   87  #endif\n   88  \t\t    )\n   89: \t\t\t /* we gave the read buffer to RAW handler already */\n   90: \t\t\tgoto read_ok;\n   91  \n   92  \t\t/*\n   ..\n   94  \t\t * rx flow control has stopped us dealing with this early,\n   95  \t\t * but lws_handshake_server doesn't update len for us.\n   96: \t\t * Figure out how much was read, so that we can proceed\n   97  \t\t * appropriately:\n   98  \t\t */\n   ..\n  101  \t\tif (!wsi->hdr_parsing_completed)\n  102  \t\t\t/* More header content on the way */\n  103: \t\t\tgoto read_ok;\n  104  \n  105  \t\tswitch (lwsi_state(wsi)) {\n  106  \t\t\tcase LRS_ESTABLISHED:\n  107  \t\t\tcase LRS_HEADERS:\n  108: \t\t\t\tgoto read_ok;\n  109  \t\t\tcase LRS_ISSUING_FILE:\n  110: \t\t\t\tgoto read_ok;\n  111  \t\t\tcase LRS_DISCARD_BODY:\n  112  \t\t\tcase LRS_BODY:\n  ...\n  135  \t\twhile (len && (!wsi->http.content_length_given || wsi->http.rx_content_remain)) {\n  136  \t\t\t/* Copy as much as possible, up to the limit of:\n  137: \t\t\t * what we have in the read buffer (len)\n  138  \t\t\t * remaining portion of the POST body (content_remain)\n  139  \t\t\t */\n  ...\n  301  \t}\n  302  \n  303: read_ok:\n  304  \t/* Nothing more to do for now */\n  305: //\tlwsl_info(\"%s: %p: read_ok, used %ld (len %d, state %d)\\n\", __func__,\n  306  //\t\t  wsi, (long)(buf - oldbuf), (int)len, wsi->state);\n  307  \n  ...\n  338  \t\tgoto try_pollout;\n  339  \n  340: \t/* any incoming data ready? */\n  341  \n  342  \tif (!(pollfd->revents & pollfd->events & LWS_POLLIN))\n  ...\n  359  \t/*\n  360  \t * We haven't processed that the tunnel is set up yet, so\n  361: \t * defer reading\n  362  \t */\n  363  \n  ...\n  387  \t\t *\n  388  \t\t * We will not notice a connection close until the buflist is\n  389: \t\t * exhausted and we tried to do a read of some kind.\n  390  \t\t */\n  391  \n  ...\n  395  \t\tswitch (ebuf.len) {\n  396  \t\tcase 0:\n  397: \t\t\tlwsl_info(\"%s: read 0 len a\\n\", __func__);\n  398  \t\t\twsi->seen_zero_length_recv = 1;\n  399  \t\t\tif (lws_change_pollfd(wsi, LWS_POLLIN, 0))\n  ...\n  498  \t}\n  499  \n  500: \t/* clear back-to-back write detection */\n  501  \twsi->could_have_pending = 0;\n  502  \n  ...\n  529  \t\t\t\t\t\twsi->user_space, NULL, 0);\n  530  \t\tif (n < 0) {\n  531: \t\t\tlwsl_info(\"writeable_fail\\n\");\n  532  \t\t\tgoto fail;\n  533  \t\t}\n  ...\n  542  \t * We'll get a LWS_CALLBACK_HTTP_FILE_COMPLETION callback when\n  543  \t * it's done.  That's the case even if we just completed the\n  544: \t * send, so wait for that.\n  545  \t */\n  546  \tn = lws_serve_http_file_fragment(wsi);\n  ...\n  571  \t\t * h1 staggered spins here in IDLING if we don't close it.\n  572  \t\t * It shows POLLIN but the tls connection returns ERROR if\n  573: \t\t * you try to read it.\n  574  \t\t */\n  575  \n  ...\n  606  \t\tif (lws_rops_fidx(wsi->role_ops, LWS_ROPS_write_role_protocol) &&\n  607  \t\t    lws_rops_func_fidx(wsi->role_ops, LWS_ROPS_write_role_protocol).\n  608: \t\t\t\t\twrite_role_protocol(wsi, NULL, 0, &wp) < 0) {\n  609  \t\t\tlwsl_info(\"%s signalling to close\\n\", __func__);\n  610  \t\t\treturn LWS_HPI_RET_PLEASE_CLOSE_ME;\n  ...\n  666  \t\t * other in or out before that happens.\n  667  \t\t *\n  668: \t\t * simply mark ourselves as having readable data\n  669  \t\t * and turn off our POLLIN\n  670  \t\t */\n  ...\n  675  \t\t//lwsl_notice(\"calling back %s\\n\", wsi->a.protocol->name);\n  676  \n  677: \t\t/* let user code know, he'll usually ask for writeable\n  678  \t\t * callback and drain / re-enable it there\n  679  \t\t */\n  ...\n  740  \t\t\t\tn = lws_write(wsi, prebuf + LWS_PRE, len, LWS_WRITE_HTTP);\n  741  \t\t\t\tif (n < 0) {\n  742: \t\t\t\t\tlwsl_err(\"%s: PROXY_BODY: write %d failed\\n\",\n  743  \t\t\t\t\t\t __func__, (int)len);\n  744  \t\t\t\t\treturn LWS_HP_RET_BAIL_DIE;\n  ...\n  754  \t\t\t}\n  755  \n  756: \t\t\tlwsl_wsi_info(wsi, \"nothing to send\");\n  757  #if defined(LWS_ROLE_H1) || defined(LWS_ROLE_H2)\n  758  \t\t\t/* prepare ourselves to do the parsing */\n  ...\n  858  \t\t * mandatory.\n  859  \t\t *\n  860: \t\t * Knowing this lets us proceed with sending pipelined headers\n  861  \t\t * before we received the first response headers.\n  862  \t\t */\n  ...\n 1118  \t/*  2 */ { .handle_POLLIN\t  = rops_handle_POLLIN_h1 },\n 1119  \t/*  3 */ { .handle_POLLOUT\t  = rops_handle_POLLOUT_h1 },\n 1120: \t/*  4 */ { .write_role_protocol\t  = rops_write_role_protocol_h1 },\n 1121  \t/*  5 */ { .alpn_negotiated\t  = rops_alpn_negotiated_h1 },\n 1122  \t/*  6 */ { .close_kill_connection = rops_close_kill_connection_h1 },\n ....\n 1173  \t/* rx_cb clnt, srv */\t\t{ LWS_CALLBACK_RECEIVE_CLIENT_HTTP,\n 1174  \t\t\t\t\t  0 /* may be POST, etc */ },\n 1175: \t/* writeable cb clnt, srv */\t{ LWS_CALLBACK_CLIENT_HTTP_WRITEABLE,\n 1176  \t\t\t\t\t  LWS_CALLBACK_HTTP_WRITEABLE },\n 1177  \t/* close cb clnt, srv */\t{ LWS_CALLBACK_CLOSED_CLIENT_HTTP,\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/mqtt/private-lib-roles-mqtt.h:\n  368  \n  369  #if defined(LWS_WITH_CLIENT)\n  370: \tuint8_t \t\tsend_pingreq:1;\n  371  \tuint8_t\t\t\tsession_resumed:1;\n  372  #endif\n  ...\n  376  \tuint8_t\t\t\tinside_birth:1;\n  377  \tuint8_t\t\t\tinside_resume_session:1;\n  378: \tuint8_t \t\tsend_puback:1;\n  379: \tuint8_t \t\tsend_pubrel:1;\n  380: \tuint8_t \t\tsend_pubrec:1;\n  381: \tuint8_t \t\tsend_pubcomp:1;\n  382  \tuint8_t\t\t\tunacked_publish:1;\n  383  \tuint8_t\t\t\tunacked_pubrel:1;\n  ...\n  387  \tuint8_t\t\t\tinside_shadow:1;\n  388  \tuint8_t\t\t\tdone_shadow_subscribe:1;\n  389: \tuint8_t\t\t\tsend_shadow_unsubscribe:1;\n  390  };\n  391  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/mqtt/mqtt.c:\n  556  \t\t\t\tlwsl_notice(\"%s: server sent non-CONNACK\\n\",\n  557  \t\t\t\t\t\t__func__);\n  558: \t\t\t\tgoto send_protocol_error_and_close;\n  559  \t\t\t}\n  560  #endif /* LWS_WITH_CLIENT */\n  ...\n  572  \t\t\t\t\t    par->packet_type_flags, n, (int)len + 1);\n  573  \t\t\t\tlwsl_hexdump_err(buf - 1, len + 1);\n  574: \t\t\t\tgoto send_protocol_error_and_close;\n  575  \t\t\t}\n  576  \n  ...\n  604  \t\t\tdefault:\n  605  \t\t\t\tlwsl_notice(\"%s: bad vbi\\n\", __func__);\n  606: \t\t\t\tgoto send_protocol_error_and_close;\n  607  \t\t\t}\n  608  \t\t\tbreak;\n  ...\n  619  \t\t\t\t\t\t  __func__, par->s_temp.len,\n  620  \t\t\t\t\t\t  par->s_temp.buf);\n  621: \t\t\t\t\tgoto send_unsupp_connack_and_close;\n  622  \t\t\t\t}\n  623  \t\t\t\tpar->state = LMQCPP_CONNECT_VH_PVERSION;\n  ...\n  625  \t\t\tdefault:\n  626  \t\t\t\tlwsl_notice(\"%s: bad protocol name\\n\", __func__);\n  627: \t\t\t\tgoto send_protocol_error_and_close;\n  628  \t\t\t}\n  629  \t\t\tbreak;\n  ...\n  635  \t\t\t\tlwsl_info(\"%s: unsupported MQTT version %d\\n\",\n  636  \t\t\t\t\t  __func__, par->conn_protocol_version);\n  637: \t\t\t\tgoto send_unsupp_connack_and_close;\n  638  \t\t\t}\n  639  \t\t\tpar->state = LMQCPP_CONNECT_VH_FLAGS;\n  ...\n  650  \t\t\t\t */\n  651  \t\t\t\tpar->reason = LMQCP_REASON_MALFORMED_PACKET;\n  652: \t\t\t\tgoto send_reason_and_close;\n  653  \t\t\t}\n  654  \t\t\t/*\n  ...\n  671  \t\t\tdefault:\n  672  \t\t\t\tlwsl_notice(\"%s: ka bad vbi\\n\", __func__);\n  673: \t\t\t\tgoto send_protocol_error_and_close;\n  674  \t\t\t}\n  675  \t\t\tbreak;\n  ...\n  679  \t\t\t/* second byte of PINGRESP must be zero */\n  680  \t\t\tif (*buf++)\n  681: \t\t\t\tgoto send_protocol_error_and_close;\n  682  \t\t\tgoto cmd_completion;\n  683  \n  ...\n  695  \t\t\tdefault:\n  696  \t\t\t\tlwsl_notice(\"%s: connpr bad vbi\\n\", __func__);\n  697: \t\t\t\tgoto send_protocol_error_and_close;\n  698  \t\t\t}\n  699  \t\t\tbreak;\n  ...\n  711  \t\t\t\t\t   __func__, (int)par->cpkt_remlen);\n  712  \t\t\t\tif (par->cpkt_remlen < 2)\n  713: \t\t\t\t\tgoto send_protocol_error_and_close;\n  714  \t\t\t\tpar->state = LMQCPP_PUBREC_VH_PKT_ID;\n  715  \t\t\t\tbreak;\n  716  \t\t\tdefault:\n  717  \t\t\t\tlwsl_notice(\"%s: pubrec bad vbi\\n\", __func__);\n  718: \t\t\t\tgoto send_protocol_error_and_close;\n  719  \t\t\t}\n  720  \t\t\tbreak;\n  ...\n  747  \t\t\t\t\t   __func__, (int)par->cpkt_remlen);\n  748  \t\t\t\tif (par->cpkt_remlen < 2)\n  749: \t\t\t\t\tgoto send_protocol_error_and_close;\n  750  \t\t\t\tpar->state = LMQCPP_PUBREL_VH_PKT_ID;\n  751  \t\t\t\tbreak;\n  752  \t\t\tdefault:\n  753  \t\t\t\tlwsl_err(\"%s: pubrel bad vbi\\n\", __func__);\n  754: \t\t\t\tgoto send_protocol_error_and_close;\n  755  \t\t\t}\n  756  \t\t\tbreak;\n  ...\n  783  \t\t\t\t\t   __func__, (int)par->cpkt_remlen);\n  784  \t\t\t\tif (par->cpkt_remlen < 2)\n  785: \t\t\t\t\tgoto send_protocol_error_and_close;\n  786  \t\t\t\tpar->state = LMQCPP_PUBCOMP_VH_PKT_ID;\n  787  \t\t\t\tbreak;\n  788  \t\t\tdefault:\n  789  \t\t\t\tlwsl_err(\"%s: pubcmp bad vbi\\n\", __func__);\n  790: \t\t\t\tgoto send_protocol_error_and_close;\n  791  \t\t\t}\n  792  \t\t\tbreak;\n  ...\n  811  \t\t\t\tlwsl_notice(\"%s: Topic rx before subscribing\\n\",\n  812  \t\t\t\t\t    __func__);\n  813: \t\t\t\tgoto send_protocol_error_and_close;\n  814  \t\t\t}\n  815  \t\t\tlwsl_info(\"%s: received PUBLISH pkt\\n\", __func__);\n  ...\n  830  \t\t\tdefault:\n  831  \t\t\t\tlwsl_notice(\"%s: pubrem bad vbi\\n\", __func__);\n  832: \t\t\t\tgoto send_protocol_error_and_close;\n  833  \t\t\t}\n  834  \t\t\tbreak;\n  ...\n  857  \t\t\t\tlwsl_notice(\"%s: zero topic len\\n\", __func__);\n  858  \t\t\t\tpar->reason = LMQCP_REASON_MALFORMED_PACKET;\n  859: \t\t\t\tgoto send_reason_and_close;\n  860  \t\t\t}\n  861  \t\t\tlwsl_debug(\"%s: PUBLISH topic len %d\\n\",\n  ...\n  904  \t\t\t\tlws_free_set_NULL(pub->topic);\n  905  \t\t\t\tlws_free_set_NULL(wsi->mqtt->rx_cpkt_param);\n  906: \t\t\t\tgoto send_reason_and_close;\n  907  \t\t\t}\n  908  \t\t\tbreak;\n  ...\n  940  \t\t\t\tlwsl_err(\"%s: Uninitialized pub_param\\n\",\n  941  \t\t\t\t\t\t__func__);\n  942: \t\t\t\tgoto send_protocol_error_and_close;\n  943  \t\t\t}\n  944  \n  ...\n  951  \t\t\t\tlwsl_err(\"%s: CONNACK is only Server to Client\",\n  952  \t\t\t\t\t\t__func__);\n  953: \t\t\t\tgoto send_unsupp_connack_and_close;\n  954  \t\t\t}\n  955  \n  ...\n  964  \t\t\t\t\t   __func__, (int)par->cpkt_remlen);\n  965  \t\t\t\tif (par->cpkt_remlen != 2)\n  966: \t\t\t\t\tgoto send_protocol_error_and_close;\n  967  \n  968  \t\t\t\tpar->state = LMQCPP_CONNACK_VH_FLAGS;\n  ...\n  970  \t\t\tdefault:\n  971  \t\t\t\tlwsl_notice(\"%s: connack bad vbi\\n\", __func__);\n  972: \t\t\t\tgoto send_protocol_error_and_close;\n  973  \t\t\t}\n  974  \t\t\tbreak;\n  ...\n  987  \t\t\t\t */\n  988  \t\t\t\tpar->reason = LMQCP_REASON_MALFORMED_PACKET;\n  989: \t\t\t\tgoto send_reason_and_close;\n  990  \t\t\t}\n  991  \t\t\t/*\n  ...\n 1010  \t\t\tif ((c->conn_flags & LMQCFT_CLEAN_START) &&\n 1011  \t\t\t    (par->cpkt_flags & LMQCFT_SESSION_PRESENT))\n 1012: \t\t\t\tgoto send_protocol_error_and_close;\n 1013  \n 1014  \t\t\twsi->mqtt->session_resumed = ((unsigned int)par->cpkt_flags &\n ....\n 1023  \t\t\tlen--;\n 1024  \t\t\t/*\n 1025: \t\t\t * If a server sends a CONNACK packet containing a\n 1026  \t\t\t * non-zero return code it MUST then close the Network\n 1027  \t\t\t * Connection [MQTT-3.2.2-5]\n ....\n 1037  \t\t\t\tpar->reason = LMQCP_REASON_UNSUPPORTED_PROTOCOL +\n 1038  \t\t\t\t\t\tpar->conn_rc - 1;\n 1039: \t\t\t\tgoto send_reason_and_close;\n 1040  \t\t\tdefault:\n 1041  \t\t\t\tlwsl_notice(\"%s: bad connack retcode\\n\", __func__);\n 1042: \t\t\t\tgoto send_protocol_error_and_close;\n 1043  \t\t\t}\n 1044  \t\t\tbreak;\n ....\n 1049  \t\t\t\tlwsl_err(\"%s: SUBACK is only Server to Client\",\n 1050  \t\t\t\t\t\t__func__);\n 1051: \t\t\t\tgoto send_unsupp_connack_and_close;\n 1052  \t\t\t}\n 1053  \n ....\n 1062  \t\t\t\t\t   __func__, (int)par->cpkt_remlen);\n 1063  \t\t\t\tif (par->cpkt_remlen <= 2)\n 1064: \t\t\t\t\tgoto send_protocol_error_and_close;\n 1065  \t\t\t\tpar->state = LMQCPP_SUBACK_VH_PKT_ID;\n 1066  \t\t\t\tbreak;\n 1067  \t\t\tdefault:\n 1068  \t\t\t\tlwsl_notice(\"%s: suback bad vbi\\n\", __func__);\n 1069: \t\t\t\tgoto send_protocol_error_and_close;\n 1070  \t\t\t}\n 1071  \t\t\tbreak;\n ....\n 1099  \t\t\t\t\tbreak;\n 1100  \t\t\t\tcase FAILURE_QOS_LEVEL:\n 1101: \t\t\t\t\tgoto send_protocol_error_and_close;\n 1102  \n 1103  \t\t\t\tdefault:\n 1104  \t\t\t\t\tpar->reason = LMQCP_REASON_MALFORMED_PACKET;\n 1105: \t\t\t\t\tgoto send_reason_and_close;\n 1106  \t\t\t}\n 1107  \n ....\n 1119  \t\t\t\tlwsl_err(\"%s: UNSUBACK is only Server to Client\",\n 1120  \t\t\t\t\t\t__func__);\n 1121: \t\t\t\tgoto send_unsupp_connack_and_close;\n 1122  \t\t\t}\n 1123  \n ....\n 1132  \t\t\t\t\t   __func__, (int)par->cpkt_remlen);\n 1133  \t\t\t\tif (par->cpkt_remlen < 2)\n 1134: \t\t\t\t\tgoto send_protocol_error_and_close;\n 1135  \t\t\t\tpar->state = LMQCPP_UNSUBACK_VH_PKT_ID;\n 1136  \t\t\t\tbreak;\n 1137  \t\t\tdefault:\n 1138  \t\t\t\tlwsl_notice(\"%s: unsuback bad vbi\\n\", __func__);\n 1139: \t\t\t\tgoto send_protocol_error_and_close;\n 1140  \t\t\t}\n 1141  \t\t\tbreak;\n ....\n 1172  \t\t\t\tif (par->cpkt_remlen <= 1 ||\n 1173  \t\t\t\t    par->cpkt_remlen == 3)\n 1174: \t\t\t\t\tgoto send_protocol_error_and_close;\n 1175  \n 1176  \t\t\t\tpar->state = LMQCPP_PUBACK_VH_PKT_ID;\n ....\n 1181  \t\t\tdefault:\n 1182  \t\t\t\tlwsl_notice(\"%s: puback bad vbi\\n\", __func__);\n 1183: \t\t\t\tgoto send_protocol_error_and_close;\n 1184  \t\t\t}\n 1185  \t\t\tbreak;\n ....\n 1234  \t\t\tdefault:\n 1235  \t\t\t\tlwsl_notice(\"%s: puback pr bad vbi\\n\", __func__);\n 1236: \t\t\t\tgoto send_protocol_error_and_close;\n 1237  \t\t\t}\n 1238  \t\t\tbreak;\n ....\n 1417  \t\t\t\t\treturn -1;\n 1418  \t\t\t\t}\n 1419: \t\t\t\twsi->mqtt->send_pubrel = 1;\n 1420  \t\t\t\tlws_callback_on_writable(wsi);\n 1421  \t\t\t\tbreak;\n ....\n 1451  \t\t\t\tlwsl_err(\"%s: cmd_completion: PUBREL\\n\",\n 1452  \t\t\t\t\t\t__func__);\n 1453: \t\t\t\twsi->mqtt->send_pubcomp = 1;\n 1454  \t\t\t\tlws_callback_on_writable(wsi);\n 1455  \t\t\t\tbreak;\n ....\n 1683  \n 1684  \t\t\t\tif (pub->qos == 1) {\n 1685: \t\t\t\t/* For QOS = 1, send out PUBACK */\n 1686: \t\t\t\t\twsi->mqtt->send_puback = 1;\n 1687  \t\t\t\t\tlws_callback_on_writable(wsi);\n 1688  \t\t\t\t} else if (pub->qos == 2) {\n 1689: \t\t\t\t/* For QOS = 2, send out PUBREC */\n 1690: \t\t\t\t\twsi->mqtt->send_pubrec = 1;\n 1691  \t\t\t\t\tlws_callback_on_writable(wsi);\n 1692  \t\t\t\t}\n ....\n 1715  \t\t\t\t\tlwsl_notice(\"%s: undef prop id 0x%x\\n\",\n 1716  \t\t\t\t\t\t  __func__, (int)par->vbit.value);\n 1717: \t\t\t\t\tgoto send_protocol_error_and_close;\n 1718  \t\t\t\t}\n 1719  \t\t\t\tif (!(property_valid[par->vbit.value] &\n ....\n 1723  \t\t\t\t\t\t  (int)par->vbit.value,\n 1724  \t\t\t\t\t\t  ctl_pkt_type(par));\n 1725: \t\t\t\t\tgoto send_protocol_error_and_close;\n 1726  \t\t\t\t}\n 1727  \t\t\t\tpar->prop_id = par->vbit.value;\n ....\n 1750  \t\t\tdefault:\n 1751  \t\t\t\tlwsl_notice(\"%s: prop id bad vbi\\n\", __func__);\n 1752: \t\t\t\tgoto send_protocol_error_and_close;\n 1753  \t\t\t}\n 1754  \t\t\tbreak;\n ....\n 1773  \t\t\tlen--;\n 1774  \t\t\tif (lws_mqtt_pconsume(par, 1))\n 1775: \t\t\t\tgoto send_protocol_error_and_close;\n 1776  \t\t\tbreak;\n 1777  \n ....\n 1791  \t\t\tcase LMSPR_COMPLETED:\n 1792  \t\t\t\tif (lws_mqtt_pconsume(par, par->vbit.consumed))\n 1793: \t\t\t\t\tgoto send_protocol_error_and_close;\n 1794  \t\t\t\tbreak;\n 1795  \t\t\tdefault:\n 1796: \t\t\t\tgoto send_protocol_error_and_close;\n 1797  \t\t\t}\n 1798  \t\t\tbreak;\n ....\n 1813  \t\t\tcase LMSPR_COMPLETED:\n 1814  \t\t\t\tif (lws_mqtt_pconsume(par, par->vbit.consumed))\n 1815: \t\t\t\t\tgoto send_protocol_error_and_close;\n 1816  \t\t\t\tbreak;\n 1817  \t\t\tdefault:\n 1818: \t\t\t\tgoto send_protocol_error_and_close;\n 1819  \t\t\t}\n 1820  \t\t\tbreak;\n ....\n 1841  \t\t\tcase LMSPR_COMPLETED:\n 1842  \t\t\t\tif (lws_mqtt_pconsume(par, par->s_temp.len))\n 1843: \t\t\t\t\tgoto send_protocol_error_and_close;\n 1844  \t\t\t\tbreak;\n 1845  \n 1846  \t\t\tdefault:\n 1847  \t\t\t\tlwsl_info(\"%s: bad protocol name\\n\", __func__);\n 1848: \t\t\t\tgoto send_protocol_error_and_close;\n 1849  \t\t\t}\n 1850  \t\t\tbreak;\n ....\n 1866  oom:\n 1867  \tlwsl_err(\"%s: OOM!\\n\", __func__);\n 1868: \tgoto send_protocol_error_and_close;\n 1869  \n 1870  singular_prop_seen_twice:\n 1871  \tlwsl_info(\"%s: property appears twice\\n\", __func__);\n 1872  \n 1873: send_protocol_error_and_close:\n 1874  \tlwsl_notice(\"%s: peac\\n\", __func__);\n 1875  \tpar->reason = LMQCP_REASON_PROTOCOL_ERROR;\n 1876  \n 1877: send_reason_and_close:\n 1878  \tlwsl_notice(\"%s: srac\\n\", __func__);\n 1879  \tpar->flag_pending_send_reason_close = 1;\n 1880  \tgoto ask;\n 1881  \n 1882: send_unsupp_connack_and_close:\n 1883  \tlwsl_notice(\"%s: unsupac\\n\", __func__);\n 1884  \tpar->reason = LMQCP_REASON_UNSUPPORTED_PROTOCOL;\n ....\n 1980  \tif (wsi->mqtt->inside_payload) {\n 1981  \t\t/*\n 1982: \t\t * Headers are filled, we are sending\n 1983  \t\t * the payload - a buffer with LWS_PRE\n 1984  \t\t * in front it.\n ....\n 2070  \tif (lws_write(nwsi, start, lws_ptr_diff_size_t(p, start), LWS_WRITE_BINARY) !=\n 2071  \t\t\tlws_ptr_diff(p, start)) {\n 2072: \t\tlwsl_err(\"%s: write failed\\n\", __func__);\n 2073  \t\treturn 1;\n 2074  \t}\n ....\n 2312  \tstruct lws *nwsi = lws_get_network_wsi(wsi);\n 2313  \tlws_mqtt_str_t mqtt_vh_payload;\n 2314: \tuint8_t send_unsub[8], orphaned;\n 2315  \tuint32_t rem_len, n;\n 2316  \tlws_mqtt_subs_t *mysub;\n ....\n 2324  \tcase LRS_ESTABLISHED: /* Protocol connection established */\n 2325  \t\torphaned = 0;\n 2326: \t\tmemset(&send_unsub, 0, sizeof(send_unsub));\n 2327  \t\tfor (n = 0; n < unsub->num_topics; n++) {\n 2328  \t\t\tmysub = lws_mqtt_find_sub(nwsi->mqtt,\n ....\n 2331  \n 2332  \t\t\tif (mysub && --mysub->ref_count == 0) {\n 2333: \t\t\t\tlwsl_notice(\"%s: Need to send UNSUB\\n\", __func__);\n 2334: \t\t\t\tsend_unsub[n] = 1;\n 2335  \t\t\t\torphaned++;\n 2336  \t\t\t}\n ....\n 2342  \t\t\t * topics.\n 2343  \t\t\t *\n 2344: \t\t\t * So, don't send UNSUB to server, and just fake the\n 2345  \t\t\t * UNSUB ACK event for the guy going away.\n 2346  \t\t\t */\n ....\n 2382  \t\trem_len = 2;\n 2383  \t\tfor (n = 0; n < unsub->num_topics; n++)\n 2384: \t\t\tif (send_unsub[n])\n 2385  \t\t\t\trem_len += (2 + (uint32_t)strlen(unsub->topic[n].name));\n 2386  \n ....\n 2425  \t\t\t * from the server\n 2426  \t\t\t */\n 2427: \t\t\tif (!send_unsub[n])\n 2428  \t\t\t\tcontinue;\n 2429  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/mqtt/ops-mqtt.c:\n   76  \t}\n   77  \n   78: \t/* 1: something requested a callback when it was OK to write */\n   79  \n   80  \tif ((pollfd->revents & LWS_POLLOUT) &&\n   ..\n   89  \t/* 3: buflist needs to be drained\n   90  \t */\n   91: read:\n   92  \t// lws_buflist_describe(&wsi->buflist, wsi, __func__);\n   93  \tebuf.len = (int)lws_buflist_next_segment_len(&wsi->buflist, &ebuf.token);\n   ..\n  110  \t\t/*\n  111  \t\t * In case we are going to react to this rx by scheduling\n  112: \t\t * writes, we need to restrict the amount of rx to the size\n  113  \t\t * the protocol reported for rx buffer.\n  114  \t\t *\n  115  \t\t * Otherwise we get a situation we have to absorb possibly a\n  116: \t\t * lot of reads before we get a chance to drain them by writing\n  117  \t\t * them, eg, with echo type tests in autobahn.\n  118  \t\t */\n  ...\n  133  \t\tswitch (ebuf.len) {\n  134  \t\tcase 0:\n  135: \t\t\tlwsl_info(\"%s: zero length read\\n\",\n  136  \t\t\t\t  __func__);\n  137  \t\t\treturn LWS_HPI_RET_PLEASE_CLOSE_ME;\n  ...\n  146  \n  147  \t\t/*\n  148: \t\t * coverity thinks ssl_capable_read() may read over\n  149  \t\t * 2GB.  Dissuade it...\n  150  \t\t */\n  ...\n  176  \t\tpending = pending > wsi->a.context->pt_serv_buf_size ?\n  177  \t\t\twsi->a.context->pt_serv_buf_size : pending;\n  178: \t\tgoto read;\n  179  \t}\n  180  \n  ...\n  280  \n  281  #if defined(LWS_WITH_CLIENT)\n  282: \tif (wsi->mqtt && wsi->mqtt->send_pingreq && !wsi->mqtt->inside_payload) {\n  283  \t\tuint8_t buf[LWS_PRE + 2];\n  284  \n  285  \t\t/*\n  286: \t\t * We are swallowing this POLLOUT in order to send a PINGREQ\n  287  \t\t * autonomously\n  288  \t\t */\n  289  \n  290: \t\twsi->mqtt->send_pingreq = 0;\n  291  \n  292  \t\tlwsl_notice(\"%s: issuing PINGREQ\\n\", __func__);\n  ...\n  303  #endif\n  304  \tif (wsi->mqtt && !wsi->mqtt->inside_payload &&\n  305: \t    (wsi->mqtt->send_pubrec || wsi->mqtt->send_pubrel ||\n  306: \t     wsi->mqtt->send_pubcomp)) {\n  307  \t\tuint8_t buf[LWS_PRE + 4];\n  308  \t\t/* Remaining len = 2 */\n  309  \t\tbuf[LWS_PRE + 1] = 2;\n  310: \t\tif (wsi->mqtt->send_pubrec) {\n  311  \t\t\tlwsl_notice(\"%s: issuing PUBREC for pkt id: %d\\n\",\n  312  \t\t\t\t    __func__, wsi->mqtt->peer_ack_pkt_id);\n  ...\n  315  \t\t\tlws_ser_wu16be(&buf[LWS_PRE + 2],\n  316  \t\t\t\t       wsi->mqtt->peer_ack_pkt_id);\n  317: \t\t\twsi->mqtt->send_pubrec = 0;\n  318: \t\t} else if (wsi->mqtt->send_pubrel) {\n  319  \t\t\tlwsl_notice(\"%s: issuing PUBREL for pkt id: %d\\n\",\n  320  \t\t\t\t    __func__, wsi->mqtt->ack_pkt_id);\n  ...\n  322  \t\t\tlws_ser_wu16be(&buf[LWS_PRE + 2],\n  323  \t\t\t\t       wsi->mqtt->ack_pkt_id);\n  324: \t\t\twsi->mqtt->send_pubrel = 0;\n  325  \t\t} else {\n  326  \t\t\tlwsl_notice(\"%s: issuing PUBCOMP for pkt id: %d\\n\",\n  ...\n  329  \t\t\tlws_ser_wu16be(&buf[LWS_PRE + 2],\n  330  \t\t\t\t       wsi->mqtt->peer_ack_pkt_id);\n  331: \t\t\twsi->mqtt->send_pubcomp = 0;\n  332  \t\t}\n  333  \t\tif (lws_write(wsi, (uint8_t *)&buf[LWS_PRE], 4,\n  ...\n  364  \t\t/*\n  365  \t\t * If the nwsi is in the middle of a frame, we can only\n  366: \t\t * continue to send that\n  367  \t\t */\n  368  \n  ...\n  385  \t\tif (lwsi_state(wsi) == LRS_ESTABLISHED &&\n  386  \t\t    !wsi->mqtt->inside_payload &&\n  387: \t\t    wsi->mqtt->send_puback) {\n  388  \t\t\tuint8_t buf[LWS_PRE + 4];\n  389  \t\t\tlwsl_notice(\"%s: issuing PUBACK for pkt id: %d\\n\",\n  ...\n  401  \t\t\t\treturn LWS_HP_RET_BAIL_DIE;\n  402  \n  403: \t\t\twsi->mqtt->send_puback = 0;\n  404  \t\t\tw->mux.requested_POLLOUT = 1;\n  405  \n  ...\n  439  \t}\n  440  \n  441: \tnwsi->mqtt->send_pingreq = 1;\n  442  \tlws_callback_on_writable(nwsi);\n  443  \n  ...\n  523  \t    !lws_h2_tx_cr_get(wsi)) {\n  524  \t\t/*\n  525: \t\t * other side is not able to cope with us sending DATA\n  526  \t\t * anything so no matter if we have POLLOUT on our side if it's\n  527: \t\t * DATA we want to send.\n  528  \t\t *\n  529  \t\t * Delay waiting for our POLLOUT until peer indicates he has\n  ...\n  657  \t.rx_cb =\t\t\t{ LWS_CALLBACK_MQTT_CLIENT_RX,\n  658  \t\t\t\t\t  LWS_CALLBACK_MQTT_CLIENT_RX },\n  659: \t.writeable_cb =\t\t\t{ LWS_CALLBACK_MQTT_CLIENT_WRITEABLE,\n  660  \t\t\t\t\t  LWS_CALLBACK_MQTT_CLIENT_WRITEABLE },\n  661  \t.close_cb =\t\t\t{ LWS_CALLBACK_MQTT_CLIENT_CLOSED,\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/mqtt/client/client-mqtt.c:\n  289  \tcase LRS_MQTTC_IDLE:\n  290  \t\t/*\n  291: \t\t * we should be ready to send out MQTT CONNECT\n  292  \t\t */\n  293: \t\tlwsl_info(\"%s: %s: Transport established, send out CONNECT\\n\",\n  294  \t\t\t\t__func__, lws_wsi_tag(wsi));\n  295  \t\tif (lws_change_pollfd(wsi, LWS_POLLOUT, 0))\n  296  \t\t\treturn -1;\n  297  \t\tif (!lws_mqtt_client_send_connect(wsi)) {\n  298: \t\t\tlwsl_err(\"%s: Unable to send MQTT CONNECT\\n\", __func__);\n  299  \t\t\treturn -1;\n  300  \t\t}\n  ...\n  322  \t\tswitch (ebuf.len) {\n  323  \t\tcase 0:\n  324: \t\t\tlwsl_info(\"%s: zero length read\\n\",\n  325  \t\t\t\t  __func__);\n  326  \t\t\tgoto fail;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/mqtt/client/client-mqtt-handshake.c:\n  166  \n  167  \t/*\n  168: \t * Perform the actual write\n  169  \t */\n  170  \tif (lws_write(wsi, (unsigned char *)&b[LWS_PRE], lws_ptr_diff_size_t(p, start),\n  171  \t\t  LWS_WRITE_BINARY) != lws_ptr_diff(p, start)) {\n  172: \t\tlwsl_notice(\"%s: write failed\\n\", __func__);\n  173  \n  174  \t\treturn NULL;\n  ...\n  192  \tif (lws_write(wsi, (unsigned char *)&b[LWS_PRE], lws_ptr_diff_size_t(p, start),\n  193  \t\t\t\tLWS_WRITE_BINARY) != lws_ptr_diff(p, start)) {\n  194: \t\tlwsl_err(\"%s: write failed\\n\", __func__);\n  195  \n  196  \t\treturn NULL;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/parsers.c:\n  132  \t    lws_buflist_next_segment_len(&wsi->buflist, NULL) &&\n  133  \t    autoservice) {\n  134: \t\tlwsl_debug(\"%s: service on readbuf ah\\n\", __func__);\n  135  \n  136  \t\tpt = &wsi->a.context->pt[(int)wsi->tsi];\n  ...\n 1408  \t\t\t\t/*\n 1409  \t\t\t\t * WSORIGIN is protocol equiv to ORIGIN,\n 1410: \t\t\t\t * JWebSocket likes to send it, map to ORIGIN\n 1411  \t\t\t\t */\n 1412  \t\t\t\tif (n == WSI_TOKEN_SWORIGIN)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/private-lib-roles-http.h:\n   83  \tint pos;\n   84  \tenum range_states state;\n   85: \tchar start_valid, end_valid, ctr, count_ranges, did_try, inside, send_ctr;\n   86  };\n   87  \n   ..\n  231  \tstruct lws *ah_wait_list;\n  232  \n  233: \tunsigned long\t\twriteable_len;\n  234  \n  235  #if defined(LWS_WITH_FILE_OPS)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/cookie.c:\n  503  \n  504  \t\t\t\tif (c.f[CE_HOSTONLY] && !hostdomain){\n  505: \t\t\t\t\tlwsl_cookie(\"%s: not sending this\\n\",\n  506  \t\t\t\t\t\t\t__func__);\n  507  \t\t\t\t\tcontinue;\n  ...\n  678  \n  679  \t\tif (lws_cookie_write_nsc(wsi, &c))\n  680: \t\t\tlwsl_err(\"%s:failed to write nsc\\n\", __func__);\n  681  \t}\n  682  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/header.c:\n  225  \t\t\t *  - h1 connection\n  226  \t\t\t *  - http compression transform active\n  227: \t\t\t *  - did not send content length\n  228  \t\t\t *\n  229  \t\t\t * then mark as chunked...\n  ...\n  497  \t\t * the pipe being choked or SSL_WANT_.\n  498  \t\t *\n  499: \t\t * However we do need to send the human-readable body, and the\n  500  \t\t * END_STREAM.\n  501  \t\t *\n  ...\n  508  \n  509  \t\t/*\n  510: \t\t * ... but stash the body and send it as a priority next\n  511  \t\t * handle_POLLOUT\n  512  \t\t */\n  ...\n  528  \t\t/*\n  529  \t\t * for http/1, we can just append the body after the finalized\n  530: \t\t * headers and send it all in one go.\n  531  \t\t */\n  532  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/client/client-http.c:\n  113  \t\t}\n  114  \n  115: \t\tn = (int)recv(wsi->desc.sockfd, sb, context->pt_serv_buf_size, 0);\n  116  \t\tif (n < 0) {\n  117  \t\t\tif (LWS_ERRNO == LWS_EAGAIN) {\n  118: \t\t\t\tlwsl_debug(\"Proxy read EAGAIN... retrying\\n\");\n  119  \t\t\t\treturn 0;\n  120  \t\t\t}\n  121: \t\t\tlwsl_err(\"ERROR reading from proxy socket\\n\");\n  122: \t\t\tcce = \"proxy read err\";\n  123  \t\t\tgoto bail3;\n  124  \t\t}\n  ...\n  199  \t\t/*\n  200  \t\t * lws_client_create_tls() can already have done the\n  201: \t\t * whole tls setup and preface send... if so he set our state\n  202  \t\t * to LRS_H1C_ISSUE_HANDSHAKE2... let's proceed but be prepared\n  203  \t\t * to notice our state and not resend the preface...\n  ...\n  243  \n  244  \t\t\t/*\n  245: \t\t\t * send the H2 preface to legitimize the connection\n  246  \t\t\t *\n  247  \t\t\t * transitions us to LRS_H2_WAITING_TO_SEND_HEADERS\n  ...\n  249  \t\t\tif (wsi->client_h2_alpn)\n  250  \t\t\t\tif (lws_h2_issue_preface(wsi)) {\n  251: \t\t\t\t\tcce = \"error sending h2 preface\";\n  252  \t\t\t\t\tgoto bail3;\n  253  \t\t\t\t}\n  ...\n  282  \t\t}\n  283  \n  284: \t\t/* send our request to the server */\n  285  \n  286: \t\tlwsl_info(\"%s: HANDSHAKE2: %s: sending headers \"\n  287  \t\t\t  \"(wsistate 0x%lx), w sock %d\\n\",\n  288  \t\t\t  __func__, lws_wsi_tag(wsi),\n  ...\n  408  \t\t * coalesce both handshake response and websocket traffic\n  409  \t\t * in one packet, since at that point the connection is\n  410: \t\t * definitively ready from browser pov.\n  411  \t\t */\n  412  \t\twhile (wsi->http.ah->parser_state != WSI_PARSING_COMPLETE) {\n  ...\n  417  \t\t\teb.len = 0;\n  418  \t\t\tbuffered = lws_buflist_aware_read(pt, wsi, &eb, 0, __func__);\n  419: \t\t\tlwsl_debug(\"%s: buflist-aware-read %d %d\\n\", __func__,\n  420  \t\t\t\t\tbuffered, eb.len);\n  421  \t\t\tif (eb.len == LWS_SSL_CAPABLE_MORE_SERVICE)\n  422  \t\t\t\treturn 0;\n  423  \t\t\tif (buffered < 0 || eb.len < 0) {\n  424: \t\t\t\tcce = \"read failed\";\n  425  \t\t\t\tgoto bail3;\n  426  \t\t\t}\n  ...\n  560  \t */\n  561  \n  562: \t/* otherwise set ourselves up ready to go again */\n  563  \tlwsi_set_state(wsi, LRS_WAITING_SERVER_REPLY);\n  564  \n  ...\n  624  \tint m, ml, fi;\n  625  \n  626: \t/* Did he send auth? */\n  627  \tml = lws_hdr_total_length(wsi, WSI_TOKEN_HTTP_WWW_AUTHENTICATE);\n  628  \tif (!ml)\n  ...\n  927  \n  928  \t\t/*\n  929: \t\t * Keep track of digest auth to send it at next attempt, lws_client_reset will free it\n  930  \t\t*/\n  931  \n  ...\n 1291  #endif\n 1292  \n 1293: \t/* he may choose to send us stuff in chunked transfer-coding */\n 1294  \twsi->chunked = 0;\n 1295  \twsi->chunk_remaining = 0; /* ie, next thing is chunk size */\n ....\n 1685  \tif (wsi->flags & LCCSCF_HTTP_X_WWW_FORM_URLENCODED) {\n 1686  \t\tp += lws_snprintf(p, lws_ptr_diff_size_t(end, p), \"Content-Type: application/x-www-form-urlencoded\\x0d\\x0a\");\n 1687: \t\tp += lws_snprintf(p,  lws_ptr_diff_size_t(end, p), \"Content-Length: %lu\\x0d\\x0a\", wsi->http.writeable_len);\n 1688  \t\tlws_client_http_body_pending(wsi, 1);\n 1689  \t}\n ....\n 1748  \t/*\n 1749  \t * If the caller provided a non-NULL *buf and nonzero *len, we should\n 1750: \t * use that as the buffer for the read action, limititing it to *len\n 1751  \t * (actual payload will be less if chunked headers inside).\n 1752  \t *\n ....\n 1934  \t\t\t}\n 1935  \t\t} else\n 1936: \t\t\tlwsl_notice(\"%s: swallowed read (%d)\\n\", __func__, n);\n 1937  \t}\n 1938  \n ....\n 2002   * port:\tport to connect to\n 2003   * path:\turi path to connect to on the new server\n 2004:  * host:\thost header to send to the new server\n 2005   */\n 2006  struct lws *\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/compression/stream.c:\n  157  \tif (ctx->buflist_comp) {\n  158  \t\t/*\n  159: \t\t * we can't send this new stuff when we have old stuff\n  160  \t\t * buffered and not compressed yet.  Add it to the tail\n  161  \t\t * and switch to trying to process the head.\n  ...\n  211  \tif (!use && ilen_iused != len) {\n  212  \t\t /*\n  213: \t\t  * ...we were sending stuff from the caller directly and not\n  214  \t\t  * all of it got processed... stash on the buflist tail\n  215  \t\t  */\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/server/access-log.c:\n  188  \tass[sizeof(ass) - 1] = '\\0';\n  189  \n  190: \tif ((int)write(wsi->a.vhost->log_fd, ass, (size_t)l) != l)\n  191: \t\tlwsl_err(\"Failed to write log\\n\");\n  192  \n  193  \tif (wsi->http.access_log.header_log) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/server/fops-zip.c:\n  372  \t *    receiving GZIP... we can wrap it in a GZIP header and trailer\n  373  \t *    and serve the content part directly.  The flag indicating we\n  374: \t *    are providing GZIP directly is set so lws will send the right\n  375  \t *    headers.\n  376  \t *\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/server/lejp-conf.c:\n 1028  \n 1029  \tdo {\n 1030: \t\tn = (int)read(fd, buf, sizeof(buf));\n 1031  \t\tif (!n)\n 1032  \t\t\tbreak;\n ....\n 1093  \tinfo->plugin_dirs = (void *)a.p;\n 1094  #endif\n 1095: \ta.plugin_dirs = (void *)a.p; /* writeable version */\n 1096  \ta.p += MAX_PLUGIN_DIRS * sizeof(void *);\n 1097  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/server/server.c:\n  793  #if !defined(WIN32) && !defined(LWS_PLAT_FREERTOS)\n  794  \t\tif ((S_IFMT & st.st_mode) == S_IFLNK) {\n  795: \t\t\tlen = (size_t)readlink(path, sym, sizeof(sym) - 1);\n  796  \t\t\tif (len) {\n  797: \t\t\t\tlwsl_err(\"Failed to read link %s\\n\", path);\n  798  \t\t\t\tgoto notfound;\n  799  \t\t\t}\n  ...\n  839  \t\t\t\t   uri, origin);\n  840  \n  841: \t\t\t/* we don't need to send the payload */\n  842  \t\t\tif (lws_add_http_header_status(wsi,\n  843  \t\t\t\t\tHTTP_STATUS_NOT_MODIFIED, &p, end)) {\n  ...\n  852  \t\t\t\treturn -1;\n  853  \n  854: \t\t\t/* but we still need to send cache control... */\n  855  \n  856  \t\t\tif (m->cache_max_age && m->cache_reusable) {\n  ...\n  912  \t}\n  913  \tif (!mimetype[0])\n  914: \t\tlwsl_debug(\"sending no mimetype for %s\\n\", path);\n  915  \n  916: \twsi->sending_chunked = 0;\n  917  \twsi->interpreting = 0;\n  918  \n  ...\n  927  \t\t\twsi->interpreting = 1;\n  928  \t\t\tif (!wsi->mux_substream)\n  929: \t\t\t\twsi->sending_chunked = 1;\n  930  \n  931  \t\t\twsi->protocol_interpret_idx = (char)(\n  ...\n  949  \t}\n  950  \n  951: \tif (wsi->sending_chunked) {\n  952  \t\tif (lws_add_http_header_by_token(wsi,\n  953  \t\t\t\tWSI_TOKEN_HTTP_TRANSFER_ENCODING,\n  ...\n 1051  \twhile (1) {\n 1052  \t\tif (pos == n) {\n 1053: \t\t\tn = (int)read(fd, buf, sizeof(buf));\n 1054  \t\t\tif (n <= 0) {\n 1055  \t\t\t\tif (match == stringlen)\n ....\n 1212  \t\treturn LCBA_CONTINUE;\n 1213  \n 1214: \t/* Did he send auth? */\n 1215  \tml = lws_hdr_total_length(wsi, WSI_TOKEN_HTTP_AUTHORIZATION);\n 1216  \tif (!ml)\n ....\n 1422  \tlwsl_wsi_info(wsi, \"proxied path '%s'\", i.path);\n 1423  \n 1424: \t/* incoming may be h1 or h2... if he sends h1 HOST, use that\n 1425  \t * directly, otherwise we must convert h2 :authority to h1\n 1426  \t * host */\n ....\n 2068  \t\treturn 0;\n 2069  \n 2070: \t/* Prepare to read body if we have a content length: */\n 2071  \tlwsl_debug(\"wsi->http.rx_content_length %lld %d %d\\n\",\n 2072  \t\t   (long long)wsi->http.rx_content_length,\n ....\n 2083  \t\t * to, eg, instantiation of lws_spa never happened).\n 2084  \t\t *\n 2085: \t\t * HTTP_BODY_COMPLETION is responsible for sending the result\n 2086  \t\t * status code and result body if any, and to do the transaction\n 2087  \t\t * complete processing.\n ....\n 2604  \t) {\n 2605  \t\t/*\n 2606: \t\t * ...so he tried to send something large as the http reply,\n 2607  \t\t * it went as a partial, but he immediately said the\n 2608  \t\t * transaction was completed.\n ....\n 2704  \n 2705  \t/*\n 2706: \t * otherwise set ourselves up ready to go again, but because we have no\n 2707  \t * idea about the wsi writability, we make put it in a holding state\n 2708  \t * until we can verify POLLOUT.  The part of this that confirms POLLOUT\n ....\n 2715  \twsi->http.tx_content_remain = 0;\n 2716  \twsi->hdr_parsing_completed = 0;\n 2717: \twsi->sending_chunked = 0;\n 2718  #ifdef LWS_WITH_ACCESS_LOG\n 2719  \twsi->http.access_log.sent = 0;\n ....\n 2992  \tif (!wsi->mux_substream) {\n 2993  \t\t/* for http/1.1 ... */\n 2994: \t\tif (!wsi->sending_chunked\n 2995  #if defined(LWS_WITH_HTTP_STREAM_COMPRESSION)\n 2996  \t\t\t\t&& !wsi->http.lcs\n ....\n 2998  \t\t) {\n 2999  \t\t\t/* ... if not already using chunked and not using an\n 3000: \t\t\t * http compression translation, then send the naive\n 3001  \t\t\t * content length\n 3002  \t\t\t */\n ....\n 3151  \t\tif (lws_rops_fidx(wsi->role_ops, LWS_ROPS_write_role_protocol) &&\n 3152  \t\t    lws_rops_func_fidx(wsi->role_ops, LWS_ROPS_write_role_protocol).\n 3153: \t\t\t\t\twrite_role_protocol(wsi, NULL, 0, &wp) < 0) {\n 3154  \t\t\tlwsl_info(\"%s signalling to close\\n\", __func__);\n 3155  \t\t\tgoto file_had_it;\n ....\n 3206  #if defined(LWS_ROLE_H2)\n 3207  \t\t/*\n 3208: \t\t * If it's h2, restrict any lump that we are sending to the\n 3209  \t\t * max h2 frame size the peer indicated he could handle in\n 3210  \t\t * his SETTINGS\n ....\n 3222  \n 3223  \t\t/*\n 3224: \t\t * If there is a hint about how much we will do well to send at\n 3225: \t\t * one time, restrict ourselves to only trying to send that.\n 3226  \t\t */\n 3227  \t\tif (wsi->a.protocol->tx_packet_size &&\n ....\n 3261  \t\t}\n 3262  #endif\n 3263: \t\tif (wsi->sending_chunked) {\n 3264  \t\t\t/* we need to drop the chunk size in here */\n 3265  \t\t\tp += 10;\n ....\n 3272  \t\t\tgoto file_had_it; /* caller will close */\n 3273  \n 3274: \t\tif (wsi->sending_chunked)\n 3275  \t\t\tn = (int)amount;\n 3276  \t\telse\n 3277  \t\t\tn = lws_ptr_diff(p, pstart) + (int)amount;\n 3278  \n 3279: \t\tlwsl_debug(\"%s: sending %d\\n\", __func__, n);\n 3280  \n 3281  \t\tif (n) {\n ....\n 3289  \t\t\t\targs.final = wsi->http.filepos + (unsigned int)n ==\n 3290  \t\t\t\t\t\t\twsi->http.filelen;\n 3291: \t\t\t\targs.chunked = wsi->sending_chunked;\n 3292  \t\t\t\tif (user_callback_handle_rxflow(\n 3293  \t\t\t\t     wsi->a.vhost->protocols[\n ....\n 3302  \n 3303  #if defined(LWS_WITH_RANGES)\n 3304: \t\t\tif (wsi->http.range.send_ctr + 1 ==\n 3305  \t\t\t\twsi->http.range.count_ranges && // last range\n 3306  \t\t\t    wsi->http.range.count_ranges > 1 && // was 2+ ranges (ie, multipart)\n ....\n 3325  \t\t\t\t\tlwsl_notice(\"range budget exhausted\\n\");\n 3326  \t\t\t\t\twsi->http.range.inside = 0;\n 3327: \t\t\t\t\twsi->http.range.send_ctr++;\n 3328  \n 3329  \t\t\t\t\tif (lws_ranges_next(&wsi->http.range) < 1) {\n ....\n 3396  \t\t/*\n 3397  \t\t * while(1) here causes us to spam the whole file contents into\n 3398: \t\t * a hugely bloated output buffer if it ever can't send the\n 3399  \t\t * whole chunk...\n 3400  \t\t */\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/server/ranges.c:\n  183  {\n  184  \trp->agg = 0;\n  185: \trp->send_ctr = 0;\n  186  \trp->inside = 0;\n  187  \trp->count_ranges = 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/listen/ops-listen.c:\n  214  \t/* adoption_cb clnt, srv */\t{ 0, 0 },\n  215  \t/* rx_cb clnt, srv */\t\t{ 0, 0 },\n  216: \t/* writeable cb clnt, srv */\t{ 0, 0 },\n  217  \t/* close cb clnt, srv */\t{ 0, 0 },\n  218  \t/* protocol_bind_cb c,s */\t{ 0, 0 },\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/raw-skt/ops-raw-skt.c:\n   88  \tint n = 0, buffered = 0;\n   89  \n   90: \t/* pending truncated sends have uber priority */\n   91  \n   92  \tif (lws_has_buffered_out(wsi)) {\n   ..\n   98  \t\t\tgoto fail;\n   99  \t\t/*\n  100: \t\t * we can't afford to allow input processing to send\n  101  \t\t * something new, so spin around he event loop until\n  102  \t\t * he doesn't have any partials\n  ...\n  182  \t\t\t\tif (wsi->unix_skt)\n  183  \t\t\t\t\tbreak;\n  184: \t\t\t\tlwsl_wsi_info(wsi, \"read 0 len\");\n  185  \t\t\t\twsi->seen_zero_length_recv = 1;\n  186  \t\t\t\tif (lws_change_pollfd(wsi, LWS_POLLIN, 0))\n  ...\n  255  \t\tgoto fail;\n  256  \n  257: \t/* clear back-to-back write detection */\n  258  \twsi->could_have_pending = 0;\n  259  \n  ...\n  262  \t\t\twsi->user_space, NULL, 0);\n  263  \tif (n < 0) {\n  264: \t\tlwsl_info(\"writeable_fail\\n\");\n  265  \t\tgoto fail;\n  266  \t}\n  ...\n  393  \t/* rx_cb clnt, srv */\t\t{ LWS_CALLBACK_RAW_RX,\n  394  \t\t\t\t\t  LWS_CALLBACK_RAW_RX },\n  395: \t/* writeable cb clnt, srv */\t{ LWS_CALLBACK_RAW_WRITEABLE,\n  396  \t\t\t\t\t  LWS_CALLBACK_RAW_WRITEABLE},\n  397  \t/* close cb clnt, srv */\t{ LWS_CALLBACK_RAW_CLOSE,\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/raw-proxy/ops-raw-proxy.c:\n   32  \tint n, buffered;\n   33  \n   34: \t/* pending truncated sends have uber priority */\n   35  \n   36  \tif (lws_has_buffered_out(wsi)) {\n   ..\n   42  \t\t\tgoto fail;\n   43  \t\t/*\n   44: \t\t * we can't afford to allow input processing to send\n   45  \t\t * something new, so spin around he event loop until\n   46  \t\t * he doesn't have any partials\n   ..\n   66  \t\tswitch (ebuf.len) {\n   67  \t\tcase 0:\n   68: \t\t\tlwsl_info(\"%s: read 0 len\\n\", __func__);\n   69  \t\t\twsi->seen_zero_length_recv = 1;\n   70  \t\t\tif (lws_change_pollfd(wsi, LWS_POLLIN, 0))\n   ..\n  235  \t/* rx_cb clnt, srv */\t\t{ LWS_CALLBACK_RAW_PROXY_CLI_RX,\n  236  \t\t\t\t\t  LWS_CALLBACK_RAW_PROXY_SRV_RX },\n  237: \t/* writeable cb clnt, srv */\t{ LWS_CALLBACK_RAW_PROXY_CLI_WRITEABLE,\n  238  \t\t\t\t\t  LWS_CALLBACK_RAW_PROXY_SRV_WRITEABLE, },\n  239  \t/* close cb clnt, srv */\t{ LWS_CALLBACK_RAW_PROXY_CLI_CLOSE,\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/cgi/ops-cgi.c:\n  174  \t/* adoption_cb clnt, srv */\t{ 0, 0 },\n  175  \t/* rx_cb clnt, srv */\t\t{ 0, 0 },\n  176: \t/* writeable cb clnt, srv */\t{ 0, 0 },\n  177  \t/* close cb clnt, srv */\t{ 0, 0 },\n  178  \t/* protocol_bind_cb c,s */\t{ 0, 0 },\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/cgi/cgi-server.c:\n  148  \t\tlws_set_timeout(cgiinfo->wsi, PENDING_TIMEOUT_CGI, cgiinfo->timeout_secs);\n  149  \n  150: \t/* the cgi stdout is always sending us http1.x header data first */\n  151  \tcgiinfo->wsi->hdr_state = LCHS_HEADER;\n  152  \n  ...\n  623  \t\t\twsi->reason_bf |= LWS_CB_REASON_AUX_BF__CGI_HEADERS;\n  624  \t\t\tlws_callback_on_writable(wsi);\n  625: \t\t\t/* back to the loop for writeability again */\n  626  \t\t\treturn 0;\n  627  \n  ...\n  646  \t\t\t\t      (unsigned int)n, (enum lws_write_protocol)cmd);\n  647  \t\t\tif (m < 0) {\n  648: \t\t\t\tlwsl_wsi_debug(wsi, \"write says %d\", m);\n  649  \t\t\t\treturn -1;\n  650  \t\t\t}\n  ...\n  659  \t\t\t\t\tlwsl_wsi_info(wsi, \"post data still \"\n  660  \t\t\t\t\t\t\t   \"expected, asking \"\n  661: \t\t\t\t\t\t\t   \"for writeable\");\n  662  \t\t\t\t\tlws_callback_on_writable(wsi);\n  663  \t\t\t\t}\n  ...\n  670  \n  671  \t\t\t/*\n  672: \t\t\t * writeability becomes uncertain now we wrote\n  673  \t\t\t * something, we must return to the event loop\n  674  \t\t\t */\n  ...\n  705  \t\tif (n < 0)\n  706  \t\t\treturn -1;\n  707: \t\tn = (int)read(n, &c, 1);\n  708  \t\tif (n < 0) {\n  709  \t\t\tif (errno != EAGAIN) {\n  710: \t\t\t\tlwsl_wsi_debug(wsi, \"read says %d\", n);\n  711  \t\t\t\treturn -1;\n  712  \t\t\t}\n  ...\n  766  \t\t\t}\n  767  \n  768: \t\t\t/* some cgi only send us \\x0a for EOL */\n  769  \t\t\tif (c == '\\x0a') {\n  770  \t\t\t\twsi->hdr_state = LCHS_SINGLE_0A;\n  ...\n  856  \tif (n < 0)\n  857  \t\treturn -1;\n  858: \tn = (int)read(n, start, sizeof(buf) - LWS_PRE - 16);\n  859  \n  860  \tif (n < 0 && errno != EAGAIN) {\n  861: \t\tlwsl_wsi_debug(wsi, \"stdout read says %d\", n);\n  862  \t\treturn -1;\n  863  \t}\n  ...\n  895  \n  896  \t\tm = lws_write(wsi, (unsigned char *)start, (unsigned int)n, (enum lws_write_protocol)cmd);\n  897: \t\t//lwsl_notice(\"write %d\\n\", m);\n  898  \t\tif (m < 0) {\n  899: \t\t\tlwsl_wsi_debug(wsi, \"stdout write says %d\\n\", m);\n  900  \t\t\treturn -1;\n  901  \t\t}\n  ...\n  986  \t\t\t\tcontinue;\n  987  \n  988: \t\t\t/* finish sending cached headers */\n  989  \t\t\tif (cgi->headers_buf)\n  990  \t\t\t\tcontinue;\n  ...\n 1013  \t\t\t\tif (!cgi->content_length) {\n 1014  \t\t\t\t\t/*\n 1015: \t\t\t\t\t * well, if he sends chunked...\n 1016  \t\t\t\t\t * give him 2s after the\n 1017: \t\t\t\t\t * cgi terminated to send buffered\n 1018  \t\t\t\t\t */\n 1019  \t\t\t\t\tcgi->chunked_grace++;\n ....\n 1054  \t\t}\n 1055  \n 1056: \t\t/* finish sending cached headers */\n 1057  \t\tif (cgi->headers_buf)\n 1058  \t\t\tcontinue;\n ....\n 1071  \t\t\tif (!cgi->content_length) {\n 1072  \t\t\t\t/*\n 1073: \t\t\t\t * well, if he sends chunked...\n 1074  \t\t\t\t * give him 2s after the\n 1075: \t\t\t\t * cgi terminated to send buffered\n 1076  \t\t\t\t */\n 1077  \t\t\t\tcgi->chunked_grace += 4;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/pipe/ops-pipe.c:\n   35  \tn = eventfd_read(wsi->desc.sockfd, &value);\n   36  \tif (n < 0) {\n   37: \t\tlwsl_notice(\"%s: eventfd read %d bailed errno %d\\n\", __func__,\n   38  \t\t\t\twsi->desc.sockfd, LWS_ERRNO);\n   39  \t\treturn LWS_HPI_RET_PLEASE_CLOSE_ME;\n   ..\n   48  \t * thinks we should.\n   49  \t */\n   50: \tn = (int)read(wsi->desc.sockfd, s, sizeof(s));\n   51  \t(void)n;\n   52  \tif (n < 0)\n   ..\n   56  \tint n;\n   57  \n   58: \tn = recv(wsi->desc.sockfd, s, sizeof(s), 0);\n   59  \tif (n == SOCKET_ERROR)\n   60  \t\treturn LWS_HPI_RET_PLEASE_CLOSE_ME;\n   ..\n  152  \t/* adoption_cb clnt, srv */\t{ 0, 0 },\n  153  \t/* rx_cb clnt, srv */\t\t{ 0, 0 },\n  154: \t/* writeable cb clnt, srv */\t{ 0, 0 },\n  155  \t/* close cb clnt, srv */\t{ 0, 0 },\n  156  \t/* protocol_bind_cb c,s */\t{ 0, 0 },\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/raw-file/ops-raw-file.c:\n  116  \t/* rx_cb clnt, srv */\t\t{ LWS_CALLBACK_RAW_RX_FILE,\n  117  \t\t\t\t\t  LWS_CALLBACK_RAW_RX_FILE },\n  118: \t/* writeable cb clnt, srv */\t{ LWS_CALLBACK_RAW_WRITEABLE_FILE,\n  119  \t\t\t\t\t  LWS_CALLBACK_RAW_WRITEABLE_FILE},\n  120  \t/* close cb clnt, srv */\t{ LWS_CALLBACK_RAW_CLOSE_FILE,\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/h2/hpack.c:\n 1276  \t\t\tif (m < 0)\n 1277  \t\t\t\t/*\n 1278: \t\t\t\t * The peer may only send known 6-bit indexes,\n 1279: \t\t\t\t * there's still the possibility it sends an unset\n 1280  \t\t\t\t * dynamic index that we can't succeed to look up\n 1281  \t\t\t\t */\n ....\n 1467  \tint n;\n 1468  \n 1469: \twsi->h2.send_END_STREAM = 0; // !!(code >= 400);\n 1470  \n 1471  \tn = sprintf((char *)status, \"%u\", code);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/h2/private-lib-roles-h2.h:\n   83  \t * Recv HEADERS         -> LWS_H2_STATE_OPEN\n   84  \t *\n   85: \t *  - Only PUSH_PROMISE + HEADERS valid to send\n   86  \t *  - Only HEADERS or PRIORITY valid to receive\n   87  \t */\n   ..\n   92  \t * Send HEADERS         -> LWS_H2_STATE_HALF_CLOSED_REMOTE\n   93  \t *\n   94: \t * - Only HEADERS, RST_STREAM, or PRIORITY valid to send\n   95  \t * - Only RST_STREAM, PRIORITY, or WINDOW_UPDATE valid to receive\n   96  \t */\n   ..\n  101  \t * Recv HEADERS         -> LWS_H2_STATE_HALF_CLOSED_LOCAL\n  102  \t *\n  103: \t *  - Only RST_STREAM, WINDOW_UPDATE, or PRIORITY valid to send\n  104  \t *  - Only HEADERS, RST_STREAM, or PRIORITY valid to receive\n  105  \t */\n  ...\n  117  \t * Send END_STREAM flag -> LWS_H2_STATE_CLOSED\n  118  \t *\n  119: \t *  - Any frame valid to send\n  120  \t *  - Only WINDOW_UPDATE, PRIORITY, or RST_STREAM valid to receive\n  121  \t */\n  ...\n  126  \t * Recv END_STREAM flag -> LWS_H2_STATE_CLOSED\n  127  \t *\n  128: \t *  - Only WINDOW_UPDATE, PRIORITY, and RST_STREAM valid to send\n  129  \t *  - Any frame valid to receive\n  130  \t */\n  ...\n  134  \t *     may be received\n  135  \t *\n  136: \t *  - Only PRIORITY valid to send\n  137  \t */\n  138  };\n  ...\n  314  \tuint8_t\t\t\tEND_STREAM:1;\n  315  \tuint8_t\t\t\tEND_HEADERS:1;\n  316: \tuint8_t\t\t\tsend_END_STREAM:1;\n  317  \tuint8_t\t\t\tlong_poll:1;\n  318  \tuint8_t\t\t\tinitialized:1;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/h2/http2.c:\n  344  \n  345  #if 0\n  346: \t/* only assign sid at header send time when we know it */\n  347  \tif (!wsi->mux.my_sid) {\n  348  \t\twsi->mux.my_sid = nwsi->h2.h2n->highest_sid;\n  ...\n  415  \n  416  \t/*\n  417: \t * we must send a settings frame\n  418  \t */\n  419  \tpps = lws_h2_new_pps(LWS_H2_PPS_MY_SETTINGS);\n  ...\n  421  \t\treturn 1;\n  422  \tlws_pps_schedule(wsi, pps);\n  423: \tlwsl_info(\"%s: h2 client sending settings\\n\", __func__);\n  424  \n  425  \treturn 0;\n  ...\n  621   *\n  622   * Two flow-control windows are applicable: the stream flow-control\n  623:  * window and the connection flow-control window.  The sender MUST NOT\n  624:  * send a flow-controlled frame with a length that exceeds the space\n  625   * available in either of the flow-control windows advertised by the\n  626   * receiver.  Frames with zero length with the END_STREAM flag set (that\n  ...\n  689  \t\tif (wsi->txc.tx_cr < (int)len)\n  690  \n  691: \t\t\tlwsl_info(\"%s: %s: sending payload len %d\"\n  692  \t\t\t\t \" but tx_cr only %d!\\n\", __func__,\n  693  \t\t\t\t lws_wsi_tag(wsi), len, (int)wsi->txc.tx_cr);\n  ...\n  754  \t\tfor (n = 1; n < H2SET_COUNT; n++)\n  755  \t\t\tif (h2n->our_set.s[n] != lws_h2_defaults.s[n]) {\n  756: \t\t\t\tlwsl_debug(\"sending SETTING %d 0x%x\\n\", n,\n  757  \t\t\t\t\t   (unsigned int)\n  758  \t\t\t\t\t\t   wsi->h2.h2n->our_set.s[n]);\n  ...\n  765  \t\t     \t\t       &set[LWS_PRE]);\n  766  \t\tif (n != m) {\n  767: \t\t\tlwsl_info(\"send %d %d\\n\", n, m);\n  768  \t\t\tgoto bail;\n  769  \t\t}\n  ...\n  786  \t\t     \t\t       &set[LWS_PRE]);\n  787  \t\tif (n != 6) {\n  788: \t\t\tlwsl_info(\"send %d %d\\n\", n, m);\n  789  \t\t\tgoto bail;\n  790  \t\t}\n  ...\n  792  \n  793  \tcase LWS_H2_PPS_ACK_SETTINGS:\n  794: \t\t/* send ack ... always empty */\n  795  \t\tn = lws_h2_frame_write(wsi, LWS_H2_FRAME_TYPE_SETTINGS, 1,\n  796  \t\t\t\t       LWS_H2_STREAM_ID_MASTER, 0,\n  ...\n  861  \tcase LWS_H2_PPS_PONG:\n  862  \t\tif (pps->type == LWS_H2_PPS_PING)\n  863: \t\t\tlwsl_info(\"sending PING\\n\");\n  864  \t\telse {\n  865: \t\t\tlwsl_info(\"sending PONG\\n\");\n  866  \t\t\tflags = LWS_H2_FLAG_SETTINGS_ACK;\n  867  \t\t}\n  ...\n  896  \t\t\t\t       &set[LWS_PRE]);\n  897  \t\tif (n != 4) {\n  898: \t\t\tlwsl_info(\"send %d %d\\n\", n, m);\n  899  \t\t\tgoto bail;\n  900  \t\t}\n  ...\n  910  \t\t\t\t       0, pps->u.rs.sid, 4, &set[LWS_PRE]);\n  911  \t\tif (n != 4) {\n  912: \t\t\tlwsl_info(\"send %d %d\\n\", n, m);\n  913  \t\t\tgoto bail;\n  914  \t\t}\n  ...\n  935  \t\t\t\t       &set[LWS_PRE]);\n  936  \t\tif (n != 4) {\n  937: \t\t\tlwsl_info(\"send %d %d\\n\", n, m);\n  938  \t\t\tgoto bail;\n  939  \t\t}\n  ...\n 1344  \t\t * initiated by that peer with a lower-valued stream identifier.\n 1345  \t\t *\n 1346: \t\t * For example, if a client sends a HEADERS frame on stream 7\n 1347: \t\t * without ever sending a frame on stream 5, then stream 5\n 1348  \t\t * transitions to the \"closed\" state when the first frame for\n 1349  \t\t * stream 7 is sent or received.\n ....\n 1445   *\n 1446   * This is the crunch time for parsing that may have occured on a network\n 1447:  * wsi with a pending partial send... we may call lws_http_action() to send\n 1448   * a response, conflicting with the partial.\n 1449   *\n ....\n 1587  \n 1588  \t\t\t\tlwsl_info(\"%s: initial tx credit for us to \"\n 1589: \t\t\t\t\t  \"write on nwsi %s: %d\\n\", __func__,\n 1590  \t\t\t\t\t  lws_wsi_tag(wsi), (int)wsi->txc.tx_cr);\n 1591  \t\t\t\twsi->h2.initialized = 1;\n ....\n 1853  \t\t/*\n 1854  \t\t * client... remote END_STREAM implies we weren't going to\n 1855: \t\t * send anything else anyway.\n 1856  \t\t */\n 1857  \n ....\n 1889  \t\t\tlws_validity_confirmed(wsi);\n 1890  \t\telse {\n 1891: \t\t\t/* they're sending us a ping request */\n 1892  \t\t\tstruct lws_h2_protocol_send *pps =\n 1893  \t\t\t\t\tlws_h2_new_pps(LWS_H2_PPS_PONG);\n ....\n 1960  \n 1961  \t\tif (n <= 0 && eff_wsi->txc.tx_cr <= 0)\n 1962: \t\t\t/* it helps, but won't change sendability for anyone */\n 1963  \t\t\tbreak;\n 1964  \n 1965  \t\t/*\n 1966: \t\t * It may have changed sendability (depends on SID 0 tx credit\n 1967  \t\t * too)... for us and any children waiting on us... reassess\n 1968  \t\t * blockage for all children first\n ....\n 1976  \t\t\t\t\t     lws_h2_tx_cr_get(eff_wsi)))\n 1977  \t\t\t/*\n 1978: \t\t\t * This one became un-skint, schedule a writeable\n 1979  \t\t\t * callback\n 1980  \t\t\t */\n ....\n 2004  \n 2005  /*\n 2006:  * This may want to send something on the network wsi, which may be in the\n 2007:  * middle of a partial send.  PPS sends are OK because they are queued to\n 2008   * go through the WRITABLE handler already.\n 2009   *\n 2010:  * The read parser for the network wsi has no choice but to parse its stream\n 2011   * anyway, because otherwise it will not be able to get tx credit window\n 2012   * messages.\n 2013   *\n 2014:  * Therefore if we will send non-PPS, ie, lws_http_action() for a stream\n 2015   * wsi, we must change its state and handle it as a priority in the\n 2016   * POLLOUT handler instead of writing it here.\n ....\n 2050  \n 2051  \t\t\t/*\n 2052: \t\t\t * we must send a settings frame -- empty one is OK...\n 2053  \t\t\t * that must be the first thing sent by server\n 2054: \t\t\t * and the peer must send a SETTINGS with ACK flag...\n 2055  \t\t\t */\n 2056  \t\t\tpps = lws_h2_new_pps(LWS_H2_PPS_MY_SETTINGS);\n ....\n 2408  \t\t\tcase LWS_H2_FRAME_TYPE_PING:\n 2409  \t\t\t\tif (h2n->flags & LWS_H2_FLAG_SETTINGS_ACK) { // ack\n 2410: \t\t\t\t} else { /* they're sending us a ping request */\n 2411  \t\t\t\t\tif (h2n->count > 8)\n 2412  \t\t\t\t\t\treturn 1;\n ....\n 2550  \n 2551  \t/*\n 2552: \t * We MUST allocate our sid here at the point we're about to send the\n 2553  \t * stream open.  It's because we don't know the order in which multiple\n 2554: \t * open streams will send their headers... in h2, sending the headers\n 2555  \t * is the point the stream is opened.  The peer requires that we only\n 2556  \t * open streams in ascending sid order\n ....\n 2558  \n 2559  \twsi->mux.my_sid = nwsi->h2.h2n->highest_sid_opened = sid;\n 2560: \tlwsl_info(\"%s: %s: assigning SID %d at header send\\n\", __func__,\n 2561  \t\t\tlws_wsi_tag(wsi), sid);\n 2562  \n ....\n 2568  \tend = start + (wsi->a.context->pt_serv_buf_size / 2) - LWS_PRE - 1;\n 2569  \n 2570: \t/* it's time for us to send our client stream headers */\n 2571  \n 2572  \tif (!meth)\n ....\n 2797           * enable on this connection, and give him back the list.\n 2798           *\n 2799:          * Give him a limited write bugdet\n 2800           */\n 2801          if (lws_extension_server_handshake(wsi, (char **)&p, 192))\n ....\n 2870  \n 2871  \t\t/*\n 2872: \t\t * lws_h2_parser() may send something; when it gets the\n 2873  \t\t * whole frame, it will want to perform some action\n 2874: \t\t * involving a reply.  But we may be in a partial send\n 2875  \t\t * situation on the network wsi...\n 2876  \t\t *\n 2877: \t\t * Even though we may be in a partial send and unable to\n 2878: \t\t * send anything new, we still have to parse the network\n 2879: \t\t * wsi in order to gain tx credit to send, which is\n 2880: \t\t * potentially necessary to clear the old partial send.\n 2881  \t\t *\n 2882  \t\t * ALL network wsi-specific frames are sent by PPS\n 2883  \t\t * already, these are sent as a priority on the writable\n 2884: \t\t * handler, and so respect partial sends.  The only\n 2885: \t\t * problem is when a stream wsi wants to send an, eg,\n 2886  \t\t * reply headers frame in response to the parsing\n 2887  \t\t * we will do now... the *stream wsi* must stall in a\n ....\n 2923  \n 2924  \t/*\n 2925: \t * Elect to send an empty DATA with END_STREAM, to force the stream\n 2926  \t * into HALF_CLOSED LOCAL\n 2927  \t */\n 2928  \twsi->h2.long_poll = 1;\n 2929: \twsi->h2.send_END_STREAM = 1;\n 2930  \n 2931  \t// lws_header_table_detach(wsi, 0);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/h2/ops-h2.c:\n   35  \t/* H2SET_HEADER_TABLE_SIZE */\t\t\t4096,\n   36  \t/* *** This controls how many entries in the dynamic table ***\n   37: \t * Allows the sender to inform the remote endpoint of the maximum\n   38  \t * size of the header compression table used to decode header\n   39  \t * blocks, in octets.  The encoder can select any size equal to or\n   ..\n   48  \t/* H2SET_MAX_HEADER_LIST_SIZE */\t  0x7fffffff,\n   49  \t/*< This advisory setting informs a peer of the maximum size of\n   50: \t * header list that the sender is prepared to accept, in octets.\n   51  \t * The value is based on the uncompressed size of header fields,\n   52  \t * including the length of the name and value in octets plus an\n   ..\n   63  \t/* H2SET_HEADER_TABLE_SIZE */\t\t\t65536, /* ffox */\n   64  \t/* *** This controls how many entries in the dynamic table ***\n   65: \t * Allows the sender to inform the remote endpoint of the maximum\n   66  \t * size of the header compression table used to decode header\n   67  \t * blocks, in octets.  The encoder can select any size equal to or\n   ..\n   81  \t/* H2SET_MAX_HEADER_LIST_SIZE */\t        4096,\n   82  \t/*< This advisory setting informs a peer of the maximum size of\n   83: \t * header list that the sender is prepared to accept, in octets.\n   84  \t * The value is based on the uncompressed size of header fields,\n   85  \t * including the length of the name and value in octets plus an\n   ..\n  153  \t}\n  154  \n  155: \t/* 1: something requested a callback when it was OK to write */\n  156  \n  157  \tif ((pollfd->revents & LWS_POLLOUT) &&\n  ...\n  160  \t\tif (lwsi_state(wsi) == LRS_RETURNED_CLOSE)\n  161  \t\t\tlwsi_set_state(wsi, LRS_FLUSHING_BEFORE_CLOSE);\n  162: \t\t/* the write failed... it's had it */\n  163  \t\twsi->socket_is_permanently_unusable = 1;\n  164  \n  ...\n  188  \t\t\t/*\n  189  \t\t\t * We cannot deal with any kind of new RX\n  190: \t\t\t * because we are dealing with a partial send\n  191  \t\t\t * (new RX may trigger new http_action() that\n  192: \t\t\t * expect to be able to send)\n  193  \t\t\t */\n  194  \t\t\treturn LWS_HPI_RET_HANDLED;\n  ...\n  196  \t}\n  197  \n  198: read:\n  199  \t/* 3: network wsi buflist needs to be drained */\n  200  \n  ...\n  221  \t\treturn LWS_HPI_RET_HANDLED;\n  222  \n  223: \t/* We have something to read... */\n  224  \n  225  \tif (!(lwsi_role_client(wsi) &&\n  ...\n  236  \t\tswitch (scr_ret) {\n  237  \t\tcase 0:\n  238: \t\t\tlwsl_info(\"%s: zero length read\\n\", __func__);\n  239  \t\t\treturn LWS_HPI_RET_PLEASE_CLOSE_ME;\n  240  \t\tcase LWS_SSL_CAPABLE_MORE_SERVICE:\n  ...\n  263  \t\t//\tlwsl_hexdump_notice(ebuf.token, ebuf.len);\n  264  \t} else\n  265: \t\tlwsl_info(\"%s: skipped read\\n\", __func__);\n  266  \n  267  \tif (ebuf.len < 0)\n  ...\n  281  \t\t * other in or out before that happens.\n  282  \t\t *\n  283: \t\t * simply mark ourselves as having readable data\n  284  \t\t * and turn off our POLLIN\n  285  \t\t */\n  ...\n  288  \t\t\treturn LWS_HPI_RET_PLEASE_CLOSE_ME;\n  289  \n  290: \t\t/* let user code know, he'll usually ask for writeable\n  291  \t\t * callback and drain / re-enable it there\n  292  \t\t */\n  ...\n  371  \tif (pending) {\n  372  \t\t// lwsl_info(\"going around\\n\");\n  373: \t\tgoto read;\n  374  \t}\n  375  \n  ...\n  412  \t}\n  413  \n  414: \t/* Priority 2: if we are closing, not allowed to send more data frags\n  415  \t *\t       which means user callback or tx ext flush banned now\n  416  \t */\n  ...\n  432  #endif\n  433  \n  434: \t/* if not in a state to send stuff, then just send nothing */\n  435  \n  436  \tif (!lwsi_role_ws(wsi) && !wsi->mux_stream_immortal &&\n  ...\n  489  \t\tif (!((*wp) & LWS_WRITE_NO_FIN))\n  490  \t\t\tflags = LWS_H2_FLAG_END_HEADERS;\n  491: \t\tif (wsi->h2.send_END_STREAM ||\n  492  \t\t    ((*wp) & LWS_WRITE_H2_STREAM_END)) {\n  493  \t\t\tflags |= LWS_H2_FLAG_END_STREAM;\n  494: \t\t\twsi->h2.send_END_STREAM = 1;\n  495  \t\t}\n  496  \t}\n  ...\n  500  \t\tif (!((*wp) & LWS_WRITE_NO_FIN))\n  501  \t\t\tflags = LWS_H2_FLAG_END_HEADERS;\n  502: \t\tif (wsi->h2.send_END_STREAM ||\n  503  \t\t    ((*wp) & LWS_WRITE_H2_STREAM_END)) {\n  504  \t\t\tflags |= LWS_H2_FLAG_END_STREAM;\n  505: \t\t\twsi->h2.send_END_STREAM = 1;\n  506  \t\t}\n  507  \t}\n  ...\n  515  \t\t\t  (unsigned long long)wsi->http.tx_content_remain);\n  516  \t\tif (!wsi->http.tx_content_remain) {\n  517: \t\t\tlwsl_info(\"%s: selecting final write mode\\n\", __func__);\n  518  \t\t\tbase = *wp = LWS_WRITE_HTTP_FINAL;\n  519  \t\t}\n  ...\n  524  \t\tlwsl_info(\"%s: %s: setting END_STREAM, 0x%x\\n\", __func__,\n  525  \t\t\t\tlws_wsi_tag(wsi), flags);\n  526: \t\twsi->h2.send_END_STREAM = 1;\n  527  \t}\n  528  \n  ...\n  628  \t\tif (peer_to_us == LWSTXCR_PEER_TO_US) {\n  629  \t\t\t/*\n  630: \t\t\t * We want to tell the peer they can write an additional\n  631  \t\t\t * \"add\" bytes to us\n  632  \t\t\t */\n  ...\n  635  \n  636  \t\t/*\n  637: \t\t * We're being told we can write an additional \"add\" bytes\n  638  \t\t * to the peer\n  639  \t\t */\n  ...\n  786  \t\t/*\n  787  \t\t * refuse his efforts to get WRITABLE if we have no credit and\n  788: \t\t * no non-DATA pps to send\n  789  \t\t */\n  790  \t\tlwsl_err(\"%s: skint\\n\", __func__);\n  ...\n  938   *\n  939   * But because any child could exhaust the socket's ability to take\n  940:  * writes, we can only let one child get notified each time.\n  941   *\n  942   * In addition children may be closed / deleted / added between POLLOUT\n  ...\n  949  \tstruct lws **wsi2;\n  950  #if defined(LWS_ROLE_WS)\n  951: \tint write_type = LWS_WRITE_PONG;\n  952  #endif\n  953  \tint n;\n  ...\n 1023  \t\t\t\tlwsl_info(\"%s signalling to close\\n\", __func__);\n 1024  \t\t\t\tlws_close_free_wsi(w, LWS_CLOSE_STATUS_NOSTATUS,\n 1025: \t\t\t\t\t\t   \"comp write fail\");\n 1026  \t\t\t}\n 1027  \t\t\tlws_callback_on_writable(w);\n ....\n 1046  \n 1047  \t\tif (w->h2.pending_status_body) {\n 1048: \t\t\tw->h2.send_END_STREAM = 1;\n 1049  \t\t\tn = lws_write(w, (uint8_t *)w->h2.pending_status_body +\n 1050  \t\t\t\t\t LWS_PRE,\n ....\n 1072  \t\t\t/*\n 1073  \t\t\t * we had to defer the http_action to the POLLOUT\n 1074: \t\t\t * handler, because we know it will send something and\n 1075  \t\t\t * only in the POLLOUT handler do we know for sure\n 1076  \t\t\t * that there is no partial pending on the network wsi.\n ....\n 1121  \t\t\t */\n 1122  \t\t\tif (n >= 0 && !w->h2.pending_status_body &&\n 1123: \t\t\t    (n || w->h2.send_END_STREAM)) {\n 1124  \t\t\t\tlwsl_info(\"closing stream after h2 action\\n\");\n 1125  \t\t\t\tlws_close_free_wsi(w, LWS_CLOSE_STATUS_NOSTATUS,\n ....\n 1150  \t\t\t * We'll get a LWS_CALLBACK_HTTP_FILE_COMPLETION\n 1151  \t\t\t * callback when it's done.  That's the case even if we\n 1152: \t\t\t * just completed the send, so wait for that.\n 1153  \t\t\t */\n 1154  \t\t\tn = lws_serve_http_file_fragment(w);\n ....\n 1159  \t\t\t * DATA here... if so close the actual wsi\n 1160  \t\t\t */\n 1161: \t\t\tif (n < 0 || w->h2.send_END_STREAM) {\n 1162  \t\t\t\tlwsl_debug(\"Closing POLLOUT child %s\\n\",\n 1163  \t\t\t\t\t\tlws_wsi_tag(w));\n ....\n 1186  \t\tif (lwsi_role_ws(w) &&\n 1187  \t\t    lwsi_state(w) == LRS_WAITING_TO_SEND_CLOSE) {\n 1188: \t\t\tlwsl_debug(\"sending close packet\\n\");\n 1189  \t\t\tw->waiting_to_send_close_frame = 0;\n 1190  \t\t\tn = lws_write(w, &w->ws->ping_payload_buf[LWS_PRE],\n ....\n 1210  \n 1211  \t\t\tif (w->ws->payload_is_close)\n 1212: \t\t\t\twrite_type = LWS_WRITE_CLOSE |\n 1213  \t\t\t\t\t     LWS_WRITE_H2_STREAM_END;\n 1214  \n 1215  \t\t\tn = lws_write(w, &w->ws->pong_payload_buf[LWS_PRE],\n 1216: \t\t\t\t      w->ws->pong_payload_len, (enum lws_write_protocol)write_type);\n 1217  \t\t\tif (n < 0)\n 1218  \t\t\t\treturn -1;\n ....\n 1240  \n 1241  \t\t/*\n 1242: \t\t * set client wsi to immortal long-poll mode; send END_STREAM\n 1243  \t\t * flag on headers to indicate to a server, that allows\n 1244  \t\t * it, that you want them to leave the stream in a long poll\n 1245: \t\t * ro immortal state.  We have to send headers so the client\n 1246  \t\t * understands the http connection is ongoing.\n 1247  \t\t */\n 1248  \n 1249: \t\tif (w->h2.send_END_STREAM && w->h2.long_poll) {\n 1250  \t\t\tuint8_t buf[LWS_PRE + 1];\n 1251  \t\t\tenum lws_write_protocol wp = 0;\n ....\n 1264  \t\tif (lws_callback_as_writeable(w)) {\n 1265  \t\t\tlwsl_info(\"Closing POLLOUT child (end stream %d)\\n\",\n 1266: \t\t\t\t  w->h2.send_END_STREAM);\n 1267  \t\t\tlws_close_free_wsi(w, LWS_CLOSE_STATUS_NOSTATUS,\n 1268  \t\t\t\t\t   \"h2 pollout handle\");\n 1269  \t\t\twa = &wsi->mux.child_list;\n 1270  \t\t} else\n 1271: \t\t\t if (w->h2.send_END_STREAM)\n 1272  \t\t\t\tlws_h2_state(w, LWS_H2_STATE_HALF_CLOSED_LOCAL);\n 1273  \n ....\n 1351  \n 1352  \t/*\n 1353: \t * We can only send these frames on the network connection itself...\n 1354  \t * we shouldn't be tracking validity on anything else\n 1355  \t */\n ....\n 1363  \t/*\n 1364  \t * The peer is defined to copy us back the unchanged payload in another\n 1365: \t * PING frame this time with ACK set.  So by sending that out with the\n 1366  \t * current time, it's an interesting opportunity to learn the effective\n 1367  \t * RTT on the link when the PONG comes in, plus or minus the time to\n ....\n 1388  \t/*  7 */ { .callback_on_writable  = rops_callback_on_writable_h2 },\n 1389  \t/*  8 */ { .tx_credit\t\t  = rops_tx_credit_h2 },\n 1390: \t/*  9 */ { .write_role_protocol\t  = rops_write_role_protocol_h2 },\n 1391  \t/* 10 */ { .encapsulation_parent  = rops_encapsulation_parent_h2 },\n 1392  \t/* 11 */ { .alpn_negotiated\t  = rops_alpn_negotiated_h2 },\n ....\n 1432  \t/* rx cb clnt, srv */\t\t{ LWS_CALLBACK_RECEIVE_CLIENT_HTTP,\n 1433  \t\t\t\t\t  0 /* may be POST, etc */ },\n 1434: \t/* writeable cb clnt, srv */\t{ LWS_CALLBACK_CLIENT_HTTP_WRITEABLE,\n 1435  \t\t\t\t\t  LWS_CALLBACK_HTTP_WRITEABLE },\n 1436  \t/* close cb clnt, srv */\t{ LWS_CALLBACK_CLOSED_CLIENT_HTTP,\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/system/system.c:\n  206  #endif\n  207  \n  208: \t/* nobody ready to go... leave *get as NULL and return cleanly */\n  209  \n  210  \treturn 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/system/ota/ota.c:\n  122  \t\t/*\n  123  \t\t * The task is busy, we can't start anything atm.  When it\n  124: \t\t * is finished, the write completion will come back here.\n  125  \t\t */\n  126  \t\t// lwsl_notice(\"%s: async_last busy\\n\", __func__);\n  ...\n  129  \n  130  \t/*\n  131: \t * We have a chance to write the next chunk... let's stage g->buf with\n  132  \t * as much inflated data as we can with what we have to hand, and set it\n  133  \t * writing\n  ...\n  373  \t\t * service g->flow / buflist state ONLY and do not know or care\n  374  \t\t * about direct inflator state (it makes itself felt by using\n  375: \t\t * g->flow data in the write completion).\n  376  \t\t *\n  377  \t\t * The inflator may not need any g->flow data to produce output,\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/system/dhcpclient/dhcpc4.c:\n  217  \t\t * UDP is not reliable, it can be locally dropped, or dropped\n  218  \t\t * by any intermediary or the remote peer.  So even though we\n  219: \t\t * will do the write in a moment, we schedule another request\n  220  \t\t * for rewrite according to the wsi retry policy.\n  221  \t\t *\n  ...\n  223  \t\t *\n  224  \t\t * If we have already reached the end of our concealed retries\n  225: \t\t * in the policy, just close without another write.\n  226  \t\t */\n  227  \t\tif (lws_dll2_is_detached(&r->sul_write.list) &&\n  ...\n  258  \t\t\t\t\t\t      (const char *)&r[1]);\n  259  \t\t\tif (m < 0)\n  260: \t\t\t\tlwsl_err(\"%s: Failed to write dhcp client req: \"\n  261  \t\t\t\t\t \"%d %d, errno %d\\n\", __func__,\n  262  \t\t\t\t\t n, m, LWS_ERRNO);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/system/smd/smd.c:\n  215  \n  216  \t/*\n  217: \t * In the case we received a message and in the callback for that, send\n  218  \t * one, we end up here already holding lock_peers and will deadlock if\n  219  \t * we try to take it again.  Throughout the callback, ctx->smd.delivering\n  ...\n  316  \tva_end(ap);\n  317  \tif (n > LWS_SMD_MAX_PAYLOAD)\n  318: \t\t/* too large to send */\n  319  \t\treturn 1;\n  320  \n  ...\n  362  \tif (n > LWS_SMD_MAX_PAYLOAD ||\n  363  \t    (unsigned int)n > (*len) - LWS_SMD_SS_RX_HEADER_LEN)\n  364: \t\t/* too large to send */\n  365  \t\treturn 1;\n  366  \n  367  \t*len = LWS_SMD_SS_RX_HEADER_LEN + (unsigned int)n;\n  368  \n  369: \tlwsl_info(\"%s: %s send cl 0x%x, len %u\\n\", __func__, tag, (unsigned int)_class,\n  370  \t\t\t(unsigned int)n);\n  371  \n  ...\n  428  \n  429  \tif (_lws_smd_msg_send(ctx, p, pr)) {\n  430: \t\t/* we couldn't send it after all that... */\n  431  \t\tlws_smd_msg_free(&p);\n  432  \n  ...\n  434  \t}\n  435  \n  436: \tlwsl_info(\"%s: %s send cl 0x%x, len %u, ts %llu\\n\", __func__,\n  437  \t\t    tag, (unsigned int)_class, msg->length,\n  438  \t\t    (unsigned long long)msg->timestamp);\n  ...\n  528   * if no more filtered queued messages.  Returns nonzero if tail non-NULL.\n  529   *\n  530:  * For Proxied SS, only asks for writeable and does not advance or change the\n  531   * tail.\n  532   *\n  ...\n  556  \t * We hold the peer lock for the duration.\n  557  \t * That's tricky because if, in the callback, he uses smd\n  558: \t * apis to send, we will deadlock if we try to grab the\n  559  \t * peer lock as usual in there.\n  560  \t *\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/system/async-dns/async-dns.c:\n   38  \n   39  \tlws_sul_cancel(&q->sul);\n   40: \tlws_sul_cancel(&q->write_sul);\n   41  \tlws_dll2_remove(&q->list);\n   42  \tlws_free(q);\n   ..\n  162  \t/*\n  163  \t * We managed to get to the point of being WRITEABLE, which is not a\n  164: \t * given if no routes.  So call off the write_sul timeout for that.\n  165  \t */\n  166: \tlws_sul_cancel(&q->write_sul);\n  167  \n  168  \tif (!q->is_retry && q->sent[0]\n  ...\n  178  \t * UDP is not reliable, it can be locally dropped, or dropped\n  179  \t * by any intermediary or the remote peer.  So even though we\n  180: \t * will do the write in a moment, we schedule another request\n  181  \t * for rewrite according to the wsi retry policy.\n  182  \t *\n  ...\n  185  \t *\n  186  \t * If we have already reached the end of our concealed retries\n  187: \t * in the policy, just close without another write.\n  188  \t */\n  189  \tif (lws_dll2_is_detached(&q->sul.list) &&\n  ...\n  266  \tm = lws_write(wsi, pkt + LWS_PRE, (unsigned int)n, 0);\n  267  \tif (m != n) {\n  268: \t\tlwsl_wsi_notice(wsi, \"dns write failed %d %d errno %d\",\n  269  \t\t\t    m, n, errno);\n  270  \t\tgoto qfail;\n  ...\n  273  #if defined(LWS_WITH_IPV6)\n  274  \tif (!q->responded && q->sent[0] != q->sent[1]) {\n  275: \t\tlwsl_wsi_debug(wsi, \"request writeable for ipv6\");\n  276  \t\tlws_callback_on_writable(wsi);\n  277  \t}\n  ...\n  460  \n  461  /*\n  462:  * Ensure every logical DNS server has a wsi ready\n  463   */\n  464  \n  ...\n  633  sul_cb_write(struct lws_sorted_usec_list *sul)\n  634  {\n  635: \tlws_adns_q_t *q = lws_container_of(sul, lws_adns_q_t, write_sul);\n  636  \n  637  \t/*\n  638: \t * Something's up, we couldn't even get from write request to\n  639  \t * WRITEABLE within the timeout, let alone the result... fail\n  640  \t * the query and everyone riding on it...\n  ...\n  878  \t\ts = _read(fd, buf, sizeof(buf) - 1);\n  879  #else\n  880: \t\ts = read(fd, buf, sizeof(buf) - 1);\n  881  #endif\n  882  \t\tif (s <= 0) {\n  ...\n 1175  \t\tgoto failed;\n 1176  \n 1177: \t/* fail us if we can't write by this timeout */\n 1178: \tlws_sul_schedule(context, 0, &q->write_sul, sul_cb_write, LWS_US_PER_SEC);\n 1179  \n 1180  \t/*\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/system/async-dns/private-lib-async-dns.h:\n   57  \n   58  typedef struct lws_adns_q {\n   59: \tlws_sorted_usec_list_t\tsul;\t/* per-query write retry timer */\n   60: \tlws_sorted_usec_list_t\twrite_sul;\t/* fail if unable to write by this time */\n   61  \tlws_dll2_t\t\tlist;\n   62  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/system/ntpclient/ntpclient.c:\n   34  \tconst struct lws_protocols\t*protocol;\n   35  \tlws_sorted_usec_list_t\t\tsul_conn;\n   36: \tlws_sorted_usec_list_t\t\tsul_write; /* track write retries */\n   37  \tconst char\t\t\t*ntp_server_ads;\n   38  \tstruct lws\t\t\t*wsi_udp;\n   ..\n  182  \t\tv->wsi_udp = NULL;\n  183  \n  184: \t\t/* cancel any pending write retry */\n  185  \t\tlws_sul_cancel(&v->sul_write);\n  186  \n  ...\n  248  \t\t * UDP is not reliable, it can be locally dropped, or dropped\n  249  \t\t * by any intermediary or the remote peer.  So even though we\n  250: \t\t * will do the write in a moment, we schedule another request\n  251  \t\t * for rewrite according to the wsi retry policy.\n  252  \t\t *\n  ...\n  254  \t\t *\n  255  \t\t * If we have already reached the end of our concealed retries\n  256: \t\t * in the policy, just close without another write.\n  257  \t\t */\n  258  \t\tif (lws_dll2_is_detached(&v->sul_write.list) &&\n  ...\n  274  \t\t\tbreak;\n  275  \n  276: \t\tlwsl_err(\"%s: Failed to write ntp client req\\n\", __func__);\n  277  \n  278  retry_conn:\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/event-libs/glib/glib.c:\n  160  /*\n  161   * This is the callback for a timer object that is set to the earliest scheduled\n  162:  * lws event... it services any lws scheduled events that are ready, and then\n  163   * resets the event loop timer to the earliest remaining event, if any.\n  164   */\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/event-libs/libuv/libuv.c:\n  770  \n  771  \t/*\n  772: \t * Initialize the accept wsi read watcher with all the listening sockets\n  773: \t * and register a callback for read operations\n  774  \t *\n  775  \t * We have to do it here because the uv loop(s) are not\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/policy-json.c:\n 1240  \n 1241  \tdo {\n 1242: \t\tn = (int)read(fd, buf, sizeof(buf));\n 1243  \t\tif (n < 0) {\n 1244  \t\t\tm = -1;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/secure-streams.c:\n  607   *\n  608   * After the SS is created and registered, still nothing is going to come here\n  609:  * until the peer sends us his rx_class_mask and we update his registration with\n  610   * it, because from SS creation his rx_class_mask defaults to 0.\n  611   */\n  ...\n  653  \tn = h->info.tx(h + 1, h->txord++, buf, &len, &flags);\n  654  \tif (n)\n  655: \t\t/* nonzero return means don't want to send anything */\n  656  \t\treturn;\n  657  \n  ...\n 1821  /*\n 1822   * Deal with tx requests between source and accepted sink... h is the guy who\n 1823:  * requested the write\n 1824   */\n 1825  \n ....\n 1834  \tint flags = 0;\n 1835  \n 1836: \t/* !!! just let writes happen for now */\n 1837  \n 1838  \tassert(h->sink_local_bind);\n ....\n 1964  \t     h->policy->protocol == LWSSSP_H2 ||\n 1965  \t     h->policy->protocol == LWSSSP_WS))\n 1966: \t\th->wsi->http.writeable_len = len;\n 1967  \telse\n 1968: \t\th->writeable_len = len;\n 1969  \n 1970  \treturn lws_ss_request_tx(h);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/private-lib-secure-streams.h:\n  164  \t\t\tuint32_t\t\t\tunacked_size;\n  165  \t\t\tuint8_t\t\t\t\tretry_count;\n  166: \t\t\tuint8_t\t\t\t\tsend_unacked:1;\n  167  \t\t} mqtt;\n  168  #endif\n  ...\n  175  \t} u;\n  176  \n  177: \tunsigned long\t\twriteable_len;\n  178  \n  179  \tlws_ss_constate_t\tconnstate;/**< public connection state */\n  ...\n  198  \n  199  \tuint8_t\t\t\ttxn_resp_set:1; /**< user code set one */\n  200: \tuint8_t\t\t\ttxn_resp_pending:1; /**< we have yet to send */\n  201  \tuint8_t\t\t\ttxn_n_acked:1; /** < set if we did NACK or ACK */\n  202  \tuint8_t\t\t\thanging_som:1;\n  ...\n  415  \tlws_usec_t\t\tus_start_upstream;\n  416  \n  417: \tunsigned long\t\twriteable_len;\n  418  \n  419  \tlws_ss_conn_states_t\tstate;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/serialized/client/sspc-deserialize.c:\n  508  \t\t\t/*\n  509  \t\t\t * Proxy is telling us remote endpoint is allowing us\n  510: \t\t\t * par->temp32 more bytes tx credit to write to it\n  511  \t\t\t */\n  512  \n  ...\n  579  \t\t/*\n  580  \t\t * These are the client adjusting our / the remote peer ability\n  581: \t\t * to send back to him. He's sending a signed u32 BE\n  582  \t\t */\n  583  \n  ...\n  601  \t\t\t * We're the client, being told by the proxy\n  602  \t\t\t * about tx credit being given to us from the\n  603: \t\t\t * remote peer, allowing the client to write to\n  604  \t\t\t * it.\n  605  \t\t\t */\n  ...\n  785  \t\t\t *\n  786  \t\t\t * The reason is he may set metadata in CREATING, and\n  787: \t\t\t * we will try to do writeables to sync the stream to\n  788  \t\t\t * proxy and ultimately bring up the onward connection\n  789  \t\t\t * now we are in LOCAL_CONNECTED.  We need to do the\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/serialized/client/sspc.c:\n  517  \n  518  /*\n  519:  * Currently we fulfil the writeable part locally by just enabling POLLOUT on\n  520   * the UDS link, without serialization footprint, which is reasonable as far as\n  521   * it goes.\n  ...\n  549  #endif\n  550  \n  551: \tlwsl_sspc_notice(h, \"setting writeable_len %u\", (unsigned int)len);\n  552: \th->writeable_len = len;\n  553  \th->pending_writeable_len = 1;\n  554  \n  ...\n  561  \n  562  \t/*\n  563: \t * We're going to use this up with serializing h->writeable_len... that\n  564  \t * will request again.\n  565  \t */\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/serialized/client/sspc-transport.c:\n   70  \tif (md->name[0] == '\\0') {\n   71  \n   72: \t\tlwsl_sspc_info(h, \"sending tx credit update %d\",\n   73  \t\t\t\tmd->tx_cr_adjust);\n   74  \n   ..\n   81  \t} else {\n   82  \n   83: \t\tlwsl_sspc_info(h, \"sending metadata\");\n   84  \n   85  \t\tp[0] = LWSSS_SER_TXPRE_METADATA;\n   ..\n  253  \t\tlws_ser_wu32be(s + 3, h->timeout_ms);\n  254  \n  255: \t\t/* in case anything else to write */\n  256  \t\th->txp_path.ops_onw->req_write(h->txp_path.priv_onw);\n  257  \t\th->pending_timeout_update = 0;\n  ...\n  298  \n  299  \t\t/*\n  300: \t\t * Do we need to prioritize sending any metadata\n  301  \t\t * changes?\n  302  \t\t */\n  ...\n  327  \t\tif (h->pending_writeable_len) {\n  328  \t\t\tlwsl_sspc_debug(h, \"(local_conn) PAYLOAD_LENGTH_HINT %u\",\n  329: \t\t\t\t   (unsigned int)h->writeable_len);\n  330  \t\t\tcp = s;\n  331  \t\t\t*s = LWSSS_SER_TXPRE_PAYLOAD_LENGTH_HINT;\n  332  \t\t\tlws_ser_wu16be(s + 1, 4);\n  333: \t\t\tlws_ser_wu32be(s + 3, (uint32_t)h->writeable_len);\n  334  \t\t\th->pending_writeable_len = 0;\n  335  \t\t\ttxl = 7;\n  ...\n  359  \t\t/*\n  360  \t\t *\n  361: \t\t * - Do we need to prioritize sending any metadata\n  362  \t\t *   changes?  (includes txcr updates)\n  363  \t\t *\n  ...\n  386  \t\tif (h->pending_writeable_len) {\n  387  \t\t\tlwsl_sspc_info(h, \"PAYLOAD_LENGTH_HINT %u\",\n  388: \t\t\t\t  (unsigned int)h->writeable_len);\n  389  \t\t\tcp = s;\n  390  \t\t\t*s = LWSSS_SER_TXPRE_PAYLOAD_LENGTH_HINT;\n  391  \t\t\tlws_ser_wu16be(s + 1, 4);\n  392: \t\t\tlws_ser_wu32be(s + 3, (uint32_t)h->writeable_len);\n  393  \t\t\th->pending_writeable_len = 0;\n  394  \t\t\ttxl = 7;\n  ...\n  396  \t\t}\n  397  \n  398: \t\t/* we can't write anything if we don't have credit */\n  399  \t\tif (!h->ignore_txc && h->txc.tx_cr <= 0)\n  400  \t\t\tlwsl_sspc_info(h, \"WRITEABLE / OPERATIONAL:\"\n  ...\n  432  \t\tlws_ser_wu16be(&p[1], (uint16_t)(len + 19 - 3));\n  433  \t\tlws_ser_wu32be(&p[3], (uint32_t)flags);\n  434: \t\t/* time spent here waiting to send this */\n  435  \t\tlws_ser_wu32be(&p[7], (uint32_t)(us - h->us_earliest_write_req));\n  436: \t\t/* ust that the client write happened */\n  437  \t\tlws_ser_wu64be(&p[11], (uint64_t)us);\n  438  \t\th->us_earliest_write_req = 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/serialized/proxy/proxy.c:\n   34   * lws-secure-streams.h for documentation and definitions.\n   35   *\n   36:  * Proxying in either direction can face the situation it cannot send the onward\n   37:  * packet immediately and is subject to separating the write request from the\n   38:  * write action.  To make the best use of memory, a single preallocated buffer\n   39   * stashes pending packets in all four directions (c->p, p->c, p->ss, ss->p).\n   40   * This allows it to adapt to different traffic patterns without wasted areas\n   ..\n  138  \tlws_ser_wu16be(&pre[1], (uint16_t)(len + (size_t)est - 3));\n  139  \tlws_ser_wu32be(&pre[3], (uint32_t)flags);\n  140: \tlws_ser_wu32be(&pre[7], 0);\t/* write will compute latency here... */\n  141: \tlws_ser_wu64be(&pre[11], (uint64_t)us);\t/* ... and set this to the write time */\n  142  \n  143  \t/*\n  ...\n  208  \t\t\t * This just affects the one stream that owns the\n  209  \t\t\t * dsh, caller should enter stream close flow and not\n  210: \t\t\t * send any further payload.\n  211  \t\t\t */\n  212  \n  ...\n  240  \t}\n  241  \n  242: \tif (m->conn->txp_path.priv_onw) /* if possible, request client conn write */\n  243  \t\tm->conn->txp_path.ops_onw->proxy_req_write(m->conn->txp_path.priv_onw);\n  244  \n  ...\n  259  \n  260  \tif (!m->conn->ss || m->conn->state != LPCSPROX_OPERATIONAL) {\n  261: \t\tlwsl_notice(\"%s: ss not ready\\n\", __func__);\n  262  \t\t*len = 0;\n  263  \n  ...\n  266  \n  267  \t/*\n  268: \t * The onward secure stream says that we could send something to it\n  269  \t * (by putting it in buf, and setting *len and *flags)... dredge the\n  270  \t * next thing out of the dsh\n  ...\n  275  \t\treturn LWSSSSRET_TX_DONT_SEND;\n  276  \n  277: \t/* ... there's more we want to send? */\n  278  \tif (!lws_dsh_get_head(m->conn->dsh, KIND_C_TO_P, (void **)&p, &si))\n  279  \t\t_lws_ss_request_tx(m->conn->ss);\n  280  \n  281  \tif (!*len && !*flags)\n  282: \t\t/* we don't actually want to send anything */\n  283  \t\treturn LWSSSSRET_TX_DONT_SEND;\n  284  \n  ...\n  413  \tif (lws_ss_serialize_state(m->conn, state, ack))\n  414  \t\t/*\n  415: \t\t * Failed to alloc state packet that we want to send in dsh,\n  416  \t\t * we will lose coherence and have to disconnect the link\n  417  \t\t */\n  ...\n  419  \n  420  \tif (state != LWSSSCS_DESTROYING &&\n  421: \t    m->conn->txp_path.priv_onw) /* if possible, request client conn write */\n  422  \t\tm->conn->txp_path.ops_onw->proxy_req_write(m->conn->txp_path.priv_onw);\n  423  \n  ...\n  461  \tlws_ss_serialize_txcr(m->conn->dsh, bump);\n  462  \n  463: \tif (m->conn->txp_path.priv_onw) /* if possible, request client conn write */\n  464  \t\tm->conn->txp_path.ops_onw->proxy_req_write(m->conn->txp_path.priv_onw);\n  465  }\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/serialized/proxy/proxy-deserialize.c:\n  527  \t\t/*\n  528  \t\t * These are the client adjusting our / the remote peer ability\n  529: \t\t * to send back to him. He's sending a signed u32 BE\n  530  \t\t */\n  531  \n  ...\n  824  \t\t\t}\n  825  \n  826: \t\t\t/* parent needs to schedule write on client conn */\n  827  \t\t\tbreak;\n  828  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/serialized/proxy/proxy-transport.c:\n  293  \t\t/*\n  294  \t\t * If we have performance data, render it in JSON\n  295: \t\t * and send that in LWSSS_SER_RXPRE_PERF has\n  296  \t\t * priority 2\n  297  \t\t */\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/system/auth-api.amazon.com/auth.c:\n  175  \n  176  \t/*\n  177: \t * We send out auth slot AUTH_IDX_ROOT, it's the LWA user / device\n  178  \t * identity token\n  179  \t */\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/system/auth-sigv4/sign.c:\n  516  \t\t\tstr++;\n  517  \n  518: \t\t\t/* only read the first key for each */\n  519  \t\t\tif (*(i ? aws_keyid : aws_key))\n  520  \t\t\t\tcontinue;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/protocols/ss-h1.c:\n   73  \t\t\t * It's possible we already started the decode before\n   74  \t\t\t * the end of the last packet.  Then there is no\n   75: \t\t\t * remainder to send.\n   76  \t\t\t */\n   77  \t\t\tif (n >= pending_issue + h->u.http.boundary_len +\n   ..\n  124  \t\t\t * It's possible we already started the decode before\n  125  \t\t\t * the end of the last packet.  Then there is no\n  126: \t\t\t * remainder to send.\n  127  \t\t\t */\n  128  \t\t\tif (n >= pending_issue + h->u.http.boundary_len +\n  ...\n  258  #endif\n  259  \t\t(!strcmp(h->policy->u.http.method, \"POST\"))) &&\n  260: \t    wsi->http.writeable_len) {\n  261  \t\tif (!(h->policy->flags &\n  262  \t\t\tLWSSSPOLF_HTTP_NO_CONTENT_LENGTH)) {\n  263  \t\t\tint n = lws_snprintf((char *)buf, 20, \"%u\",\n  264: \t\t\t\t(unsigned int)wsi->http.writeable_len);\n  265  \t\t\tif (lws_add_http_header_by_token(wsi,\n  266  \t\t\t\t\tWSI_TOKEN_HTTP_CONTENT_LENGTH,\n  ...\n  757  \t\tif (!h)\n  758  \t\t\treturn -1;\n  759: \t\tif (h->writeable_len)\n  760: \t\t\twsi->http.writeable_len = h->writeable_len;\n  761  \n  762  \t\t{\n  ...\n  841  \t\t/*\n  842  \t\t * So when proxied, for POST we have to synthesize a CONNECTED\n  843: \t\t * state, so it can request a writeable and deliver the POST\n  844  \t\t * body\n  845  \t\t */\n  ...\n  866  \tcase LWS_CALLBACK_HTTP_BODY:\n  867  \tcase LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ:\n  868: \t\tlwsl_debug(\"%s: RECEIVE_CLIENT_HTTP_READ: read %d\\n\",\n  869  \t\t\t\t__func__, (int)len);\n  870  \t\tif (!h || !h->info.rx)\n  ...\n  920  \t\t}\n  921  \n  922: \t\twsi->http.writeable_len = h->writeable_len = 0;\n  923  \t\tlws_sul_cancel(&h->sul_timeout);\n  924  \n  ...\n  959  \t\tif (h->txn_resp_pending) {\n  960  \t\t\t/*\n  961: \t\t\t * If we're going to start sending something, we need to\n  962  \t\t\t * to take care of the http response header for it first\n  963  \t\t\t */\n  ...\n  971  \t\t\t\t\th->policy->flags & LWSSSPOLF_HTTP_NO_CONTENT_LENGTH ?\n  972  \t\t\t\t\t\tLWS_ILLEGAL_HTTP_CONTENT_LEN :\n  973: \t\t\t\t\t\th->wsi->http.writeable_len,\n  974  \t\t\t\t\t&p, end))\n  975  \t\t\t\treturn 1;\n  ...\n  985  \t\t\t\treturn 1;\n  986  \n  987: \t\t\t/* write the body separately */\n  988  \t\t\tlws_callback_on_writable(wsi);\n  989  \n  ...\n 1054  \t\t\th->inside_msg = 0;\n 1055  \t\t} else {\n 1056: \t\t\t/* otherwise we can spin with zero length writes */\n 1057  \t\t\tif (!f && !lws_ptr_diff(p, buf + LWS_PRE))\n 1058  \t\t\t\tbreak;\n ....\n 1068  \t\t\t\t    LWS_WRITE_HTTP_FINAL : LWS_WRITE_HTTP) !=\n 1069  \t\t\t\t(int)lws_ptr_diff(p, buf + LWS_PRE)) {\n 1070: \t\t\tlwsl_err(\"%s: write failed\\n\", __func__);\n 1071  \t\t\treturn -1;\n 1072  \t\t}\n ....\n 1096  \t\t\th->txn_resp_set = 0;\n 1097  \t\t\th->txn_resp_pending = 1;\n 1098: \t\t\th->writeable_len = 0;\n 1099  \n 1100  #if defined(LWS_ROLE_H2)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/protocols/ss-raw.c:\n  124         case LWS_CALLBACK_RAW_RX_FILE:\n  125                 in = p;\n  126:                f = (int)read((int)(intptr_t)wsi->desc.filefd, p, sizeof(buf) - LWS_PRE);\n  127                 if (f < 0)\n  128                         return 0;\n  ...\n  161  \t\tif (lws_write(wsi, buf + LWS_PRE, lws_ptr_diff_size_t(p, buf + LWS_PRE),\n  162  \t\t\t LWS_WRITE_HTTP) != lws_ptr_diff(p, buf + LWS_PRE)) {\n  163: \t\t\tlwsl_err(\"%s: write failed\\n\", __func__);\n  164  \t\t\treturn -1;\n  165  \t\t}\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/protocols/ss-h2.c:\n   49  \t\t\t * We are the proxy-side SS for a remote client... we\n   50  \t\t\t * need to inform the client about the initial tx credit\n   51: \t\t\t * to write to it that the remote h2 server set up\n   52  \t\t\t */\n   53  \t\t\tlwsl_info(\"%s: reporting initial tx cr from server %d\\n\",\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/protocols/ss-ws.c:\n  130  \tcase LWS_CALLBACK_RECEIVE:\n  131  \tcase LWS_CALLBACK_CLIENT_RECEIVE:\n  132: \t\t// lwsl_user(\"LWS_CALLBACK_CLIENT_RECEIVE: read %d\\n\", (int)len);\n  133  \t\tif (!h || !h->info.rx)\n  134  \t\t\treturn 0;\n  ...\n  173  \t\tn = lws_write(wsi, buf + LWS_PRE, buflen, (enum lws_write_protocol)f1);\n  174  \t\tif (n < (int)buflen) {\n  175: \t\t\tlwsl_info(\"%s: write failed %d %d\\n\", __func__,\n  176  \t\t\t\t\tn, (int)buflen);\n  177  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/protocols/ss-mqtt.c:\n  274  \t} else {\n  275  \t\tr = secstream_mqtt_publish(wsi, buffered, len,\n  276: \t\t\t\t\t   (uint32_t)h->writeable_len,\n  277  \t\t\t\t\t   h->policy->u.mqtt.topic,\n  278  \t\t\t\t\t   h->policy->u.mqtt.qos,\n  ...\n  284  \tif (r) {\n  285  \t\tlws_buflist_destroy_all_segments(&h->u.mqtt.buflist_unacked);\n  286: \t\th->u.mqtt.retry_count = h->u.mqtt.send_unacked = 0;\n  287  \n  288  \t\tif (wsi->mqtt->inside_birth) {\n  289: \t\t\tlwsl_err(\"%s: %s: failed to send Birth\\n\", __func__,\n  290  \t\t\t\t lws_ss_tag(h));\n  291  \t\t\treturn -1;\n  ...\n  401  \n  402  \tif (h->u.mqtt.shadow_sub.num_topics == 0) {\n  403: \t\twsi->mqtt->send_shadow_unsubscribe = 0;\n  404  \t\twsi->mqtt->inside_shadow = 0;\n  405  \t\twsi->mqtt->done_shadow_subscribe = 0;\n  ...\n  409  \n  410  \tif (lws_mqtt_client_send_unsubcribe(wsi, &h->u.mqtt.shadow_sub)) {\n  411: \t\tlwsl_wsi_err(wsi, \"Failed to send MQTT unsubsribe\");\n  412  \n  413  \t\treturn LWSSSSRET_DISCONNECT_ME;\n  ...\n  419  \t\treturn LWSSSSRET_DISCONNECT_ME;\n  420  \t}\n  421: \twsi->mqtt->send_shadow_unsubscribe = 0;\n  422  \n  423  \treturn LWSSSSRET_OK;\n  ...\n  568  \t\t\t\t\t * If any Birth was sent out or\n  569  \t\t\t\t\t * is pending on other stream,\n  570: \t\t\t\t\t * skip sending Birth.\n  571  \t\t\t\t\t */\n  572  \t\t\t\t\twsi->mqtt->done_birth = 1;\n  ...\n  580  \t\t\t/*\n  581  \t\t\t * If subscribe is empty in the policy, then,\n  582: \t\t\t * skip sending SUBSCRIBE and signal the user\n  583  \t\t\t * application.\n  584  \t\t\t */\n  ...\n  630  \n  631  \tcase LWS_CALLBACK_MQTT_CLIENT_RX:\n  632: \t\t// lwsl_user(\"LWS_CALLBACK_CLIENT_RECEIVE: read %d\\n\", (int)len);\n  633  \t\tif (!h || !h->info.rx)\n  634  \t\t\treturn 0;\n  ...\n  708  \t\t\t\t\t\t LWS_MQTT_SHADOW_RESP_REJECTED_STR)) {\n  709  \t\t\t\t\tlws_sul_cancel(&wsi->mqtt->sul_shadow_wait);\n  710: \t\t\t\t\twsi->mqtt->send_shadow_unsubscribe = 1;\n  711  \t\t\t\t\tlws_callback_on_writable(wsi);\n  712  \n  ...\n  740  \tcase LWS_CALLBACK_MQTT_ACK:\n  741  \t\tlws_sul_cancel(&h->sul_timeout);\n  742: \t\tif (h->u.mqtt.send_unacked) {\n  743  \t\t\tlws_buflist_destroy_all_segments(&h->u.mqtt.buflist_unacked);\n  744: \t\t\th->u.mqtt.retry_count = h->u.mqtt.send_unacked = 0;\n  745  \t\t}\n  746  \n  ...\n  773  \t\t\t\t\t    h->u.mqtt.retry_count,\n  774  \t\t\t\t\t    LWS_MQTT_MAX_PUBLISH_RETRY);\n  775: \t\t\t\th->u.mqtt.send_unacked = 1;\n  776  \t\t\t\tlws_callback_on_writable(wsi);\n  777  \t\t\t\tbreak;\n  ...\n  780  \n  781  \t\tlws_buflist_destroy_all_segments(&h->u.mqtt.buflist_unacked);\n  782: \t\th->u.mqtt.retry_count = h->u.mqtt.send_unacked = 0;\n  783  \n  784  \t\tif (wsi->mqtt->inside_birth) {\n  785: \t\t\tlwsl_err(\"%s: %s: failed to send Birth\\n\", __func__,\n  786  \t\t\t\t lws_ss_tag(h));\n  787  \t\t\treturn -1;\n  ...\n  807  \t\t\treturn secstream_mqtt_subscribe(wsi);\n  808  \n  809: \t\tif (h->u.mqtt.send_unacked)\n  810  \t\t\treturn secstream_mqtt_resend(wsi, buf + LWS_PRE);\n  811  \n  ...\n  818  \t\t\t\tif (!wsi->mqtt->done_shadow_subscribe)\n  819  \t\t\t\t\treturn secstream_mqtt_shadow_subscribe(wsi);\n  820: \t\t\t\tif (wsi->mqtt->send_shadow_unsubscribe)\n  821  \t\t\t\t\treturn secstream_mqtt_shadow_unsubscribe(wsi);\n  822  \t\t\t}\n  ...\n  841  \t\t\t\tif (lws_mqtt_client_send_unsubcribe(wsi,\n  842  \t\t\t\t\t\t\t\t    &lmsp)) {\n  843: \t\t\t\t\tlwsl_err(\"%s, failed to send\"\n  844  \t\t\t\t\t         \" MQTT unsubsribe\", __func__);\n  845  \t\t\t\t\treturn -1;\n  ...\n  853  \n  854  \t\tif (secstream_mqtt_publish(wsi, buf + LWS_PRE, buflen,\n  855: \t\t\t\t\t   (uint32_t)h->writeable_len,\n  856  \t\t\t\t\t   h->policy->u.mqtt.topic,\n  857  \t\t\t\t\t   h->policy->u.mqtt.qos,\n  ...\n  906  \t\t\tlwsl_warn(\"%s: %s: Shadow timeout.\\n\", __func__,\n  907  \t\t\t\t  lws_ss_tag(h));\n  908: \t\t\twsi->mqtt->send_shadow_unsubscribe = 1;\n  909  \t\t\tlws_callback_on_writable(wsi);\n  910  \t\t}\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/daemonize.c:\n   65  \t\t}\n   66  \t\tlen = sprintf(sz, \"%u\", (unsigned int)pid_daemon);\n   67: \t\tsent = (int)write(fd, sz, (size_t)len);\n   68  \t\tif (sent != len)\n   69  \t\t\tfprintf(stderr,\n   70: \t\t\t  \"unable to write pid to lock file %s, code=%d (%s)\\n\",\n   71  \t\t\t\t\t     lock_path, errno, strerror(errno));\n   72  \n   ..\n  118  \t\t\tchar buf[10];\n  119  \n  120: \t\t\tn = (int)read(fd, buf, sizeof(buf));\n  121  \t\t\tclose(fd);\n  122  \t\t\tif (n) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/upng-gzip.c:\n  157  \n  158  static lws_stateful_ret_t\n  159: read_bit(inflator_ctx_t *inf, uint8_t *bits)\n  160  {\n  161  \tsize_t bo = inf->bp >> 3;\n  ...\n  174  \n  175  static lws_stateful_ret_t\n  176: read_bits(inflator_ctx_t *inf, unsigned int nbits, unsigned int *bits)\n  177  {\n  178  \tlws_stateful_ret_t r;\n  179  \tuint8_t b;\n  180  \n  181: \tif (!inf->read_bits_ongoing) {\n  182: \t\tinf->read_bits_ongoing\t= 1;\n  183: \t\tinf->read_bits_shifter\t= 0;\n  184: \t\tinf->read_bits_limit\t= nbits;\n  185: \t\tinf->read_bits_i\t= 0;\n  186  \t}\n  187  \n  188: \twhile (inf->read_bits_i < inf->read_bits_limit) {\n  189: \t\t r =read_bit(inf, &b);\n  190  \t\t if (r)\n  191  \t\t\t return r;\n  192  \n  193: \t\t inf->read_bits_shifter = inf->read_bits_shifter | (unsigned int)(b << inf->read_bits_i);\n  194  \n  195: \t\t inf->read_bits_i++;\n  196  \t}\n  197  \n  198: \tinf->read_bits_ongoing = 0;\n  199: \t*bits = inf->read_bits_shifter;\n  200  \n  201  \treturn LWS_SRET_OK;\n  ...\n  203  \n  204  static lws_stateful_ret_t\n  205: read_byte(inflator_ctx_t *inf, uint8_t *byte)\n  206  {\n  207  \tsize_t bo;\n  ...\n  317  \n  318  \tdo {\n  319: \t\tr = read_bit(inf, &bit);\n  320  \t\tif (r)\n  321  \t\t\treturn r;\n  ...\n  342  \t\tswitch (inf->state) {\n  343  \t\tcase UPNS_ID_BL_GB_DONE:\n  344: \t\t\tr = read_bit(inf, &inf->done);\n  345  \t\t\tif (r)\n  346  \t\t\t\treturn r;\n  ...\n  349  \t\t\t/* fallthru */\n  350  \t\tcase UPNS_ID_BL_GB_BTYPEb0:\n  351: \t\t\tr = read_bit(inf, &inf->btype);\n  352  \t\t\tif (r)\n  353  \t\t\t\treturn r;\n  ...\n  356  \t\t\t/* fallthru */\n  357  \t\tcase UPNS_ID_BL_GB_BTYPEb1:\n  358: \t\t\tr = read_bit(inf, &t);\n  359  \t\t\tif (r)\n  360  \t\t\t\treturn r;\n  ...\n  383  \n  384  \t\tcase UPNS_ID_BL_GB_BTYPE_0: /* no compression */\n  385: \t\t\tr = read_byte(inf, &t);\n  386  \t\t\tif (r)\n  387  \t\t\t\treturn r;\n  ...\n  394  \t\t\t/* fallthru */\n  395  \t\tcase UPNS_ID_BL_GB_BTYPE_0a:\n  396: \t\t\tr = read_byte(inf, &t);\n  397  \t\t\tif (r)\n  398  \t\t\t\treturn r;\n  ...\n  403  \n  404  \t\tcase UPNS_ID_BL_GB_BTYPE_0b:\n  405: \t\t\tr = read_byte(inf, &t);\n  406  \t\t\tif (r)\n  407  \t\t\t\treturn r;\n  ...\n  412  \t\t\t/* fallthru */\n  413  \t\tcase UPNS_ID_BL_GB_BTYPE_0c:\n  414: \t\t\tr = read_byte(inf, &t);\n  415  \t\t\tif (r)\n  416  \t\t\t\treturn r;\n  ...\n  431  \t\t\tif (inf->n < inf->len) {\n  432  \n  433: \t\t\t\tr = read_byte(inf, &t);\n  434  \t\t\t\tif (r)\n  435  \t\t\t\t\treturn r;\n  ...\n  496  \n  497  \t\tcase UPNS_ID_BL_GB_BTYPE_2a:\n  498: \t\t\tr = read_bits(inf, 5, &inf->hlit);\n  499  \t\t\tif (r)\n  500  \t\t\t\treturn r;\n  ...\n  504  \t\t\t/* fallthru */\n  505  \t\tcase UPNS_ID_BL_GB_BTYPE_2b:\n  506: \t\t\tr = read_bits(inf, 5, &inf->hdist);\n  507  \t\t\tif (r)\n  508  \t\t\t\treturn r;\n  ...\n  512  \t\t\t/* fallthru */\n  513  \t\tcase UPNS_ID_BL_GB_BTYPE_2c:\n  514: \t\t\tr = read_bits(inf, 4, &inf->hclen);\n  515  \t\t\tif (r)\n  516  \t\t\t\treturn r;\n  ...\n  523  \t\t\tif (inf->i < NUM_CODE_LENGTH_CODES) {\n  524  \t\t\t\tif (inf->i < inf->hclen) {\n  525: \t\t\t\t\tr = read_bits(inf, 3,\n  526  \t\t\t\t\t\t&inf->clenc[huff_cl_cl[inf->i]]);\n  527  \t\t\t\t\tif (r)\n  ...\n  595  \n  596  \t\tcase UPNS_ID_BL_GB_BTYPE_2_16: /* repeat previous */\n  597: \t\t\tr = read_bits(inf, 2, &tu);\n  598  \t\t\tif (r)\n  599  \t\t\t\treturn r;\n  ...\n  611  \n  612  \t\tcase UPNS_ID_BL_GB_BTYPE_2_17: /*repeat \"0\" 3-10 times */\n  613: \t\t\tr = read_bits(inf, 3, &tu);\n  614  \t\t\tif (r)\n  615  \t\t\t\treturn r;\n  ...\n  620  \n  621  \t\tcase UPNS_ID_BL_GB_BTYPE_2_18: /*repeat \"0\" 11-138 times */\n  622: \t\t\tr = read_bits(inf, 7, &tu);\n  623  \t\t\tif (r)\n  624  \t\t\t\treturn r;\n  ...\n  692  \t\t\t/* fallthru */\n  693  \t\tcase UPNS_ID_BL_GB_SPINb:\n  694: \t\t\tr = read_bits(inf, (unsigned int)inf->exbits, &tu);\n  695  \t\t\tif (r)\n  696  \t\t\t\treturn r;\n  ...\n  725  \t\tcase UPNS_ID_BL_GB_SPINd:\n  726  \n  727: \t\t\tr = read_bits(inf, inf->exbitsD, &tu);\n  728  \t\t\tif (r)\n  729  \t\t\t\treturn r;\n  ...\n  801  \n  802  \t\tcase UPNS_ID_BL_GB_GZIP_ID1:\n  803: \t\t\tr = read_byte(inf, &t);\n  804  \t\t\tif (r)\n  805  \t\t\t\treturn r;\n  ...\n  811  \n  812  \t\tcase UPNS_ID_BL_GB_GZIP_ID2:\n  813: \t\t\tr = read_byte(inf, &t);\n  814  \t\t\tif (r)\n  815  \t\t\t\treturn r;\n  ...\n  821  \n  822  \t\tcase UPNS_ID_BL_GB_GZIP_METHOD:\n  823: \t\t\tr = read_byte(inf, &t);\n  824  \t\t\tif (r)\n  825  \t\t\t\treturn r;\n  ...\n  831  \n  832  \t\tcase UPNS_ID_BL_GB_GZIP_FLAGS:\n  833: \t\t\tr = read_byte(inf, &t);\n  834  \t\t\tif (r)\n  835  \t\t\t\treturn r;\n  ...\n  845  \t\t\t/* we want skip 6 bytes */\n  846  \t\t\tif (inf->ctr--) {\n  847: \t\t\t\tr = read_byte(inf, &t);\n  848  \t\t\t\tif (r)\n  849  \t\t\t\t\treturn r;\n  ...\n  870  \n  871  \t\tcase UPNS_ID_BL_GB_GZIP_SKIP_EXTRA_C1:\n  872: \t\t\tr = read_byte(inf, &t);\n  873  \t\t\tif (r)\n  874  \t\t\t\treturn r;\n  ...\n  881  \n  882  \t\tcase UPNS_ID_BL_GB_GZIP_SKIP_EXTRA_C2:\n  883: \t\t\tr = read_byte(inf, &t);\n  884  \t\t\tif (r)\n  885  \t\t\t\treturn r;\n  ...\n  893  \t\tcase UPNS_ID_BL_GB_GZIP_SKIP_EXTRA:\n  894  \t\t\tif (inf->ctr--) {\n  895: \t\t\t\tr = read_byte(inf, &t);\n  896  \t\t\t\tif (r)\n  897  \t\t\t\t\treturn r;\n  ...\n  915  \n  916  \t\tcase UPNS_ID_BL_GB_GZIP_SKIP_FILENAME: /* zero-terminated */\n  917: \t\t\tr = read_byte(inf, &t);\n  918  \t\t\tif (r)\n  919  \t\t\t\treturn r;\n  ...\n  934  \n  935  \t\tcase UPNS_ID_BL_GB_GZIP_SKIP_COMMENT: /* zero-terminated */\n  936: \t\t\tr = read_byte(inf, &t);\n  937  \t\t\tif (r)\n  938  \t\t\t\treturn r;\n  ...\n  952  \t\tcase UPNS_ID_BL_GB_GZIP_SKIP_CRC:\n  953  \t\t\tif (inf->ctr--) {\n  954: \t\t\t\tr = read_byte(inf, &t);\n  955  \t\t\t\tif (r)\n  956  \t\t\t\t\treturn r;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/upng.c:\n  472  \t\t\tu->inf.upng\t= u;\n  473  \n  474: \t\t\tu->u.alt\t= 0; /* which of the two lines to write to */\n  475  \t\t\tu->u.padded\t= u->u.bpp < 8 &&\n  476  \t\t\t\t\t  u->width * u->u.bpp !=\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/diskcache.c:\n  313  \n  314  \tdo {\n  315: \t\tde = readdir(dir);\n  316  \t\tif (!de)\n  317  \t\t\tbreak;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/lecp.c:\n  197  \tst->indet\t\t= 0;\n  198  \tst->ordinal\t\t= 0;\n  199: \tst->send_new_array_item = 0;\n  200  \tst->barrier\t\t= 0;\n  201  \n  ...\n  261  \t\t\til--;\n  262  \t\t\tctx->i[il]++;\n  263: \t\t\tif (!parent->send_new_array_item) {\n  264  \t\t\t\tif (ctx->pst[ctx->pst_sp].cb(ctx,\n  265  \t\t\t\t\t\tLECPCB_ARRAY_ITEM_END))\n  266  \t\t\t\t\treturn LECP_REJECT_CALLBACK;\n  267: \t\t\t\tparent->send_new_array_item = 1;\n  268  \t\t\t}\n  269  \t\t}\n  ...\n  282  \t\t\t\t/* more items to come */\n  283  \t\t\t\tif (parent->opcode == LWS_CBOR_MAJTYP_ARRAY)\n  284: \t\t\t\t\tparent->send_new_array_item = 1;\n  285  \t\t\t\tbreak;\n  286  \t\t\t}\n  ...\n  359  \tst->indet\t\t= 0;\n  360  \tst->ordinal\t\t= 0;\n  361: \tst->send_new_array_item = 0;\n  362  \tst->barrier\t\t= 1;\n  363  \n  ...\n  408  \n  409  \t\t\tif (c != 0xff && ctx->sp &&\n  410: \t\t\t    ctx->st[ctx->sp - 1].send_new_array_item) {\n  411: \t\t\t\tctx->st[ctx->sp - 1].send_new_array_item = 0;\n  412  \t\t\t\tif (ctx->pst[ctx->pst_sp].cb(ctx,\n  413  \t\t\t\t\t\tLECPCB_ARRAY_ITEM_START))\n  ...\n  532  \t\t\t\t}\n  533  \n  534: \t\t\t\tctx->st[ctx->sp].send_new_array_item = 1;\n  535  \n  536  \t\t\t\tif (sm < LWS_CBOR_1) {\n  ...\n 1306  \n 1307  \t\t/*\n 1308: \t\t * We write small things into the context scratch array, then\n 1309  \t\t * copy that into the output buffer fragmenting as needed.  Next\n 1310  \t\t * time we will finish emptying the scratch into the output\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/jpeg.c:\n  618  \n  619  static lws_stateful_ret_t\n  620: read_sof_marker(lws_jpeg_t *j)\n  621  {\n  622  \tlws_stateful_ret_t r;\n  ...\n  753  // Read a start of scan (SOS) marker.\n  754  static lws_stateful_ret_t\n  755: read_sos_marker(lws_jpeg_t *j)\n  756  {\n  757  \tlws_stateful_ret_t r;\n  ...\n 1033  \t\n 1034  \t\t\t\t\tif (j->fs_pm_skip_budget < totalRead) {\n 1035: \t\t\t\t\t\tlwsl_jpeg(\"%s: read budget\\n\",\n 1036  \t\t\t\t\t\t\t\t__func__);\n 1037  \t\t\t\t\t\treturn LWS_SRET_FATAL + 14;\n ....\n 1097  \t\t\t\t\t}\n 1098  \n 1099: \t\t\t\t\t// read quantization entries, in zag order\n 1100  \t\t\t\t\twhile (j->fs_pm_i < 64) {\n 1101  \t\t\t\t\t\tswitch (j->fs_pm_have_n) {\n ....\n 1185  \t\t\tbreak;\n 1186  \n 1187: \t\t\t//case PJM_APP0:  /* no need to read the JFIF marker */\n 1188  \n 1189  \t\tcase PJM_JPG:\n ....\n 1399  \n 1400  \tcase 1:\n 1401: \t\tr = read_sos_marker(j);\n 1402  \t\tif (r)\n 1403  \t\t\treturn r;\n ....\n 2606  \t\tcase LWSJDS_FIND_SOF2:\n 2607  \t\t\t\n 2608: \t\t\tr = read_sof_marker(j);\n 2609  \t\t\tif (r)\n 2610  \t\t\t\tgoto fin;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/base64-decode.c:\n  209   * according to out_size\n  210   *\n  211:  * Only reads up to in_len chars, otherwise if in_len is -1 on entry reads until\n  212   * the first NUL in the input.\n  213   */\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/lejp.c:\n  403  \t\t\t\t\t * 0x080 - 0xfff (0x0800 - 0xffff)\n  404  \t\t\t\t\t * middle 3-byte seq\n  405: \t\t\t\t\t * send ....XXXXXX..\n  406  \t\t\t\t\t */\n  407  \t\t\t\t\tc = (unsigned char)(0x80 | ((ctx->uni >> 2) & 0x3f));\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/dir.c:\n   37  #if defined(WIN32)\n   38  #include <direct.h>\n   39: #define read _read\n   40  #define open _open\n   41  #define close _close\n   42: #define write _write\n   43  #define mkdir(x,y) _mkdir(x)\n   44  #define rmdir _rmdir\n   ..\n  257  \t\t * a symlink at all.\n  258  \t\t *\n  259: \t\t * Hide this from Coverity since it flags any use of readlink()\n  260  \t\t * even if safe.\n  261  \t\t */\n  262: \t\tif (readlink(path, dummy, sizeof(dummy)) < 0)\n  263  #endif\n  264  \t\t\tlws_dir(path, NULL, lws_dir_rm_rf_cb);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/dlo/dlo-font-mcufont.c:\n  143  \n  144  static void\n  145: write_ref_codeword(mcu_glyph_t *g, const uint8_t *bf, uint8_t c)\n  146  {\n  147  \tuint32_t o, o1;\n  ...\n  169  \n  170  \tif (c < DICT_START + lws_ser_ru32be(bf + MCUFO_COUNT_RLE_DICT)) {\n  171: \t\t/* write_rle_dictentry */\n  172  \t\to1 = lws_ser_ru32be(bf + MCUFO_FOFS_DICT_OFS);\n  173  \t\to = lws_ser_ru16be(bf + o1 + ((c - DICT_START) * 2));\n  ...\n  197  \tif (c < DICT_START + lws_ser_ru32be(&bf[MCUFO_COUNT_RLE_DICT]) ||\n  198  \t    c >= DICT_START + lws_ser_ru32be(&bf[MCUFO_COUNT_REF_RLE_DICT])) {\n  199: \t\twrite_ref_codeword(g, bf, c);\n  200  \t\treturn;\n  201  \t}\n  202  \n  203: \t/* write_ref_dictentry() */\n  204  \n  205  \to1 = lws_ser_ru32be(bf + MCUFO_FOFS_DICT_OFS);\n  ...\n  413  \n  414  \t\t\t\tcase DICT1:\n  415: \t\t\t\t\t/* write_bin_codeword() states */\n  416  \t\t\t\t\tel = 0;\n  417  \t\t\t\t\twhile (g->st[(int)g->sp].bitcount--) {\n  ...\n  454  \t\t\t\t\tbreak;\n  455  \n  456: \t\t\t\tcase DICT2: /* write_rle_dictentry */\n  457  \t\t\t\t\tc = (*g->st[(int)g->sp].dict++);\n  458  \t\t\t\t\tif (!--g->st[(int)g->sp].dictlen) {\n  ...\n  494  \t\t\t\t\t}\n  495  \n  496: \t\t\t\t\twrite_ref_codeword(g, bf,  c);\n  497  \t\t\t\t\tbreak;\n  498  \t\t\t\t}\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/cache-ttl/file.c:\n  144   * regenerate it, so we need to bind to a new inode.  We open it with an\n  145   * exclusive flock() so other processes can't replace conflicting changes\n  146:  * while we also write changes, without having to wait and see our changes.\n  147   */\n  148  \n  ...\n  165  \t\tlwsl_debug(\"%s: n %d, m %d\\n\", __func__, n, m);\n  166  \n  167: read:\n  168  \t\tif ((size_t)n >= sizeof(temp) - 1)\n  169  \t\t\t/* there's no space left in temp */\n  ...\n  179  \t\t\t * Removing this function from Coverity\n  180  \t\t\t */\n  181: \t\t\tn1s = read(fd, temp + n, sizeof(temp) - (size_t)n);\n  182  \n  183  \t\tlwsl_debug(\"%s: n1 %d\\n\", __func__, (int)n1s);\n  ...\n  240  \t\t\t}\n  241  \n  242: \t\t\tgoto read;\n  243  \t\t}\n  244  \n  ...\n  615  \tcache->cache.current_footprint += (uint64_t)size;\n  616  \n  617: \tif (write(ctx->fdt, buf, /*msvc*/(unsigned int)size) != (ssize_t)size)\n  618  \t\treturn NIR_FINISH_ERROR;\n  619  \n  620  \tif (flags & LCN_EOL)\n  621: \t\tif ((size_t)write(ctx->fdt, \"\\n\", 1) != 1)\n  622  \t\t\treturn NIR_FINISH_ERROR;\n  623  \n  ...\n  657  \tif (lws_fi(&cache->cache.info.cx->fic, \"cache_regen_temp_write\") ||\n  658  \t/* other consumers insist to see this at start of cookie jar */\n  659: \t    write(ctx.fdt, \"# Netscape HTTP Cookie File\\n\", 28) != 28)\n  660  \t\tgoto bail1;\n  661  \n  ...\n  663  \n  664  \tif (pay &&\n  665: \t    write(ctx.fdt, pay, /*msvc*/(unsigned int)pay_size) !=\n  666  \t\t\t\t\t\t    (ssize_t)pay_size)\n  667  \t\tgoto bail1;\n  668: \tif (pay && write(ctx.fdt, \"\\n\", 1u) != (ssize_t)1)\n  669  \t\tgoto bail1;\n  670  \n  ...\n  809  \n  810  \t*ctx->psize = size;\n  811: \tif (ctx->l1->info.ops->write(ctx->l1,\n  812  \t\t\t\t     ctx->specific_key, (const uint8_t *)buf,\n  813  \t\t\t\t     size, ctx->expiry, (void **)ctx->pdata))\n  ...\n  832  \n  833  \t*ctx->psize = size;\n  834: \tif (ctx->l1->info.ops->write(ctx->l1, ctx->specific_key, NULL,\n  835  \t\t\t\t     lws_buflist_total_len(&ctx->buflist),\n  836  \t\t\t\t     ctx->expiry, (void **)&q))\n  ...\n  984  \t.expunge\t\t= lws_cache_nscookiejar_expunge,\n  985  \n  986: \t.write\t\t\t= lws_cache_nscookiejar_write,\n  987  \t.tag_match\t\t= lws_cache_nscookiejar_tag_match,\n  988  \t.lookup\t\t\t= lws_cache_nscookiejar_lookup,\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/cache-ttl/lws-cache-ttl.c:\n   28  #include <assert.h>\n   29  \n   30: #if defined(write)\n   31: #undef write\n   32  #endif\n   33  \n   ..\n   74  \twhile (n) {\n   75  \t\tn--;\n   76: \t\tr = levels[n]->info.ops->write(levels[n], specific_key,\n   77  \t\t\t\t\t\tsource, size, expiry, ppay);\n   78  \t}\n   ..\n  185  \t */\n  186  \n  187: \tn = l1->info.ops->write(l1, meta_key, temp, sum, expiry, (void **)&p);\n  188  \t/* done with temp */\n  189  \tlws_free(temp);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/cache-ttl/heap.c:\n   26  #include \"private-lib-misc-cache-ttl.h\"\n   27  \n   28: #if defined(write)\n   29: #undef write\n   30  #endif\n   31  \n   ..\n  598  \t.expunge\t\t= lws_cache_heap_expunge,\n  599  \n  600: \t.write\t\t\t= lws_cache_heap_write,\n  601  \t.tag_match\t\t= lws_cache_heap_tag_match,\n  602  \t.lookup\t\t\t= lws_cache_heap_lookup,\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/lwsac/private-lib-misc-lwsac.h:\n   47  \tstruct lwsac *head; /* pointer back to the first chunk */\n   48  \tsize_t alloc_size; /* alloc size of the whole chunk */\n   49: \tsize_t ofs; /* next writeable position inside chunk */\n   50  };\n   51  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/lwsac/cached-file.c:\n  192  \ta[s.st_size] = '\\0';\n  193  \n  194: \trd = read(fd, a, (unsigned long)s.st_size);\n  195  \tif (rd != s.st_size) {\n  196: \t\tlwsl_err(\"%s: cannot read %s (%d)\\n\", __func__, filepath,\n  197  \t\t\t (int)rd);\n  198  \t\tgoto bail1;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/jrpc/private-lib-misc-jrpc.h:\n   37   * parsed by a method-bound user callback.\n   38   *\n   39:  * Streamed request processing must buffer its output before sending, since\n   40   * it does not know until the end if it must replace the intended response\n   41   * with an exception.  It may not know that it wants to make an exception\n   ..\n   51  \n   52  /*\n   53:  * Opaque object representing a request both at the sender and receiver\n   54   */\n   55  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/threadpool/threadpool.c:\n  446  \t\t * This will cause lws_threadpool_tsi_context() to get called\n  447  \t\t * from each tsi service context, where we can safely ask for\n  448: \t\t * a callback on writeable on the wsi we are associated with.\n  449  \t\t */\n  450  \t\tlws_cancel_service(lws_get_context(wsi));\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/fts/trie.c:\n  170  #define spill(margin, force) \\\n  171  \tif (bp && ((uint32_t)bp >= (sizeof(buf) - (size_t)(margin)) || (force))) { \\\n  172: \t\tif ((int)write(t->fd, buf, (size_t)bp) != bp) { \\\n  173: \t\t\tlwsl_err(\"%s: write %d failed (%d)\\n\", __func__, \\\n  174  \t\t\t\t bp, errno); \\\n  175  \t\t\treturn 1; \\\n  ...\n  222  \n  223  \n  224: /* read a VLI, return the number of bytes used */\n  225  \n  226  int\n  ...\n  278  \tmemset(t->root_lookup, 0, sizeof(*t->root_lookup));\n  279  \n  280: \t/* write the header */\n  281  \n  282  \tbuf[0] = 0xca;\n  ...\n  296  \tg32(&buf[0x10], 0);\n  297  \n  298: \tif (write(t->fd, buf, TRIE_FILE_HDR_SIZE) != TRIE_FILE_HDR_SIZE) {\n  299: \t\tlwsl_err(\"%s: trie header write failed\\n\", __func__);\n  300  \t\tgoto unwind;\n  301  \t}\n  ...\n  404  \tbp += g16(&buf[bp], 0);\n  405  \tbp += g32(&buf[bp], 0);\n  406: \tif ((int)write(t->fd, buf, (size_t)bp) != bp)\n  407  \t\treturn 1;\n  408  \tt->c += (unsigned int)bp;\n  ...\n  592  \t\t\tbp += wq32(&linetable[bp], (uint32_t)t->chars_in_line);\n  593  \t\t\tif ((unsigned int)bp > sizeof(linetable) - 6) {\n  594: \t\t\t\tif ((int)write(t->fd, linetable, (unsigned int)bp) != bp) {\n  595: \t\t\t\t\tlwsl_err(\"%s: linetable write failed\\n\",\n  596  \t\t\t\t\t\t\t__func__);\n  597  \t\t\t\t\treturn 1;\n  ...\n 1039  \t\t\tif (!strcmp(ne, \"describ\")) {\n 1040  \t\t\t\tlwsl_err(\"     %s %d\\n\", ne, t->str_match_pos);\n 1041: \t\t\t\twrite(1, buf - 10, 20);\n 1042  \t\t\t}\n 1043  \t\t}\n ....\n 1051  \n 1052  \tif (bp) {\n 1053: \t\tif ((int)write(t->fd, linetable, (size_t)bp) != bp)\n 1054  \t\t\treturn 1;\n 1055  \t\tt->c += (unsigned int)bp;\n ....\n 1066  \tg16(linetable + 2, (uint16_t)(t->line_number - sline));\n 1067  \tg32(linetable + 4, (uint32_t)chars);\n 1068: \tif ((int)write(t->fd, linetable, 8) != 8) {\n 1069: \t\tlwsl_err(\"%s: write linetable header failed\\n\", __func__);\n 1070  \t\treturn 1;\n 1071  \t}\n ....\n 1188  \tg32(buf, t->c + (unsigned int)bp);\n 1189  \tg32(buf + 4, (uint32_t)t->next_file_index);\n 1190: \tif ((int)write(t->fd, buf, 8) != 8)\n 1191  \t\tgoto bail;\n 1192  \n ....\n 1238  \t\te->ofs = t->c + (unsigned int)bp;\n 1239  \n 1240: \t\t/* write the trie entry header */\n 1241  \n 1242  \t\tspill((3 * MAX_VLI), 0);\n ....\n 1276  \t\t} while (!stasis);\n 1277  \n 1278: \t\t/* write the children */\n 1279  \n 1280  \t\te1 = e->child_list;\n ....\n 1347  \tg32(buf, t->root->ofs);\n 1348  \tg32(buf + 4, t->c);\n 1349: \tif (write(t->fd, buf, 0x8) != 0x8)\n 1350  \t\tgoto bail;\n 1351  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/fts/trie-fd.c:\n  102  \t}\n  103  \n  104: \tra = (int)read(jtf->fd, buf, 4);\n  105  \tif (ra < 0)\n  106  \t\treturn 1;\n  ...\n  113  \t}\n  114  \n  115: \tra = (int)read(jtf->fd, buf, sizeof(buf));\n  116  \tif (ra < 0)\n  117  \t\treturn 1;\n  ...\n  151  \toff_t ot;\n  152  \n  153: \tif (read(jtf->fd, buf, TRIE_FILE_HDR_SIZE) != TRIE_FILE_HDR_SIZE) {\n  154: \t\tlwsl_err(\"%s: unable to read file header\\n\", __func__);\n  155  \t\tgoto bail;\n  156  \t}\n  ...\n  231  \t\t} \\\n  232  \\\n  233: \t\tra = (int)read(jtf->fd, buf, (size_t)(_size)); \\\n  234  \t\tif (ra < 0) \\\n  235  \t\t\tgoto bail; \\\n  ...\n  603  \t\treturn result;\n  604  \n  605: \t/* the match list may easily exceed one read buffer load ... */\n  606  \n  607  \to += bp;\n  ...\n  714  \t\t\t\t\tcontinue;\n  715  \n  716: \t\t\t\tm = (int)read(ofd, lbuf, sizeof(lbuf) - 1);\n  717  \t\t\t\tif (m < 0)\n  718  \t\t\t\t\tcontinue;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/readable-stream.js:\n  183          ++this._size;\n  184      }\n  185:     // Like push(), shift() follows the read -> calculate -> mutate pattern for\n  186      // exception safety.\n  187      shift() {\n  ...\n  258  /* ----------- end of 'src/lib/abstract-ops/internal-methods.js' ------------ */\n  259  \n  260: /* ---------- start of 'src/lib/readable-stream/generic-reader.js' ---------- */\n  261  \n  262: export function ReadableStreamReaderGenericInitialize(reader, stream) {\n  263:     reader._ownerReadableStream = stream;\n  264:     stream._reader = reader;\n  265:     if (stream._state === 'readable') {\n  266:         defaultReaderClosedPromiseInitialize(reader);\n  267      }\n  268      else if (stream._state === 'closed') {\n  269:         defaultReaderClosedPromiseInitializeAsResolved(reader);\n  270      }\n  271      else {\n  272          assert(stream._state === 'errored');\n  273:         defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n  274      }\n  275  }\n  276  // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n  277  // check.\n  278: export function ReadableStreamReaderGenericCancel(reader, reason) {\n  279:     const stream = reader._ownerReadableStream;\n  280      assert(stream !== undefined);\n  281      return ReadableStreamCancel(stream, reason);\n  282  }\n  283: export function ReadableStreamReaderGenericRelease(reader) {\n  284:     const stream = reader._ownerReadableStream;\n  285      assert(stream !== undefined);\n  286:     assert(stream._reader === reader);\n  287:     if (stream._state === 'readable') {\n  288:         defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  289      }\n  290      else {\n  291:         defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  292      }\n  293      stream._readableStreamController[ReleaseSteps]();\n  294      stream._reader = undefined;\n  295:     reader._ownerReadableStream = undefined;\n  296  }\n  297: // Helper functions for the readers.\n  298: export function readerLockException(name) {\n  299:     return new TypeError('Cannot ' + name + ' a stream using a released reader');\n  300  }\n  301  // Helper functions for the ReadableStreamDefaultReader.\n  302: export function defaultReaderClosedPromiseInitialize(reader) {\n  303:     reader._closedPromise = newPromise((resolve, reject) => {\n  304:         reader._closedPromise_resolve = resolve;\n  305:         reader._closedPromise_reject = reject;\n  306      });\n  307  }\n  308: export function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n  309:     defaultReaderClosedPromiseInitialize(reader);\n  310:     defaultReaderClosedPromiseReject(reader, reason);\n  311  }\n  312: export function defaultReaderClosedPromiseInitializeAsResolved(reader) {\n  313:     defaultReaderClosedPromiseInitialize(reader);\n  314:     defaultReaderClosedPromiseResolve(reader);\n  315  }\n  316: export function defaultReaderClosedPromiseReject(reader, reason) {\n  317:     if (reader._closedPromise_reject === undefined) {\n  318          return;\n  319      }\n  320:     setPromiseIsHandledToTrue(reader._closedPromise);\n  321:     reader._closedPromise_reject(reason);\n  322:     reader._closedPromise_resolve = undefined;\n  323:     reader._closedPromise_reject = undefined;\n  324  }\n  325: export function defaultReaderClosedPromiseResetToRejected(reader, reason) {\n  326:     assert(reader._closedPromise_resolve === undefined);\n  327:     assert(reader._closedPromise_reject === undefined);\n  328:     defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n  329  }\n  330: export function defaultReaderClosedPromiseResolve(reader) {\n  331:     if (reader._closedPromise_resolve === undefined) {\n  332          return;\n  333      }\n  334:     reader._closedPromise_resolve(undefined);\n  335:     reader._closedPromise_resolve = undefined;\n  336:     reader._closedPromise_reject = undefined;\n  337  }\n  338  \n  339: /* ----------- end of 'src/lib/readable-stream/generic-reader.js' ----------- */\n  340  \n  341  /* ----------------- start of 'src/stub/number-isfinite.js' ----------------- */\n  ...\n  430  /* ------------------ end of 'src/lib/validators/basic.js' ------------------ */\n  431  \n  432: /* ------------ start of 'src/lib/validators/readable-stream.js' ------------ */\n  433  \n  434  export function assertReadableStream(x, context) {\n  ...\n  438  }\n  439  \n  440: /* ------------- end of 'src/lib/validators/readable-stream.js' ------------- */\n  441  \n  442: /* ---------- start of 'src/lib/readable-stream/default-reader.js' ---------- */\n  443  \n  444  // Abstract operations for the ReadableStream.\n  ...\n  447  }\n  448  // ReadableStream API exposed for controllers.\n  449: export function ReadableStreamAddReadRequest(stream, readRequest) {\n  450      assert(IsReadableStreamDefaultReader(stream._reader));\n  451:     assert(stream._state === 'readable');\n  452:     stream._reader._readRequests.push(readRequest);\n  453  }\n  454  export function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n  455:     const reader = stream._reader;\n  456:     assert(reader._readRequests.length > 0);\n  457:     const readRequest = reader._readRequests.shift();\n  458      if (done) {\n  459:         readRequest._closeSteps();\n  460      }\n  461      else {\n  462:         readRequest._chunkSteps(chunk);\n  463      }\n  464  }\n  ...\n  467  }\n  468  export function ReadableStreamHasDefaultReader(stream) {\n  469:     const reader = stream._reader;\n  470:     if (reader === undefined) {\n  471          return false;\n  472      }\n  473:     if (!IsReadableStreamDefaultReader(reader)) {\n  474          return false;\n  475      }\n  ...\n  477  }\n  478  /**\n  479:  * A default reader vended by a {@link ReadableStream}.\n  480   *\n  481   * @public\n  ...\n  486          assertReadableStream(stream, 'First parameter');\n  487          if (IsReadableStreamLocked(stream)) {\n  488:             throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n  489          }\n  490          ReadableStreamReaderGenericInitialize(this, stream);\n  ...\n  493      /**\n  494       * Returns a promise that will be fulfilled when the stream becomes closed,\n  495:      * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n  496       */\n  497      get closed() {\n  ...\n  502      }\n  503      /**\n  504:      * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n  505       */\n  506      cancel(reason = undefined) {\n  ...\n  509          }\n  510          if (this._ownerReadableStream === undefined) {\n  511:             return promiseRejectedWith(readerLockException('cancel'));\n  512          }\n  513          return ReadableStreamReaderGenericCancel(this, reason);\n  ...\n  516       * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n  517       *\n  518:      * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  519       */\n  520:     read() {\n  521          if (!IsReadableStreamDefaultReader(this)) {\n  522:             return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  523          }\n  524          if (this._ownerReadableStream === undefined) {\n  525:             return promiseRejectedWith(readerLockException('read from'));\n  526          }\n  527          let resolvePromise;\n  ...\n  531              rejectPromise = reject;\n  532          });\n  533:         const readRequest = {\n  534              _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n  535              _closeSteps: () => resolvePromise({ value: undefined, done: true }),\n  536              _errorSteps: e => rejectPromise(e)\n  537          };\n  538:         ReadableStreamDefaultReaderRead(this, readRequest);\n  539          return promise;\n  540      }\n  541      /**\n  542:      * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n  543:      * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n  544:      * from now on; otherwise, the reader will appear closed.\n  545       *\n  546:      * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  547:      * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  548:      * do so will throw a `TypeError` and leave the reader locked to the stream.\n  549       */\n  550      releaseLock() {\n  ...\n  560  Object.defineProperties(ReadableStreamDefaultReader.prototype, {\n  561      cancel: { enumerable: true },\n  562:     read: { enumerable: true },\n  563      releaseLock: { enumerable: true },\n  564      closed: { enumerable: true }\n  565  });\n  566  setFunctionName(ReadableStreamDefaultReader.prototype.cancel, 'cancel');\n  567: setFunctionName(ReadableStreamDefaultReader.prototype.read, 'read');\n  568  setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, 'releaseLock');\n  569  if (typeof Symbol.toStringTag === 'symbol') {\n  ...\n  573      });\n  574  }\n  575: // Abstract operations for the readers.\n  576  export function IsReadableStreamDefaultReader(x) {\n  577      if (!typeIsObject(x)) {\n  ...\n  583      return x instanceof ReadableStreamDefaultReader;\n  584  }\n  585: export function ReadableStreamDefaultReaderRead(reader, readRequest) {\n  586:     const stream = reader._ownerReadableStream;\n  587      assert(stream !== undefined);\n  588      stream._disturbed = true;\n  589      if (stream._state === 'closed') {\n  590:         readRequest._closeSteps();\n  591      }\n  592      else if (stream._state === 'errored') {\n  593:         readRequest._errorSteps(stream._storedError);\n  594      }\n  595      else {\n  596:         assert(stream._state === 'readable');\n  597:         stream._readableStreamController[PullSteps](readRequest);\n  598      }\n  599  }\n  600: export function ReadableStreamDefaultReaderRelease(reader) {\n  601:     ReadableStreamReaderGenericRelease(reader);\n  602      const e = new TypeError('Reader was released');\n  603:     ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n  604  }\n  605: export function ReadableStreamDefaultReaderErrorReadRequests(reader, e) {\n  606:     const readRequests = reader._readRequests;\n  607:     reader._readRequests = new SimpleQueue();\n  608:     readRequests.forEach((readRequest) => {\n  609:         readRequest._errorSteps(e);\n  610      });\n  611  }\n  ...\n  615  }\n  616  \n  617: /* ----------- end of 'src/lib/readable-stream/default-reader.js' ----------- */\n  618  \n  619  /* ------------- start of 'src/lib/abstract-ops/ecmascript.js' -------------- */\n  ...\n  773  /* -------------- end of 'src/lib/abstract-ops/ecmascript.js' --------------- */\n  774  \n  775: /* ---------- start of 'src/lib/readable-stream/async-iterator.js' ---------- */\n  776  \n  777  export class ReadableStreamAsyncIteratorImpl {\n  778:     constructor(reader, preventCancel) {\n  779          this._ongoingPromise = undefined;\n  780          this._isFinished = false;\n  781:         this._reader = reader;\n  782          this._preventCancel = preventCancel;\n  783      }\n  ...\n  800              return Promise.resolve({ value: undefined, done: true });\n  801          }\n  802:         const reader = this._reader;\n  803:         assert(reader._ownerReadableStream !== undefined);\n  804          let resolvePromise;\n  805          let rejectPromise;\n  ...\n  808              rejectPromise = reject;\n  809          });\n  810:         const readRequest = {\n  811              _chunkSteps: (chunk) => {\n  812                  this._ongoingPromise = undefined;\n  ...\n  818                  this._ongoingPromise = undefined;\n  819                  this._isFinished = true;\n  820:                 ReadableStreamReaderGenericRelease(reader);\n  821                  resolvePromise({ value: undefined, done: true });\n  822              },\n  ...\n  824                  this._ongoingPromise = undefined;\n  825                  this._isFinished = true;\n  826:                 ReadableStreamReaderGenericRelease(reader);\n  827                  rejectPromise(reason);\n  828              }\n  829          };\n  830:         ReadableStreamDefaultReaderRead(reader, readRequest);\n  831          return promise;\n  832      }\n  ...\n  836          }\n  837          this._isFinished = true;\n  838:         const reader = this._reader;\n  839:         assert(reader._ownerReadableStream !== undefined);\n  840:         assert(reader._readRequests.length === 0);\n  841          if (!this._preventCancel) {\n  842:             const result = ReadableStreamReaderGenericCancel(reader, value);\n  843:             ReadableStreamReaderGenericRelease(reader);\n  844              return transformPromiseWith(result, () => ({ value, done: true }));\n  845          }\n  846:         ReadableStreamReaderGenericRelease(reader);\n  847          return promiseResolvedWith({ value, done: true });\n  848      }\n  ...\n  872  // Abstract operations for the ReadableStream.\n  873  export function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n  874:     const reader = AcquireReadableStreamDefaultReader(stream);\n  875:     const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n  876      const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n  877      iterator._asyncIteratorImpl = impl;\n  ...\n  899  }\n  900  \n  901: /* ----------- end of 'src/lib/readable-stream/async-iterator.js' ----------- */\n  902  \n  903  /* ------------------ start of 'src/stub/number-isnan.js' ------------------- */\n  ...\n  996  /* ------------- end of 'src/lib/helpers/array-buffer-view.js' -------------- */\n  997  \n  998: /* ------ start of 'src/lib/readable-stream/byte-stream-controller.js' ------ */\n  999  \n 1000  /**\n ....\n 1063  }\n 1064  /**\n 1065:  * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n 1066   *\n 1067   * @public\n ....\n 1091      }\n 1092      /**\n 1093:      * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n 1094:      * the stream, but once those are read, the stream will become closed.\n 1095       */\n 1096      close() {\n ....\n 1102          }\n 1103          const state = this._controlledReadableByteStream._state;\n 1104:         if (state !== 'readable') {\n 1105:             throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n 1106          }\n 1107          ReadableByteStreamControllerClose(this);\n ....\n 1125          }\n 1126          const state = this._controlledReadableByteStream._state;\n 1127:         if (state !== 'readable') {\n 1128:             throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n 1129          }\n 1130          ReadableByteStreamControllerEnqueue(this, chunk);\n 1131      }\n 1132      /**\n 1133:      * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n 1134       */\n 1135      error(e = undefined) {\n ....\n 1148      }\n 1149      /** @internal */\n 1150:     [PullSteps](readRequest) {\n 1151          const stream = this._controlledReadableByteStream;\n 1152          assert(ReadableStreamHasDefaultReader(stream));\n 1153          if (this._queueTotalSize > 0) {\n 1154              assert(ReadableStreamGetNumReadRequests(stream) === 0);\n 1155:             ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);\n 1156              return;\n 1157          }\n ....\n 1163              }\n 1164              catch (bufferE) {\n 1165:                 readRequest._errorSteps(bufferE);\n 1166                  return;\n 1167              }\n ....\n 1175                  elementSize: 1,\n 1176                  viewConstructor: Uint8Array,\n 1177:                 readerType: 'default'\n 1178              };\n 1179              this._pendingPullIntos.push(pullIntoDescriptor);\n 1180          }\n 1181:         ReadableStreamAddReadRequest(stream, readRequest);\n 1182          ReadableByteStreamControllerCallPullIfNeeded(this);\n 1183      }\n ....\n 1186          if (this._pendingPullIntos.length > 0) {\n 1187              const firstPullInto = this._pendingPullIntos.peek();\n 1188:             firstPullInto.readerType = 'none';\n 1189              this._pendingPullIntos = new SimpleQueue();\n 1190              this._pendingPullIntos.push(firstPullInto);\n ....\n 1258  function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n 1259      assert(stream._state !== 'errored');\n 1260:     assert(pullIntoDescriptor.readerType !== 'none');\n 1261      let done = false;\n 1262      if (stream._state === 'closed') {\n ....\n 1265      }\n 1266      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n 1267:     if (pullIntoDescriptor.readerType === 'default') {\n 1268          ReadableStreamFulfillReadRequest(stream, filledView, done);\n 1269      }\n 1270      else {\n 1271:         assert(pullIntoDescriptor.readerType === 'byob');\n 1272          ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n 1273      }\n ....\n 1301  }\n 1302  function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {\n 1303:     assert(firstDescriptor.readerType === 'none');\n 1304      if (firstDescriptor.bytesFilled > 0) {\n 1305          ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);\n ....\n 1311      const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n 1312      let totalBytesToCopyRemaining = maxBytesToCopy;\n 1313:     let ready = false;\n 1314      assert(!IsDetachedBuffer(pullIntoDescriptor.buffer));\n 1315      assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n 1316      const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\n 1317      const maxAlignedBytes = maxBytesFilled - remainderBytes;\n 1318:     // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n 1319      // of the queue, so the underlying source can keep filling it.\n 1320      if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n 1321          totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n 1322:         ready = true;\n 1323      }\n 1324      const queue = controller._queue;\n ....\n 1340          totalBytesToCopyRemaining -= bytesToCopy;\n 1341      }\n 1342:     if (!ready) {\n 1343          assert(controller._queueTotalSize === 0);\n 1344          assert(pullIntoDescriptor.bytesFilled > 0);\n 1345          assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n 1346      }\n 1347:     return ready;\n 1348  }\n 1349  function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n ....\n 1353  }\n 1354  function ReadableByteStreamControllerHandleQueueDrain(controller) {\n 1355:     assert(controller._controlledReadableByteStream._state === 'readable');\n 1356      if (controller._queueTotalSize === 0 && controller._closeRequested) {\n 1357          ReadableByteStreamControllerClearAlgorithms(controller);\n ....\n 1378          }\n 1379          const pullIntoDescriptor = controller._pendingPullIntos.peek();\n 1380:         assert(pullIntoDescriptor.readerType !== 'none');\n 1381          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n 1382              ReadableByteStreamControllerShiftPendingPullInto(controller);\n ....\n 1387  }\n 1388  function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller) {\n 1389:     const reader = controller._controlledReadableByteStream._reader;\n 1390:     assert(IsReadableStreamDefaultReader(reader));\n 1391:     while (reader._readRequests.length > 0) {\n 1392          if (controller._queueTotalSize === 0) {\n 1393              return;\n 1394          }\n 1395:         const readRequest = reader._readRequests.shift();\n 1396:         ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);\n 1397      }\n 1398  }\n 1399: export function ReadableByteStreamControllerPullInto(controller, view, min, readIntoRequest) {\n 1400      const stream = controller._controlledReadableByteStream;\n 1401      const ctor = view.constructor;\n ....\n 1410      }\n 1411      catch (e) {\n 1412:         readIntoRequest._errorSteps(e);\n 1413          return;\n 1414      }\n ....\n 1422          elementSize,\n 1423          viewConstructor: ctor,\n 1424:         readerType: 'byob'\n 1425      };\n 1426      if (controller._pendingPullIntos.length > 0) {\n ....\n 1428          // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n 1429          // - No change happens on desiredSize\n 1430:         // - The source has already been notified of that there's at least 1 pending read(view)\n 1431:         ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n 1432          return;\n 1433      }\n 1434      if (stream._state === 'closed') {\n 1435          const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n 1436:         readIntoRequest._closeSteps(emptyView);\n 1437          return;\n 1438      }\n ....\n 1441              const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n 1442              ReadableByteStreamControllerHandleQueueDrain(controller);\n 1443:             readIntoRequest._chunkSteps(filledView);\n 1444              return;\n 1445          }\n ....\n 1447              const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n 1448              ReadableByteStreamControllerError(controller, e);\n 1449:             readIntoRequest._errorSteps(e);\n 1450              return;\n 1451          }\n 1452      }\n 1453      controller._pendingPullIntos.push(pullIntoDescriptor);\n 1454:     ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n 1455      ReadableByteStreamControllerCallPullIfNeeded(controller);\n 1456  }\n 1457  function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n 1458      assert(firstDescriptor.bytesFilled % firstDescriptor.elementSize === 0);\n 1459:     if (firstDescriptor.readerType === 'none') {\n 1460          ReadableByteStreamControllerShiftPendingPullInto(controller);\n 1461      }\n ....\n 1472      assert(pullIntoDescriptor.bytesFilled + bytesWritten <= pullIntoDescriptor.byteLength);\n 1473      ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n 1474:     if (pullIntoDescriptor.readerType === 'none') {\n 1475          ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);\n 1476          const filledPullIntos = ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n ....\n 1479      }\n 1480      if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\n 1481:         // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n 1482          // of the queue, so the underlying source can keep filling it.\n 1483          return;\n ....\n 1504      }\n 1505      else {\n 1506:         assert(state === 'readable');\n 1507          assert(bytesWritten > 0);\n 1508          ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n ....\n 1517  function ReadableByteStreamControllerShouldCallPull(controller) {\n 1518      const stream = controller._controlledReadableByteStream;\n 1519:     if (stream._state !== 'readable') {\n 1520          return false;\n 1521      }\n ....\n 1546  export function ReadableByteStreamControllerClose(controller) {\n 1547      const stream = controller._controlledReadableByteStream;\n 1548:     if (controller._closeRequested || stream._state !== 'readable') {\n 1549          return;\n 1550      }\n ....\n 1566  export function ReadableByteStreamControllerEnqueue(controller, chunk) {\n 1567      const stream = controller._controlledReadableByteStream;\n 1568:     if (controller._closeRequested || stream._state !== 'readable') {\n 1569          return;\n 1570      }\n ....\n 1581          ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n 1582          firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n 1583:         if (firstPendingPullInto.readerType === 'none') {\n 1584              ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);\n 1585          }\n ....\n 1594              assert(controller._queue.length === 0);\n 1595              if (controller._pendingPullIntos.length > 0) {\n 1596:                 assert(controller._pendingPullIntos.peek().readerType === 'default');\n 1597                  ReadableByteStreamControllerShiftPendingPullInto(controller);\n 1598              }\n ....\n 1615  export function ReadableByteStreamControllerError(controller, e) {\n 1616      const stream = controller._controlledReadableByteStream;\n 1617:     if (stream._state !== 'readable') {\n 1618          return;\n 1619      }\n ....\n 1623      ReadableStreamError(stream, e);\n 1624  }\n 1625: export function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {\n 1626      assert(controller._queueTotalSize > 0);\n 1627      const entry = controller._queue.shift();\n ....\n 1629      ReadableByteStreamControllerHandleQueueDrain(controller);\n 1630      const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n 1631:     readRequest._chunkSteps(view);\n 1632  }\n 1633  export function ReadableByteStreamControllerGetBYOBRequest(controller) {\n ....\n 1661      }\n 1662      else {\n 1663:         assert(state === 'readable');\n 1664          if (bytesWritten === 0) {\n 1665:             throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');\n 1666          }\n 1667          if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n ....\n 1683      }\n 1684      else {\n 1685:         assert(state === 'readable');\n 1686          if (view.byteLength === 0) {\n 1687:             throw new TypeError('The view\\'s length must be greater than 0 when calling respondWithNewView() on a readable stream');\n 1688          }\n 1689      }\n ....\n 1780  }\n 1781  \n 1782: /* ------- end of 'src/lib/readable-stream/byte-stream-controller.js' ------- */\n 1783  \n 1784: /* ------------ start of 'src/lib/validators/reader-options.js' ------------- */\n 1785  \n 1786  export function convertReaderOptions(options, context) {\n ....\n 1807  }\n 1808  \n 1809: /* ------------- end of 'src/lib/validators/reader-options.js' -------------- */\n 1810  \n 1811: /* ----------- start of 'src/lib/readable-stream/byob-reader.js' ------------ */\n 1812  \n 1813  // Abstract operations for the ReadableStream.\n ....\n 1816  }\n 1817  // ReadableStream API exposed for controllers.\n 1818: export function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n 1819      assert(IsReadableStreamBYOBReader(stream._reader));\n 1820:     assert(stream._state === 'readable' || stream._state === 'closed');\n 1821:     stream._reader._readIntoRequests.push(readIntoRequest);\n 1822  }\n 1823  export function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n 1824:     const reader = stream._reader;\n 1825:     assert(reader._readIntoRequests.length > 0);\n 1826:     const readIntoRequest = reader._readIntoRequests.shift();\n 1827      if (done) {\n 1828:         readIntoRequest._closeSteps(chunk);\n 1829      }\n 1830      else {\n 1831:         readIntoRequest._chunkSteps(chunk);\n 1832      }\n 1833  }\n ....\n 1836  }\n 1837  export function ReadableStreamHasBYOBReader(stream) {\n 1838:     const reader = stream._reader;\n 1839:     if (reader === undefined) {\n 1840          return false;\n 1841      }\n 1842:     if (!IsReadableStreamBYOBReader(reader)) {\n 1843          return false;\n 1844      }\n ....\n 1846  }\n 1847  /**\n 1848:  * A BYOB reader vended by a {@link ReadableStream}.\n 1849   *\n 1850   * @public\n ....\n 1855          assertReadableStream(stream, 'First parameter');\n 1856          if (IsReadableStreamLocked(stream)) {\n 1857:             throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n 1858          }\n 1859          if (!IsReadableByteStreamController(stream._readableStreamController)) {\n ....\n 1866      /**\n 1867       * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n 1868:      * the reader's lock is released before the stream finishes closing.\n 1869       */\n 1870      get closed() {\n ....\n 1875      }\n 1876      /**\n 1877:      * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n 1878       */\n 1879      cancel(reason = undefined) {\n ....\n 1882          }\n 1883          if (this._ownerReadableStream === undefined) {\n 1884:             return promiseRejectedWith(readerLockException('cancel'));\n 1885          }\n 1886          return ReadableStreamReaderGenericCancel(this, reason);\n 1887      }\n 1888:     read(view, rawOptions = {}) {\n 1889          if (!IsReadableStreamBYOBReader(this)) {\n 1890:             return promiseRejectedWith(byobReaderBrandCheckException('read'));\n 1891          }\n 1892          if (!ArrayBuffer.isView(view)) {\n ....\n 1922          }\n 1923          if (this._ownerReadableStream === undefined) {\n 1924:             return promiseRejectedWith(readerLockException('read from'));\n 1925          }\n 1926          let resolvePromise;\n ....\n 1930              rejectPromise = reject;\n 1931          });\n 1932:         const readIntoRequest = {\n 1933              _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n 1934              _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n 1935              _errorSteps: e => rejectPromise(e)\n 1936          };\n 1937:         ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);\n 1938          return promise;\n 1939      }\n 1940      /**\n 1941:      * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n 1942:      * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n 1943:      * from now on; otherwise, the reader will appear closed.\n 1944       *\n 1945:      * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n 1946:      * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n 1947:      * do so will throw a `TypeError` and leave the reader locked to the stream.\n 1948       */\n 1949      releaseLock() {\n ....\n 1959  Object.defineProperties(ReadableStreamBYOBReader.prototype, {\n 1960      cancel: { enumerable: true },\n 1961:     read: { enumerable: true },\n 1962      releaseLock: { enumerable: true },\n 1963      closed: { enumerable: true }\n 1964  });\n 1965  setFunctionName(ReadableStreamBYOBReader.prototype.cancel, 'cancel');\n 1966: setFunctionName(ReadableStreamBYOBReader.prototype.read, 'read');\n 1967  setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, 'releaseLock');\n 1968  if (typeof Symbol.toStringTag === 'symbol') {\n ....\n 1972      });\n 1973  }\n 1974: // Abstract operations for the readers.\n 1975  export function IsReadableStreamBYOBReader(x) {\n 1976      if (!typeIsObject(x)) {\n ....\n 1982      return x instanceof ReadableStreamBYOBReader;\n 1983  }\n 1984: export function ReadableStreamBYOBReaderRead(reader, view, min, readIntoRequest) {\n 1985:     const stream = reader._ownerReadableStream;\n 1986      assert(stream !== undefined);\n 1987      stream._disturbed = true;\n 1988      if (stream._state === 'errored') {\n 1989:         readIntoRequest._errorSteps(stream._storedError);\n 1990      }\n 1991      else {\n 1992:         ReadableByteStreamControllerPullInto(stream._readableStreamController, view, min, readIntoRequest);\n 1993      }\n 1994  }\n 1995: export function ReadableStreamBYOBReaderRelease(reader) {\n 1996:     ReadableStreamReaderGenericRelease(reader);\n 1997      const e = new TypeError('Reader was released');\n 1998:     ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n 1999  }\n 2000: export function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e) {\n 2001:     const readIntoRequests = reader._readIntoRequests;\n 2002:     reader._readIntoRequests = new SimpleQueue();\n 2003:     readIntoRequests.forEach((readIntoRequest) => {\n 2004:         readIntoRequest._errorSteps(e);\n 2005      });\n 2006  }\n ....\n 2010  }\n 2011  \n 2012: /* ------------ end of 'src/lib/readable-stream/byob-reader.js' ------------- */\n 2013  \n 2014  /* ---------- start of 'src/lib/abstract-ops/queuing-strategy.js' ----------- */\n ....\n 2060      const start = original === null || original === void 0 ? void 0 : original.start;\n 2061      const type = original === null || original === void 0 ? void 0 : original.type;\n 2062:     const write = original === null || original === void 0 ? void 0 : original.write;\n 2063      return {\n 2064          abort: abort === undefined\n ....\n 2071              ? undefined\n 2072              : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n 2073:         write: write === undefined\n 2074              ? undefined\n 2075:             : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n 2076          type\n 2077      };\n ....\n 2137  \n 2138  /**\n 2139:  * A writable stream represents a destination for data, into which you can write.\n 2140   *\n 2141   * @public\n ....\n 2161      }\n 2162      /**\n 2163:      * Returns whether or not the writable stream is locked to a writer.\n 2164       */\n 2165      get locked() {\n ....\n 2170      }\n 2171      /**\n 2172:      * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n 2173:      * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n 2174       * mechanism of the underlying sink.\n 2175       *\n ....\n 2183          }\n 2184          if (IsWritableStreamLocked(this)) {\n 2185:             return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n 2186          }\n 2187          return WritableStreamAbort(this, reason);\n ....\n 2189      /**\n 2190       * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n 2191:      * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n 2192       *\n 2193       * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n ....\n 2200          }\n 2201          if (IsWritableStreamLocked(this)) {\n 2202:             return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n 2203          }\n 2204          if (WritableStreamCloseQueuedOrInFlight(this)) {\n ....\n 2208      }\n 2209      /**\n 2210:      * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n 2211:      * is locked, no other writer can be acquired until this one is released.\n 2212       *\n 2213:      * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n 2214:      * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n 2215       * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n 2216       */\n ....\n 2243  }\n 2244  // Throws if and only if startAlgorithm throws.\n 2245: function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n 2246      assert(IsNonNegativeNumber(highWaterMark));\n 2247      const stream = Object.create(WritableStream.prototype);\n 2248      InitializeWritableStream(stream);\n 2249      const controller = Object.create(WritableStreamDefaultController.prototype);\n 2250:     SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n 2251      return stream;\n 2252  }\n ....\n 2260      // variable to validate the caller.\n 2261      stream._writableStreamController = undefined;\n 2262:     // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n 2263:     // producer without waiting for the queued writes to finish.\n 2264      stream._writeRequests = new SimpleQueue();\n 2265:     // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n 2266:     // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n 2267      stream._inFlightWriteRequest = undefined;\n 2268:     // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n 2269      // has been detached.\n 2270      stream._closeRequest = undefined;\n ....\n 2272      // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n 2273      stream._inFlightCloseRequest = undefined;\n 2274:     // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n 2275      stream._pendingAbortRequest = undefined;\n 2276      // The backpressure signal set by the controller.\n ....\n 2346          stream._closeRequest = closeRequest;\n 2347      });\n 2348:     const writer = stream._writer;\n 2349:     if (writer !== undefined && stream._backpressure && state === 'writable') {\n 2350:         defaultWriterReadyPromiseResolve(writer);\n 2351      }\n 2352      WritableStreamDefaultControllerClose(stream._writableStreamController);\n ....\n 2358      assert(stream._state === 'writable');\n 2359      const promise = newPromise((resolve, reject) => {\n 2360:         const writeRequest = {\n 2361              _resolve: resolve,\n 2362              _reject: reject\n 2363          };\n 2364:         stream._writeRequests.push(writeRequest);\n 2365      });\n 2366      return promise;\n ....\n 2382      stream._state = 'erroring';\n 2383      stream._storedError = reason;\n 2384:     const writer = stream._writer;\n 2385:     if (writer !== undefined) {\n 2386:         WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n 2387      }\n 2388      if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n ....\n 2396      stream._writableStreamController[ErrorSteps]();\n 2397      const storedError = stream._storedError;\n 2398:     stream._writeRequests.forEach((writeRequest) => {\n 2399:         writeRequest._reject(storedError);\n 2400      });\n 2401      stream._writeRequests = new SimpleQueue();\n ....\n 2449      }\n 2450      stream._state = 'closed';\n 2451:     const writer = stream._writer;\n 2452:     if (writer !== undefined) {\n 2453:         defaultWriterClosedPromiseResolve(writer);\n 2454      }\n 2455      assert(stream._pendingAbortRequest === undefined);\n ....\n 2499          stream._closeRequest = undefined;\n 2500      }\n 2501:     const writer = stream._writer;\n 2502:     if (writer !== undefined) {\n 2503:         defaultWriterClosedPromiseReject(writer, stream._storedError);\n 2504      }\n 2505  }\n ....\n 2507      assert(stream._state === 'writable');\n 2508      assert(!WritableStreamCloseQueuedOrInFlight(stream));\n 2509:     const writer = stream._writer;\n 2510:     if (writer !== undefined && backpressure !== stream._backpressure) {\n 2511          if (backpressure) {\n 2512:             defaultWriterReadyPromiseReset(writer);\n 2513          }\n 2514          else {\n 2515              assert(!backpressure);\n 2516:             defaultWriterReadyPromiseResolve(writer);\n 2517          }\n 2518      }\n ....\n 2520  }\n 2521  /**\n 2522:  * A default writer vended by a {@link WritableStream}.\n 2523   *\n 2524   * @public\n ....\n 2529          assertWritableStream(stream, 'First parameter');\n 2530          if (IsWritableStreamLocked(stream)) {\n 2531:             throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n 2532          }\n 2533          this._ownerWritableStream = stream;\n ....\n 2560      /**\n 2561       * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n 2562:      * the writerâ€™s lock is released before the stream finishes closing.\n 2563       */\n 2564      get closed() {\n ....\n 2570      /**\n 2571       * Returns the desired size to fill the streamâ€™s internal queue. It can be negative, if the queue is over-full.\n 2572:      * A producer can use this information to determine the right amount of data to write.\n 2573       *\n 2574       * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n 2575       * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n 2576:      * the writerâ€™s lock is released.\n 2577       */\n 2578      get desiredSize() {\n ....\n 2590       * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n 2591       *\n 2592:      * If the stream becomes errored or aborted, or the writerâ€™s lock is released, the returned promise will become\n 2593       * rejected.\n 2594       */\n 2595:     get ready() {\n 2596          if (!IsWritableStreamDefaultWriter(this)) {\n 2597:             return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n 2598          }\n 2599          return this._readyPromise;\n 2600      }\n 2601      /**\n 2602:      * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n 2603       */\n 2604      abort(reason = undefined) {\n ....\n 2612      }\n 2613      /**\n 2614:      * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n 2615       */\n 2616      close() {\n ....\n 2628      }\n 2629      /**\n 2630:      * Releases the writerâ€™s lock on the corresponding stream. After the lock is released, the writer is no longer active.\n 2631:      * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n 2632:      * now on; otherwise, the writer will appear closed.\n 2633       *\n 2634:      * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n 2635:      * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n 2636:      * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n 2637       * other producers from writing in an interleaved manner.\n 2638       */\n ....\n 2648          WritableStreamDefaultWriterRelease(this);\n 2649      }\n 2650:     write(chunk = undefined) {\n 2651          if (!IsWritableStreamDefaultWriter(this)) {\n 2652:             return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n 2653          }\n 2654          if (this._ownerWritableStream === undefined) {\n 2655:             return promiseRejectedWith(defaultWriterLockException('write to'));\n 2656          }\n 2657          return WritableStreamDefaultWriterWrite(this, chunk);\n ....\n 2662      close: { enumerable: true },\n 2663      releaseLock: { enumerable: true },\n 2664:     write: { enumerable: true },\n 2665      closed: { enumerable: true },\n 2666      desiredSize: { enumerable: true },\n 2667:     ready: { enumerable: true }\n 2668  });\n 2669  setFunctionName(WritableStreamDefaultWriter.prototype.abort, 'abort');\n 2670  setFunctionName(WritableStreamDefaultWriter.prototype.close, 'close');\n 2671  setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, 'releaseLock');\n 2672: setFunctionName(WritableStreamDefaultWriter.prototype.write, 'write');\n 2673  if (typeof Symbol.toStringTag === 'symbol') {\n 2674      Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {\n ....\n 2688  }\n 2689  // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n 2690: function WritableStreamDefaultWriterAbort(writer, reason) {\n 2691:     const stream = writer._ownerWritableStream;\n 2692      assert(stream !== undefined);\n 2693      return WritableStreamAbort(stream, reason);\n 2694  }\n 2695: function WritableStreamDefaultWriterClose(writer) {\n 2696:     const stream = writer._ownerWritableStream;\n 2697      assert(stream !== undefined);\n 2698      return WritableStreamClose(stream);\n 2699  }\n 2700: function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n 2701:     const stream = writer._ownerWritableStream;\n 2702      assert(stream !== undefined);\n 2703      const state = stream._state;\n ....\n 2709      }\n 2710      assert(state === 'writable' || state === 'erroring');\n 2711:     return WritableStreamDefaultWriterClose(writer);\n 2712  }\n 2713: function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n 2714:     if (writer._closedPromiseState === 'pending') {\n 2715:         defaultWriterClosedPromiseReject(writer, error);\n 2716      }\n 2717      else {\n 2718:         defaultWriterClosedPromiseResetToRejected(writer, error);\n 2719      }\n 2720  }\n 2721: function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n 2722:     if (writer._readyPromiseState === 'pending') {\n 2723:         defaultWriterReadyPromiseReject(writer, error);\n 2724      }\n 2725      else {\n 2726:         defaultWriterReadyPromiseResetToRejected(writer, error);\n 2727      }\n 2728  }\n 2729: function WritableStreamDefaultWriterGetDesiredSize(writer) {\n 2730:     const stream = writer._ownerWritableStream;\n 2731      const state = stream._state;\n 2732      if (state === 'errored' || state === 'erroring') {\n ....\n 2738      return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n 2739  }\n 2740: function WritableStreamDefaultWriterRelease(writer) {\n 2741:     const stream = writer._ownerWritableStream;\n 2742      assert(stream !== undefined);\n 2743:     assert(stream._writer === writer);\n 2744      const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n 2745:     WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n 2746:     // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n 2747      // rejected until afterwards. This means that simply testing state will not work.\n 2748:     WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n 2749      stream._writer = undefined;\n 2750:     writer._ownerWritableStream = undefined;\n 2751  }\n 2752: function WritableStreamDefaultWriterWrite(writer, chunk) {\n 2753:     const stream = writer._ownerWritableStream;\n 2754      assert(stream !== undefined);\n 2755      const controller = stream._writableStreamController;\n 2756      const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n 2757:     if (stream !== writer._ownerWritableStream) {\n 2758:         return promiseRejectedWith(defaultWriterLockException('write to'));\n 2759      }\n 2760      const state = stream._state;\n ....\n 2797      }\n 2798      /**\n 2799:      * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n 2800       */\n 2801      get signal() {\n ....\n 2862      return x instanceof WritableStreamDefaultController;\n 2863  }\n 2864: function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n 2865      assert(IsWritableStream(stream));\n 2866      assert(stream._writableStreamController === undefined);\n ....\n 2876      controller._strategySizeAlgorithm = sizeAlgorithm;\n 2877      controller._strategyHWM = highWaterMark;\n 2878:     controller._writeAlgorithm = writeAlgorithm;\n 2879      controller._closeAlgorithm = closeAlgorithm;\n 2880      controller._abortAlgorithm = abortAlgorithm;\n ....\n 2898      const controller = Object.create(WritableStreamDefaultController.prototype);\n 2899      let startAlgorithm;\n 2900:     let writeAlgorithm;\n 2901      let closeAlgorithm;\n 2902      let abortAlgorithm;\n ....\n 2907          startAlgorithm = () => undefined;\n 2908      }\n 2909:     if (underlyingSink.write !== undefined) {\n 2910:         writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n 2911      }\n 2912      else {\n 2913:         writeAlgorithm = () => promiseResolvedWith(undefined);\n 2914      }\n 2915      if (underlyingSink.close !== undefined) {\n ....\n 2925          abortAlgorithm = () => promiseResolvedWith(undefined);\n 2926      }\n 2927:     SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n 2928  }\n 2929  // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\n ....\n 3062  }\n 3063  function defaultWriterLockException(name) {\n 3064:     return new TypeError('Cannot ' + name + ' a stream using a released writer');\n 3065  }\n 3066: function defaultWriterClosedPromiseInitialize(writer) {\n 3067:     writer._closedPromise = newPromise((resolve, reject) => {\n 3068:         writer._closedPromise_resolve = resolve;\n 3069:         writer._closedPromise_reject = reject;\n 3070:         writer._closedPromiseState = 'pending';\n 3071      });\n 3072  }\n 3073: function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n 3074:     defaultWriterClosedPromiseInitialize(writer);\n 3075:     defaultWriterClosedPromiseReject(writer, reason);\n 3076  }\n 3077: function defaultWriterClosedPromiseInitializeAsResolved(writer) {\n 3078:     defaultWriterClosedPromiseInitialize(writer);\n 3079:     defaultWriterClosedPromiseResolve(writer);\n 3080  }\n 3081: function defaultWriterClosedPromiseReject(writer, reason) {\n 3082:     if (writer._closedPromise_reject === undefined) {\n 3083          return;\n 3084      }\n 3085:     assert(writer._closedPromiseState === 'pending');\n 3086:     setPromiseIsHandledToTrue(writer._closedPromise);\n 3087:     writer._closedPromise_reject(reason);\n 3088:     writer._closedPromise_resolve = undefined;\n 3089:     writer._closedPromise_reject = undefined;\n 3090:     writer._closedPromiseState = 'rejected';\n 3091  }\n 3092: function defaultWriterClosedPromiseResetToRejected(writer, reason) {\n 3093:     assert(writer._closedPromise_resolve === undefined);\n 3094:     assert(writer._closedPromise_reject === undefined);\n 3095:     assert(writer._closedPromiseState !== 'pending');\n 3096:     defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n 3097  }\n 3098: function defaultWriterClosedPromiseResolve(writer) {\n 3099:     if (writer._closedPromise_resolve === undefined) {\n 3100          return;\n 3101      }\n 3102:     assert(writer._closedPromiseState === 'pending');\n 3103:     writer._closedPromise_resolve(undefined);\n 3104:     writer._closedPromise_resolve = undefined;\n 3105:     writer._closedPromise_reject = undefined;\n 3106:     writer._closedPromiseState = 'resolved';\n 3107  }\n 3108: function defaultWriterReadyPromiseInitialize(writer) {\n 3109:     writer._readyPromise = newPromise((resolve, reject) => {\n 3110:         writer._readyPromise_resolve = resolve;\n 3111:         writer._readyPromise_reject = reject;\n 3112      });\n 3113:     writer._readyPromiseState = 'pending';\n 3114  }\n 3115: function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n 3116:     defaultWriterReadyPromiseInitialize(writer);\n 3117:     defaultWriterReadyPromiseReject(writer, reason);\n 3118  }\n 3119: function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n 3120:     defaultWriterReadyPromiseInitialize(writer);\n 3121:     defaultWriterReadyPromiseResolve(writer);\n 3122  }\n 3123: function defaultWriterReadyPromiseReject(writer, reason) {\n 3124:     if (writer._readyPromise_reject === undefined) {\n 3125          return;\n 3126      }\n 3127:     setPromiseIsHandledToTrue(writer._readyPromise);\n 3128:     writer._readyPromise_reject(reason);\n 3129:     writer._readyPromise_resolve = undefined;\n 3130:     writer._readyPromise_reject = undefined;\n 3131:     writer._readyPromiseState = 'rejected';\n 3132  }\n 3133: function defaultWriterReadyPromiseReset(writer) {\n 3134:     assert(writer._readyPromise_resolve === undefined);\n 3135:     assert(writer._readyPromise_reject === undefined);\n 3136:     defaultWriterReadyPromiseInitialize(writer);\n 3137  }\n 3138: function defaultWriterReadyPromiseResetToRejected(writer, reason) {\n 3139:     assert(writer._readyPromise_resolve === undefined);\n 3140:     assert(writer._readyPromise_reject === undefined);\n 3141:     defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n 3142  }\n 3143: function defaultWriterReadyPromiseResolve(writer) {\n 3144:     if (writer._readyPromise_resolve === undefined) {\n 3145          return;\n 3146      }\n 3147:     writer._readyPromise_resolve(undefined);\n 3148:     writer._readyPromise_resolve = undefined;\n 3149:     writer._readyPromise_reject = undefined;\n 3150:     writer._readyPromiseState = 'fulfilled';\n 3151  }\n 3152  \n ....\n 3222  /* ------------------- end of 'src/stub/dom-exception.js' ------------------- */\n 3223  \n 3224: /* --------------- start of 'src/lib/readable-stream/pipe.js' --------------- */\n 3225  \n 3226  export function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n ....\n 3233      assert(!IsReadableStreamLocked(source));\n 3234      assert(!IsWritableStreamLocked(dest));\n 3235:     const reader = AcquireReadableStreamDefaultReader(source);\n 3236:     const writer = AcquireWritableStreamDefaultWriter(dest);\n 3237      source._disturbed = true;\n 3238      let shuttingDown = false;\n 3239:     // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n 3240      let currentWrite = promiseResolvedWith(undefined);\n 3241      return newPromise((resolve, reject) => {\n ....\n 3255                  if (!preventCancel) {\n 3256                      actions.push(() => {\n 3257:                         if (source._state === 'readable') {\n 3258                              return ReadableStreamCancel(source, error);\n 3259                          }\n ....\n 3269              signal.addEventListener('abort', abortAlgorithm);\n 3270          }\n 3271:         // Using reader and writer, read all chunks from this and write them to dest\n 3272          // - Backpressure must be enforced\n 3273          // - Shutdown must stop all activity\n ....\n 3291                  return promiseResolvedWith(true);\n 3292              }\n 3293:             return PerformPromiseThen(writer._readyPromise, () => {\n 3294                  return newPromise((resolveRead, rejectRead) => {\n 3295:                     ReadableStreamDefaultReaderRead(reader, {\n 3296                          _chunkSteps: (chunk) => {\n 3297:                             currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n 3298                              resolveRead(false);\n 3299                          },\n ....\n 3305          }\n 3306          // Errors must be propagated forward\n 3307:         isOrBecomesErrored(source, reader._closedPromise, (storedError) => {\n 3308              if (!preventAbort) {\n 3309                  shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n ....\n 3315          });\n 3316          // Errors must be propagated backward\n 3317:         isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {\n 3318              if (!preventCancel) {\n 3319                  shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n ....\n 3325          });\n 3326          // Closing must be propagated forward\n 3327:         isOrBecomesClosed(source, reader._closedPromise, () => {\n 3328              if (!preventClose) {\n 3329:                 shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n 3330              }\n 3331              else {\n ....\n 3346          setPromiseIsHandledToTrue(pipeLoop());\n 3347          function waitForWritesToFinish() {\n 3348:             // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n 3349              // for that too.\n 3350              const oldCurrentWrite = currentWrite;\n ....\n 3396          }\n 3397          function finalize(isError, error) {\n 3398:             WritableStreamDefaultWriterRelease(writer);\n 3399:             ReadableStreamReaderGenericRelease(reader);\n 3400              if (signal !== undefined) {\n 3401                  signal.removeEventListener('abort', abortAlgorithm);\n ....\n 3412  }\n 3413  \n 3414: /* ---------------- end of 'src/lib/readable-stream/pipe.js' ---------------- */\n 3415  \n 3416: /* -------- start of 'src/lib/readable-stream/default-controller.js' -------- */\n 3417  \n 3418  /**\n 3419:  * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n 3420   *\n 3421   * @public\n ....\n 3436      }\n 3437      /**\n 3438:      * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n 3439:      * the stream, but once those are read, the stream will become closed.\n 3440       */\n 3441      close() {\n ....\n 3458      }\n 3459      /**\n 3460:      * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n 3461       */\n 3462      error(e = undefined) {\n ....\n 3474      }\n 3475      /** @internal */\n 3476:     [PullSteps](readRequest) {\n 3477          const stream = this._controlledReadableStream;\n 3478          if (this._queue.length > 0) {\n ....\n 3485                  ReadableStreamDefaultControllerCallPullIfNeeded(this);\n 3486              }\n 3487:             readRequest._chunkSteps(chunk);\n 3488          }\n 3489          else {\n 3490:             ReadableStreamAddReadRequest(stream, readRequest);\n 3491              ReadableStreamDefaultControllerCallPullIfNeeded(this);\n 3492          }\n ....\n 3610  export function ReadableStreamDefaultControllerError(controller, e) {\n 3611      const stream = controller._controlledReadableStream;\n 3612:     if (stream._state !== 'readable') {\n 3613          return;\n 3614      }\n ....\n 3636  export function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n 3637      const state = controller._controlledReadableStream._state;\n 3638:     if (!controller._closeRequested && state === 'readable') {\n 3639          return true;\n 3640      }\n ....\n 3698  }\n 3699  \n 3700: /* --------- end of 'src/lib/readable-stream/default-controller.js' --------- */\n 3701  \n 3702: /* --------------- start of 'src/lib/readable-stream/tee.js' ---------------- */\n 3703  \n 3704  export function ReadableStreamTee(stream, cloneForBranch2) {\n ....\n 3713      assert(IsReadableStream(stream));\n 3714      assert(typeof cloneForBranch2 === 'boolean');\n 3715:     const reader = AcquireReadableStreamDefaultReader(stream);\n 3716:     let reading = false;\n 3717:     let readAgain = false;\n 3718      let canceled1 = false;\n 3719      let canceled2 = false;\n ....\n 3727      });\n 3728      function pullAlgorithm() {\n 3729:         if (reading) {\n 3730:             readAgain = true;\n 3731              return promiseResolvedWith(undefined);\n 3732          }\n 3733:         reading = true;\n 3734:         const readRequest = {\n 3735              _chunkSteps: (chunk) => {\n 3736                  // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n 3737:                 // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n 3738:                 // successful synchronously-available reads get ahead of asynchronously-available errors.\n 3739                  queueMicrotask(() => {\n 3740:                     readAgain = false;\n 3741                      const chunk1 = chunk;\n 3742                      const chunk2 = chunk;\n ....\n 3752                          ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n 3753                      }\n 3754:                     reading = false;\n 3755:                     if (readAgain) {\n 3756                          pullAlgorithm();\n 3757                      }\n ....\n 3759              },\n 3760              _closeSteps: () => {\n 3761:                 reading = false;\n 3762                  if (!canceled1) {\n 3763                      ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n ....\n 3771              },\n 3772              _errorSteps: () => {\n 3773:                 reading = false;\n 3774              }\n 3775          };\n 3776:         ReadableStreamDefaultReaderRead(reader, readRequest);\n 3777          return promiseResolvedWith(undefined);\n 3778      }\n ....\n 3802      branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n 3803      branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n 3804:     uponRejection(reader._closedPromise, (r) => {\n 3805          ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n 3806          ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n ....\n 3815      assert(IsReadableStream(stream));\n 3816      assert(IsReadableByteStreamController(stream._readableStreamController));\n 3817:     let reader = AcquireReadableStreamDefaultReader(stream);\n 3818:     let reading = false;\n 3819:     let readAgainForBranch1 = false;\n 3820:     let readAgainForBranch2 = false;\n 3821      let canceled1 = false;\n 3822      let canceled2 = false;\n ....\n 3831      function forwardReaderError(thisReader) {\n 3832          uponRejection(thisReader._closedPromise, (r) => {\n 3833:             if (thisReader !== reader) {\n 3834                  return null;\n 3835              }\n ....\n 3843      }\n 3844      function pullWithDefaultReader() {\n 3845:         if (IsReadableStreamBYOBReader(reader)) {\n 3846:             assert(reader._readIntoRequests.length === 0);\n 3847:             ReadableStreamReaderGenericRelease(reader);\n 3848:             reader = AcquireReadableStreamDefaultReader(stream);\n 3849:             forwardReaderError(reader);\n 3850          }\n 3851:         const readRequest = {\n 3852              _chunkSteps: (chunk) => {\n 3853                  // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n 3854:                 // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n 3855:                 // successful synchronously-available reads get ahead of asynchronously-available errors.\n 3856                  queueMicrotask(() => {\n 3857:                     readAgainForBranch1 = false;\n 3858:                     readAgainForBranch2 = false;\n 3859                      const chunk1 = chunk;\n 3860                      let chunk2 = chunk;\n ....\n 3876                          ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n 3877                      }\n 3878:                     reading = false;\n 3879:                     if (readAgainForBranch1) {\n 3880                          pull1Algorithm();\n 3881                      }\n 3882:                     else if (readAgainForBranch2) {\n 3883                          pull2Algorithm();\n 3884                      }\n ....\n 3886              },\n 3887              _closeSteps: () => {\n 3888:                 reading = false;\n 3889                  if (!canceled1) {\n 3890                      ReadableByteStreamControllerClose(branch1._readableStreamController);\n ....\n 3904              },\n 3905              _errorSteps: () => {\n 3906:                 reading = false;\n 3907              }\n 3908          };\n 3909:         ReadableStreamDefaultReaderRead(reader, readRequest);\n 3910      }\n 3911      function pullWithBYOBReader(view, forBranch2) {\n 3912:         if (IsReadableStreamDefaultReader(reader)) {\n 3913:             assert(reader._readRequests.length === 0);\n 3914:             ReadableStreamReaderGenericRelease(reader);\n 3915:             reader = AcquireReadableStreamBYOBReader(stream);\n 3916:             forwardReaderError(reader);\n 3917          }\n 3918          const byobBranch = forBranch2 ? branch2 : branch1;\n 3919          const otherBranch = forBranch2 ? branch1 : branch2;\n 3920:         const readIntoRequest = {\n 3921              _chunkSteps: (chunk) => {\n 3922                  // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n 3923:                 // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n 3924:                 // successful synchronously-available reads get ahead of asynchronously-available errors.\n 3925                  queueMicrotask(() => {\n 3926:                     readAgainForBranch1 = false;\n 3927:                     readAgainForBranch2 = false;\n 3928                      const byobCanceled = forBranch2 ? canceled2 : canceled1;\n 3929                      const otherCanceled = forBranch2 ? canceled1 : canceled2;\n ....\n 3947                          ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n 3948                      }\n 3949:                     reading = false;\n 3950:                     if (readAgainForBranch1) {\n 3951                          pull1Algorithm();\n 3952                      }\n 3953:                     else if (readAgainForBranch2) {\n 3954                          pull2Algorithm();\n 3955                      }\n ....\n 3957              },\n 3958              _closeSteps: (chunk) => {\n 3959:                 reading = false;\n 3960                  const byobCanceled = forBranch2 ? canceled2 : canceled1;\n 3961                  const otherCanceled = forBranch2 ? canceled1 : canceled2;\n ....\n 3980              },\n 3981              _errorSteps: () => {\n 3982:                 reading = false;\n 3983              }\n 3984          };\n 3985:         ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);\n 3986      }\n 3987      function pull1Algorithm() {\n 3988:         if (reading) {\n 3989:             readAgainForBranch1 = true;\n 3990              return promiseResolvedWith(undefined);\n 3991          }\n 3992:         reading = true;\n 3993          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n 3994          if (byobRequest === null) {\n ....\n 4001      }\n 4002      function pull2Algorithm() {\n 4003:         if (reading) {\n 4004:             readAgainForBranch2 = true;\n 4005              return promiseResolvedWith(undefined);\n 4006          }\n 4007:         reading = true;\n 4008          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n 4009          if (byobRequest === null) {\n ....\n 4040      branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n 4041      branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n 4042:     forwardReaderError(reader);\n 4043      return [branch1, branch2];\n 4044  }\n 4045  \n 4046: /* ---------------- end of 'src/lib/readable-stream/tee.js' ----------------- */\n 4047  \n 4048: /* ------- start of 'src/lib/readable-stream/readable-stream-like.js' ------- */\n 4049  \n 4050  export function isReadableStreamLike(stream) {\n ....\n 4052  }\n 4053  \n 4054: /* -------- end of 'src/lib/readable-stream/readable-stream-like.js' -------- */\n 4055  \n 4056: /* --------------- start of 'src/lib/readable-stream/from.js' --------------- */\n 4057  \n 4058  export function ReadableStreamFrom(source) {\n ....\n 4112      return stream;\n 4113  }\n 4114: export function ReadableStreamFromDefaultReader(reader) {\n 4115      let stream;\n 4116      const startAlgorithm = noop;\n 4117      function pullAlgorithm() {\n 4118:         let readPromise;\n 4119          try {\n 4120:             readPromise = reader.read();\n 4121          }\n 4122          catch (e) {\n 4123              return promiseRejectedWith(e);\n 4124          }\n 4125:         return transformPromiseWith(readPromise, (readResult) => {\n 4126:             if (!typeIsObject(readResult)) {\n 4127:                 throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\n 4128              }\n 4129:             if (readResult.done) {\n 4130                  ReadableStreamDefaultControllerClose(stream._readableStreamController);\n 4131              }\n 4132              else {\n 4133:                 const value = readResult.value;\n 4134                  ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\n 4135              }\n ....\n 4138      function cancelAlgorithm(reason) {\n 4139          try {\n 4140:             return promiseResolvedWith(reader.cancel(reason));\n 4141          }\n 4142          catch (e) {\n ....\n 4148  }\n 4149  \n 4150: /* ---------------- end of 'src/lib/readable-stream/from.js' ---------------- */\n 4151  \n 4152  /* ----------- start of 'src/lib/validators/underlying-source.js' ----------- */\n ....\n 4234  /* -------------- end of 'src/lib/validators/pipe-options.js' --------------- */\n 4235  \n 4236: /* -------- start of 'src/lib/validators/readable-writable-pair.js' --------- */\n 4237  \n 4238  export function convertReadableWritablePair(pair, context) {\n 4239      assertDictionary(pair, context);\n 4240:     const readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n 4241:     assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n 4242:     assertReadableStream(readable, `${context} has member 'readable' that`);\n 4243      const writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n 4244      assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n 4245      assertWritableStream(writable, `${context} has member 'writable' that`);\n 4246:     return { readable, writable };\n 4247  }\n 4248  \n 4249: /* --------- end of 'src/lib/validators/readable-writable-pair.js' ---------- */\n 4250  \n 4251  /**\n 4252:  * A readable stream represents a source of data, from which you can read.\n 4253   *\n 4254   * @public\n ....\n 4280      }\n 4281      /**\n 4282:      * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n 4283       */\n 4284      get locked() {\n ....\n 4299          }\n 4300          if (IsReadableStreamLocked(this)) {\n 4301:             return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n 4302          }\n 4303          return ReadableStreamCancel(this, reason);\n ....\n 4329          const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n 4330          setPromiseIsHandledToTrue(promise);\n 4331:         return transform.readable;\n 4332      }\n 4333      pipeTo(destination, rawOptions = {}) {\n ....\n 4357      }\n 4358      /**\n 4359:      * Tees this readable stream, returning a two-element array containing the two resulting branches as\n 4360       * new {@link ReadableStream} instances.\n 4361       *\n 4362:      * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n 4363       * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n 4364       * propagated to the stream's underlying source.\n ....\n 4388       * Creates a new ReadableStream wrapping the provided iterable or async iterable.\n 4389       *\n 4390:      * This can be used to adapt various kinds of objects into a readable stream,\n 4391:      * such as an array, an async generator, or a Node.js readable stream.\n 4392       */\n 4393      static from(asyncIterable) {\n ....\n 4444  }\n 4445  function InitializeReadableStream(stream) {\n 4446:     stream._state = 'readable';\n 4447      stream._reader = undefined;\n 4448      stream._storedError = undefined;\n ....\n 4479      }\n 4480      ReadableStreamClose(stream);\n 4481:     const reader = stream._reader;\n 4482:     if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n 4483:         const readIntoRequests = reader._readIntoRequests;\n 4484:         reader._readIntoRequests = new SimpleQueue();\n 4485:         readIntoRequests.forEach((readIntoRequest) => {\n 4486:             readIntoRequest._closeSteps(undefined);\n 4487          });\n 4488      }\n ....\n 4491  }\n 4492  export function ReadableStreamClose(stream) {\n 4493:     assert(stream._state === 'readable');\n 4494      stream._state = 'closed';\n 4495:     const reader = stream._reader;\n 4496:     if (reader === undefined) {\n 4497          return;\n 4498      }\n 4499:     defaultReaderClosedPromiseResolve(reader);\n 4500:     if (IsReadableStreamDefaultReader(reader)) {\n 4501:         const readRequests = reader._readRequests;\n 4502:         reader._readRequests = new SimpleQueue();\n 4503:         readRequests.forEach((readRequest) => {\n 4504:             readRequest._closeSteps();\n 4505          });\n 4506      }\n ....\n 4508  export function ReadableStreamError(stream, e) {\n 4509      assert(IsReadableStream(stream));\n 4510:     assert(stream._state === 'readable');\n 4511      stream._state = 'errored';\n 4512      stream._storedError = e;\n 4513:     const reader = stream._reader;\n 4514:     if (reader === undefined) {\n 4515          return;\n 4516      }\n 4517:     defaultReaderClosedPromiseReject(reader, e);\n 4518:     if (IsReadableStreamDefaultReader(reader)) {\n 4519:         ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n 4520      }\n 4521      else {\n 4522:         assert(IsReadableStreamBYOBReader(reader));\n 4523:         ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n 4524      }\n 4525  }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/ponyfill.js:\n  135      ++this._size;\n  136    }\n  137:   // Like push(), shift() follows the read -> calculate -> mutate pattern for\n  138    // exception safety.\n  139    shift() {\n  ...\n  203  var ReleaseSteps = Symbol('[[ReleaseSteps]]');\n  204  \n  205: // src/lib/readable-stream/generic-reader.ts\n  206: function ReadableStreamReaderGenericInitialize(reader, stream) {\n  207:   reader._ownerReadableStream = stream;\n  208:   stream._reader = reader;\n  209:   if(stream._state === 'readable') {\n  210:     defaultReaderClosedPromiseInitialize(reader);\n  211    } else if(stream._state === 'closed') {\n  212:     defaultReaderClosedPromiseInitializeAsResolved(reader);\n  213    } else {\n  214      assert_default(stream._state === 'errored');\n  215:     defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n  216    }\n  217  }\n  218: function ReadableStreamReaderGenericCancel(reader, reason) {\n  219:   const stream = reader._ownerReadableStream;\n  220    assert_default(stream !== void 0);\n  221    return ReadableStreamCancel(stream, reason);\n  222  }\n  223: function ReadableStreamReaderGenericRelease(reader) {\n  224:   const stream = reader._ownerReadableStream;\n  225    assert_default(stream !== void 0);\n  226:   assert_default(stream._reader === reader);\n  227:   if(stream._state === 'readable') {\n  228:     defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  229    } else {\n  230:     defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  231    }\n  232    stream._readableStreamController[ReleaseSteps]();\n  233    stream._reader = void 0;\n  234:   reader._ownerReadableStream = void 0;\n  235  }\n  236: function readerLockException(name) {\n  237:   return new TypeError('Cannot ' + name + ' a stream using a released reader');\n  238  }\n  239: function defaultReaderClosedPromiseInitialize(reader) {\n  240:   reader._closedPromise = newPromise((resolve, reject) => {\n  241:     reader._closedPromise_resolve = resolve;\n  242:     reader._closedPromise_reject = reject;\n  243    });\n  244  }\n  245: function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n  246:   defaultReaderClosedPromiseInitialize(reader);\n  247:   defaultReaderClosedPromiseReject(reader, reason);\n  248  }\n  249: function defaultReaderClosedPromiseInitializeAsResolved(reader) {\n  250:   defaultReaderClosedPromiseInitialize(reader);\n  251:   defaultReaderClosedPromiseResolve(reader);\n  252  }\n  253: function defaultReaderClosedPromiseReject(reader, reason) {\n  254:   if(reader._closedPromise_reject === void 0) {\n  255      return;\n  256    }\n  257:   setPromiseIsHandledToTrue(reader._closedPromise);\n  258:   reader._closedPromise_reject(reason);\n  259:   reader._closedPromise_resolve = void 0;\n  260:   reader._closedPromise_reject = void 0;\n  261  }\n  262: function defaultReaderClosedPromiseResetToRejected(reader, reason) {\n  263:   assert_default(reader._closedPromise_resolve === void 0);\n  264:   assert_default(reader._closedPromise_reject === void 0);\n  265:   defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n  266  }\n  267: function defaultReaderClosedPromiseResolve(reader) {\n  268:   if(reader._closedPromise_resolve === void 0) {\n  269      return;\n  270    }\n  271:   reader._closedPromise_resolve(void 0);\n  272:   reader._closedPromise_resolve = void 0;\n  273:   reader._closedPromise_reject = void 0;\n  274  }\n  275  \n  ...\n  349  }\n  350  \n  351: // src/lib/validators/readable-stream.ts\n  352  function assertReadableStream(x, context) {\n  353    if(!IsReadableStream(x)) {\n  ...\n  356  }\n  357  \n  358: // src/lib/readable-stream/default-reader.ts\n  359  function AcquireReadableStreamDefaultReader(stream) {\n  360    return new ReadableStreamDefaultReader(stream);\n  361  }\n  362: function ReadableStreamAddReadRequest(stream, readRequest) {\n  363    assert_default(IsReadableStreamDefaultReader(stream._reader));\n  364:   assert_default(stream._state === 'readable');\n  365:   stream._reader._readRequests.push(readRequest);\n  366  }\n  367  function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n  368:   const reader = stream._reader;\n  369:   assert_default(reader._readRequests.length > 0);\n  370:   const readRequest = reader._readRequests.shift();\n  371    if(done) {\n  372:     readRequest._closeSteps();\n  373    } else {\n  374:     readRequest._chunkSteps(chunk);\n  375    }\n  376  }\n  ...\n  379  }\n  380  function ReadableStreamHasDefaultReader(stream) {\n  381:   const reader = stream._reader;\n  382:   if(reader === void 0) {\n  383      return false;\n  384    }\n  385:   if(!IsReadableStreamDefaultReader(reader)) {\n  386      return false;\n  387    }\n  ...\n  393      assertReadableStream(stream, 'First parameter');\n  394      if(IsReadableStreamLocked(stream)) {\n  395:       throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n  396      }\n  397      ReadableStreamReaderGenericInitialize(this, stream);\n  ...\n  400    /**\n  401     * Returns a promise that will be fulfilled when the stream becomes closed,\n  402:    * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n  403     */\n  404    get closed() {\n  ...\n  409    }\n  410    /**\n  411:    * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n  412     */\n  413    cancel(reason = void 0) {\n  ...\n  416      }\n  417      if(this._ownerReadableStream === void 0) {\n  418:       return promiseRejectedWith(readerLockException('cancel'));\n  419      }\n  420      return ReadableStreamReaderGenericCancel(this, reason);\n  ...\n  423     * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n  424     *\n  425:    * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  426     */\n  427:   read() {\n  428      if(!IsReadableStreamDefaultReader(this)) {\n  429:       return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  430      }\n  431      if(this._ownerReadableStream === void 0) {\n  432:       return promiseRejectedWith(readerLockException('read from'));\n  433      }\n  434      let resolvePromise;\n  ...\n  438        rejectPromise = reject;\n  439      });\n  440:     const readRequest = {\n  441        _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n  442        _closeSteps: () => resolvePromise({ value: void 0, done: true }),\n  443        _errorSteps: e => rejectPromise(e),\n  444      };\n  445:     ReadableStreamDefaultReaderRead(this, readRequest);\n  446      return promise;\n  447    }\n  448    /**\n  449:    * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n  450:    * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n  451:    * from now on; otherwise, the reader will appear closed.\n  452     *\n  453:    * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  454:    * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  455:    * do so will throw a `TypeError` and leave the reader locked to the stream.\n  456     */\n  457    releaseLock() {\n  ...\n  467  Object.defineProperties(ReadableStreamDefaultReader.prototype, {\n  468    cancel: { enumerable: true },\n  469:   read: { enumerable: true },\n  470    releaseLock: { enumerable: true },\n  471    closed: { enumerable: true },\n  472  });\n  473  setFunctionName(ReadableStreamDefaultReader.prototype.cancel, 'cancel');\n  474: setFunctionName(ReadableStreamDefaultReader.prototype.read, 'read');\n  475  setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, 'releaseLock');\n  476  if(typeof Symbol.toStringTag === 'symbol') {\n  ...\n  489    return x instanceof ReadableStreamDefaultReader;\n  490  }\n  491: function ReadableStreamDefaultReaderRead(reader, readRequest) {\n  492:   const stream = reader._ownerReadableStream;\n  493    assert_default(stream !== void 0);\n  494    stream._disturbed = true;\n  495    if(stream._state === 'closed') {\n  496:     readRequest._closeSteps();\n  497    } else if(stream._state === 'errored') {\n  498:     readRequest._errorSteps(stream._storedError);\n  499    } else {\n  500:     assert_default(stream._state === 'readable');\n  501:     stream._readableStreamController[PullSteps](readRequest);\n  502    }\n  503  }\n  504: function ReadableStreamDefaultReaderRelease(reader) {\n  505:   ReadableStreamReaderGenericRelease(reader);\n  506    const e = new TypeError('Reader was released');\n  507:   ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n  508  }\n  509: function ReadableStreamDefaultReaderErrorReadRequests(reader, e) {\n  510:   const readRequests = reader._readRequests;\n  511:   reader._readRequests = new SimpleQueue();\n  512:   readRequests.forEach(readRequest => {\n  513:     readRequest._errorSteps(e);\n  514    });\n  515  }\n  ...\n  646  }\n  647  \n  648: // src/lib/readable-stream/async-iterator.ts\n  649  var ReadableStreamAsyncIteratorImpl = class {\n  650:   constructor(reader, preventCancel) {\n  651      this._ongoingPromise = void 0;\n  652      this._isFinished = false;\n  653:     this._reader = reader;\n  654      this._preventCancel = preventCancel;\n  655    }\n  ...\n  668        return Promise.resolve({ value: void 0, done: true });\n  669      }\n  670:     const reader = this._reader;\n  671:     assert_default(reader._ownerReadableStream !== void 0);\n  672      let resolvePromise;\n  673      let rejectPromise;\n  ...\n  676        rejectPromise = reject;\n  677      });\n  678:     const readRequest = {\n  679        _chunkSteps: chunk => {\n  680          this._ongoingPromise = void 0;\n  ...\n  684          this._ongoingPromise = void 0;\n  685          this._isFinished = true;\n  686:         ReadableStreamReaderGenericRelease(reader);\n  687          resolvePromise({ value: void 0, done: true });\n  688        },\n  ...\n  690          this._ongoingPromise = void 0;\n  691          this._isFinished = true;\n  692:         ReadableStreamReaderGenericRelease(reader);\n  693          rejectPromise(reason);\n  694        },\n  695      };\n  696:     ReadableStreamDefaultReaderRead(reader, readRequest);\n  697      return promise;\n  698    }\n  ...\n  702      }\n  703      this._isFinished = true;\n  704:     const reader = this._reader;\n  705:     assert_default(reader._ownerReadableStream !== void 0);\n  706:     assert_default(reader._readRequests.length === 0);\n  707      if(!this._preventCancel) {\n  708:       const result = ReadableStreamReaderGenericCancel(reader, value);\n  709:       ReadableStreamReaderGenericRelease(reader);\n  710        return transformPromiseWith(result, () => ({ value, done: true }));\n  711      }\n  712:     ReadableStreamReaderGenericRelease(reader);\n  713      return promiseResolvedWith({ value, done: true });\n  714    }\n  ...\n  737  });\n  738  function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n  739:   const reader = AcquireReadableStreamDefaultReader(stream);\n  740:   const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n  741    const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n  742    iterator._asyncIteratorImpl = impl;\n  ...\n  839  }\n  840  \n  841: // src/lib/readable-stream/byte-stream-controller.ts\n  842  var ReadableStreamBYOBRequest = class {\n  843    constructor() {\n  ...\n  923    }\n  924    /**\n  925:    * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n  926:    * the stream, but once those are read, the stream will become closed.\n  927     */\n  928    close() {\n  ...\n  934      }\n  935      const state = this._controlledReadableByteStream._state;\n  936:     if(state !== 'readable') {\n  937:       throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n  938      }\n  939      ReadableByteStreamControllerClose(this);\n  ...\n  957      }\n  958      const state = this._controlledReadableByteStream._state;\n  959:     if(state !== 'readable') {\n  960:       throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n  961      }\n  962      ReadableByteStreamControllerEnqueue(this, chunk);\n  963    }\n  964    /**\n  965:    * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n  966     */\n  967    error(e = void 0) {\n  ...\n  980    }\n  981    /** @internal */\n  982:   [PullSteps](readRequest) {\n  983      const stream = this._controlledReadableByteStream;\n  984      assert_default(ReadableStreamHasDefaultReader(stream));\n  985      if(this._queueTotalSize > 0) {\n  986        assert_default(ReadableStreamGetNumReadRequests(stream) === 0);\n  987:       ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);\n  988        return;\n  989      }\n  ...\n  994          buffer = new ArrayBuffer(autoAllocateChunkSize);\n  995        } catch(bufferE) {\n  996:         readRequest._errorSteps(bufferE);\n  997          return;\n  998        }\n  ...\n 1006          elementSize: 1,\n 1007          viewConstructor: Uint8Array,\n 1008:         readerType: 'default',\n 1009        };\n 1010        this._pendingPullIntos.push(pullIntoDescriptor);\n 1011      }\n 1012:     ReadableStreamAddReadRequest(stream, readRequest);\n 1013      ReadableByteStreamControllerCallPullIfNeeded(this);\n 1014    }\n ....\n 1017      if(this._pendingPullIntos.length > 0) {\n 1018        const firstPullInto = this._pendingPullIntos.peek();\n 1019:       firstPullInto.readerType = 'none';\n 1020        this._pendingPullIntos = new SimpleQueue();\n 1021        this._pendingPullIntos.push(firstPullInto);\n ....\n 1091  function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n 1092    assert_default(stream._state !== 'errored');\n 1093:   assert_default(pullIntoDescriptor.readerType !== 'none');\n 1094    let done = false;\n 1095    if(stream._state === 'closed') {\n ....\n 1098    }\n 1099    const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n 1100:   if(pullIntoDescriptor.readerType === 'default') {\n 1101      ReadableStreamFulfillReadRequest(stream, filledView, done);\n 1102    } else {\n 1103:     assert_default(pullIntoDescriptor.readerType === 'byob');\n 1104      ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n 1105    }\n ....\n 1132  }\n 1133  function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {\n 1134:   assert_default(firstDescriptor.readerType === 'none');\n 1135    if(firstDescriptor.bytesFilled > 0) {\n 1136      ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);\n ....\n 1142    const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n 1143    let totalBytesToCopyRemaining = maxBytesToCopy;\n 1144:   let ready = false;\n 1145    assert_default(!IsDetachedBuffer(pullIntoDescriptor.buffer));\n 1146    assert_default(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n ....\n 1149    if(maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n 1150      totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n 1151:     ready = true;\n 1152    }\n 1153    const queue = controller._queue;\n ....\n 1168      totalBytesToCopyRemaining -= bytesToCopy;\n 1169    }\n 1170:   if(!ready) {\n 1171      assert_default(controller._queueTotalSize === 0);\n 1172      assert_default(pullIntoDescriptor.bytesFilled > 0);\n 1173      assert_default(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n 1174    }\n 1175:   return ready;\n 1176  }\n 1177  function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n ....\n 1181  }\n 1182  function ReadableByteStreamControllerHandleQueueDrain(controller) {\n 1183:   assert_default(controller._controlledReadableByteStream._state === 'readable');\n 1184    if(controller._queueTotalSize === 0 && controller._closeRequested) {\n 1185      ReadableByteStreamControllerClearAlgorithms(controller);\n ....\n 1205      }\n 1206      const pullIntoDescriptor = controller._pendingPullIntos.peek();\n 1207:     assert_default(pullIntoDescriptor.readerType !== 'none');\n 1208      if(ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n 1209        ReadableByteStreamControllerShiftPendingPullInto(controller);\n ....\n 1214  }\n 1215  function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller) {\n 1216:   const reader = controller._controlledReadableByteStream._reader;\n 1217:   assert_default(IsReadableStreamDefaultReader(reader));\n 1218:   while(reader._readRequests.length > 0) {\n 1219      if(controller._queueTotalSize === 0) {\n 1220        return;\n 1221      }\n 1222:     const readRequest = reader._readRequests.shift();\n 1223:     ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);\n 1224    }\n 1225  }\n 1226: function ReadableByteStreamControllerPullInto(controller, view, min, readIntoRequest) {\n 1227    const stream = controller._controlledReadableByteStream;\n 1228    const ctor = view.constructor;\n ....\n 1236      buffer = TransferArrayBuffer(view.buffer);\n 1237    } catch(e) {\n 1238:     readIntoRequest._errorSteps(e);\n 1239      return;\n 1240    }\n ....\n 1248      elementSize,\n 1249      viewConstructor: ctor,\n 1250:     readerType: 'byob',\n 1251    };\n 1252    if(controller._pendingPullIntos.length > 0) {\n 1253      controller._pendingPullIntos.push(pullIntoDescriptor);\n 1254:     ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n 1255      return;\n 1256    }\n 1257    if(stream._state === 'closed') {\n 1258      const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n 1259:     readIntoRequest._closeSteps(emptyView);\n 1260      return;\n 1261    }\n ....\n 1264        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n 1265        ReadableByteStreamControllerHandleQueueDrain(controller);\n 1266:       readIntoRequest._chunkSteps(filledView);\n 1267        return;\n 1268      }\n ....\n 1270        const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n 1271        ReadableByteStreamControllerError(controller, e);\n 1272:       readIntoRequest._errorSteps(e);\n 1273        return;\n 1274      }\n 1275    }\n 1276    controller._pendingPullIntos.push(pullIntoDescriptor);\n 1277:   ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n 1278    ReadableByteStreamControllerCallPullIfNeeded(controller);\n 1279  }\n 1280  function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n 1281    assert_default(firstDescriptor.bytesFilled % firstDescriptor.elementSize === 0);\n 1282:   if(firstDescriptor.readerType === 'none') {\n 1283      ReadableByteStreamControllerShiftPendingPullInto(controller);\n 1284    }\n ....\n 1295    assert_default(pullIntoDescriptor.bytesFilled + bytesWritten <= pullIntoDescriptor.byteLength);\n 1296    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n 1297:   if(pullIntoDescriptor.readerType === 'none') {\n 1298      ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);\n 1299      const filledPullIntos2 = ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n ....\n 1324      ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n 1325    } else {\n 1326:     assert_default(state === 'readable');\n 1327      assert_default(bytesWritten > 0);\n 1328      ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n ....\n 1337  function ReadableByteStreamControllerShouldCallPull(controller) {\n 1338    const stream = controller._controlledReadableByteStream;\n 1339:   if(stream._state !== 'readable') {\n 1340      return false;\n 1341    }\n ....\n 1365  function ReadableByteStreamControllerClose(controller) {\n 1366    const stream = controller._controlledReadableByteStream;\n 1367:   if(controller._closeRequested || stream._state !== 'readable') {\n 1368      return;\n 1369    }\n ....\n 1385  function ReadableByteStreamControllerEnqueue(controller, chunk) {\n 1386    const stream = controller._controlledReadableByteStream;\n 1387:   if(controller._closeRequested || stream._state !== 'readable') {\n 1388      return;\n 1389    }\n ....\n 1400      ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n 1401      firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n 1402:     if(firstPendingPullInto.readerType === 'none') {\n 1403        ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);\n 1404      }\n ....\n 1412        assert_default(controller._queue.length === 0);\n 1413        if(controller._pendingPullIntos.length > 0) {\n 1414:         assert_default(controller._pendingPullIntos.peek().readerType === 'default');\n 1415          ReadableByteStreamControllerShiftPendingPullInto(controller);\n 1416        }\n ....\n 1430  function ReadableByteStreamControllerError(controller, e) {\n 1431    const stream = controller._controlledReadableByteStream;\n 1432:   if(stream._state !== 'readable') {\n 1433      return;\n 1434    }\n ....\n 1438    ReadableStreamError(stream, e);\n 1439  }\n 1440: function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {\n 1441    assert_default(controller._queueTotalSize > 0);\n 1442    const entry = controller._queue.shift();\n ....\n 1444    ReadableByteStreamControllerHandleQueueDrain(controller);\n 1445    const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n 1446:   readRequest._chunkSteps(view);\n 1447  }\n 1448  function ReadableByteStreamControllerGetBYOBRequest(controller) {\n ....\n 1475      }\n 1476    } else {\n 1477:     assert_default(state === 'readable');\n 1478      if(bytesWritten === 0) {\n 1479:       throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');\n 1480      }\n 1481      if(firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n ....\n 1496      }\n 1497    } else {\n 1498:     assert_default(state === 'readable');\n 1499      if(view.byteLength === 0) {\n 1500:       throw new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");\n 1501      }\n 1502    }\n ....\n 1591  }\n 1592  \n 1593: // src/lib/validators/reader-options.ts\n 1594  function convertReaderOptions(options, context) {\n 1595    assertDictionary(options, context);\n ....\n 1615  }\n 1616  \n 1617: // src/lib/readable-stream/byob-reader.ts\n 1618  function AcquireReadableStreamBYOBReader(stream) {\n 1619    return new ReadableStreamBYOBReader(stream);\n 1620  }\n 1621: function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n 1622    assert_default(IsReadableStreamBYOBReader(stream._reader));\n 1623:   assert_default(stream._state === 'readable' || stream._state === 'closed');\n 1624:   stream._reader._readIntoRequests.push(readIntoRequest);\n 1625  }\n 1626  function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n 1627:   const reader = stream._reader;\n 1628:   assert_default(reader._readIntoRequests.length > 0);\n 1629:   const readIntoRequest = reader._readIntoRequests.shift();\n 1630    if(done) {\n 1631:     readIntoRequest._closeSteps(chunk);\n 1632    } else {\n 1633:     readIntoRequest._chunkSteps(chunk);\n 1634    }\n 1635  }\n ....\n 1638  }\n 1639  function ReadableStreamHasBYOBReader(stream) {\n 1640:   const reader = stream._reader;\n 1641:   if(reader === void 0) {\n 1642      return false;\n 1643    }\n 1644:   if(!IsReadableStreamBYOBReader(reader)) {\n 1645      return false;\n 1646    }\n ....\n 1652      assertReadableStream(stream, 'First parameter');\n 1653      if(IsReadableStreamLocked(stream)) {\n 1654:       throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n 1655      }\n 1656      if(!IsReadableByteStreamController(stream._readableStreamController)) {\n ....\n 1662    /**\n 1663     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n 1664:    * the reader's lock is released before the stream finishes closing.\n 1665     */\n 1666    get closed() {\n ....\n 1671    }\n 1672    /**\n 1673:    * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n 1674     */\n 1675    cancel(reason = void 0) {\n ....\n 1678      }\n 1679      if(this._ownerReadableStream === void 0) {\n 1680:       return promiseRejectedWith(readerLockException('cancel'));\n 1681      }\n 1682      return ReadableStreamReaderGenericCancel(this, reason);\n 1683    }\n 1684:   read(view, rawOptions = {}) {\n 1685      if(!IsReadableStreamBYOBReader(this)) {\n 1686:       return promiseRejectedWith(byobReaderBrandCheckException('read'));\n 1687      }\n 1688      if(!ArrayBuffer.isView(view)) {\n ....\n 1716      }\n 1717      if(this._ownerReadableStream === void 0) {\n 1718:       return promiseRejectedWith(readerLockException('read from'));\n 1719      }\n 1720      let resolvePromise;\n ....\n 1724        rejectPromise = reject;\n 1725      });\n 1726:     const readIntoRequest = {\n 1727        _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n 1728        _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n 1729        _errorSteps: e => rejectPromise(e),\n 1730      };\n 1731:     ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);\n 1732      return promise;\n 1733    }\n 1734    /**\n 1735:    * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n 1736:    * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n 1737:    * from now on; otherwise, the reader will appear closed.\n 1738     *\n 1739:    * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n 1740:    * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n 1741:    * do so will throw a `TypeError` and leave the reader locked to the stream.\n 1742     */\n 1743    releaseLock() {\n ....\n 1753  Object.defineProperties(ReadableStreamBYOBReader.prototype, {\n 1754    cancel: { enumerable: true },\n 1755:   read: { enumerable: true },\n 1756    releaseLock: { enumerable: true },\n 1757    closed: { enumerable: true },\n 1758  });\n 1759  setFunctionName(ReadableStreamBYOBReader.prototype.cancel, 'cancel');\n 1760: setFunctionName(ReadableStreamBYOBReader.prototype.read, 'read');\n 1761  setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, 'releaseLock');\n 1762  if(typeof Symbol.toStringTag === 'symbol') {\n ....\n 1775    return x instanceof ReadableStreamBYOBReader;\n 1776  }\n 1777: function ReadableStreamBYOBReaderRead(reader, view, min, readIntoRequest) {\n 1778:   const stream = reader._ownerReadableStream;\n 1779    assert_default(stream !== void 0);\n 1780    stream._disturbed = true;\n 1781    if(stream._state === 'errored') {\n 1782:     readIntoRequest._errorSteps(stream._storedError);\n 1783    } else {\n 1784:     ReadableByteStreamControllerPullInto(stream._readableStreamController, view, min, readIntoRequest);\n 1785    }\n 1786  }\n 1787: function ReadableStreamBYOBReaderRelease(reader) {\n 1788:   ReadableStreamReaderGenericRelease(reader);\n 1789    const e = new TypeError('Reader was released');\n 1790:   ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n 1791  }\n 1792: function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e) {\n 1793:   const readIntoRequests = reader._readIntoRequests;\n 1794:   reader._readIntoRequests = new SimpleQueue();\n 1795:   readIntoRequests.forEach(readIntoRequest => {\n 1796:     readIntoRequest._errorSteps(e);\n 1797    });\n 1798  }\n ....\n 1842    const start = original == null ? void 0 : original.start;\n 1843    const type = original == null ? void 0 : original.type;\n 1844:   const write = original == null ? void 0 : original.write;\n 1845    return {\n 1846      abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),\n 1847      close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),\n 1848      start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n 1849:     write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n 1850      type,\n 1851    };\n ....\n 1913    }\n 1914    /**\n 1915:    * Returns whether or not the writable stream is locked to a writer.\n 1916     */\n 1917    get locked() {\n ....\n 1922    }\n 1923    /**\n 1924:    * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n 1925:    * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n 1926     * mechanism of the underlying sink.\n 1927     *\n ....\n 1935      }\n 1936      if(IsWritableStreamLocked(this)) {\n 1937:       return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n 1938      }\n 1939      return WritableStreamAbort(this, reason);\n ....\n 1941    /**\n 1942     * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n 1943:    * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n 1944     *\n 1945     * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n ....\n 1952      }\n 1953      if(IsWritableStreamLocked(this)) {\n 1954:       return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n 1955      }\n 1956      if(WritableStreamCloseQueuedOrInFlight(this)) {\n ....\n 1960    }\n 1961    /**\n 1962:    * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n 1963:    * is locked, no other writer can be acquired until this one is released.\n 1964     *\n 1965:    * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n 1966:    * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n 1967     * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n 1968     */\n ....\n 1992    return new WritableStreamDefaultWriter(stream);\n 1993  }\n 1994: function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n 1995    assert_default(IsNonNegativeNumber(highWaterMark));\n 1996    const stream = Object.create(WritableStream2.prototype);\n 1997    InitializeWritableStream(stream);\n 1998    const controller = Object.create(WritableStreamDefaultController2.prototype);\n 1999:   SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n 2000    return stream;\n 2001  }\n ....\n 2077      stream._closeRequest = closeRequest;\n 2078    });\n 2079:   const writer = stream._writer;\n 2080:   if(writer !== void 0 && stream._backpressure && state === 'writable') {\n 2081:     defaultWriterReadyPromiseResolve(writer);\n 2082    }\n 2083    WritableStreamDefaultControllerClose(stream._writableStreamController);\n ....\n 2088    assert_default(stream._state === 'writable');\n 2089    const promise = newPromise((resolve, reject) => {\n 2090:     const writeRequest = {\n 2091        _resolve: resolve,\n 2092        _reject: reject,\n 2093      };\n 2094:     stream._writeRequests.push(writeRequest);\n 2095    });\n 2096    return promise;\n ....\n 2112    stream._state = 'erroring';\n 2113    stream._storedError = reason;\n 2114:   const writer = stream._writer;\n 2115:   if(writer !== void 0) {\n 2116:     WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n 2117    }\n 2118    if(!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n ....\n 2126    stream._writableStreamController[ErrorSteps]();\n 2127    const storedError = stream._storedError;\n 2128:   stream._writeRequests.forEach(writeRequest => {\n 2129:     writeRequest._reject(storedError);\n 2130    });\n 2131    stream._writeRequests = new SimpleQueue();\n ....\n 2182    }\n 2183    stream._state = 'closed';\n 2184:   const writer = stream._writer;\n 2185:   if(writer !== void 0) {\n 2186:     defaultWriterClosedPromiseResolve(writer);\n 2187    }\n 2188    assert_default(stream._pendingAbortRequest === void 0);\n ....\n 2230      stream._closeRequest = void 0;\n 2231    }\n 2232:   const writer = stream._writer;\n 2233:   if(writer !== void 0) {\n 2234:     defaultWriterClosedPromiseReject(writer, stream._storedError);\n 2235    }\n 2236  }\n ....\n 2238    assert_default(stream._state === 'writable');\n 2239    assert_default(!WritableStreamCloseQueuedOrInFlight(stream));\n 2240:   const writer = stream._writer;\n 2241:   if(writer !== void 0 && backpressure !== stream._backpressure) {\n 2242      if(backpressure) {\n 2243:       defaultWriterReadyPromiseReset(writer);\n 2244      } else {\n 2245        assert_default(!backpressure);\n 2246:       defaultWriterReadyPromiseResolve(writer);\n 2247      }\n 2248    }\n ....\n 2254      assertWritableStream(stream, 'First parameter');\n 2255      if(IsWritableStreamLocked(stream)) {\n 2256:       throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n 2257      }\n 2258      this._ownerWritableStream = stream;\n ....\n 2281    /**\n 2282     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n 2283:    * the writerâ€™s lock is released before the stream finishes closing.\n 2284     */\n 2285    get closed() {\n ....\n 2291    /**\n 2292     * Returns the desired size to fill the streamâ€™s internal queue. It can be negative, if the queue is over-full.\n 2293:    * A producer can use this information to determine the right amount of data to write.\n 2294     *\n 2295     * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n 2296     * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n 2297:    * the writerâ€™s lock is released.\n 2298     */\n 2299    get desiredSize() {\n ....\n 2311     * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n 2312     *\n 2313:    * If the stream becomes errored or aborted, or the writerâ€™s lock is released, the returned promise will become\n 2314     * rejected.\n 2315     */\n 2316:   get ready() {\n 2317      if(!IsWritableStreamDefaultWriter(this)) {\n 2318:       return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n 2319      }\n 2320      return this._readyPromise;\n 2321    }\n 2322    /**\n 2323:    * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n 2324     */\n 2325    abort(reason = void 0) {\n ....\n 2333    }\n 2334    /**\n 2335:    * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n 2336     */\n 2337    close() {\n ....\n 2349    }\n 2350    /**\n 2351:    * Releases the writerâ€™s lock on the corresponding stream. After the lock is released, the writer is no longer active.\n 2352:    * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n 2353:    * now on; otherwise, the writer will appear closed.\n 2354     *\n 2355:    * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n 2356:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n 2357:    * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n 2358     * other producers from writing in an interleaved manner.\n 2359     */\n ....\n 2369      WritableStreamDefaultWriterRelease(this);\n 2370    }\n 2371:   write(chunk = void 0) {\n 2372      if(!IsWritableStreamDefaultWriter(this)) {\n 2373:       return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n 2374      }\n 2375      if(this._ownerWritableStream === void 0) {\n 2376:       return promiseRejectedWith(defaultWriterLockException('write to'));\n 2377      }\n 2378      return WritableStreamDefaultWriterWrite(this, chunk);\n ....\n 2383    close: { enumerable: true },\n 2384    releaseLock: { enumerable: true },\n 2385:   write: { enumerable: true },\n 2386    closed: { enumerable: true },\n 2387    desiredSize: { enumerable: true },\n 2388:   ready: { enumerable: true },\n 2389  });\n 2390  setFunctionName(WritableStreamDefaultWriter.prototype.abort, 'abort');\n 2391  setFunctionName(WritableStreamDefaultWriter.prototype.close, 'close');\n 2392  setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, 'releaseLock');\n 2393: setFunctionName(WritableStreamDefaultWriter.prototype.write, 'write');\n 2394  if(typeof Symbol.toStringTag === 'symbol') {\n 2395    Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {\n ....\n 2407    return x instanceof WritableStreamDefaultWriter;\n 2408  }\n 2409: function WritableStreamDefaultWriterAbort(writer, reason) {\n 2410:   const stream = writer._ownerWritableStream;\n 2411    assert_default(stream !== void 0);\n 2412    return WritableStreamAbort(stream, reason);\n 2413  }\n 2414: function WritableStreamDefaultWriterClose(writer) {\n 2415:   const stream = writer._ownerWritableStream;\n 2416    assert_default(stream !== void 0);\n 2417    return WritableStreamClose(stream);\n 2418  }\n 2419: function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n 2420:   const stream = writer._ownerWritableStream;\n 2421    assert_default(stream !== void 0);\n 2422    const state = stream._state;\n ....\n 2428    }\n 2429    assert_default(state === 'writable' || state === 'erroring');\n 2430:   return WritableStreamDefaultWriterClose(writer);\n 2431  }\n 2432: function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n 2433:   if(writer._closedPromiseState === 'pending') {\n 2434:     defaultWriterClosedPromiseReject(writer, error);\n 2435    } else {\n 2436:     defaultWriterClosedPromiseResetToRejected(writer, error);\n 2437    }\n 2438  }\n 2439: function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n 2440:   if(writer._readyPromiseState === 'pending') {\n 2441:     defaultWriterReadyPromiseReject(writer, error);\n 2442    } else {\n 2443:     defaultWriterReadyPromiseResetToRejected(writer, error);\n 2444    }\n 2445  }\n 2446: function WritableStreamDefaultWriterGetDesiredSize(writer) {\n 2447:   const stream = writer._ownerWritableStream;\n 2448    const state = stream._state;\n 2449    if(state === 'errored' || state === 'erroring') {\n ....\n 2455    return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n 2456  }\n 2457: function WritableStreamDefaultWriterRelease(writer) {\n 2458:   const stream = writer._ownerWritableStream;\n 2459    assert_default(stream !== void 0);\n 2460:   assert_default(stream._writer === writer);\n 2461    const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n 2462:   WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n 2463:   WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n 2464    stream._writer = void 0;\n 2465:   writer._ownerWritableStream = void 0;\n 2466  }\n 2467: function WritableStreamDefaultWriterWrite(writer, chunk) {\n 2468:   const stream = writer._ownerWritableStream;\n 2469    assert_default(stream !== void 0);\n 2470    const controller = stream._writableStreamController;\n 2471    const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n 2472:   if(stream !== writer._ownerWritableStream) {\n 2473:     return promiseRejectedWith(defaultWriterLockException('write to'));\n 2474    }\n 2475    const state = stream._state;\n ....\n 2507    }\n 2508    /**\n 2509:    * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n 2510     */\n 2511    get signal() {\n ....\n 2566    return x instanceof WritableStreamDefaultController2;\n 2567  }\n 2568: function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n 2569    assert_default(IsWritableStream(stream));\n 2570    assert_default(stream._writableStreamController === void 0);\n ....\n 2579    controller._strategySizeAlgorithm = sizeAlgorithm;\n 2580    controller._strategyHWM = highWaterMark;\n 2581:   controller._writeAlgorithm = writeAlgorithm;\n 2582    controller._closeAlgorithm = closeAlgorithm;\n 2583    controller._abortAlgorithm = abortAlgorithm;\n ....\n 2605    const controller = Object.create(WritableStreamDefaultController2.prototype);\n 2606    let startAlgorithm;\n 2607:   let writeAlgorithm;\n 2608    let closeAlgorithm;\n 2609    let abortAlgorithm;\n ....\n 2613      startAlgorithm = () => void 0;\n 2614    }\n 2615:   if(underlyingSink.write !== void 0) {\n 2616:     writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n 2617    } else {\n 2618:     writeAlgorithm = () => promiseResolvedWith(void 0);\n 2619    }\n 2620    if(underlyingSink.close !== void 0) {\n ....\n 2628      abortAlgorithm = () => promiseResolvedWith(void 0);\n 2629    }\n 2630:   SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n 2631  }\n 2632  function WritableStreamDefaultControllerClearAlgorithms(controller) {\n ....\n 2764  }\n 2765  function defaultWriterLockException(name) {\n 2766:   return new TypeError('Cannot ' + name + ' a stream using a released writer');\n 2767  }\n 2768: function defaultWriterClosedPromiseInitialize(writer) {\n 2769:   writer._closedPromise = newPromise((resolve, reject) => {\n 2770:     writer._closedPromise_resolve = resolve;\n 2771:     writer._closedPromise_reject = reject;\n 2772:     writer._closedPromiseState = 'pending';\n 2773    });\n 2774  }\n 2775: function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n 2776:   defaultWriterClosedPromiseInitialize(writer);\n 2777:   defaultWriterClosedPromiseReject(writer, reason);\n 2778  }\n 2779: function defaultWriterClosedPromiseInitializeAsResolved(writer) {\n 2780:   defaultWriterClosedPromiseInitialize(writer);\n 2781:   defaultWriterClosedPromiseResolve(writer);\n 2782  }\n 2783: function defaultWriterClosedPromiseReject(writer, reason) {\n 2784:   if(writer._closedPromise_reject === void 0) {\n 2785      return;\n 2786    }\n 2787:   assert_default(writer._closedPromiseState === 'pending');\n 2788:   setPromiseIsHandledToTrue(writer._closedPromise);\n 2789:   writer._closedPromise_reject(reason);\n 2790:   writer._closedPromise_resolve = void 0;\n 2791:   writer._closedPromise_reject = void 0;\n 2792:   writer._closedPromiseState = 'rejected';\n 2793  }\n 2794: function defaultWriterClosedPromiseResetToRejected(writer, reason) {\n 2795:   assert_default(writer._closedPromise_resolve === void 0);\n 2796:   assert_default(writer._closedPromise_reject === void 0);\n 2797:   assert_default(writer._closedPromiseState !== 'pending');\n 2798:   defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n 2799  }\n 2800: function defaultWriterClosedPromiseResolve(writer) {\n 2801:   if(writer._closedPromise_resolve === void 0) {\n 2802      return;\n 2803    }\n 2804:   assert_default(writer._closedPromiseState === 'pending');\n 2805:   writer._closedPromise_resolve(void 0);\n 2806:   writer._closedPromise_resolve = void 0;\n 2807:   writer._closedPromise_reject = void 0;\n 2808:   writer._closedPromiseState = 'resolved';\n 2809  }\n 2810: function defaultWriterReadyPromiseInitialize(writer) {\n 2811:   writer._readyPromise = newPromise((resolve, reject) => {\n 2812:     writer._readyPromise_resolve = resolve;\n 2813:     writer._readyPromise_reject = reject;\n 2814    });\n 2815:   writer._readyPromiseState = 'pending';\n 2816  }\n 2817: function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n 2818:   defaultWriterReadyPromiseInitialize(writer);\n 2819:   defaultWriterReadyPromiseReject(writer, reason);\n 2820  }\n 2821: function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n 2822:   defaultWriterReadyPromiseInitialize(writer);\n 2823:   defaultWriterReadyPromiseResolve(writer);\n 2824  }\n 2825: function defaultWriterReadyPromiseReject(writer, reason) {\n 2826:   if(writer._readyPromise_reject === void 0) {\n 2827      return;\n 2828    }\n 2829:   setPromiseIsHandledToTrue(writer._readyPromise);\n 2830:   writer._readyPromise_reject(reason);\n 2831:   writer._readyPromise_resolve = void 0;\n 2832:   writer._readyPromise_reject = void 0;\n 2833:   writer._readyPromiseState = 'rejected';\n 2834  }\n 2835: function defaultWriterReadyPromiseReset(writer) {\n 2836:   assert_default(writer._readyPromise_resolve === void 0);\n 2837:   assert_default(writer._readyPromise_reject === void 0);\n 2838:   defaultWriterReadyPromiseInitialize(writer);\n 2839  }\n 2840: function defaultWriterReadyPromiseResetToRejected(writer, reason) {\n 2841:   assert_default(writer._readyPromise_resolve === void 0);\n 2842:   assert_default(writer._readyPromise_reject === void 0);\n 2843:   defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n 2844  }\n 2845: function defaultWriterReadyPromiseResolve(writer) {\n 2846:   if(writer._readyPromise_resolve === void 0) {\n 2847      return;\n 2848    }\n 2849:   writer._readyPromise_resolve(void 0);\n 2850:   writer._readyPromise_resolve = void 0;\n 2851:   writer._readyPromise_reject = void 0;\n 2852:   writer._readyPromiseState = 'fulfilled';\n 2853  }\n 2854  \n ....\n 2901  var DOMException = getFromGlobal() || createPolyfill();\n 2902  \n 2903: // src/lib/readable-stream/pipe.ts\n 2904  function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n 2905    assert_default(IsReadableStream(source));\n ....\n 2911    assert_default(!IsReadableStreamLocked(source));\n 2912    assert_default(!IsWritableStreamLocked(dest));\n 2913:   const reader = AcquireReadableStreamDefaultReader(source);\n 2914:   const writer = AcquireWritableStreamDefaultWriter(dest);\n 2915    source._disturbed = true;\n 2916    let shuttingDown = false;\n ....\n 2932          if(!preventCancel) {\n 2933            actions.push(() => {\n 2934:             if(source._state === 'readable') {\n 2935                return ReadableStreamCancel(source, error);\n 2936              }\n ....\n 2962          return promiseResolvedWith(true);\n 2963        }\n 2964:       return PerformPromiseThen(writer._readyPromise, () => {\n 2965          return newPromise((resolveRead, rejectRead) => {\n 2966:           ReadableStreamDefaultReaderRead(reader, {\n 2967              _chunkSteps: chunk => {\n 2968:               currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop);\n 2969                resolveRead(false);\n 2970              },\n ....\n 2975        });\n 2976      }\n 2977:     isOrBecomesErrored(source, reader._closedPromise, storedError => {\n 2978        if(!preventAbort) {\n 2979          shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n ....\n 2983        return null;\n 2984      });\n 2985:     isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n 2986        if(!preventCancel) {\n 2987          shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n ....\n 2991        return null;\n 2992      });\n 2993:     isOrBecomesClosed(source, reader._closedPromise, () => {\n 2994        if(!preventClose) {\n 2995:         shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n 2996        } else {\n 2997          shutdown();\n ....\n 3057      }\n 3058      function finalize(isError, error) {\n 3059:       WritableStreamDefaultWriterRelease(writer);\n 3060:       ReadableStreamReaderGenericRelease(reader);\n 3061        if(signal !== void 0) {\n 3062          signal.removeEventListener('abort', abortAlgorithm);\n ....\n 3072  }\n 3073  \n 3074: // src/lib/readable-stream/default-controller.ts\n 3075  var ReadableStreamDefaultController = class {\n 3076    constructor() {\n ....\n 3088    }\n 3089    /**\n 3090:    * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n 3091:    * the stream, but once those are read, the stream will become closed.\n 3092     */\n 3093    close() {\n ....\n 3110    }\n 3111    /**\n 3112:    * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n 3113     */\n 3114    error(e = void 0) {\n ....\n 3126    }\n 3127    /** @internal */\n 3128:   [PullSteps](readRequest) {\n 3129      const stream = this._controlledReadableStream;\n 3130      if(this._queue.length > 0) {\n ....\n 3136          ReadableStreamDefaultControllerCallPullIfNeeded(this);\n 3137        }\n 3138:       readRequest._chunkSteps(chunk);\n 3139      } else {\n 3140:       ReadableStreamAddReadRequest(stream, readRequest);\n 3141        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n 3142      }\n ....\n 3257  function ReadableStreamDefaultControllerError(controller, e) {\n 3258    const stream = controller._controlledReadableStream;\n 3259:   if(stream._state !== 'readable') {\n 3260      return;\n 3261    }\n ....\n 3282  function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n 3283    const state = controller._controlledReadableStream._state;\n 3284:   if(!controller._closeRequested && state === 'readable') {\n 3285      return true;\n 3286    }\n ....\n 3344  }\n 3345  \n 3346: // src/lib/readable-stream/tee.ts\n 3347  function ReadableStreamTee(stream, cloneForBranch2) {\n 3348    assert_default(IsReadableStream(stream));\n ....\n 3356    assert_default(IsReadableStream(stream));\n 3357    assert_default(typeof cloneForBranch2 === 'boolean');\n 3358:   const reader = AcquireReadableStreamDefaultReader(stream);\n 3359:   let reading = false;\n 3360:   let readAgain = false;\n 3361    let canceled1 = false;\n 3362    let canceled2 = false;\n ....\n 3370    });\n 3371    function pullAlgorithm() {\n 3372:     if(reading) {\n 3373:       readAgain = true;\n 3374        return promiseResolvedWith(void 0);\n 3375      }\n 3376:     reading = true;\n 3377:     const readRequest = {\n 3378        _chunkSteps: chunk => {\n 3379          _queueMicrotask(() => {\n 3380:           readAgain = false;\n 3381            const chunk1 = chunk;\n 3382            const chunk2 = chunk;\n ....\n 3387              ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n 3388            }\n 3389:           reading = false;\n 3390:           if(readAgain) {\n 3391              pullAlgorithm();\n 3392            }\n ....\n 3394        },\n 3395        _closeSteps: () => {\n 3396:         reading = false;\n 3397          if(!canceled1) {\n 3398            ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n ....\n 3406        },\n 3407        _errorSteps: () => {\n 3408:         reading = false;\n 3409        },\n 3410      };\n 3411:     ReadableStreamDefaultReaderRead(reader, readRequest);\n 3412      return promiseResolvedWith(void 0);\n 3413    }\n ....\n 3435    branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n 3436    branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n 3437:   uponRejection(reader._closedPromise, r => {\n 3438      ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n 3439      ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n ....\n 3448    assert_default(IsReadableStream(stream));\n 3449    assert_default(IsReadableByteStreamController(stream._readableStreamController));\n 3450:   let reader = AcquireReadableStreamDefaultReader(stream);\n 3451:   let reading = false;\n 3452:   let readAgainForBranch1 = false;\n 3453:   let readAgainForBranch2 = false;\n 3454    let canceled1 = false;\n 3455    let canceled2 = false;\n ....\n 3464    function forwardReaderError(thisReader) {\n 3465      uponRejection(thisReader._closedPromise, r => {\n 3466:       if(thisReader !== reader) {\n 3467          return null;\n 3468        }\n ....\n 3476    }\n 3477    function pullWithDefaultReader() {\n 3478:     if(IsReadableStreamBYOBReader(reader)) {\n 3479:       assert_default(reader._readIntoRequests.length === 0);\n 3480:       ReadableStreamReaderGenericRelease(reader);\n 3481:       reader = AcquireReadableStreamDefaultReader(stream);\n 3482:       forwardReaderError(reader);\n 3483      }\n 3484:     const readRequest = {\n 3485        _chunkSteps: chunk => {\n 3486          _queueMicrotask(() => {\n 3487:           readAgainForBranch1 = false;\n 3488:           readAgainForBranch2 = false;\n 3489            const chunk1 = chunk;\n 3490            let chunk2 = chunk;\n ....\n 3505              ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n 3506            }\n 3507:           reading = false;\n 3508:           if(readAgainForBranch1) {\n 3509              pull1Algorithm();\n 3510:           } else if(readAgainForBranch2) {\n 3511              pull2Algorithm();\n 3512            }\n ....\n 3514        },\n 3515        _closeSteps: () => {\n 3516:         reading = false;\n 3517          if(!canceled1) {\n 3518            ReadableByteStreamControllerClose(branch1._readableStreamController);\n ....\n 3532        },\n 3533        _errorSteps: () => {\n 3534:         reading = false;\n 3535        },\n 3536      };\n 3537:     ReadableStreamDefaultReaderRead(reader, readRequest);\n 3538    }\n 3539    function pullWithBYOBReader(view, forBranch2) {\n 3540:     if(IsReadableStreamDefaultReader(reader)) {\n 3541:       assert_default(reader._readRequests.length === 0);\n 3542:       ReadableStreamReaderGenericRelease(reader);\n 3543:       reader = AcquireReadableStreamBYOBReader(stream);\n 3544:       forwardReaderError(reader);\n 3545      }\n 3546      const byobBranch = forBranch2 ? branch2 : branch1;\n 3547      const otherBranch = forBranch2 ? branch1 : branch2;\n 3548:     const readIntoRequest = {\n 3549        _chunkSteps: chunk => {\n 3550          _queueMicrotask(() => {\n 3551:           readAgainForBranch1 = false;\n 3552:           readAgainForBranch2 = false;\n 3553            const byobCanceled = forBranch2 ? canceled2 : canceled1;\n 3554            const otherCanceled = forBranch2 ? canceled1 : canceled2;\n ....\n 3570              ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n 3571            }\n 3572:           reading = false;\n 3573:           if(readAgainForBranch1) {\n 3574              pull1Algorithm();\n 3575:           } else if(readAgainForBranch2) {\n 3576              pull2Algorithm();\n 3577            }\n ....\n 3579        },\n 3580        _closeSteps: chunk => {\n 3581:         reading = false;\n 3582          const byobCanceled = forBranch2 ? canceled2 : canceled1;\n 3583          const otherCanceled = forBranch2 ? canceled1 : canceled2;\n ....\n 3602        },\n 3603        _errorSteps: () => {\n 3604:         reading = false;\n 3605        },\n 3606      };\n 3607:     ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);\n 3608    }\n 3609    function pull1Algorithm() {\n 3610:     if(reading) {\n 3611:       readAgainForBranch1 = true;\n 3612        return promiseResolvedWith(void 0);\n 3613      }\n 3614:     reading = true;\n 3615      const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n 3616      if(byobRequest === null) {\n ....\n 3622    }\n 3623    function pull2Algorithm() {\n 3624:     if(reading) {\n 3625:       readAgainForBranch2 = true;\n 3626        return promiseResolvedWith(void 0);\n 3627      }\n 3628:     reading = true;\n 3629      const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n 3630      if(byobRequest === null) {\n ....\n 3660    branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n 3661    branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n 3662:   forwardReaderError(reader);\n 3663    return [branch1, branch2];\n 3664  }\n 3665  \n 3666: // src/lib/readable-stream/readable-stream-like.ts\n 3667  function isReadableStreamLike(stream) {\n 3668    return typeIsObject(stream) && typeof stream.getReader !== 'undefined';\n 3669  }\n 3670  \n 3671: // src/lib/readable-stream/from.ts\n 3672  function ReadableStreamFrom(source) {\n 3673    if(isReadableStreamLike(source)) {\n ....\n 3723    return stream;\n 3724  }\n 3725: function ReadableStreamFromDefaultReader(reader) {\n 3726    let stream;\n 3727    const startAlgorithm = noop;\n 3728    function pullAlgorithm() {\n 3729:     let readPromise;\n 3730      try {\n 3731:       readPromise = reader.read();\n 3732      } catch(e) {\n 3733        return promiseRejectedWith(e);\n 3734      }\n 3735:     return transformPromiseWith(readPromise, readResult => {\n 3736:       if(!typeIsObject(readResult)) {\n 3737:         throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\n 3738        }\n 3739:       if(readResult.done) {\n 3740          ReadableStreamDefaultControllerClose(stream._readableStreamController);\n 3741        } else {\n 3742:         const value = readResult.value;\n 3743          ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\n 3744        }\n ....\n 3747    function cancelAlgorithm(reason) {\n 3748      try {\n 3749:       return promiseResolvedWith(reader.cancel(reason));\n 3750      } catch(e) {\n 3751        return promiseRejectedWith(e);\n ....\n 3823  }\n 3824  \n 3825: // src/lib/validators/readable-writable-pair.ts\n 3826  function convertReadableWritablePair(pair, context) {\n 3827    assertDictionary(pair, context);\n 3828:   const readable = pair == null ? void 0 : pair.readable;\n 3829:   assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n 3830:   assertReadableStream(readable, `${context} has member 'readable' that`);\n 3831    const writable = pair == null ? void 0 : pair.writable;\n 3832    assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n 3833    assertWritableStream(writable, `${context} has member 'writable' that`);\n 3834:   return { readable, writable };\n 3835  }\n 3836  \n 3837: // src/lib/readable-stream.ts\n 3838  var ReadableStream9 = class {\n 3839    constructor(rawUnderlyingSource = {}, rawStrategy = {}) {\n ....\n 3860    }\n 3861    /**\n 3862:    * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n 3863     */\n 3864    get locked() {\n ....\n 3879      }\n 3880      if(IsReadableStreamLocked(this)) {\n 3881:       return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n 3882      }\n 3883      return ReadableStreamCancel(this, reason);\n ....\n 3909      const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n 3910      setPromiseIsHandledToTrue(promise);\n 3911:     return transform.readable;\n 3912    }\n 3913    pipeTo(destination, rawOptions = {}) {\n ....\n 3936    }\n 3937    /**\n 3938:    * Tees this readable stream, returning a two-element array containing the two resulting branches as\n 3939     * new {@link ReadableStream} instances.\n 3940     *\n 3941:    * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n 3942     * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n 3943     * propagated to the stream's underlying source.\n ....\n 3966     * Creates a new ReadableStream wrapping the provided iterable or async iterable.\n 3967     *\n 3968:    * This can be used to adapt various kinds of objects into a readable stream,\n 3969:    * such as an array, an async generator, or a Node.js readable stream.\n 3970     */\n 3971    static from(asyncIterable) {\n ....\n 4019  }\n 4020  function InitializeReadableStream(stream) {\n 4021:   stream._state = 'readable';\n 4022    stream._reader = void 0;\n 4023    stream._storedError = void 0;\n ....\n 4049    }\n 4050    ReadableStreamClose(stream);\n 4051:   const reader = stream._reader;\n 4052:   if(reader !== void 0 && IsReadableStreamBYOBReader(reader)) {\n 4053:     const readIntoRequests = reader._readIntoRequests;\n 4054:     reader._readIntoRequests = new SimpleQueue();\n 4055:     readIntoRequests.forEach(readIntoRequest => {\n 4056:       readIntoRequest._closeSteps(void 0);\n 4057      });\n 4058    }\n ....\n 4061  }\n 4062  function ReadableStreamClose(stream) {\n 4063:   assert_default(stream._state === 'readable');\n 4064    stream._state = 'closed';\n 4065:   const reader = stream._reader;\n 4066:   if(reader === void 0) {\n 4067      return;\n 4068    }\n 4069:   defaultReaderClosedPromiseResolve(reader);\n 4070:   if(IsReadableStreamDefaultReader(reader)) {\n 4071:     const readRequests = reader._readRequests;\n 4072:     reader._readRequests = new SimpleQueue();\n 4073:     readRequests.forEach(readRequest => {\n 4074:       readRequest._closeSteps();\n 4075      });\n 4076    }\n ....\n 4078  function ReadableStreamError(stream, e) {\n 4079    assert_default(IsReadableStream(stream));\n 4080:   assert_default(stream._state === 'readable');\n 4081    stream._state = 'errored';\n 4082    stream._storedError = e;\n 4083:   const reader = stream._reader;\n 4084:   if(reader === void 0) {\n 4085      return;\n 4086    }\n 4087:   defaultReaderClosedPromiseReject(reader, e);\n 4088:   if(IsReadableStreamDefaultReader(reader)) {\n 4089:     ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n 4090    } else {\n 4091:     assert_default(IsReadableStreamBYOBReader(reader));\n 4092:     ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n 4093    }\n 4094  }\n ....\n 4219    const cancel = original == null ? void 0 : original.cancel;\n 4220    const flush = original == null ? void 0 : original.flush;\n 4221:   const readableType = original == null ? void 0 : original.readableType;\n 4222    const start = original == null ? void 0 : original.start;\n 4223    const transform = original == null ? void 0 : original.transform;\n ....\n 4226      cancel: cancel === void 0 ? void 0 : convertTransformerCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n 4227      flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\n 4228:     readableType,\n 4229      start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),\n 4230      transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),\n ....\n 4256      }\n 4257      const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n 4258:     const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n 4259      const transformer = convertTransformer(rawTransformer, 'First parameter');\n 4260:     if(transformer.readableType !== void 0) {\n 4261:       throw new RangeError('Invalid readableType specified');\n 4262      }\n 4263      if(transformer.writableType !== void 0) {\n 4264        throw new RangeError('Invalid writableType specified');\n 4265      }\n 4266:     const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n 4267:     const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n 4268      const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n 4269      const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n ....\n 4272        startPromise_resolve = resolve;\n 4273      });\n 4274:     InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n 4275      SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n 4276      if(transformer.start !== void 0) {\n ....\n 4281    }\n 4282    /**\n 4283:    * The readable side of the transform stream.\n 4284     */\n 4285:   get readable() {\n 4286      if(!IsTransformStream(this)) {\n 4287:       throw streamBrandCheckException3('readable');\n 4288      }\n 4289      return this._readable;\n ....\n 4300  };\n 4301  Object.defineProperties(TransformStream.prototype, {\n 4302:   readable: { enumerable: true },\n 4303    writable: { enumerable: true },\n 4304  });\n ....\n 4309    });\n 4310  }\n 4311: function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n 4312    function startAlgorithm() {\n 4313      return startPromise;\n 4314    }\n 4315:   function writeAlgorithm(chunk) {\n 4316      return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n 4317    }\n ....\n 4322      return TransformStreamDefaultSinkCloseAlgorithm(stream);\n 4323    }\n 4324:   stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n 4325    function pullAlgorithm() {\n 4326      return TransformStreamDefaultSourcePullAlgorithm(stream);\n ....\n 4329      return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);\n 4330    }\n 4331:   stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n 4332    stream._backpressure = void 0;\n 4333    stream._backpressureChangePromise = void 0;\n ....\n 4374    }\n 4375    /**\n 4376:    * Returns the desired size to fill the readable sideâ€™s internal queue. It can be negative, if the queue is over-full.\n 4377     */\n 4378    get desiredSize() {\n ....\n 4380        throw defaultControllerBrandCheckException3('desiredSize');\n 4381      }\n 4382:     const readableController = this._controlledTransformStream._readable._readableStreamController;\n 4383:     return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n 4384    }\n 4385    enqueue(chunk = void 0) {\n ....\n 4390    }\n 4391    /**\n 4392:    * Errors both the readable side and the writable side of the controlled transform stream, making all future\n 4393     * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n 4394     */\n ....\n 4400    }\n 4401    /**\n 4402:    * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n 4403     * transformer only needs to consume a portion of the chunks written to the writable side.\n 4404     */\n ....\n 4482  function TransformStreamDefaultControllerEnqueue(controller, chunk) {\n 4483    const stream = controller._controlledTransformStream;\n 4484:   const readableController = stream._readable._readableStreamController;\n 4485:   if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n 4486      throw new TypeError('Readable side is not in a state that permits enqueue');\n 4487    }\n 4488    try {\n 4489:     ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n 4490    } catch(e) {\n 4491      TransformStreamErrorWritableAndUnblockWrite(stream, e);\n 4492      throw stream._readable._storedError;\n 4493    }\n 4494:   const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n 4495    if(backpressure !== stream._backpressure) {\n 4496      assert_default(backpressure);\n ....\n 4510  function TransformStreamDefaultControllerTerminate(controller) {\n 4511    const stream = controller._controlledTransformStream;\n 4512:   const readableController = stream._readable._readableStreamController;\n 4513:   ReadableStreamDefaultControllerClose(readableController);\n 4514    const error = new TypeError('TransformStream terminated');\n 4515    TransformStreamErrorWritableAndUnblockWrite(stream, error);\n ....\n 4538      return controller._finishPromise;\n 4539    }\n 4540:   const readable = stream._readable;\n 4541    controller._finishPromise = newPromise((resolve, reject) => {\n 4542      controller._finishPromise_resolve = resolve;\n ....\n 4548      cancelPromise,\n 4549      () => {\n 4550:       if(readable._state === 'errored') {\n 4551:         defaultControllerFinishPromiseReject(controller, readable._storedError);\n 4552        } else {\n 4553:         ReadableStreamDefaultControllerError(readable._readableStreamController, reason);\n 4554          defaultControllerFinishPromiseResolve(controller);\n 4555        }\n ....\n 4557      },\n 4558      r => {\n 4559:       ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n 4560        defaultControllerFinishPromiseReject(controller, r);\n 4561        return null;\n ....\n 4569      return controller._finishPromise;\n 4570    }\n 4571:   const readable = stream._readable;\n 4572    controller._finishPromise = newPromise((resolve, reject) => {\n 4573      controller._finishPromise_resolve = resolve;\n ....\n 4579      flushPromise,\n 4580      () => {\n 4581:       if(readable._state === 'errored') {\n 4582:         defaultControllerFinishPromiseReject(controller, readable._storedError);\n 4583        } else {\n 4584:         ReadableStreamDefaultControllerClose(readable._readableStreamController);\n 4585          defaultControllerFinishPromiseResolve(controller);\n 4586        }\n ....\n 4588      },\n 4589      r => {\n 4590:       ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n 4591        defaultControllerFinishPromiseReject(controller, r);\n 4592        return null;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/out.js:\n  104  var ReleaseSteps = Symbol('[[ReleaseSteps]]');\n  105  \n  106: // src/lib/readable-stream/generic-reader.ts\n  107: function ReadableStreamReaderGenericInitialize(reader, stream) {\n  108:   reader._ownerReadableStream = stream;\n  109:   stream._reader = reader;\n  110:   if(stream._state === 'readable') {\n  111:     defaultReaderClosedPromiseInitialize(reader);\n  112    } else if(stream._state === 'closed') {\n  113:     defaultReaderClosedPromiseInitializeAsResolved(reader);\n  114    } else {\n  115      assert_default(stream._state === 'errored');\n  116:     defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n  117    }\n  118  }\n  119: function ReadableStreamReaderGenericCancel(reader, reason) {\n  120:   const stream = reader._ownerReadableStream;\n  121    assert_default(stream !== void 0);\n  122    return ReadableStreamCancel(stream, reason);\n  123  }\n  124: function ReadableStreamReaderGenericRelease(reader) {\n  125:   const stream = reader._ownerReadableStream;\n  126    assert_default(stream !== void 0);\n  127:   assert_default(stream._reader === reader);\n  128:   if(stream._state === 'readable') {\n  129:     defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  130    } else {\n  131:     defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  132    }\n  133    stream._readableStreamController[ReleaseSteps]();\n  134    stream._reader = void 0;\n  135:   reader._ownerReadableStream = void 0;\n  136  }\n  137: function readerLockException(name) {\n  138:   return new TypeError('Cannot ' + name + ' a stream using a released reader');\n  139  }\n  140: function defaultReaderClosedPromiseInitialize(reader) {\n  141:   reader._closedPromise = newPromise((resolve, reject) => {\n  142:     reader._closedPromise_resolve = resolve;\n  143:     reader._closedPromise_reject = reject;\n  144    });\n  145  }\n  146: function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n  147:   defaultReaderClosedPromiseInitialize(reader);\n  148:   defaultReaderClosedPromiseReject(reader, reason);\n  149  }\n  150: function defaultReaderClosedPromiseInitializeAsResolved(reader) {\n  151:   defaultReaderClosedPromiseInitialize(reader);\n  152:   defaultReaderClosedPromiseResolve(reader);\n  153  }\n  154: function defaultReaderClosedPromiseReject(reader, reason) {\n  155:   if(reader._closedPromise_reject === void 0) {\n  156      return;\n  157    }\n  158:   setPromiseIsHandledToTrue(reader._closedPromise);\n  159:   reader._closedPromise_reject(reason);\n  160:   reader._closedPromise_resolve = void 0;\n  161:   reader._closedPromise_reject = void 0;\n  162  }\n  163: function defaultReaderClosedPromiseResetToRejected(reader, reason) {\n  164:   assert_default(reader._closedPromise_resolve === void 0);\n  165:   assert_default(reader._closedPromise_reject === void 0);\n  166:   defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n  167  }\n  168: function defaultReaderClosedPromiseResolve(reader) {\n  169:   if(reader._closedPromise_resolve === void 0) {\n  170      return;\n  171    }\n  172:   reader._closedPromise_resolve(void 0);\n  173:   reader._closedPromise_resolve = void 0;\n  174:   reader._closedPromise_reject = void 0;\n  175  }\n  176  \n  ...\n  213      ++this._size;\n  214    }\n  215:   // Like push(), shift() follows the read -> calculate -> mutate pattern for\n  216    // exception safety.\n  217    shift() {\n  ...\n  349  }\n  350  \n  351: // src/lib/validators/readable-stream.ts\n  352  function assertReadableStream(x, context) {\n  353    if(!IsReadableStream(x)) {\n  ...\n  356  }\n  357  \n  358: // src/lib/readable-stream/default-reader.ts\n  359  function AcquireReadableStreamDefaultReader(stream) {\n  360    return new ReadableStreamDefaultReader(stream);\n  361  }\n  362: function ReadableStreamAddReadRequest(stream, readRequest) {\n  363    assert_default(IsReadableStreamDefaultReader(stream._reader));\n  364:   assert_default(stream._state === 'readable');\n  365:   stream._reader._readRequests.push(readRequest);\n  366  }\n  367  function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n  368:   const reader = stream._reader;\n  369:   assert_default(reader._readRequests.length > 0);\n  370:   const readRequest = reader._readRequests.shift();\n  371    if(done) {\n  372:     readRequest._closeSteps();\n  373    } else {\n  374:     readRequest._chunkSteps(chunk);\n  375    }\n  376  }\n  ...\n  379  }\n  380  function ReadableStreamHasDefaultReader(stream) {\n  381:   const reader = stream._reader;\n  382:   if(reader === void 0) {\n  383      return false;\n  384    }\n  385:   if(!IsReadableStreamDefaultReader(reader)) {\n  386      return false;\n  387    }\n  ...\n  393      assertReadableStream(stream, 'First parameter');\n  394      if(IsReadableStreamLocked(stream)) {\n  395:       throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n  396      }\n  397      ReadableStreamReaderGenericInitialize(this, stream);\n  ...\n  400    /**\n  401     * Returns a promise that will be fulfilled when the stream becomes closed,\n  402:    * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n  403     */\n  404    get closed() {\n  ...\n  409    }\n  410    /**\n  411:    * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n  412     */\n  413    cancel(reason = void 0) {\n  ...\n  416      }\n  417      if(this._ownerReadableStream === void 0) {\n  418:       return promiseRejectedWith(readerLockException('cancel'));\n  419      }\n  420      return ReadableStreamReaderGenericCancel(this, reason);\n  ...\n  423     * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n  424     *\n  425:    * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  426     */\n  427:   read() {\n  428      if(!IsReadableStreamDefaultReader(this)) {\n  429:       return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  430      }\n  431      if(this._ownerReadableStream === void 0) {\n  432:       return promiseRejectedWith(readerLockException('read from'));\n  433      }\n  434      let resolvePromise;\n  ...\n  438        rejectPromise = reject;\n  439      });\n  440:     const readRequest = {\n  441        _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n  442        _closeSteps: () => resolvePromise({ value: void 0, done: true }),\n  443        _errorSteps: e => rejectPromise(e),\n  444      };\n  445:     ReadableStreamDefaultReaderRead(this, readRequest);\n  446      return promise;\n  447    }\n  448    /**\n  449:    * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n  450:    * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n  451:    * from now on; otherwise, the reader will appear closed.\n  452     *\n  453:    * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  454:    * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  455:    * do so will throw a `TypeError` and leave the reader locked to the stream.\n  456     */\n  457    releaseLock() {\n  ...\n  467  Object.defineProperties(ReadableStreamDefaultReader.prototype, {\n  468    cancel: { enumerable: true },\n  469:   read: { enumerable: true },\n  470    releaseLock: { enumerable: true },\n  471    closed: { enumerable: true },\n  472  });\n  473  setFunctionName(ReadableStreamDefaultReader.prototype.cancel, 'cancel');\n  474: setFunctionName(ReadableStreamDefaultReader.prototype.read, 'read');\n  475  setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, 'releaseLock');\n  476  if(typeof Symbol.toStringTag === 'symbol') {\n  ...\n  489    return x instanceof ReadableStreamDefaultReader;\n  490  }\n  491: function ReadableStreamDefaultReaderRead(reader, readRequest) {\n  492:   const stream = reader._ownerReadableStream;\n  493    assert_default(stream !== void 0);\n  494    stream._disturbed = true;\n  495    if(stream._state === 'closed') {\n  496:     readRequest._closeSteps();\n  497    } else if(stream._state === 'errored') {\n  498:     readRequest._errorSteps(stream._storedError);\n  499    } else {\n  500:     assert_default(stream._state === 'readable');\n  501:     stream._readableStreamController[PullSteps](readRequest);\n  502    }\n  503  }\n  504: function ReadableStreamDefaultReaderRelease(reader) {\n  505:   ReadableStreamReaderGenericRelease(reader);\n  506    const e = new TypeError('Reader was released');\n  507:   ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n  508  }\n  509: function ReadableStreamDefaultReaderErrorReadRequests(reader, e) {\n  510:   const readRequests = reader._readRequests;\n  511:   reader._readRequests = new SimpleQueue();\n  512:   readRequests.forEach(readRequest => {\n  513:     readRequest._errorSteps(e);\n  514    });\n  515  }\n  ...\n  724  }\n  725  \n  726: // src/lib/readable-stream/byte-stream-controller.ts\n  727  var ReadableStreamBYOBRequest = class {\n  728    constructor() {\n  ...\n  808    }\n  809    /**\n  810:    * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n  811:    * the stream, but once those are read, the stream will become closed.\n  812     */\n  813    close() {\n  ...\n  819      }\n  820      const state = this._controlledReadableByteStream._state;\n  821:     if(state !== 'readable') {\n  822:       throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n  823      }\n  824      ReadableByteStreamControllerClose(this);\n  ...\n  842      }\n  843      const state = this._controlledReadableByteStream._state;\n  844:     if(state !== 'readable') {\n  845:       throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n  846      }\n  847      ReadableByteStreamControllerEnqueue(this, chunk);\n  848    }\n  849    /**\n  850:    * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n  851     */\n  852    error(e = void 0) {\n  ...\n  865    }\n  866    /** @internal */\n  867:   [PullSteps](readRequest) {\n  868      const stream = this._controlledReadableByteStream;\n  869      assert_default(ReadableStreamHasDefaultReader(stream));\n  870      if(this._queueTotalSize > 0) {\n  871        assert_default(ReadableStreamGetNumReadRequests(stream) === 0);\n  872:       ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);\n  873        return;\n  874      }\n  ...\n  879          buffer = new ArrayBuffer(autoAllocateChunkSize);\n  880        } catch(bufferE) {\n  881:         readRequest._errorSteps(bufferE);\n  882          return;\n  883        }\n  ...\n  891          elementSize: 1,\n  892          viewConstructor: Uint8Array,\n  893:         readerType: 'default',\n  894        };\n  895        this._pendingPullIntos.push(pullIntoDescriptor);\n  896      }\n  897:     ReadableStreamAddReadRequest(stream, readRequest);\n  898      ReadableByteStreamControllerCallPullIfNeeded(this);\n  899    }\n  ...\n  902      if(this._pendingPullIntos.length > 0) {\n  903        const firstPullInto = this._pendingPullIntos.peek();\n  904:       firstPullInto.readerType = 'none';\n  905        this._pendingPullIntos = new SimpleQueue();\n  906        this._pendingPullIntos.push(firstPullInto);\n  ...\n  976  function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n  977    assert_default(stream._state !== 'errored');\n  978:   assert_default(pullIntoDescriptor.readerType !== 'none');\n  979    let done = false;\n  980    if(stream._state === 'closed') {\n  ...\n  983    }\n  984    const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n  985:   if(pullIntoDescriptor.readerType === 'default') {\n  986      ReadableStreamFulfillReadRequest(stream, filledView, done);\n  987    } else {\n  988:     assert_default(pullIntoDescriptor.readerType === 'byob');\n  989      ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  990    }\n  ...\n 1017  }\n 1018  function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {\n 1019:   assert_default(firstDescriptor.readerType === 'none');\n 1020    if(firstDescriptor.bytesFilled > 0) {\n 1021      ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);\n ....\n 1027    const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n 1028    let totalBytesToCopyRemaining = maxBytesToCopy;\n 1029:   let ready = false;\n 1030    assert_default(!IsDetachedBuffer(pullIntoDescriptor.buffer));\n 1031    assert_default(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n ....\n 1034    if(maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n 1035      totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n 1036:     ready = true;\n 1037    }\n 1038    const queue = controller._queue;\n ....\n 1053      totalBytesToCopyRemaining -= bytesToCopy;\n 1054    }\n 1055:   if(!ready) {\n 1056      assert_default(controller._queueTotalSize === 0);\n 1057      assert_default(pullIntoDescriptor.bytesFilled > 0);\n 1058      assert_default(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n 1059    }\n 1060:   return ready;\n 1061  }\n 1062  function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n ....\n 1066  }\n 1067  function ReadableByteStreamControllerHandleQueueDrain(controller) {\n 1068:   assert_default(controller._controlledReadableByteStream._state === 'readable');\n 1069    if(controller._queueTotalSize === 0 && controller._closeRequested) {\n 1070      ReadableByteStreamControllerClearAlgorithms(controller);\n ....\n 1090      }\n 1091      const pullIntoDescriptor = controller._pendingPullIntos.peek();\n 1092:     assert_default(pullIntoDescriptor.readerType !== 'none');\n 1093      if(ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n 1094        ReadableByteStreamControllerShiftPendingPullInto(controller);\n ....\n 1099  }\n 1100  function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller) {\n 1101:   const reader = controller._controlledReadableByteStream._reader;\n 1102:   assert_default(IsReadableStreamDefaultReader(reader));\n 1103:   while(reader._readRequests.length > 0) {\n 1104      if(controller._queueTotalSize === 0) {\n 1105        return;\n 1106      }\n 1107:     const readRequest = reader._readRequests.shift();\n 1108:     ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);\n 1109    }\n 1110  }\n 1111: function ReadableByteStreamControllerPullInto(controller, view, min, readIntoRequest) {\n 1112    const stream = controller._controlledReadableByteStream;\n 1113    const ctor = view.constructor;\n ....\n 1121      buffer = TransferArrayBuffer(view.buffer);\n 1122    } catch(e) {\n 1123:     readIntoRequest._errorSteps(e);\n 1124      return;\n 1125    }\n ....\n 1133      elementSize,\n 1134      viewConstructor: ctor,\n 1135:     readerType: 'byob',\n 1136    };\n 1137    if(controller._pendingPullIntos.length > 0) {\n 1138      controller._pendingPullIntos.push(pullIntoDescriptor);\n 1139:     ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n 1140      return;\n 1141    }\n 1142    if(stream._state === 'closed') {\n 1143      const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n 1144:     readIntoRequest._closeSteps(emptyView);\n 1145      return;\n 1146    }\n ....\n 1149        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n 1150        ReadableByteStreamControllerHandleQueueDrain(controller);\n 1151:       readIntoRequest._chunkSteps(filledView);\n 1152        return;\n 1153      }\n ....\n 1155        const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n 1156        ReadableByteStreamControllerError(controller, e);\n 1157:       readIntoRequest._errorSteps(e);\n 1158        return;\n 1159      }\n 1160    }\n 1161    controller._pendingPullIntos.push(pullIntoDescriptor);\n 1162:   ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n 1163    ReadableByteStreamControllerCallPullIfNeeded(controller);\n 1164  }\n 1165  function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n 1166    assert_default(firstDescriptor.bytesFilled % firstDescriptor.elementSize === 0);\n 1167:   if(firstDescriptor.readerType === 'none') {\n 1168      ReadableByteStreamControllerShiftPendingPullInto(controller);\n 1169    }\n ....\n 1180    assert_default(pullIntoDescriptor.bytesFilled + bytesWritten <= pullIntoDescriptor.byteLength);\n 1181    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n 1182:   if(pullIntoDescriptor.readerType === 'none') {\n 1183      ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);\n 1184      const filledPullIntos2 = ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n ....\n 1209      ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n 1210    } else {\n 1211:     assert_default(state === 'readable');\n 1212      assert_default(bytesWritten > 0);\n 1213      ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n ....\n 1222  function ReadableByteStreamControllerShouldCallPull(controller) {\n 1223    const stream = controller._controlledReadableByteStream;\n 1224:   if(stream._state !== 'readable') {\n 1225      return false;\n 1226    }\n ....\n 1250  function ReadableByteStreamControllerClose(controller) {\n 1251    const stream = controller._controlledReadableByteStream;\n 1252:   if(controller._closeRequested || stream._state !== 'readable') {\n 1253      return;\n 1254    }\n ....\n 1270  function ReadableByteStreamControllerEnqueue(controller, chunk) {\n 1271    const stream = controller._controlledReadableByteStream;\n 1272:   if(controller._closeRequested || stream._state !== 'readable') {\n 1273      return;\n 1274    }\n ....\n 1285      ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n 1286      firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n 1287:     if(firstPendingPullInto.readerType === 'none') {\n 1288        ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);\n 1289      }\n ....\n 1297        assert_default(controller._queue.length === 0);\n 1298        if(controller._pendingPullIntos.length > 0) {\n 1299:         assert_default(controller._pendingPullIntos.peek().readerType === 'default');\n 1300          ReadableByteStreamControllerShiftPendingPullInto(controller);\n 1301        }\n ....\n 1315  function ReadableByteStreamControllerError(controller, e) {\n 1316    const stream = controller._controlledReadableByteStream;\n 1317:   if(stream._state !== 'readable') {\n 1318      return;\n 1319    }\n ....\n 1323    ReadableStreamError(stream, e);\n 1324  }\n 1325: function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {\n 1326    assert_default(controller._queueTotalSize > 0);\n 1327    const entry = controller._queue.shift();\n ....\n 1329    ReadableByteStreamControllerHandleQueueDrain(controller);\n 1330    const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n 1331:   readRequest._chunkSteps(view);\n 1332  }\n 1333  function ReadableByteStreamControllerGetBYOBRequest(controller) {\n ....\n 1360      }\n 1361    } else {\n 1362:     assert_default(state === 'readable');\n 1363      if(bytesWritten === 0) {\n 1364:       throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');\n 1365      }\n 1366      if(firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n ....\n 1381      }\n 1382    } else {\n 1383:     assert_default(state === 'readable');\n 1384      if(view.byteLength === 0) {\n 1385:       throw new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");\n 1386      }\n 1387    }\n ....\n 1476  }\n 1477  \n 1478: // src/lib/validators/reader-options.ts\n 1479  function convertReaderOptions(options, context) {\n 1480    assertDictionary(options, context);\n ....\n 1499  }\n 1500  \n 1501: // src/lib/readable-stream/byob-reader.ts\n 1502  function AcquireReadableStreamBYOBReader(stream) {\n 1503    return new ReadableStreamBYOBReader(stream);\n 1504  }\n 1505: function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n 1506    assert_default(IsReadableStreamBYOBReader(stream._reader));\n 1507:   assert_default(stream._state === 'readable' || stream._state === 'closed');\n 1508:   stream._reader._readIntoRequests.push(readIntoRequest);\n 1509  }\n 1510  function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n 1511:   const reader = stream._reader;\n 1512:   assert_default(reader._readIntoRequests.length > 0);\n 1513:   const readIntoRequest = reader._readIntoRequests.shift();\n 1514    if(done) {\n 1515:     readIntoRequest._closeSteps(chunk);\n 1516    } else {\n 1517:     readIntoRequest._chunkSteps(chunk);\n 1518    }\n 1519  }\n ....\n 1522  }\n 1523  function ReadableStreamHasBYOBReader(stream) {\n 1524:   const reader = stream._reader;\n 1525:   if(reader === void 0) {\n 1526      return false;\n 1527    }\n 1528:   if(!IsReadableStreamBYOBReader(reader)) {\n 1529      return false;\n 1530    }\n ....\n 1536      assertReadableStream(stream, 'First parameter');\n 1537      if(IsReadableStreamLocked(stream)) {\n 1538:       throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n 1539      }\n 1540      if(!IsReadableByteStreamController(stream._readableStreamController)) {\n ....\n 1546    /**\n 1547     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n 1548:    * the reader's lock is released before the stream finishes closing.\n 1549     */\n 1550    get closed() {\n ....\n 1555    }\n 1556    /**\n 1557:    * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n 1558     */\n 1559    cancel(reason = void 0) {\n ....\n 1562      }\n 1563      if(this._ownerReadableStream === void 0) {\n 1564:       return promiseRejectedWith(readerLockException('cancel'));\n 1565      }\n 1566      return ReadableStreamReaderGenericCancel(this, reason);\n 1567    }\n 1568:   read(view, rawOptions = {}) {\n 1569      if(!IsReadableStreamBYOBReader(this)) {\n 1570:       return promiseRejectedWith(byobReaderBrandCheckException('read'));\n 1571      }\n 1572      if(!ArrayBuffer.isView(view)) {\n ....\n 1600      }\n 1601      if(this._ownerReadableStream === void 0) {\n 1602:       return promiseRejectedWith(readerLockException('read from'));\n 1603      }\n 1604      let resolvePromise;\n ....\n 1608        rejectPromise = reject;\n 1609      });\n 1610:     const readIntoRequest = {\n 1611        _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n 1612        _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n 1613        _errorSteps: e => rejectPromise(e),\n 1614      };\n 1615:     ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);\n 1616      return promise;\n 1617    }\n 1618    /**\n 1619:    * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n 1620:    * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n 1621:    * from now on; otherwise, the reader will appear closed.\n 1622     *\n 1623:    * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n 1624:    * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n 1625:    * do so will throw a `TypeError` and leave the reader locked to the stream.\n 1626     */\n 1627    releaseLock() {\n ....\n 1637  Object.defineProperties(ReadableStreamBYOBReader.prototype, {\n 1638    cancel: { enumerable: true },\n 1639:   read: { enumerable: true },\n 1640    releaseLock: { enumerable: true },\n 1641    closed: { enumerable: true },\n 1642  });\n 1643  setFunctionName(ReadableStreamBYOBReader.prototype.cancel, 'cancel');\n 1644: setFunctionName(ReadableStreamBYOBReader.prototype.read, 'read');\n 1645  setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, 'releaseLock');\n 1646  if(typeof Symbol.toStringTag === 'symbol') {\n ....\n 1659    return x instanceof ReadableStreamBYOBReader;\n 1660  }\n 1661: function ReadableStreamBYOBReaderRead(reader, view, min, readIntoRequest) {\n 1662:   const stream = reader._ownerReadableStream;\n 1663    assert_default(stream !== void 0);\n 1664    stream._disturbed = true;\n 1665    if(stream._state === 'errored') {\n 1666:     readIntoRequest._errorSteps(stream._storedError);\n 1667    } else {\n 1668:     ReadableByteStreamControllerPullInto(stream._readableStreamController, view, min, readIntoRequest);\n 1669    }\n 1670  }\n 1671: function ReadableStreamBYOBReaderRelease(reader) {\n 1672:   ReadableStreamReaderGenericRelease(reader);\n 1673    const e = new TypeError('Reader was released');\n 1674:   ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n 1675  }\n 1676: function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e) {\n 1677:   const readIntoRequests = reader._readIntoRequests;\n 1678:   reader._readIntoRequests = new SimpleQueue();\n 1679:   readIntoRequests.forEach(readIntoRequest => {\n 1680:     readIntoRequest._errorSteps(e);\n 1681    });\n 1682  }\n ....\n 1726    const start = original?.start;\n 1727    const type = original?.type;\n 1728:   const write = original?.write;\n 1729    return {\n 1730      abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),\n 1731      close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),\n 1732      start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n 1733:     write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n 1734      type,\n 1735    };\n ....\n 1797    }\n 1798    /**\n 1799:    * Returns whether or not the writable stream is locked to a writer.\n 1800     */\n 1801    get locked() {\n ....\n 1806    }\n 1807    /**\n 1808:    * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n 1809:    * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n 1810     * mechanism of the underlying sink.\n 1811     *\n ....\n 1819      }\n 1820      if(IsWritableStreamLocked(this)) {\n 1821:       return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n 1822      }\n 1823      return WritableStreamAbort(this, reason);\n ....\n 1825    /**\n 1826     * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n 1827:    * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n 1828     *\n 1829     * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n ....\n 1836      }\n 1837      if(IsWritableStreamLocked(this)) {\n 1838:       return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n 1839      }\n 1840      if(WritableStreamCloseQueuedOrInFlight(this)) {\n ....\n 1844    }\n 1845    /**\n 1846:    * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n 1847:    * is locked, no other writer can be acquired until this one is released.\n 1848     *\n 1849:    * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n 1850:    * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n 1851     * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n 1852     */\n ....\n 1876    return new WritableStreamDefaultWriter(stream);\n 1877  }\n 1878: function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n 1879    assert_default(IsNonNegativeNumber(highWaterMark));\n 1880    const stream = Object.create(WritableStream2.prototype);\n 1881    InitializeWritableStream(stream);\n 1882    const controller = Object.create(WritableStreamDefaultController2.prototype);\n 1883:   SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n 1884    return stream;\n 1885  }\n ....\n 1960      stream._closeRequest = closeRequest;\n 1961    });\n 1962:   const writer = stream._writer;\n 1963:   if(writer !== void 0 && stream._backpressure && state === 'writable') {\n 1964:     defaultWriterReadyPromiseResolve(writer);\n 1965    }\n 1966    WritableStreamDefaultControllerClose(stream._writableStreamController);\n ....\n 1971    assert_default(stream._state === 'writable');\n 1972    const promise = newPromise((resolve, reject) => {\n 1973:     const writeRequest = {\n 1974        _resolve: resolve,\n 1975        _reject: reject,\n 1976      };\n 1977:     stream._writeRequests.push(writeRequest);\n 1978    });\n 1979    return promise;\n ....\n 1995    stream._state = 'erroring';\n 1996    stream._storedError = reason;\n 1997:   const writer = stream._writer;\n 1998:   if(writer !== void 0) {\n 1999:     WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n 2000    }\n 2001    if(!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n ....\n 2009    stream._writableStreamController[ErrorSteps]();\n 2010    const storedError = stream._storedError;\n 2011:   stream._writeRequests.forEach(writeRequest => {\n 2012:     writeRequest._reject(storedError);\n 2013    });\n 2014    stream._writeRequests = new SimpleQueue();\n ....\n 2065    }\n 2066    stream._state = 'closed';\n 2067:   const writer = stream._writer;\n 2068:   if(writer !== void 0) {\n 2069:     defaultWriterClosedPromiseResolve(writer);\n 2070    }\n 2071    assert_default(stream._pendingAbortRequest === void 0);\n ....\n 2113      stream._closeRequest = void 0;\n 2114    }\n 2115:   const writer = stream._writer;\n 2116:   if(writer !== void 0) {\n 2117:     defaultWriterClosedPromiseReject(writer, stream._storedError);\n 2118    }\n 2119  }\n ....\n 2121    assert_default(stream._state === 'writable');\n 2122    assert_default(!WritableStreamCloseQueuedOrInFlight(stream));\n 2123:   const writer = stream._writer;\n 2124:   if(writer !== void 0 && backpressure !== stream._backpressure) {\n 2125      if(backpressure) {\n 2126:       defaultWriterReadyPromiseReset(writer);\n 2127      } else {\n 2128        assert_default(!backpressure);\n 2129:       defaultWriterReadyPromiseResolve(writer);\n 2130      }\n 2131    }\n ....\n 2137      assertWritableStream(stream, 'First parameter');\n 2138      if(IsWritableStreamLocked(stream)) {\n 2139:       throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n 2140      }\n 2141      this._ownerWritableStream = stream;\n ....\n 2164    /**\n 2165     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n 2166:    * the writerâ€™s lock is released before the stream finishes closing.\n 2167     */\n 2168    get closed() {\n ....\n 2174    /**\n 2175     * Returns the desired size to fill the streamâ€™s internal queue. It can be negative, if the queue is over-full.\n 2176:    * A producer can use this information to determine the right amount of data to write.\n 2177     *\n 2178     * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n 2179     * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n 2180:    * the writerâ€™s lock is released.\n 2181     */\n 2182    get desiredSize() {\n ....\n 2194     * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n 2195     *\n 2196:    * If the stream becomes errored or aborted, or the writerâ€™s lock is released, the returned promise will become\n 2197     * rejected.\n 2198     */\n 2199:   get ready() {\n 2200      if(!IsWritableStreamDefaultWriter(this)) {\n 2201:       return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n 2202      }\n 2203      return this._readyPromise;\n 2204    }\n 2205    /**\n 2206:    * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n 2207     */\n 2208    abort(reason = void 0) {\n ....\n 2216    }\n 2217    /**\n 2218:    * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n 2219     */\n 2220    close() {\n ....\n 2232    }\n 2233    /**\n 2234:    * Releases the writerâ€™s lock on the corresponding stream. After the lock is released, the writer is no longer active.\n 2235:    * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n 2236:    * now on; otherwise, the writer will appear closed.\n 2237     *\n 2238:    * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n 2239:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n 2240:    * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n 2241     * other producers from writing in an interleaved manner.\n 2242     */\n ....\n 2252      WritableStreamDefaultWriterRelease(this);\n 2253    }\n 2254:   write(chunk = void 0) {\n 2255      if(!IsWritableStreamDefaultWriter(this)) {\n 2256:       return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n 2257      }\n 2258      if(this._ownerWritableStream === void 0) {\n 2259:       return promiseRejectedWith(defaultWriterLockException('write to'));\n 2260      }\n 2261      return WritableStreamDefaultWriterWrite(this, chunk);\n ....\n 2266    close: { enumerable: true },\n 2267    releaseLock: { enumerable: true },\n 2268:   write: { enumerable: true },\n 2269    closed: { enumerable: true },\n 2270    desiredSize: { enumerable: true },\n 2271:   ready: { enumerable: true },\n 2272  });\n 2273  setFunctionName(WritableStreamDefaultWriter.prototype.abort, 'abort');\n 2274  setFunctionName(WritableStreamDefaultWriter.prototype.close, 'close');\n 2275  setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, 'releaseLock');\n 2276: setFunctionName(WritableStreamDefaultWriter.prototype.write, 'write');\n 2277  if(typeof Symbol.toStringTag === 'symbol') {\n 2278    Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {\n ....\n 2290    return x instanceof WritableStreamDefaultWriter;\n 2291  }\n 2292: function WritableStreamDefaultWriterAbort(writer, reason) {\n 2293:   const stream = writer._ownerWritableStream;\n 2294    assert_default(stream !== void 0);\n 2295    return WritableStreamAbort(stream, reason);\n 2296  }\n 2297: function WritableStreamDefaultWriterClose(writer) {\n 2298:   const stream = writer._ownerWritableStream;\n 2299    assert_default(stream !== void 0);\n 2300    return WritableStreamClose(stream);\n 2301  }\n 2302: function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n 2303:   const stream = writer._ownerWritableStream;\n 2304    assert_default(stream !== void 0);\n 2305    const state = stream._state;\n ....\n 2311    }\n 2312    assert_default(state === 'writable' || state === 'erroring');\n 2313:   return WritableStreamDefaultWriterClose(writer);\n 2314  }\n 2315: function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n 2316:   if(writer._closedPromiseState === 'pending') {\n 2317:     defaultWriterClosedPromiseReject(writer, error);\n 2318    } else {\n 2319:     defaultWriterClosedPromiseResetToRejected(writer, error);\n 2320    }\n 2321  }\n 2322: function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n 2323:   if(writer._readyPromiseState === 'pending') {\n 2324:     defaultWriterReadyPromiseReject(writer, error);\n 2325    } else {\n 2326:     defaultWriterReadyPromiseResetToRejected(writer, error);\n 2327    }\n 2328  }\n 2329: function WritableStreamDefaultWriterGetDesiredSize(writer) {\n 2330:   const stream = writer._ownerWritableStream;\n 2331    const state = stream._state;\n 2332    if(state === 'errored' || state === 'erroring') {\n ....\n 2338    return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n 2339  }\n 2340: function WritableStreamDefaultWriterRelease(writer) {\n 2341:   const stream = writer._ownerWritableStream;\n 2342    assert_default(stream !== void 0);\n 2343:   assert_default(stream._writer === writer);\n 2344    const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n 2345:   WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n 2346:   WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n 2347    stream._writer = void 0;\n 2348:   writer._ownerWritableStream = void 0;\n 2349  }\n 2350: function WritableStreamDefaultWriterWrite(writer, chunk) {\n 2351:   const stream = writer._ownerWritableStream;\n 2352    assert_default(stream !== void 0);\n 2353    const controller = stream._writableStreamController;\n 2354    const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n 2355:   if(stream !== writer._ownerWritableStream) {\n 2356:     return promiseRejectedWith(defaultWriterLockException('write to'));\n 2357    }\n 2358    const state = stream._state;\n ....\n 2390    }\n 2391    /**\n 2392:    * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n 2393     */\n 2394    get signal() {\n ....\n 2449    return x instanceof WritableStreamDefaultController2;\n 2450  }\n 2451: function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n 2452    assert_default(IsWritableStream(stream));\n 2453    assert_default(stream._writableStreamController === void 0);\n ....\n 2462    controller._strategySizeAlgorithm = sizeAlgorithm;\n 2463    controller._strategyHWM = highWaterMark;\n 2464:   controller._writeAlgorithm = writeAlgorithm;\n 2465    controller._closeAlgorithm = closeAlgorithm;\n 2466    controller._abortAlgorithm = abortAlgorithm;\n ....\n 2488    const controller = Object.create(WritableStreamDefaultController2.prototype);\n 2489    let startAlgorithm;\n 2490:   let writeAlgorithm;\n 2491    let closeAlgorithm;\n 2492    let abortAlgorithm;\n ....\n 2496      startAlgorithm = () => void 0;\n 2497    }\n 2498:   if(underlyingSink.write !== void 0) {\n 2499:     writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n 2500    } else {\n 2501:     writeAlgorithm = () => promiseResolvedWith(void 0);\n 2502    }\n 2503    if(underlyingSink.close !== void 0) {\n ....\n 2511      abortAlgorithm = () => promiseResolvedWith(void 0);\n 2512    }\n 2513:   SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n 2514  }\n 2515  function WritableStreamDefaultControllerClearAlgorithms(controller) {\n ....\n 2647  }\n 2648  function defaultWriterLockException(name) {\n 2649:   return new TypeError('Cannot ' + name + ' a stream using a released writer');\n 2650  }\n 2651: function defaultWriterClosedPromiseInitialize(writer) {\n 2652:   writer._closedPromise = newPromise((resolve, reject) => {\n 2653:     writer._closedPromise_resolve = resolve;\n 2654:     writer._closedPromise_reject = reject;\n 2655:     writer._closedPromiseState = 'pending';\n 2656    });\n 2657  }\n 2658: function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n 2659:   defaultWriterClosedPromiseInitialize(writer);\n 2660:   defaultWriterClosedPromiseReject(writer, reason);\n 2661  }\n 2662: function defaultWriterClosedPromiseInitializeAsResolved(writer) {\n 2663:   defaultWriterClosedPromiseInitialize(writer);\n 2664:   defaultWriterClosedPromiseResolve(writer);\n 2665  }\n 2666: function defaultWriterClosedPromiseReject(writer, reason) {\n 2667:   if(writer._closedPromise_reject === void 0) {\n 2668      return;\n 2669    }\n 2670:   assert_default(writer._closedPromiseState === 'pending');\n 2671:   setPromiseIsHandledToTrue(writer._closedPromise);\n 2672:   writer._closedPromise_reject(reason);\n 2673:   writer._closedPromise_resolve = void 0;\n 2674:   writer._closedPromise_reject = void 0;\n 2675:   writer._closedPromiseState = 'rejected';\n 2676  }\n 2677: function defaultWriterClosedPromiseResetToRejected(writer, reason) {\n 2678:   assert_default(writer._closedPromise_resolve === void 0);\n 2679:   assert_default(writer._closedPromise_reject === void 0);\n 2680:   assert_default(writer._closedPromiseState !== 'pending');\n 2681:   defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n 2682  }\n 2683: function defaultWriterClosedPromiseResolve(writer) {\n 2684:   if(writer._closedPromise_resolve === void 0) {\n 2685      return;\n 2686    }\n 2687:   assert_default(writer._closedPromiseState === 'pending');\n 2688:   writer._closedPromise_resolve(void 0);\n 2689:   writer._closedPromise_resolve = void 0;\n 2690:   writer._closedPromise_reject = void 0;\n 2691:   writer._closedPromiseState = 'resolved';\n 2692  }\n 2693: function defaultWriterReadyPromiseInitialize(writer) {\n 2694:   writer._readyPromise = newPromise((resolve, reject) => {\n 2695:     writer._readyPromise_resolve = resolve;\n 2696:     writer._readyPromise_reject = reject;\n 2697    });\n 2698:   writer._readyPromiseState = 'pending';\n 2699  }\n 2700: function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n 2701:   defaultWriterReadyPromiseInitialize(writer);\n 2702:   defaultWriterReadyPromiseReject(writer, reason);\n 2703  }\n 2704: function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n 2705:   defaultWriterReadyPromiseInitialize(writer);\n 2706:   defaultWriterReadyPromiseResolve(writer);\n 2707  }\n 2708: function defaultWriterReadyPromiseReject(writer, reason) {\n 2709:   if(writer._readyPromise_reject === void 0) {\n 2710      return;\n 2711    }\n 2712:   setPromiseIsHandledToTrue(writer._readyPromise);\n 2713:   writer._readyPromise_reject(reason);\n 2714:   writer._readyPromise_resolve = void 0;\n 2715:   writer._readyPromise_reject = void 0;\n 2716:   writer._readyPromiseState = 'rejected';\n 2717  }\n 2718: function defaultWriterReadyPromiseReset(writer) {\n 2719:   assert_default(writer._readyPromise_resolve === void 0);\n 2720:   assert_default(writer._readyPromise_reject === void 0);\n 2721:   defaultWriterReadyPromiseInitialize(writer);\n 2722  }\n 2723: function defaultWriterReadyPromiseResetToRejected(writer, reason) {\n 2724:   assert_default(writer._readyPromise_resolve === void 0);\n 2725:   assert_default(writer._readyPromise_reject === void 0);\n 2726:   defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n 2727  }\n 2728: function defaultWriterReadyPromiseResolve(writer) {\n 2729:   if(writer._readyPromise_resolve === void 0) {\n 2730      return;\n 2731    }\n 2732:   writer._readyPromise_resolve(void 0);\n 2733:   writer._readyPromise_resolve = void 0;\n 2734:   writer._readyPromise_reject = void 0;\n 2735:   writer._readyPromiseState = 'fulfilled';\n 2736  }\n 2737  \n ....\n 2783  var DOMException = getFromGlobal() || createPolyfill();\n 2784  \n 2785: // src/lib/readable-stream/pipe.ts\n 2786  function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n 2787    assert_default(IsReadableStream(source));\n ....\n 2793    assert_default(!IsReadableStreamLocked(source));\n 2794    assert_default(!IsWritableStreamLocked(dest));\n 2795:   const reader = AcquireReadableStreamDefaultReader(source);\n 2796:   const writer = AcquireWritableStreamDefaultWriter(dest);\n 2797    source._disturbed = true;\n 2798    let shuttingDown = false;\n ....\n 2814          if(!preventCancel) {\n 2815            actions.push(() => {\n 2816:             if(source._state === 'readable') {\n 2817                return ReadableStreamCancel(source, error);\n 2818              }\n ....\n 2844          return promiseResolvedWith(true);\n 2845        }\n 2846:       return PerformPromiseThen(writer._readyPromise, () => {\n 2847          return newPromise((resolveRead, rejectRead) => {\n 2848:           ReadableStreamDefaultReaderRead(reader, {\n 2849              _chunkSteps: chunk => {\n 2850:               currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop);\n 2851                resolveRead(false);\n 2852              },\n ....\n 2857        });\n 2858      }\n 2859:     isOrBecomesErrored(source, reader._closedPromise, storedError => {\n 2860        if(!preventAbort) {\n 2861          shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n ....\n 2865        return null;\n 2866      });\n 2867:     isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n 2868        if(!preventCancel) {\n 2869          shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n ....\n 2873        return null;\n 2874      });\n 2875:     isOrBecomesClosed(source, reader._closedPromise, () => {\n 2876        if(!preventClose) {\n 2877:         shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n 2878        } else {\n 2879          shutdown();\n ....\n 2939      }\n 2940      function finalize(isError, error) {\n 2941:       WritableStreamDefaultWriterRelease(writer);\n 2942:       ReadableStreamReaderGenericRelease(reader);\n 2943        if(signal !== void 0) {\n 2944          signal.removeEventListener('abort', abortAlgorithm);\n ....\n 2954  }\n 2955  \n 2956: // src/lib/readable-stream/default-controller.ts\n 2957  var ReadableStreamDefaultController = class {\n 2958    constructor() {\n ....\n 2970    }\n 2971    /**\n 2972:    * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n 2973:    * the stream, but once those are read, the stream will become closed.\n 2974     */\n 2975    close() {\n ....\n 2992    }\n 2993    /**\n 2994:    * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n 2995     */\n 2996    error(e = void 0) {\n ....\n 3008    }\n 3009    /** @internal */\n 3010:   [PullSteps](readRequest) {\n 3011      const stream = this._controlledReadableStream;\n 3012      if(this._queue.length > 0) {\n ....\n 3018          ReadableStreamDefaultControllerCallPullIfNeeded(this);\n 3019        }\n 3020:       readRequest._chunkSteps(chunk);\n 3021      } else {\n 3022:       ReadableStreamAddReadRequest(stream, readRequest);\n 3023        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n 3024      }\n ....\n 3139  function ReadableStreamDefaultControllerError(controller, e) {\n 3140    const stream = controller._controlledReadableStream;\n 3141:   if(stream._state !== 'readable') {\n 3142      return;\n 3143    }\n ....\n 3164  function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n 3165    const state = controller._controlledReadableStream._state;\n 3166:   if(!controller._closeRequested && state === 'readable') {\n 3167      return true;\n 3168    }\n ....\n 3226  }\n 3227  \n 3228: // src/lib/readable-stream/tee.ts\n 3229  function ReadableStreamTee(stream, cloneForBranch2) {\n 3230    assert_default(IsReadableStream(stream));\n ....\n 3238    assert_default(IsReadableStream(stream));\n 3239    assert_default(typeof cloneForBranch2 === 'boolean');\n 3240:   const reader = AcquireReadableStreamDefaultReader(stream);\n 3241:   let reading = false;\n 3242:   let readAgain = false;\n 3243    let canceled1 = false;\n 3244    let canceled2 = false;\n ....\n 3252    });\n 3253    function pullAlgorithm() {\n 3254:     if(reading) {\n 3255:       readAgain = true;\n 3256        return promiseResolvedWith(void 0);\n 3257      }\n 3258:     reading = true;\n 3259:     const readRequest = {\n 3260        _chunkSteps: chunk => {\n 3261          _queueMicrotask(() => {\n 3262:           readAgain = false;\n 3263            const chunk1 = chunk;\n 3264            const chunk2 = chunk;\n ....\n 3269              ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n 3270            }\n 3271:           reading = false;\n 3272:           if(readAgain) {\n 3273              pullAlgorithm();\n 3274            }\n ....\n 3276        },\n 3277        _closeSteps: () => {\n 3278:         reading = false;\n 3279          if(!canceled1) {\n 3280            ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n ....\n 3288        },\n 3289        _errorSteps: () => {\n 3290:         reading = false;\n 3291        },\n 3292      };\n 3293:     ReadableStreamDefaultReaderRead(reader, readRequest);\n 3294      return promiseResolvedWith(void 0);\n 3295    }\n ....\n 3317    branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n 3318    branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n 3319:   uponRejection(reader._closedPromise, r => {\n 3320      ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n 3321      ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n ....\n 3330    assert_default(IsReadableStream(stream));\n 3331    assert_default(IsReadableByteStreamController(stream._readableStreamController));\n 3332:   let reader = AcquireReadableStreamDefaultReader(stream);\n 3333:   let reading = false;\n 3334:   let readAgainForBranch1 = false;\n 3335:   let readAgainForBranch2 = false;\n 3336    let canceled1 = false;\n 3337    let canceled2 = false;\n ....\n 3346    function forwardReaderError(thisReader) {\n 3347      uponRejection(thisReader._closedPromise, r => {\n 3348:       if(thisReader !== reader) {\n 3349          return null;\n 3350        }\n ....\n 3358    }\n 3359    function pullWithDefaultReader() {\n 3360:     if(IsReadableStreamBYOBReader(reader)) {\n 3361:       assert_default(reader._readIntoRequests.length === 0);\n 3362:       ReadableStreamReaderGenericRelease(reader);\n 3363:       reader = AcquireReadableStreamDefaultReader(stream);\n 3364:       forwardReaderError(reader);\n 3365      }\n 3366:     const readRequest = {\n 3367        _chunkSteps: chunk => {\n 3368          _queueMicrotask(() => {\n 3369:           readAgainForBranch1 = false;\n 3370:           readAgainForBranch2 = false;\n 3371            const chunk1 = chunk;\n 3372            let chunk2 = chunk;\n ....\n 3387              ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n 3388            }\n 3389:           reading = false;\n 3390:           if(readAgainForBranch1) {\n 3391              pull1Algorithm();\n 3392:           } else if(readAgainForBranch2) {\n 3393              pull2Algorithm();\n 3394            }\n ....\n 3396        },\n 3397        _closeSteps: () => {\n 3398:         reading = false;\n 3399          if(!canceled1) {\n 3400            ReadableByteStreamControllerClose(branch1._readableStreamController);\n ....\n 3414        },\n 3415        _errorSteps: () => {\n 3416:         reading = false;\n 3417        },\n 3418      };\n 3419:     ReadableStreamDefaultReaderRead(reader, readRequest);\n 3420    }\n 3421    function pullWithBYOBReader(view, forBranch2) {\n 3422:     if(IsReadableStreamDefaultReader(reader)) {\n 3423:       assert_default(reader._readRequests.length === 0);\n 3424:       ReadableStreamReaderGenericRelease(reader);\n 3425:       reader = AcquireReadableStreamBYOBReader(stream);\n 3426:       forwardReaderError(reader);\n 3427      }\n 3428      const byobBranch = forBranch2 ? branch2 : branch1;\n 3429      const otherBranch = forBranch2 ? branch1 : branch2;\n 3430:     const readIntoRequest = {\n 3431        _chunkSteps: chunk => {\n 3432          _queueMicrotask(() => {\n 3433:           readAgainForBranch1 = false;\n 3434:           readAgainForBranch2 = false;\n 3435            const byobCanceled = forBranch2 ? canceled2 : canceled1;\n 3436            const otherCanceled = forBranch2 ? canceled1 : canceled2;\n ....\n 3452              ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n 3453            }\n 3454:           reading = false;\n 3455:           if(readAgainForBranch1) {\n 3456              pull1Algorithm();\n 3457:           } else if(readAgainForBranch2) {\n 3458              pull2Algorithm();\n 3459            }\n ....\n 3461        },\n 3462        _closeSteps: chunk => {\n 3463:         reading = false;\n 3464          const byobCanceled = forBranch2 ? canceled2 : canceled1;\n 3465          const otherCanceled = forBranch2 ? canceled1 : canceled2;\n ....\n 3484        },\n 3485        _errorSteps: () => {\n 3486:         reading = false;\n 3487        },\n 3488      };\n 3489:     ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);\n 3490    }\n 3491    function pull1Algorithm() {\n 3492:     if(reading) {\n 3493:       readAgainForBranch1 = true;\n 3494        return promiseResolvedWith(void 0);\n 3495      }\n 3496:     reading = true;\n 3497      const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n 3498      if(byobRequest === null) {\n ....\n 3504    }\n 3505    function pull2Algorithm() {\n 3506:     if(reading) {\n 3507:       readAgainForBranch2 = true;\n 3508        return promiseResolvedWith(void 0);\n 3509      }\n 3510:     reading = true;\n 3511      const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n 3512      if(byobRequest === null) {\n ....\n 3542    branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n 3543    branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n 3544:   forwardReaderError(reader);\n 3545    return [branch1, branch2];\n 3546  }\n 3547  \n 3548: // src/lib/readable-stream/readable-stream-like.ts\n 3549  function isReadableStreamLike(stream) {\n 3550    return typeIsObject(stream) && typeof stream.getReader !== 'undefined';\n 3551  }\n 3552  \n 3553: // src/lib/readable-stream/from.ts\n 3554  function ReadableStreamFrom(source) {\n 3555    if(isReadableStreamLike(source)) {\n ....\n 3605    return stream;\n 3606  }\n 3607: function ReadableStreamFromDefaultReader(reader) {\n 3608    let stream;\n 3609    const startAlgorithm = noop;\n 3610    function pullAlgorithm() {\n 3611:     let readPromise;\n 3612      try {\n 3613:       readPromise = reader.read();\n 3614      } catch(e) {\n 3615        return promiseRejectedWith(e);\n 3616      }\n 3617:     return transformPromiseWith(readPromise, readResult => {\n 3618:       if(!typeIsObject(readResult)) {\n 3619:         throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\n 3620        }\n 3621:       if(readResult.done) {\n 3622          ReadableStreamDefaultControllerClose(stream._readableStreamController);\n 3623        } else {\n 3624:         const value = readResult.value;\n 3625          ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\n 3626        }\n ....\n 3629    function cancelAlgorithm(reason) {\n 3630      try {\n 3631:       return promiseResolvedWith(reader.cancel(reason));\n 3632      } catch(e) {\n 3633        return promiseRejectedWith(e);\n ....\n 3705  }\n 3706  \n 3707: // src/lib/validators/readable-writable-pair.ts\n 3708  function convertReadableWritablePair(pair, context) {\n 3709    assertDictionary(pair, context);\n 3710:   const readable = pair?.readable;\n 3711:   assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n 3712:   assertReadableStream(readable, `${context} has member 'readable' that`);\n 3713    const writable = pair?.writable;\n 3714    assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n 3715    assertWritableStream(writable, `${context} has member 'writable' that`);\n 3716:   return { readable, writable };\n 3717  }\n 3718  \n 3719: // src/lib/readable-stream.ts\n 3720  var ReadableStream8 = class {\n 3721    constructor(rawUnderlyingSource = {}, rawStrategy = {}) {\n ....\n 3742    }\n 3743    /**\n 3744:    * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n 3745     */\n 3746    get locked() {\n ....\n 3761      }\n 3762      if(IsReadableStreamLocked(this)) {\n 3763:       return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n 3764      }\n 3765      return ReadableStreamCancel(this, reason);\n ....\n 3791      const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n 3792      setPromiseIsHandledToTrue(promise);\n 3793:     return transform.readable;\n 3794    }\n 3795    pipeTo(destination, rawOptions = {}) {\n ....\n 3818    }\n 3819    /**\n 3820:    * Tees this readable stream, returning a two-element array containing the two resulting branches as\n 3821     * new {@link ReadableStream} instances.\n 3822     *\n 3823:    * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n 3824     * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n 3825     * propagated to the stream's underlying source.\n ....\n 3848     * Creates a new ReadableStream wrapping the provided iterable or async iterable.\n 3849     *\n 3850:    * This can be used to adapt various kinds of objects into a readable stream,\n 3851:    * such as an array, an async generator, or a Node.js readable stream.\n 3852     */\n 3853    static from(asyncIterable) {\n ....\n 3901  }\n 3902  function InitializeReadableStream(stream) {\n 3903:   stream._state = 'readable';\n 3904    stream._reader = void 0;\n 3905    stream._storedError = void 0;\n ....\n 3931    }\n 3932    ReadableStreamClose(stream);\n 3933:   const reader = stream._reader;\n 3934:   if(reader !== void 0 && IsReadableStreamBYOBReader(reader)) {\n 3935:     const readIntoRequests = reader._readIntoRequests;\n 3936:     reader._readIntoRequests = new SimpleQueue();\n 3937:     readIntoRequests.forEach(readIntoRequest => {\n 3938:       readIntoRequest._closeSteps(void 0);\n 3939      });\n 3940    }\n ....\n 3943  }\n 3944  function ReadableStreamClose(stream) {\n 3945:   assert_default(stream._state === 'readable');\n 3946    stream._state = 'closed';\n 3947:   const reader = stream._reader;\n 3948:   if(reader === void 0) {\n 3949      return;\n 3950    }\n 3951:   defaultReaderClosedPromiseResolve(reader);\n 3952:   if(IsReadableStreamDefaultReader(reader)) {\n 3953:     const readRequests = reader._readRequests;\n 3954:     reader._readRequests = new SimpleQueue();\n 3955:     readRequests.forEach(readRequest => {\n 3956:       readRequest._closeSteps();\n 3957      });\n 3958    }\n ....\n 3960  function ReadableStreamError(stream, e) {\n 3961    assert_default(IsReadableStream(stream));\n 3962:   assert_default(stream._state === 'readable');\n 3963    stream._state = 'errored';\n 3964    stream._storedError = e;\n 3965:   const reader = stream._reader;\n 3966:   if(reader === void 0) {\n 3967      return;\n 3968    }\n 3969:   defaultReaderClosedPromiseReject(reader, e);\n 3970:   if(IsReadableStreamDefaultReader(reader)) {\n 3971:     ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n 3972    } else {\n 3973:     assert_default(IsReadableStreamBYOBReader(reader));\n 3974:     ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n 3975    }\n 3976  }\n ....\n 3979  }\n 3980  \n 3981: // src/lib/readable-stream/async-iterator.ts\n 3982  var ReadableStreamAsyncIteratorImpl = class {\n 3983:   constructor(reader, preventCancel) {\n 3984      this._ongoingPromise = void 0;\n 3985      this._isFinished = false;\n 3986:     this._reader = reader;\n 3987      this._preventCancel = preventCancel;\n 3988    }\n ....\n 4001        return Promise.resolve({ value: void 0, done: true });\n 4002      }\n 4003:     const reader = this._reader;\n 4004:     assert_default(reader._ownerReadableStream !== void 0);\n 4005      let resolvePromise;\n 4006      let rejectPromise;\n ....\n 4009        rejectPromise = reject;\n 4010      });\n 4011:     const readRequest = {\n 4012        _chunkSteps: chunk => {\n 4013          this._ongoingPromise = void 0;\n ....\n 4017          this._ongoingPromise = void 0;\n 4018          this._isFinished = true;\n 4019:         ReadableStreamReaderGenericRelease(reader);\n 4020          resolvePromise({ value: void 0, done: true });\n 4021        },\n ....\n 4023          this._ongoingPromise = void 0;\n 4024          this._isFinished = true;\n 4025:         ReadableStreamReaderGenericRelease(reader);\n 4026          rejectPromise(reason);\n 4027        },\n 4028      };\n 4029:     ReadableStreamDefaultReaderRead(reader, readRequest);\n 4030      return promise;\n 4031    }\n ....\n 4035      }\n 4036      this._isFinished = true;\n 4037:     const reader = this._reader;\n 4038:     assert_default(reader._ownerReadableStream !== void 0);\n 4039:     assert_default(reader._readRequests.length === 0);\n 4040      if(!this._preventCancel) {\n 4041:       const result = ReadableStreamReaderGenericCancel(reader, value);\n 4042:       ReadableStreamReaderGenericRelease(reader);\n 4043        return transformPromiseWith(result, () => ({ value, done: true }));\n 4044      }\n 4045:     ReadableStreamReaderGenericRelease(reader);\n 4046      return promiseResolvedWith({ value, done: true });\n 4047    }\n ....\n 4070  });\n 4071  function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n 4072:   const reader = AcquireReadableStreamDefaultReader(stream);\n 4073:   const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n 4074    const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n 4075    iterator._asyncIteratorImpl = impl;\n ....\n 4093  }\n 4094  \n 4095: // src/lib/readable-stream.js\n 4096  var ReadableStream10 = class {\n 4097    constructor(rawUnderlyingSource = {}, rawStrategy = {}) {\n ....\n 4118    }\n 4119    /**\n 4120:    * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n 4121     */\n 4122    get locked() {\n ....\n 4137      }\n 4138      if(IsReadableStreamLocked2(this)) {\n 4139:       return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n 4140      }\n 4141      return ReadableStreamCancel2(this, reason);\n ....\n 4167      const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n 4168      setPromiseIsHandledToTrue(promise);\n 4169:     return transform.readable;\n 4170    }\n 4171    pipeTo(destination, rawOptions = {}) {\n ....\n 4194    }\n 4195    /**\n 4196:    * Tees this readable stream, returning a two-element array containing the two resulting branches as\n 4197     * new {@link ReadableStream} instances.\n 4198     *\n 4199:    * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n 4200     * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n 4201     * propagated to the stream's underlying source.\n ....\n 4224     * Creates a new ReadableStream wrapping the provided iterable or async iterable.\n 4225     *\n 4226:    * This can be used to adapt various kinds of objects into a readable stream,\n 4227:    * such as an array, an async generator, or a Node.js readable stream.\n 4228     */\n 4229    static from(asyncIterable) {\n ....\n 4262  });\n 4263  function InitializeReadableStream2(stream) {\n 4264:   stream._state = 'readable';\n 4265    stream._reader = void 0;\n 4266    stream._storedError = void 0;\n ....\n 4292    }\n 4293    ReadableStreamClose2(stream);\n 4294:   const reader = stream._reader;\n 4295:   if(reader !== void 0 && IsReadableStreamBYOBReader(reader)) {\n 4296:     const readIntoRequests = reader._readIntoRequests;\n 4297:     reader._readIntoRequests = new SimpleQueue();\n 4298:     readIntoRequests.forEach(readIntoRequest => {\n 4299:       readIntoRequest._closeSteps(void 0);\n 4300      });\n 4301    }\n ....\n 4304  }\n 4305  function ReadableStreamClose2(stream) {\n 4306:   assert_default(stream._state === 'readable');\n 4307    stream._state = 'closed';\n 4308:   const reader = stream._reader;\n 4309:   if(reader === void 0) {\n 4310      return;\n 4311    }\n 4312:   defaultReaderClosedPromiseResolve(reader);\n 4313:   if(IsReadableStreamDefaultReader(reader)) {\n 4314:     const readRequests = reader._readRequests;\n 4315:     reader._readRequests = new SimpleQueue();\n 4316:     readRequests.forEach(readRequest => {\n 4317:       readRequest._closeSteps();\n 4318      });\n 4319    }\n ....\n 4330      }\n 4331      const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n 4332:     const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n 4333      const transformer = convertTransformer(rawTransformer, 'First parameter');\n 4334:     if(transformer.readableType !== void 0) {\n 4335:       throw new RangeError('Invalid readableType specified');\n 4336      }\n 4337      if(transformer.writableType !== void 0) {\n 4338        throw new RangeError('Invalid writableType specified');\n 4339      }\n 4340:     const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n 4341:     const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n 4342      const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n 4343      const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n ....\n 4346        startPromise_resolve = resolve;\n 4347      });\n 4348:     InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n 4349      SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n 4350      if(transformer.start !== void 0) {\n ....\n 4355    }\n 4356    /**\n 4357:    * The readable side of the transform stream.\n 4358     */\n 4359:   get readable() {\n 4360      if(!IsTransformStream(this)) {\n 4361:       throw streamBrandCheckException4('readable');\n 4362      }\n 4363      return this._readable;\n ....\n 4374  };\n 4375  Object.defineProperties(TransformStream.prototype, {\n 4376:   readable: { enumerable: true },\n 4377    writable: { enumerable: true },\n 4378  });\n ....\n 4383    });\n 4384  }\n 4385: function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n 4386    function startAlgorithm() {\n 4387      return startPromise;\n 4388    }\n 4389:   function writeAlgorithm(chunk) {\n 4390      return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n 4391    }\n ....\n 4396      return TransformStreamDefaultSinkCloseAlgorithm(stream);\n 4397    }\n 4398:   stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n 4399    function pullAlgorithm() {\n 4400      return TransformStreamDefaultSourcePullAlgorithm(stream);\n ....\n 4403      return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);\n 4404    }\n 4405:   stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n 4406    stream._backpressure = void 0;\n 4407    stream._backpressureChangePromise = void 0;\n ....\n 4448    }\n 4449    /**\n 4450:    * Returns the desired size to fill the readable sideâ€™s internal queue. It can be negative, if the queue is over-full.\n 4451     */\n 4452    get desiredSize() {\n ....\n 4454        throw defaultControllerBrandCheckException3('desiredSize');\n 4455      }\n 4456:     const readableController = this._controlledTransformStream._readable._readableStreamController;\n 4457:     return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n 4458    }\n 4459    enqueue(chunk = void 0) {\n ....\n 4464    }\n 4465    /**\n 4466:    * Errors both the readable side and the writable side of the controlled transform stream, making all future\n 4467     * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n 4468     */\n ....\n 4474    }\n 4475    /**\n 4476:    * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n 4477     * transformer only needs to consume a portion of the chunks written to the writable side.\n 4478     */\n ....\n 4556  function TransformStreamDefaultControllerEnqueue(controller, chunk) {\n 4557    const stream = controller._controlledTransformStream;\n 4558:   const readableController = stream._readable._readableStreamController;\n 4559:   if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n 4560      throw new TypeError('Readable side is not in a state that permits enqueue');\n 4561    }\n 4562    try {\n 4563:     ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n 4564    } catch(e) {\n 4565      TransformStreamErrorWritableAndUnblockWrite(stream, e);\n 4566      throw stream._readable._storedError;\n 4567    }\n 4568:   const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n 4569    if(backpressure !== stream._backpressure) {\n 4570      assert_default(backpressure);\n ....\n 4584  function TransformStreamDefaultControllerTerminate(controller) {\n 4585    const stream = controller._controlledTransformStream;\n 4586:   const readableController = stream._readable._readableStreamController;\n 4587:   ReadableStreamDefaultControllerClose(readableController);\n 4588    const error = new TypeError('TransformStream terminated');\n 4589    TransformStreamErrorWritableAndUnblockWrite(stream, error);\n ....\n 4612      return controller._finishPromise;\n 4613    }\n 4614:   const readable = stream._readable;\n 4615    controller._finishPromise = newPromise((resolve, reject) => {\n 4616      controller._finishPromise_resolve = resolve;\n ....\n 4622      cancelPromise,\n 4623      () => {\n 4624:       if(readable._state === 'errored') {\n 4625:         defaultControllerFinishPromiseReject(controller, readable._storedError);\n 4626        } else {\n 4627:         ReadableStreamDefaultControllerError(readable._readableStreamController, reason);\n 4628          defaultControllerFinishPromiseResolve(controller);\n 4629        }\n ....\n 4631      },\n 4632      r => {\n 4633:       ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n 4634        defaultControllerFinishPromiseReject(controller, r);\n 4635        return null;\n ....\n 4643      return controller._finishPromise;\n 4644    }\n 4645:   const readable = stream._readable;\n 4646    controller._finishPromise = newPromise((resolve, reject) => {\n 4647      controller._finishPromise_resolve = resolve;\n ....\n 4653      flushPromise,\n 4654      () => {\n 4655:       if(readable._state === 'errored') {\n 4656:         defaultControllerFinishPromiseReject(controller, readable._storedError);\n 4657        } else {\n 4658:         ReadableStreamDefaultControllerClose(readable._readableStreamController);\n 4659          defaultControllerFinishPromiseResolve(controller);\n 4660        }\n ....\n 4662      },\n 4663      r => {\n 4664:       ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n 4665        defaultControllerFinishPromiseReject(controller, r);\n 4666        return null;\n ....\n 4737    const cancel = original?.cancel;\n 4738    const flush = original?.flush;\n 4739:   const readableType = original?.readableType;\n 4740    const start = original?.start;\n 4741    const transform = original?.transform;\n ....\n 4744      cancel: cancel === void 0 ? void 0 : convertTransformerCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n 4745      flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\n 4746:     readableType,\n 4747      start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),\n 4748      transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),\n ....\n 4774      }\n 4775      const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n 4776:     const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n 4777      const transformer = convertTransformer(rawTransformer, 'First parameter');\n 4778:     if(transformer.readableType !== void 0) {\n 4779:       throw new RangeError('Invalid readableType specified');\n 4780      }\n 4781      if(transformer.writableType !== void 0) {\n 4782        throw new RangeError('Invalid writableType specified');\n 4783      }\n 4784:     const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n 4785:     const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n 4786      const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n 4787      const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n ....\n 4790        startPromise_resolve = resolve;\n 4791      });\n 4792:     InitializeTransformStream2(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n 4793      SetUpTransformStreamDefaultControllerFromTransformer2(this, transformer);\n 4794      if(transformer.start !== void 0) {\n ....\n 4799    }\n 4800    /**\n 4801:    * The readable side of the transform stream.\n 4802     */\n 4803:   get readable() {\n 4804      if(!IsTransformStream2(this)) {\n 4805:       throw streamBrandCheckException5('readable');\n 4806      }\n 4807      return this._readable;\n ....\n 4818  };\n 4819  Object.defineProperties(TransformStream2.prototype, {\n 4820:   readable: { enumerable: true },\n 4821    writable: { enumerable: true },\n 4822  });\n ....\n 4827    });\n 4828  }\n 4829: function InitializeTransformStream2(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n 4830    function startAlgorithm() {\n 4831      return startPromise;\n 4832    }\n 4833:   function writeAlgorithm(chunk) {\n 4834      return TransformStreamDefaultSinkWriteAlgorithm2(stream, chunk);\n 4835    }\n ....\n 4840      return TransformStreamDefaultSinkCloseAlgorithm2(stream);\n 4841    }\n 4842:   stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n 4843    function pullAlgorithm() {\n 4844      return TransformStreamDefaultSourcePullAlgorithm2(stream);\n ....\n 4847      return TransformStreamDefaultSourceCancelAlgorithm2(stream, reason);\n 4848    }\n 4849:   stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n 4850    stream._backpressure = void 0;\n 4851    stream._backpressureChangePromise = void 0;\n ....\n 4892    }\n 4893    /**\n 4894:    * Returns the desired size to fill the readable sideâ€™s internal queue. It can be negative, if the queue is over-full.\n 4895     */\n 4896    get desiredSize() {\n ....\n 4898        throw defaultControllerBrandCheckException4('desiredSize');\n 4899      }\n 4900:     const readableController = this._controlledTransformStream._readable._readableStreamController;\n 4901:     return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n 4902    }\n 4903    enqueue(chunk = void 0) {\n ....\n 4908    }\n 4909    /**\n 4910:    * Errors both the readable side and the writable side of the controlled transform stream, making all future\n 4911     * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n 4912     */\n ....\n 4918    }\n 4919    /**\n 4920:    * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n 4921     * transformer only needs to consume a portion of the chunks written to the writable side.\n 4922     */\n ....\n 5000  function TransformStreamDefaultControllerEnqueue2(controller, chunk) {\n 5001    const stream = controller._controlledTransformStream;\n 5002:   const readableController = stream._readable._readableStreamController;\n 5003:   if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n 5004      throw new TypeError('Readable side is not in a state that permits enqueue');\n 5005    }\n 5006    try {\n 5007:     ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n 5008    } catch(e) {\n 5009      TransformStreamErrorWritableAndUnblockWrite2(stream, e);\n 5010      throw stream._readable._storedError;\n 5011    }\n 5012:   const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n 5013    if(backpressure !== stream._backpressure) {\n 5014      assert_default(backpressure);\n ....\n 5028  function TransformStreamDefaultControllerTerminate2(controller) {\n 5029    const stream = controller._controlledTransformStream;\n 5030:   const readableController = stream._readable._readableStreamController;\n 5031:   ReadableStreamDefaultControllerClose(readableController);\n 5032    const error = new TypeError('TransformStream terminated');\n 5033    TransformStreamErrorWritableAndUnblockWrite2(stream, error);\n ....\n 5056      return controller._finishPromise;\n 5057    }\n 5058:   const readable = stream._readable;\n 5059    controller._finishPromise = newPromise((resolve, reject) => {\n 5060      controller._finishPromise_resolve = resolve;\n ....\n 5066      cancelPromise,\n 5067      () => {\n 5068:       if(readable._state === 'errored') {\n 5069:         defaultControllerFinishPromiseReject2(controller, readable._storedError);\n 5070        } else {\n 5071:         ReadableStreamDefaultControllerError(readable._readableStreamController, reason);\n 5072          defaultControllerFinishPromiseResolve2(controller);\n 5073        }\n ....\n 5075      },\n 5076      r => {\n 5077:       ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n 5078        defaultControllerFinishPromiseReject2(controller, r);\n 5079        return null;\n ....\n 5087      return controller._finishPromise;\n 5088    }\n 5089:   const readable = stream._readable;\n 5090    controller._finishPromise = newPromise((resolve, reject) => {\n 5091      controller._finishPromise_resolve = resolve;\n ....\n 5097      flushPromise,\n 5098      () => {\n 5099:       if(readable._state === 'errored') {\n 5100:         defaultControllerFinishPromiseReject2(controller, readable._storedError);\n 5101        } else {\n 5102:         ReadableStreamDefaultControllerClose(readable._readableStreamController);\n 5103          defaultControllerFinishPromiseResolve2(controller);\n 5104        }\n ....\n 5106      },\n 5107      r => {\n 5108:       ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n 5109        defaultControllerFinishPromiseReject2(controller, r);\n 5110        return null;\n ....\n 5313    }\n 5314    /**\n 5315:    * Returns whether or not the writable stream is locked to a writer.\n 5316     */\n 5317    get locked() {\n ....\n 5322    }\n 5323    /**\n 5324:    * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n 5325:    * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n 5326     * mechanism of the underlying sink.\n 5327     *\n ....\n 5335      }\n 5336      if(IsWritableStreamLocked2(this)) {\n 5337:       return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n 5338      }\n 5339      return WritableStreamAbort2(this, reason);\n ....\n 5341    /**\n 5342     * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n 5343:    * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n 5344     *\n 5345     * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n ....\n 5352      }\n 5353      if(IsWritableStreamLocked2(this)) {\n 5354:       return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n 5355      }\n 5356      if(WritableStreamCloseQueuedOrInFlight2(this)) {\n ....\n 5360    }\n 5361    /**\n 5362:    * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n 5363:    * is locked, no other writer can be acquired until this one is released.\n 5364     *\n 5365:    * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n 5366:    * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n 5367     * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n 5368     */\n ....\n 5469      stream._closeRequest = closeRequest;\n 5470    });\n 5471:   const writer = stream._writer;\n 5472:   if(writer !== void 0 && stream._backpressure && state === 'writable') {\n 5473:     defaultWriterReadyPromiseResolve2(writer);\n 5474    }\n 5475    WritableStreamDefaultControllerClose2(stream._writableStreamController);\n ....\n 5480    assert_default(stream._state === 'writable');\n 5481    const promise = newPromise((resolve, reject) => {\n 5482:     const writeRequest = {\n 5483        _resolve: resolve,\n 5484        _reject: reject,\n 5485      };\n 5486:     stream._writeRequests.push(writeRequest);\n 5487    });\n 5488    return promise;\n ....\n 5504    stream._state = 'erroring';\n 5505    stream._storedError = reason;\n 5506:   const writer = stream._writer;\n 5507:   if(writer !== void 0) {\n 5508:     WritableStreamDefaultWriterEnsureReadyPromiseRejected2(writer, reason);\n 5509    }\n 5510    if(!WritableStreamHasOperationMarkedInFlight2(stream) && controller._started) {\n ....\n 5518    stream._writableStreamController[ErrorSteps]();\n 5519    const storedError = stream._storedError;\n 5520:   stream._writeRequests.forEach(writeRequest => {\n 5521:     writeRequest._reject(storedError);\n 5522    });\n 5523    stream._writeRequests = new SimpleQueue();\n ....\n 5574    }\n 5575    stream._state = 'closed';\n 5576:   const writer = stream._writer;\n 5577:   if(writer !== void 0) {\n 5578:     defaultWriterClosedPromiseResolve2(writer);\n 5579    }\n 5580    assert_default(stream._pendingAbortRequest === void 0);\n ....\n 5622      stream._closeRequest = void 0;\n 5623    }\n 5624:   const writer = stream._writer;\n 5625:   if(writer !== void 0) {\n 5626:     defaultWriterClosedPromiseReject2(writer, stream._storedError);\n 5627    }\n 5628  }\n ....\n 5630    assert_default(stream._state === 'writable');\n 5631    assert_default(!WritableStreamCloseQueuedOrInFlight2(stream));\n 5632:   const writer = stream._writer;\n 5633:   if(writer !== void 0 && backpressure !== stream._backpressure) {\n 5634      if(backpressure) {\n 5635:       defaultWriterReadyPromiseReset2(writer);\n 5636      } else {\n 5637        assert_default(!backpressure);\n 5638:       defaultWriterReadyPromiseResolve2(writer);\n 5639      }\n 5640    }\n ....\n 5646      assertWritableStream(stream, 'First parameter');\n 5647      if(IsWritableStreamLocked2(stream)) {\n 5648:       throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n 5649      }\n 5650      this._ownerWritableStream = stream;\n ....\n 5673    /**\n 5674     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n 5675:    * the writerâ€™s lock is released before the stream finishes closing.\n 5676     */\n 5677    get closed() {\n ....\n 5683    /**\n 5684     * Returns the desired size to fill the streamâ€™s internal queue. It can be negative, if the queue is over-full.\n 5685:    * A producer can use this information to determine the right amount of data to write.\n 5686     *\n 5687     * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n 5688     * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n 5689:    * the writerâ€™s lock is released.\n 5690     */\n 5691    get desiredSize() {\n ....\n 5703     * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n 5704     *\n 5705:    * If the stream becomes errored or aborted, or the writerâ€™s lock is released, the returned promise will become\n 5706     * rejected.\n 5707     */\n 5708:   get ready() {\n 5709      if(!IsWritableStreamDefaultWriter2(this)) {\n 5710:       return promiseRejectedWith(defaultWriterBrandCheckException2('ready'));\n 5711      }\n 5712      return this._readyPromise;\n 5713    }\n 5714    /**\n 5715:    * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n 5716     */\n 5717    abort(reason = void 0) {\n ....\n 5725    }\n 5726    /**\n 5727:    * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n 5728     */\n 5729    close() {\n ....\n 5741    }\n 5742    /**\n 5743:    * Releases the writerâ€™s lock on the corresponding stream. After the lock is released, the writer is no longer active.\n 5744:    * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n 5745:    * now on; otherwise, the writer will appear closed.\n 5746     *\n 5747:    * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n 5748:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n 5749:    * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n 5750     * other producers from writing in an interleaved manner.\n 5751     */\n ....\n 5761      WritableStreamDefaultWriterRelease2(this);\n 5762    }\n 5763:   write(chunk = void 0) {\n 5764      if(!IsWritableStreamDefaultWriter2(this)) {\n 5765:       return promiseRejectedWith(defaultWriterBrandCheckException2('write'));\n 5766      }\n 5767      if(this._ownerWritableStream === void 0) {\n 5768:       return promiseRejectedWith(defaultWriterLockException2('write to'));\n 5769      }\n 5770      return WritableStreamDefaultWriterWrite2(this, chunk);\n ....\n 5775    close: { enumerable: true },\n 5776    releaseLock: { enumerable: true },\n 5777:   write: { enumerable: true },\n 5778    closed: { enumerable: true },\n 5779    desiredSize: { enumerable: true },\n 5780:   ready: { enumerable: true },\n 5781  });\n 5782  setFunctionName(WritableStreamDefaultWriter2.prototype.abort, 'abort');\n 5783  setFunctionName(WritableStreamDefaultWriter2.prototype.close, 'close');\n 5784  setFunctionName(WritableStreamDefaultWriter2.prototype.releaseLock, 'releaseLock');\n 5785: setFunctionName(WritableStreamDefaultWriter2.prototype.write, 'write');\n 5786  if(typeof Symbol.toStringTag === 'symbol') {\n 5787    Object.defineProperty(WritableStreamDefaultWriter2.prototype, Symbol.toStringTag, {\n ....\n 5799    return x instanceof WritableStreamDefaultWriter2;\n 5800  }\n 5801: function WritableStreamDefaultWriterAbort2(writer, reason) {\n 5802:   const stream = writer._ownerWritableStream;\n 5803    assert_default(stream !== void 0);\n 5804    return WritableStreamAbort2(stream, reason);\n 5805  }\n 5806: function WritableStreamDefaultWriterClose2(writer) {\n 5807:   const stream = writer._ownerWritableStream;\n 5808    assert_default(stream !== void 0);\n 5809    return WritableStreamClose2(stream);\n 5810  }\n 5811: function WritableStreamDefaultWriterEnsureClosedPromiseRejected2(writer, error) {\n 5812:   if(writer._closedPromiseState === 'pending') {\n 5813:     defaultWriterClosedPromiseReject2(writer, error);\n 5814    } else {\n 5815:     defaultWriterClosedPromiseResetToRejected2(writer, error);\n 5816    }\n 5817  }\n 5818: function WritableStreamDefaultWriterEnsureReadyPromiseRejected2(writer, error) {\n 5819:   if(writer._readyPromiseState === 'pending') {\n 5820:     defaultWriterReadyPromiseReject2(writer, error);\n 5821    } else {\n 5822:     defaultWriterReadyPromiseResetToRejected2(writer, error);\n 5823    }\n 5824  }\n 5825: function WritableStreamDefaultWriterGetDesiredSize2(writer) {\n 5826:   const stream = writer._ownerWritableStream;\n 5827    const state = stream._state;\n 5828    if(state === 'errored' || state === 'erroring') {\n ....\n 5834    return WritableStreamDefaultControllerGetDesiredSize2(stream._writableStreamController);\n 5835  }\n 5836: function WritableStreamDefaultWriterRelease2(writer) {\n 5837:   const stream = writer._ownerWritableStream;\n 5838    assert_default(stream !== void 0);\n 5839:   assert_default(stream._writer === writer);\n 5840    const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n 5841:   WritableStreamDefaultWriterEnsureReadyPromiseRejected2(writer, releasedError);\n 5842:   WritableStreamDefaultWriterEnsureClosedPromiseRejected2(writer, releasedError);\n 5843    stream._writer = void 0;\n 5844:   writer._ownerWritableStream = void 0;\n 5845  }\n 5846: function WritableStreamDefaultWriterWrite2(writer, chunk) {\n 5847:   const stream = writer._ownerWritableStream;\n 5848    assert_default(stream !== void 0);\n 5849    const controller = stream._writableStreamController;\n 5850    const chunkSize = WritableStreamDefaultControllerGetChunkSize2(controller, chunk);\n 5851:   if(stream !== writer._ownerWritableStream) {\n 5852:     return promiseRejectedWith(defaultWriterLockException2('write to'));\n 5853    }\n 5854    const state = stream._state;\n ....\n 5886    }\n 5887    /**\n 5888:    * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n 5889     */\n 5890    get signal() {\n ....\n 5945    return x instanceof WritableStreamDefaultController3;\n 5946  }\n 5947: function SetUpWritableStreamDefaultController2(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n 5948    assert_default(IsWritableStream2(stream));\n 5949    assert_default(stream._writableStreamController === void 0);\n ....\n 5958    controller._strategySizeAlgorithm = sizeAlgorithm;\n 5959    controller._strategyHWM = highWaterMark;\n 5960:   controller._writeAlgorithm = writeAlgorithm;\n 5961    controller._closeAlgorithm = closeAlgorithm;\n 5962    controller._abortAlgorithm = abortAlgorithm;\n ....\n 5984    const controller = Object.create(WritableStreamDefaultController3.prototype);\n 5985    let startAlgorithm;\n 5986:   let writeAlgorithm;\n 5987    let closeAlgorithm;\n 5988    let abortAlgorithm;\n ....\n 5992      startAlgorithm = () => void 0;\n 5993    }\n 5994:   if(underlyingSink.write !== void 0) {\n 5995:     writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n 5996    } else {\n 5997:     writeAlgorithm = () => promiseResolvedWith(void 0);\n 5998    }\n 5999    if(underlyingSink.close !== void 0) {\n ....\n 6007      abortAlgorithm = () => promiseResolvedWith(void 0);\n 6008    }\n 6009:   SetUpWritableStreamDefaultController2(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n 6010  }\n 6011  function WritableStreamDefaultControllerClearAlgorithms2(controller) {\n ....\n 6143  }\n 6144  function defaultWriterLockException2(name) {\n 6145:   return new TypeError('Cannot ' + name + ' a stream using a released writer');\n 6146  }\n 6147: function defaultWriterClosedPromiseInitialize2(writer) {\n 6148:   writer._closedPromise = newPromise((resolve, reject) => {\n 6149:     writer._closedPromise_resolve = resolve;\n 6150:     writer._closedPromise_reject = reject;\n 6151:     writer._closedPromiseState = 'pending';\n 6152    });\n 6153  }\n 6154: function defaultWriterClosedPromiseInitializeAsRejected2(writer, reason) {\n 6155:   defaultWriterClosedPromiseInitialize2(writer);\n 6156:   defaultWriterClosedPromiseReject2(writer, reason);\n 6157  }\n 6158: function defaultWriterClosedPromiseInitializeAsResolved2(writer) {\n 6159:   defaultWriterClosedPromiseInitialize2(writer);\n 6160:   defaultWriterClosedPromiseResolve2(writer);\n 6161  }\n 6162: function defaultWriterClosedPromiseReject2(writer, reason) {\n 6163:   if(writer._closedPromise_reject === void 0) {\n 6164      return;\n 6165    }\n 6166:   assert_default(writer._closedPromiseState === 'pending');\n 6167:   setPromiseIsHandledToTrue(writer._closedPromise);\n 6168:   writer._closedPromise_reject(reason);\n 6169:   writer._closedPromise_resolve = void 0;\n 6170:   writer._closedPromise_reject = void 0;\n 6171:   writer._closedPromiseState = 'rejected';\n 6172  }\n 6173: function defaultWriterClosedPromiseResetToRejected2(writer, reason) {\n 6174:   assert_default(writer._closedPromise_resolve === void 0);\n 6175:   assert_default(writer._closedPromise_reject === void 0);\n 6176:   assert_default(writer._closedPromiseState !== 'pending');\n 6177:   defaultWriterClosedPromiseInitializeAsRejected2(writer, reason);\n 6178  }\n 6179: function defaultWriterClosedPromiseResolve2(writer) {\n 6180:   if(writer._closedPromise_resolve === void 0) {\n 6181      return;\n 6182    }\n 6183:   assert_default(writer._closedPromiseState === 'pending');\n 6184:   writer._closedPromise_resolve(void 0);\n 6185:   writer._closedPromise_resolve = void 0;\n 6186:   writer._closedPromise_reject = void 0;\n 6187:   writer._closedPromiseState = 'resolved';\n 6188  }\n 6189: function defaultWriterReadyPromiseInitialize2(writer) {\n 6190:   writer._readyPromise = newPromise((resolve, reject) => {\n 6191:     writer._readyPromise_resolve = resolve;\n 6192:     writer._readyPromise_reject = reject;\n 6193    });\n 6194:   writer._readyPromiseState = 'pending';\n 6195  }\n 6196: function defaultWriterReadyPromiseInitializeAsRejected2(writer, reason) {\n 6197:   defaultWriterReadyPromiseInitialize2(writer);\n 6198:   defaultWriterReadyPromiseReject2(writer, reason);\n 6199  }\n 6200: function defaultWriterReadyPromiseInitializeAsResolved2(writer) {\n 6201:   defaultWriterReadyPromiseInitialize2(writer);\n 6202:   defaultWriterReadyPromiseResolve2(writer);\n 6203  }\n 6204: function defaultWriterReadyPromiseReject2(writer, reason) {\n 6205:   if(writer._readyPromise_reject === void 0) {\n 6206      return;\n 6207    }\n 6208:   setPromiseIsHandledToTrue(writer._readyPromise);\n 6209:   writer._readyPromise_reject(reason);\n 6210:   writer._readyPromise_resolve = void 0;\n 6211:   writer._readyPromise_reject = void 0;\n 6212:   writer._readyPromiseState = 'rejected';\n 6213  }\n 6214: function defaultWriterReadyPromiseReset2(writer) {\n 6215:   assert_default(writer._readyPromise_resolve === void 0);\n 6216:   assert_default(writer._readyPromise_reject === void 0);\n 6217:   defaultWriterReadyPromiseInitialize2(writer);\n 6218  }\n 6219: function defaultWriterReadyPromiseResetToRejected2(writer, reason) {\n 6220:   assert_default(writer._readyPromise_resolve === void 0);\n 6221:   assert_default(writer._readyPromise_reject === void 0);\n 6222:   defaultWriterReadyPromiseInitializeAsRejected2(writer, reason);\n 6223  }\n 6224: function defaultWriterReadyPromiseResolve2(writer) {\n 6225:   if(writer._readyPromise_resolve === void 0) {\n 6226      return;\n 6227    }\n 6228:   writer._readyPromise_resolve(void 0);\n 6229:   writer._readyPromise_resolve = void 0;\n 6230:   writer._readyPromise_reject = void 0;\n 6231:   writer._readyPromiseState = 'fulfilled';\n 6232  }\n 6233  export {\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/writable-stream.js:\n   13  import { createAbortController } from './abort-signal';\n   14  /**\n   15:  * A writable stream represents a destination for data, into which you can write.\n   16   *\n   17   * @public\n   ..\n   36    }\n   37    /**\n   38:    * Returns whether or not the writable stream is locked to a writer.\n   39     */\n   40    get locked() {\n   ..\n   45    }\n   46    /**\n   47:    * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n   48:    * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n   49     * mechanism of the underlying sink.\n   50     *\n   ..\n   58      }\n   59      if(IsWritableStreamLocked(this)) {\n   60:       return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n   61      }\n   62      return WritableStreamAbort(this, reason);\n   ..\n   64    /**\n   65     * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n   66:    * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n   67     *\n   68     * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n   ..\n   75      }\n   76      if(IsWritableStreamLocked(this)) {\n   77:       return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n   78      }\n   79      if(WritableStreamCloseQueuedOrInFlight(this)) {\n   ..\n   83    }\n   84    /**\n   85:    * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n   86:    * is locked, no other writer can be acquired until this one is released.\n   87     *\n   88:    * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n   89:    * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n   90     * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n   91     */\n   ..\n  130  }\n  131  // Throws if and only if startAlgorithm throws.\n  132: function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n  133    assert(IsNonNegativeNumber(highWaterMark));\n  134    const stream = Object.create(WritableStream.prototype);\n  135    InitializeWritableStream(stream);\n  136    const controller = Object.create(WritableStreamDefaultController.prototype);\n  137:   SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n  138    return stream;\n  139  }\n  ...\n  147    // variable to validate the caller.\n  148    stream._writableStreamController = undefined;\n  149:   // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n  150:   // producer without waiting for the queued writes to finish.\n  151    stream._writeRequests = new SimpleQueue();\n  152:   // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  153:   // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  154    stream._inFlightWriteRequest = undefined;\n  155:   // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  156    // has been detached.\n  157    stream._closeRequest = undefined;\n  ...\n  159    // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n  160    stream._inFlightCloseRequest = undefined;\n  161:   // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n  162    stream._pendingAbortRequest = undefined;\n  163    // The backpressure signal set by the controller.\n  ...\n  233      stream._closeRequest = closeRequest;\n  234    });\n  235:   const writer = stream._writer;\n  236:   if(writer !== undefined && stream._backpressure && state === 'writable') {\n  237:     defaultWriterReadyPromiseResolve(writer);\n  238    }\n  239    WritableStreamDefaultControllerClose(stream._writableStreamController);\n  ...\n  245    assert(stream._state === 'writable');\n  246    const promise = newPromise((resolve, reject) => {\n  247:     const writeRequest = {\n  248        _resolve: resolve,\n  249        _reject: reject,\n  250      };\n  251:     stream._writeRequests.push(writeRequest);\n  252    });\n  253    return promise;\n  ...\n  269    stream._state = 'erroring';\n  270    stream._storedError = reason;\n  271:   const writer = stream._writer;\n  272:   if(writer !== undefined) {\n  273:     WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  274    }\n  275    if(!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n  ...\n  283    stream._writableStreamController[ErrorSteps]();\n  284    const storedError = stream._storedError;\n  285:   stream._writeRequests.forEach(writeRequest => {\n  286:     writeRequest._reject(storedError);\n  287    });\n  288    stream._writeRequests = new SimpleQueue();\n  ...\n  340    }\n  341    stream._state = 'closed';\n  342:   const writer = stream._writer;\n  343:   if(writer !== undefined) {\n  344:     defaultWriterClosedPromiseResolve(writer);\n  345    }\n  346    assert(stream._pendingAbortRequest === undefined);\n  ...\n  390      stream._closeRequest = undefined;\n  391    }\n  392:   const writer = stream._writer;\n  393:   if(writer !== undefined) {\n  394:     defaultWriterClosedPromiseReject(writer, stream._storedError);\n  395    }\n  396  }\n  ...\n  398    assert(stream._state === 'writable');\n  399    assert(!WritableStreamCloseQueuedOrInFlight(stream));\n  400:   const writer = stream._writer;\n  401:   if(writer !== undefined && backpressure !== stream._backpressure) {\n  402      if(backpressure) {\n  403:       defaultWriterReadyPromiseReset(writer);\n  404      } else {\n  405        assert(!backpressure);\n  406:       defaultWriterReadyPromiseResolve(writer);\n  407      }\n  408    }\n  ...\n  410  }\n  411  /**\n  412:  * A default writer vended by a {@link WritableStream}.\n  413   *\n  414   * @public\n  ...\n  419      assertWritableStream(stream, 'First parameter');\n  420      if(IsWritableStreamLocked(stream)) {\n  421:       throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n  422      }\n  423      this._ownerWritableStream = stream;\n  ...\n  446    /**\n  447     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n  448:    * the writerâ€™s lock is released before the stream finishes closing.\n  449     */\n  450    get closed() {\n  ...\n  456    /**\n  457     * Returns the desired size to fill the streamâ€™s internal queue. It can be negative, if the queue is over-full.\n  458:    * A producer can use this information to determine the right amount of data to write.\n  459     *\n  460     * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n  461     * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n  462:    * the writerâ€™s lock is released.\n  463     */\n  464    get desiredSize() {\n  ...\n  476     * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n  477     *\n  478:    * If the stream becomes errored or aborted, or the writerâ€™s lock is released, the returned promise will become\n  479     * rejected.\n  480     */\n  481:   get ready() {\n  482      if(!IsWritableStreamDefaultWriter(this)) {\n  483:       return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n  484      }\n  485      return this._readyPromise;\n  486    }\n  487    /**\n  488:    * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n  489     */\n  490    abort(reason = undefined) {\n  ...\n  498    }\n  499    /**\n  500:    * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n  501     */\n  502    close() {\n  ...\n  514    }\n  515    /**\n  516:    * Releases the writerâ€™s lock on the corresponding stream. After the lock is released, the writer is no longer active.\n  517:    * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n  518:    * now on; otherwise, the writer will appear closed.\n  519     *\n  520:    * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n  521:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n  522:    * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n  523     * other producers from writing in an interleaved manner.\n  524     */\n  ...\n  534      WritableStreamDefaultWriterRelease(this);\n  535    }\n  536:   write(chunk = undefined) {\n  537      if(!IsWritableStreamDefaultWriter(this)) {\n  538:       return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n  539      }\n  540      if(this._ownerWritableStream === undefined) {\n  541:       return promiseRejectedWith(defaultWriterLockException('write to'));\n  542      }\n  543      return WritableStreamDefaultWriterWrite(this, chunk);\n  ...\n  548    close: { enumerable: true },\n  549    releaseLock: { enumerable: true },\n  550:   write: { enumerable: true },\n  551    closed: { enumerable: true },\n  552    desiredSize: { enumerable: true },\n  553:   ready: { enumerable: true },\n  554  });\n  555  setFunctionName(WritableStreamDefaultWriter.prototype.abort, 'abort');\n  556  setFunctionName(WritableStreamDefaultWriter.prototype.close, 'close');\n  557  setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, 'releaseLock');\n  558: setFunctionName(WritableStreamDefaultWriter.prototype.write, 'write');\n  559  if(typeof Symbol.toStringTag === 'symbol') {\n  560    Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {\n  ...\n  574  }\n  575  // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n  576: function WritableStreamDefaultWriterAbort(writer, reason) {\n  577:   const stream = writer._ownerWritableStream;\n  578    assert(stream !== undefined);\n  579    return WritableStreamAbort(stream, reason);\n  580  }\n  581: function WritableStreamDefaultWriterClose(writer) {\n  582:   const stream = writer._ownerWritableStream;\n  583    assert(stream !== undefined);\n  584    return WritableStreamClose(stream);\n  585  }\n  586: function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n  587:   const stream = writer._ownerWritableStream;\n  588    assert(stream !== undefined);\n  589    const state = stream._state;\n  ...\n  595    }\n  596    assert(state === 'writable' || state === 'erroring');\n  597:   return WritableStreamDefaultWriterClose(writer);\n  598  }\n  599: function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n  600:   if(writer._closedPromiseState === 'pending') {\n  601:     defaultWriterClosedPromiseReject(writer, error);\n  602    } else {\n  603:     defaultWriterClosedPromiseResetToRejected(writer, error);\n  604    }\n  605  }\n  606: function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n  607:   if(writer._readyPromiseState === 'pending') {\n  608:     defaultWriterReadyPromiseReject(writer, error);\n  609    } else {\n  610:     defaultWriterReadyPromiseResetToRejected(writer, error);\n  611    }\n  612  }\n  613: function WritableStreamDefaultWriterGetDesiredSize(writer) {\n  614:   const stream = writer._ownerWritableStream;\n  615    const state = stream._state;\n  616    if(state === 'errored' || state === 'erroring') {\n  ...\n  622    return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n  623  }\n  624: function WritableStreamDefaultWriterRelease(writer) {\n  625:   const stream = writer._ownerWritableStream;\n  626    assert(stream !== undefined);\n  627:   assert(stream._writer === writer);\n  628    const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n  629:   WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n  630:   // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n  631    // rejected until afterwards. This means that simply testing state will not work.\n  632:   WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n  633    stream._writer = undefined;\n  634:   writer._ownerWritableStream = undefined;\n  635  }\n  636: function WritableStreamDefaultWriterWrite(writer, chunk) {\n  637:   const stream = writer._ownerWritableStream;\n  638    assert(stream !== undefined);\n  639    const controller = stream._writableStreamController;\n  640    const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n  641:   if(stream !== writer._ownerWritableStream) {\n  642:     return promiseRejectedWith(defaultWriterLockException('write to'));\n  643    }\n  644    const state = stream._state;\n  ...\n  681    }\n  682    /**\n  683:    * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n  684     */\n  685    get signal() {\n  ...\n  746    return x instanceof WritableStreamDefaultController;\n  747  }\n  748: function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n  749    assert(IsWritableStream(stream));\n  750    assert(stream._writableStreamController === undefined);\n  ...\n  760    controller._strategySizeAlgorithm = sizeAlgorithm;\n  761    controller._strategyHWM = highWaterMark;\n  762:   controller._writeAlgorithm = writeAlgorithm;\n  763    controller._closeAlgorithm = closeAlgorithm;\n  764    controller._abortAlgorithm = abortAlgorithm;\n  ...\n  786    const controller = Object.create(WritableStreamDefaultController.prototype);\n  787    let startAlgorithm;\n  788:   let writeAlgorithm;\n  789    let closeAlgorithm;\n  790    let abortAlgorithm;\n  ...\n  794      startAlgorithm = () => undefined;\n  795    }\n  796:   if(underlyingSink.write !== undefined) {\n  797:     writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n  798    } else {\n  799:     writeAlgorithm = () => promiseResolvedWith(undefined);\n  800    }\n  801    if(underlyingSink.close !== undefined) {\n  ...\n  809      abortAlgorithm = () => promiseResolvedWith(undefined);\n  810    }\n  811:   SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n  812  }\n  813  // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\n  ...\n  951  }\n  952  function defaultWriterLockException(name) {\n  953:   return new TypeError('Cannot ' + name + ' a stream using a released writer');\n  954  }\n  955: function defaultWriterClosedPromiseInitialize(writer) {\n  956:   writer._closedPromise = newPromise((resolve, reject) => {\n  957:     writer._closedPromise_resolve = resolve;\n  958:     writer._closedPromise_reject = reject;\n  959:     writer._closedPromiseState = 'pending';\n  960    });\n  961  }\n  962: function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n  963:   defaultWriterClosedPromiseInitialize(writer);\n  964:   defaultWriterClosedPromiseReject(writer, reason);\n  965  }\n  966: function defaultWriterClosedPromiseInitializeAsResolved(writer) {\n  967:   defaultWriterClosedPromiseInitialize(writer);\n  968:   defaultWriterClosedPromiseResolve(writer);\n  969  }\n  970: function defaultWriterClosedPromiseReject(writer, reason) {\n  971:   if(writer._closedPromise_reject === undefined) {\n  972      return;\n  973    }\n  974:   assert(writer._closedPromiseState === 'pending');\n  975:   setPromiseIsHandledToTrue(writer._closedPromise);\n  976:   writer._closedPromise_reject(reason);\n  977:   writer._closedPromise_resolve = undefined;\n  978:   writer._closedPromise_reject = undefined;\n  979:   writer._closedPromiseState = 'rejected';\n  980  }\n  981: function defaultWriterClosedPromiseResetToRejected(writer, reason) {\n  982:   assert(writer._closedPromise_resolve === undefined);\n  983:   assert(writer._closedPromise_reject === undefined);\n  984:   assert(writer._closedPromiseState !== 'pending');\n  985:   defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n  986  }\n  987: function defaultWriterClosedPromiseResolve(writer) {\n  988:   if(writer._closedPromise_resolve === undefined) {\n  989      return;\n  990    }\n  991:   assert(writer._closedPromiseState === 'pending');\n  992:   writer._closedPromise_resolve(undefined);\n  993:   writer._closedPromise_resolve = undefined;\n  994:   writer._closedPromise_reject = undefined;\n  995:   writer._closedPromiseState = 'resolved';\n  996  }\n  997: function defaultWriterReadyPromiseInitialize(writer) {\n  998:   writer._readyPromise = newPromise((resolve, reject) => {\n  999:     writer._readyPromise_resolve = resolve;\n 1000:     writer._readyPromise_reject = reject;\n 1001    });\n 1002:   writer._readyPromiseState = 'pending';\n 1003  }\n 1004: function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n 1005:   defaultWriterReadyPromiseInitialize(writer);\n 1006:   defaultWriterReadyPromiseReject(writer, reason);\n 1007  }\n 1008: function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n 1009:   defaultWriterReadyPromiseInitialize(writer);\n 1010:   defaultWriterReadyPromiseResolve(writer);\n 1011  }\n 1012: function defaultWriterReadyPromiseReject(writer, reason) {\n 1013:   if(writer._readyPromise_reject === undefined) {\n 1014      return;\n 1015    }\n 1016:   setPromiseIsHandledToTrue(writer._readyPromise);\n 1017:   writer._readyPromise_reject(reason);\n 1018:   writer._readyPromise_resolve = undefined;\n 1019:   writer._readyPromise_reject = undefined;\n 1020:   writer._readyPromiseState = 'rejected';\n 1021  }\n 1022: function defaultWriterReadyPromiseReset(writer) {\n 1023:   assert(writer._readyPromise_resolve === undefined);\n 1024:   assert(writer._readyPromise_reject === undefined);\n 1025:   defaultWriterReadyPromiseInitialize(writer);\n 1026  }\n 1027: function defaultWriterReadyPromiseResetToRejected(writer, reason) {\n 1028:   assert(writer._readyPromise_resolve === undefined);\n 1029:   assert(writer._readyPromise_reject === undefined);\n 1030:   defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n 1031  }\n 1032: function defaultWriterReadyPromiseResolve(writer) {\n 1033:   if(writer._readyPromise_resolve === undefined) {\n 1034      return;\n 1035    }\n 1036:   writer._readyPromise_resolve(undefined);\n 1037:   writer._readyPromise_resolve = undefined;\n 1038:   writer._readyPromise_reject = undefined;\n 1039:   writer._readyPromiseState = 'fulfilled';\n 1040  }\n 1041  \n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/bun.js:\n  191  var ReleaseSteps = Symbol('[[ReleaseSteps]]');\n  192  \n  193: // src/lib/readable-stream/generic-reader.ts\n  194: function ReadableStreamReaderGenericInitialize(reader, stream) {\n  195:   reader._ownerReadableStream = stream;\n  196:   stream._reader = reader;\n  197:   if(stream._state === 'readable') {\n  198:     defaultReaderClosedPromiseInitialize(reader);\n  199    } else if(stream._state === 'closed') {\n  200:     defaultReaderClosedPromiseInitializeAsResolved(reader);\n  201    } else {\n  202      assert_default(stream._state === 'errored');\n  203:     defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n  204    }\n  205  }\n  206: function ReadableStreamReaderGenericCancel(reader, reason) {\n  207:   const stream = reader._ownerReadableStream;\n  208    assert_default(stream !== undefined);\n  209    return ReadableStreamCancel(stream, reason);\n  210  }\n  211: function ReadableStreamReaderGenericRelease(reader) {\n  212:   const stream = reader._ownerReadableStream;\n  213    assert_default(stream !== undefined);\n  214:   assert_default(stream._reader === reader);\n  215:   if(stream._state === 'readable') {\n  216:     defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  217    } else {\n  218:     defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  219    }\n  220    stream._readableStreamController[ReleaseSteps]();\n  221    stream._reader = undefined;\n  222:   reader._ownerReadableStream = undefined;\n  223  }\n  224: function readerLockException(name) {\n  225:   return new TypeError('Cannot ' + name + ' a stream using a released reader');\n  226  }\n  227: function defaultReaderClosedPromiseInitialize(reader) {\n  228:   reader._closedPromise = newPromise((resolve, reject) => {\n  229:     reader._closedPromise_resolve = resolve;\n  230:     reader._closedPromise_reject = reject;\n  231    });\n  232  }\n  233: function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n  234:   defaultReaderClosedPromiseInitialize(reader);\n  235:   defaultReaderClosedPromiseReject(reader, reason);\n  236  }\n  237: function defaultReaderClosedPromiseInitializeAsResolved(reader) {\n  238:   defaultReaderClosedPromiseInitialize(reader);\n  239:   defaultReaderClosedPromiseResolve(reader);\n  240  }\n  241: function defaultReaderClosedPromiseReject(reader, reason) {\n  242:   if(reader._closedPromise_reject === undefined) {\n  243      return;\n  244    }\n  245:   setPromiseIsHandledToTrue(reader._closedPromise);\n  246:   reader._closedPromise_reject(reason);\n  247:   reader._closedPromise_resolve = undefined;\n  248:   reader._closedPromise_reject = undefined;\n  249  }\n  250: function defaultReaderClosedPromiseResetToRejected(reader, reason) {\n  251:   assert_default(reader._closedPromise_resolve === undefined);\n  252:   assert_default(reader._closedPromise_reject === undefined);\n  253:   defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n  254  }\n  255: function defaultReaderClosedPromiseResolve(reader) {\n  256:   if(reader._closedPromise_resolve === undefined) {\n  257      return;\n  258    }\n  259:   reader._closedPromise_resolve(undefined);\n  260:   reader._closedPromise_resolve = undefined;\n  261:   reader._closedPromise_reject = undefined;\n  262  }\n  263  \n  ...\n  337  }\n  338  \n  339: // src/lib/validators/readable-stream.ts\n  340  function assertReadableStream(x, context) {\n  341    if(!IsReadableStream(x)) {\n  ...\n  344  }\n  345  \n  346: // src/lib/readable-stream/default-reader.ts\n  347  function AcquireReadableStreamDefaultReader(stream) {\n  348    return new ReadableStreamDefaultReader(stream);\n  349  }\n  350: function ReadableStreamAddReadRequest(stream, readRequest) {\n  351    assert_default(IsReadableStreamDefaultReader(stream._reader));\n  352:   assert_default(stream._state === 'readable');\n  353:   stream._reader._readRequests.push(readRequest);\n  354  }\n  355  function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n  356:   const reader = stream._reader;\n  357:   assert_default(reader._readRequests.length > 0);\n  358:   const readRequest = reader._readRequests.shift();\n  359    if(done) {\n  360:     readRequest._closeSteps();\n  361    } else {\n  362:     readRequest._chunkSteps(chunk);\n  363    }\n  364  }\n  ...\n  367  }\n  368  function ReadableStreamHasDefaultReader(stream) {\n  369:   const reader = stream._reader;\n  370:   if(reader === undefined) {\n  371      return false;\n  372    }\n  373:   if(!IsReadableStreamDefaultReader(reader)) {\n  374      return false;\n  375    }\n  ...\n  387      assertReadableStream(stream, 'First parameter');\n  388      if(IsReadableStreamLocked(stream)) {\n  389:       throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n  390      }\n  391      ReadableStreamReaderGenericInitialize(this, stream);\n  ...\n  403      }\n  404      if(this._ownerReadableStream === undefined) {\n  405:       return promiseRejectedWith(readerLockException('cancel'));\n  406      }\n  407      return ReadableStreamReaderGenericCancel(this, reason);\n  408    }\n  409:   read() {\n  410      if(!IsReadableStreamDefaultReader(this)) {\n  411:       return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  412      }\n  413      if(this._ownerReadableStream === undefined) {\n  414:       return promiseRejectedWith(readerLockException('read from'));\n  415      }\n  416      let resolvePromise;\n  ...\n  420        rejectPromise = reject;\n  421      });\n  422:     const readRequest = {\n  423        _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n  424        _closeSteps: () => resolvePromise({ value: undefined, done: true }),\n  425        _errorSteps: e => rejectPromise(e),\n  426      };\n  427:     ReadableStreamDefaultReaderRead(this, readRequest);\n  428      return promise;\n  429    }\n  ...\n  440  Object.defineProperties(ReadableStreamDefaultReader.prototype, {\n  441    cancel: { enumerable: true },\n  442:   read: { enumerable: true },\n  443    releaseLock: { enumerable: true },\n  444    closed: { enumerable: true },\n  445  });\n  446  setFunctionName(ReadableStreamDefaultReader.prototype.cancel, 'cancel');\n  447: setFunctionName(ReadableStreamDefaultReader.prototype.read, 'read');\n  448  setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, 'releaseLock');\n  449  if(typeof Symbol.toStringTag === 'symbol') {\n  ...\n  462    return x instanceof ReadableStreamDefaultReader;\n  463  }\n  464: function ReadableStreamDefaultReaderRead(reader, readRequest) {\n  465:   const stream = reader._ownerReadableStream;\n  466    assert_default(stream !== undefined);\n  467    stream._disturbed = true;\n  468    if(stream._state === 'closed') {\n  469:     readRequest._closeSteps();\n  470    } else if(stream._state === 'errored') {\n  471:     readRequest._errorSteps(stream._storedError);\n  472    } else {\n  473:     assert_default(stream._state === 'readable');\n  474:     stream._readableStreamController[PullSteps](readRequest);\n  475    }\n  476  }\n  477: function ReadableStreamDefaultReaderRelease(reader) {\n  478:   ReadableStreamReaderGenericRelease(reader);\n  479    const e = new TypeError('Reader was released');\n  480:   ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n  481  }\n  482: function ReadableStreamDefaultReaderErrorReadRequests(reader, e) {\n  483:   const readRequests = reader._readRequests;\n  484:   reader._readRequests = new SimpleQueue();\n  485:   readRequests.forEach(readRequest => {\n  486:     readRequest._errorSteps(e);\n  487    });\n  488  }\n  ...\n  615  }\n  616  \n  617: // src/lib/readable-stream/async-iterator.ts\n  618  class ReadableStreamAsyncIteratorImpl {\n  619    _reader;\n  ...\n  621    _ongoingPromise = undefined;\n  622    _isFinished = false;\n  623:   constructor(reader, preventCancel) {\n  624:     this._reader = reader;\n  625      this._preventCancel = preventCancel;\n  626    }\n  ...\n  639        return Promise.resolve({ value: undefined, done: true });\n  640      }\n  641:     const reader = this._reader;\n  642:     assert_default(reader._ownerReadableStream !== undefined);\n  643      let resolvePromise;\n  644      let rejectPromise;\n  ...\n  647        rejectPromise = reject;\n  648      });\n  649:     const readRequest = {\n  650        _chunkSteps: chunk => {\n  651          this._ongoingPromise = undefined;\n  ...\n  655          this._ongoingPromise = undefined;\n  656          this._isFinished = true;\n  657:         ReadableStreamReaderGenericRelease(reader);\n  658          resolvePromise({ value: undefined, done: true });\n  659        },\n  ...\n  661          this._ongoingPromise = undefined;\n  662          this._isFinished = true;\n  663:         ReadableStreamReaderGenericRelease(reader);\n  664          rejectPromise(reason);\n  665        },\n  666      };\n  667:     ReadableStreamDefaultReaderRead(reader, readRequest);\n  668      return promise;\n  669    }\n  ...\n  673      }\n  674      this._isFinished = true;\n  675:     const reader = this._reader;\n  676:     assert_default(reader._ownerReadableStream !== undefined);\n  677:     assert_default(reader._readRequests.length === 0);\n  678      if(!this._preventCancel) {\n  679:       const result = ReadableStreamReaderGenericCancel(reader, value);\n  680:       ReadableStreamReaderGenericRelease(reader);\n  681        return transformPromiseWith(result, () => ({ value, done: true }));\n  682      }\n  683:     ReadableStreamReaderGenericRelease(reader);\n  684      return promiseResolvedWith({ value, done: true });\n  685    }\n  ...\n  706  });\n  707  function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n  708:   const reader = AcquireReadableStreamDefaultReader(stream);\n  709:   const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n  710    const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n  711    iterator._asyncIteratorImpl = impl;\n  ...\n  808  }\n  809  \n  810: // src/lib/readable-stream/byte-stream-controller.ts\n  811  class ReadableStreamBYOBRequest {\n  812    _associatedReadableByteStreamController;\n  ...\n  905      }\n  906      const state = this._controlledReadableByteStream._state;\n  907:     if(state !== 'readable') {\n  908:       throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n  909      }\n  910      ReadableByteStreamControllerClose(this);\n  ...\n  928      }\n  929      const state = this._controlledReadableByteStream._state;\n  930:     if(state !== 'readable') {\n  931:       throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n  932      }\n  933      ReadableByteStreamControllerEnqueue(this, chunk);\n  ...\n  946      return result;\n  947    }\n  948:   [PullSteps](readRequest) {\n  949      const stream = this._controlledReadableByteStream;\n  950      assert_default(ReadableStreamHasDefaultReader(stream));\n  951      if(this._queueTotalSize > 0) {\n  952        assert_default(ReadableStreamGetNumReadRequests(stream) === 0);\n  953:       ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);\n  954        return;\n  955      }\n  ...\n  960          buffer = new ArrayBuffer(autoAllocateChunkSize);\n  961        } catch(bufferE) {\n  962:         readRequest._errorSteps(bufferE);\n  963          return;\n  964        }\n  ...\n  972          elementSize: 1,\n  973          viewConstructor: Uint8Array,\n  974:         readerType: 'default',\n  975        };\n  976        this._pendingPullIntos.push(pullIntoDescriptor);\n  977      }\n  978:     ReadableStreamAddReadRequest(stream, readRequest);\n  979      ReadableByteStreamControllerCallPullIfNeeded(this);\n  980    }\n  ...\n  982      if(this._pendingPullIntos.length > 0) {\n  983        const firstPullInto = this._pendingPullIntos.peek();\n  984:       firstPullInto.readerType = 'none';\n  985        this._pendingPullIntos = new SimpleQueue();\n  986        this._pendingPullIntos.push(firstPullInto);\n  ...\n 1056  function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n 1057    assert_default(stream._state !== 'errored');\n 1058:   assert_default(pullIntoDescriptor.readerType !== 'none');\n 1059    let done = false;\n 1060    if(stream._state === 'closed') {\n ....\n 1063    }\n 1064    const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n 1065:   if(pullIntoDescriptor.readerType === 'default') {\n 1066      ReadableStreamFulfillReadRequest(stream, filledView, done);\n 1067    } else {\n 1068:     assert_default(pullIntoDescriptor.readerType === 'byob');\n 1069      ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n 1070    }\n ....\n 1097  }\n 1098  function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {\n 1099:   assert_default(firstDescriptor.readerType === 'none');\n 1100    if(firstDescriptor.bytesFilled > 0) {\n 1101      ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);\n ....\n 1107    const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n 1108    let totalBytesToCopyRemaining = maxBytesToCopy;\n 1109:   let ready = false;\n 1110    assert_default(!IsDetachedBuffer(pullIntoDescriptor.buffer));\n 1111    assert_default(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n ....\n 1114    if(maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n 1115      totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n 1116:     ready = true;\n 1117    }\n 1118    const queue = controller._queue;\n ....\n 1133      totalBytesToCopyRemaining -= bytesToCopy;\n 1134    }\n 1135:   if(!ready) {\n 1136      assert_default(controller._queueTotalSize === 0);\n 1137      assert_default(pullIntoDescriptor.bytesFilled > 0);\n 1138      assert_default(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n 1139    }\n 1140:   return ready;\n 1141  }\n 1142  function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n ....\n 1146  }\n 1147  function ReadableByteStreamControllerHandleQueueDrain(controller) {\n 1148:   assert_default(controller._controlledReadableByteStream._state === 'readable');\n 1149    if(controller._queueTotalSize === 0 && controller._closeRequested) {\n 1150      ReadableByteStreamControllerClearAlgorithms(controller);\n ....\n 1170      }\n 1171      const pullIntoDescriptor = controller._pendingPullIntos.peek();\n 1172:     assert_default(pullIntoDescriptor.readerType !== 'none');\n 1173      if(ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n 1174        ReadableByteStreamControllerShiftPendingPullInto(controller);\n ....\n 1179  }\n 1180  function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller) {\n 1181:   const reader = controller._controlledReadableByteStream._reader;\n 1182:   assert_default(IsReadableStreamDefaultReader(reader));\n 1183:   while(reader._readRequests.length > 0) {\n 1184      if(controller._queueTotalSize === 0) {\n 1185        return;\n 1186      }\n 1187:     const readRequest = reader._readRequests.shift();\n 1188:     ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);\n 1189    }\n 1190  }\n 1191: function ReadableByteStreamControllerPullInto(controller, view, min, readIntoRequest) {\n 1192    const stream = controller._controlledReadableByteStream;\n 1193    const ctor = view.constructor;\n ....\n 1201      buffer = TransferArrayBuffer(view.buffer);\n 1202    } catch(e) {\n 1203:     readIntoRequest._errorSteps(e);\n 1204      return;\n 1205    }\n ....\n 1213      elementSize,\n 1214      viewConstructor: ctor,\n 1215:     readerType: 'byob',\n 1216    };\n 1217    if(controller._pendingPullIntos.length > 0) {\n 1218      controller._pendingPullIntos.push(pullIntoDescriptor);\n 1219:     ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n 1220      return;\n 1221    }\n 1222    if(stream._state === 'closed') {\n 1223      const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n 1224:     readIntoRequest._closeSteps(emptyView);\n 1225      return;\n 1226    }\n ....\n 1229        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n 1230        ReadableByteStreamControllerHandleQueueDrain(controller);\n 1231:       readIntoRequest._chunkSteps(filledView);\n 1232        return;\n 1233      }\n ....\n 1235        const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n 1236        ReadableByteStreamControllerError(controller, e);\n 1237:       readIntoRequest._errorSteps(e);\n 1238        return;\n 1239      }\n 1240    }\n 1241    controller._pendingPullIntos.push(pullIntoDescriptor);\n 1242:   ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n 1243    ReadableByteStreamControllerCallPullIfNeeded(controller);\n 1244  }\n 1245  function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n 1246    assert_default(firstDescriptor.bytesFilled % firstDescriptor.elementSize === 0);\n 1247:   if(firstDescriptor.readerType === 'none') {\n 1248      ReadableByteStreamControllerShiftPendingPullInto(controller);\n 1249    }\n ....\n 1260    assert_default(pullIntoDescriptor.bytesFilled + bytesWritten <= pullIntoDescriptor.byteLength);\n 1261    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n 1262:   if(pullIntoDescriptor.readerType === 'none') {\n 1263      ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);\n 1264      const filledPullIntos2 = ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n ....\n 1289      ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n 1290    } else {\n 1291:     assert_default(state === 'readable');\n 1292      assert_default(bytesWritten > 0);\n 1293      ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n ....\n 1302  function ReadableByteStreamControllerShouldCallPull(controller) {\n 1303    const stream = controller._controlledReadableByteStream;\n 1304:   if(stream._state !== 'readable') {\n 1305      return false;\n 1306    }\n ....\n 1330  function ReadableByteStreamControllerClose(controller) {\n 1331    const stream = controller._controlledReadableByteStream;\n 1332:   if(controller._closeRequested || stream._state !== 'readable') {\n 1333      return;\n 1334    }\n ....\n 1350  function ReadableByteStreamControllerEnqueue(controller, chunk) {\n 1351    const stream = controller._controlledReadableByteStream;\n 1352:   if(controller._closeRequested || stream._state !== 'readable') {\n 1353      return;\n 1354    }\n ....\n 1365      ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n 1366      firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n 1367:     if(firstPendingPullInto.readerType === 'none') {\n 1368        ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);\n 1369      }\n ....\n 1377        assert_default(controller._queue.length === 0);\n 1378        if(controller._pendingPullIntos.length > 0) {\n 1379:         assert_default(controller._pendingPullIntos.peek().readerType === 'default');\n 1380          ReadableByteStreamControllerShiftPendingPullInto(controller);\n 1381        }\n ....\n 1395  function ReadableByteStreamControllerError(controller, e) {\n 1396    const stream = controller._controlledReadableByteStream;\n 1397:   if(stream._state !== 'readable') {\n 1398      return;\n 1399    }\n ....\n 1403    ReadableStreamError(stream, e);\n 1404  }\n 1405: function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {\n 1406    assert_default(controller._queueTotalSize > 0);\n 1407    const entry = controller._queue.shift();\n ....\n 1409    ReadableByteStreamControllerHandleQueueDrain(controller);\n 1410    const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n 1411:   readRequest._chunkSteps(view);\n 1412  }\n 1413  function ReadableByteStreamControllerGetBYOBRequest(controller) {\n ....\n 1440      }\n 1441    } else {\n 1442:     assert_default(state === 'readable');\n 1443      if(bytesWritten === 0) {\n 1444:       throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');\n 1445      }\n 1446      if(firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n ....\n 1461      }\n 1462    } else {\n 1463:     assert_default(state === 'readable');\n 1464      if(view.byteLength === 0) {\n 1465:       throw new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");\n 1466      }\n 1467    }\n ....\n 1558  }\n 1559  \n 1560: // src/lib/validators/reader-options.ts\n 1561  function convertReaderOptions(options, context) {\n 1562    assertDictionary(options, context);\n ....\n 1581  }\n 1582  \n 1583: // src/lib/readable-stream/byob-reader.ts\n 1584  function AcquireReadableStreamBYOBReader(stream) {\n 1585    return new ReadableStreamBYOBReader(stream);\n 1586  }\n 1587: function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n 1588    assert_default(IsReadableStreamBYOBReader(stream._reader));\n 1589:   assert_default(stream._state === 'readable' || stream._state === 'closed');\n 1590:   stream._reader._readIntoRequests.push(readIntoRequest);\n 1591  }\n 1592  function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n 1593:   const reader = stream._reader;\n 1594:   assert_default(reader._readIntoRequests.length > 0);\n 1595:   const readIntoRequest = reader._readIntoRequests.shift();\n 1596    if(done) {\n 1597:     readIntoRequest._closeSteps(chunk);\n 1598    } else {\n 1599:     readIntoRequest._chunkSteps(chunk);\n 1600    }\n 1601  }\n ....\n 1604  }\n 1605  function ReadableStreamHasBYOBReader(stream) {\n 1606:   const reader = stream._reader;\n 1607:   if(reader === undefined) {\n 1608      return false;\n 1609    }\n 1610:   if(!IsReadableStreamBYOBReader(reader)) {\n 1611      return false;\n 1612    }\n ....\n 1624      assertReadableStream(stream, 'First parameter');\n 1625      if(IsReadableStreamLocked(stream)) {\n 1626:       throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n 1627      }\n 1628      if(!IsReadableByteStreamController(stream._readableStreamController)) {\n ....\n 1643      }\n 1644      if(this._ownerReadableStream === undefined) {\n 1645:       return promiseRejectedWith(readerLockException('cancel'));\n 1646      }\n 1647      return ReadableStreamReaderGenericCancel(this, reason);\n 1648    }\n 1649:   read(view, rawOptions = {}) {\n 1650      if(!IsReadableStreamBYOBReader(this)) {\n 1651:       return promiseRejectedWith(byobReaderBrandCheckException('read'));\n 1652      }\n 1653      if(!ArrayBuffer.isView(view)) {\n ....\n 1681      }\n 1682      if(this._ownerReadableStream === undefined) {\n 1683:       return promiseRejectedWith(readerLockException('read from'));\n 1684      }\n 1685      let resolvePromise;\n ....\n 1689        rejectPromise = reject;\n 1690      });\n 1691:     const readIntoRequest = {\n 1692        _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n 1693        _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n 1694        _errorSteps: e => rejectPromise(e),\n 1695      };\n 1696:     ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);\n 1697      return promise;\n 1698    }\n ....\n 1709  Object.defineProperties(ReadableStreamBYOBReader.prototype, {\n 1710    cancel: { enumerable: true },\n 1711:   read: { enumerable: true },\n 1712    releaseLock: { enumerable: true },\n 1713    closed: { enumerable: true },\n 1714  });\n 1715  setFunctionName(ReadableStreamBYOBReader.prototype.cancel, 'cancel');\n 1716: setFunctionName(ReadableStreamBYOBReader.prototype.read, 'read');\n 1717  setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, 'releaseLock');\n 1718  if(typeof Symbol.toStringTag === 'symbol') {\n ....\n 1731    return x instanceof ReadableStreamBYOBReader;\n 1732  }\n 1733: function ReadableStreamBYOBReaderRead(reader, view, min, readIntoRequest) {\n 1734:   const stream = reader._ownerReadableStream;\n 1735    assert_default(stream !== undefined);\n 1736    stream._disturbed = true;\n 1737    if(stream._state === 'errored') {\n 1738:     readIntoRequest._errorSteps(stream._storedError);\n 1739    } else {\n 1740:     ReadableByteStreamControllerPullInto(stream._readableStreamController, view, min, readIntoRequest);\n 1741    }\n 1742  }\n 1743: function ReadableStreamBYOBReaderRelease(reader) {\n 1744:   ReadableStreamReaderGenericRelease(reader);\n 1745    const e = new TypeError('Reader was released');\n 1746:   ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n 1747  }\n 1748: function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e) {\n 1749:   const readIntoRequests = reader._readIntoRequests;\n 1750:   reader._readIntoRequests = new SimpleQueue();\n 1751:   readIntoRequests.forEach(readIntoRequest => {\n 1752:     readIntoRequest._errorSteps(e);\n 1753    });\n 1754  }\n ....\n 1798    const start = original?.start;\n 1799    const type = original?.type;\n 1800:   const write = original?.write;\n 1801    return {\n 1802      abort: abort === undefined ? undefined : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),\n 1803      close: close === undefined ? undefined : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),\n 1804      start: start === undefined ? undefined : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n 1805:     write: write === undefined ? undefined : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n 1806      type,\n 1807    };\n ....\n 1889      }\n 1890      if(IsWritableStreamLocked(this)) {\n 1891:       return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n 1892      }\n 1893      return WritableStreamAbort(this, reason);\n ....\n 1898      }\n 1899      if(IsWritableStreamLocked(this)) {\n 1900:       return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n 1901      }\n 1902      if(WritableStreamCloseQueuedOrInFlight(this)) {\n ....\n 1930    return new WritableStreamDefaultWriter(stream);\n 1931  }\n 1932: function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n 1933    assert_default(IsNonNegativeNumber(highWaterMark));\n 1934    const stream = Object.create(WritableStream2.prototype);\n 1935    InitializeWritableStream(stream);\n 1936    const controller = Object.create(WritableStreamDefaultController.prototype);\n 1937:   SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n 1938    return stream;\n 1939  }\n ....\n 2014      stream._closeRequest = closeRequest;\n 2015    });\n 2016:   const writer = stream._writer;\n 2017:   if(writer !== undefined && stream._backpressure && state === 'writable') {\n 2018:     defaultWriterReadyPromiseResolve(writer);\n 2019    }\n 2020    WritableStreamDefaultControllerClose(stream._writableStreamController);\n ....\n 2025    assert_default(stream._state === 'writable');\n 2026    const promise = newPromise((resolve, reject) => {\n 2027:     const writeRequest = {\n 2028        _resolve: resolve,\n 2029        _reject: reject,\n 2030      };\n 2031:     stream._writeRequests.push(writeRequest);\n 2032    });\n 2033    return promise;\n ....\n 2049    stream._state = 'erroring';\n 2050    stream._storedError = reason;\n 2051:   const writer = stream._writer;\n 2052:   if(writer !== undefined) {\n 2053:     WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n 2054    }\n 2055    if(!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n ....\n 2063    stream._writableStreamController[ErrorSteps]();\n 2064    const storedError = stream._storedError;\n 2065:   stream._writeRequests.forEach(writeRequest => {\n 2066:     writeRequest._reject(storedError);\n 2067    });\n 2068    stream._writeRequests = new SimpleQueue();\n ....\n 2119    }\n 2120    stream._state = 'closed';\n 2121:   const writer = stream._writer;\n 2122:   if(writer !== undefined) {\n 2123:     defaultWriterClosedPromiseResolve(writer);\n 2124    }\n 2125    assert_default(stream._pendingAbortRequest === undefined);\n ....\n 2167      stream._closeRequest = undefined;\n 2168    }\n 2169:   const writer = stream._writer;\n 2170:   if(writer !== undefined) {\n 2171:     defaultWriterClosedPromiseReject(writer, stream._storedError);\n 2172    }\n 2173  }\n ....\n 2175    assert_default(stream._state === 'writable');\n 2176    assert_default(!WritableStreamCloseQueuedOrInFlight(stream));\n 2177:   const writer = stream._writer;\n 2178:   if(writer !== undefined && backpressure !== stream._backpressure) {\n 2179      if(backpressure) {\n 2180:       defaultWriterReadyPromiseReset(writer);\n 2181      } else {\n 2182        assert_default(!backpressure);\n 2183:       defaultWriterReadyPromiseResolve(writer);\n 2184      }\n 2185    }\n ....\n 2201      assertWritableStream(stream, 'First parameter');\n 2202      if(IsWritableStreamLocked(stream)) {\n 2203:       throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n 2204      }\n 2205      this._ownerWritableStream = stream;\n ....\n 2241      return WritableStreamDefaultWriterGetDesiredSize(this);\n 2242    }\n 2243:   get ready() {\n 2244      if(!IsWritableStreamDefaultWriter(this)) {\n 2245:       return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n 2246      }\n 2247      return this._readyPromise;\n ....\n 2280      WritableStreamDefaultWriterRelease(this);\n 2281    }\n 2282:   write(chunk = undefined) {\n 2283      if(!IsWritableStreamDefaultWriter(this)) {\n 2284:       return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n 2285      }\n 2286      if(this._ownerWritableStream === undefined) {\n 2287:       return promiseRejectedWith(defaultWriterLockException('write to'));\n 2288      }\n 2289      return WritableStreamDefaultWriterWrite(this, chunk);\n ....\n 2294    close: { enumerable: true },\n 2295    releaseLock: { enumerable: true },\n 2296:   write: { enumerable: true },\n 2297    closed: { enumerable: true },\n 2298    desiredSize: { enumerable: true },\n 2299:   ready: { enumerable: true },\n 2300  });\n 2301  setFunctionName(WritableStreamDefaultWriter.prototype.abort, 'abort');\n 2302  setFunctionName(WritableStreamDefaultWriter.prototype.close, 'close');\n 2303  setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, 'releaseLock');\n 2304: setFunctionName(WritableStreamDefaultWriter.prototype.write, 'write');\n 2305  if(typeof Symbol.toStringTag === 'symbol') {\n 2306    Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {\n ....\n 2318    return x instanceof WritableStreamDefaultWriter;\n 2319  }\n 2320: function WritableStreamDefaultWriterAbort(writer, reason) {\n 2321:   const stream = writer._ownerWritableStream;\n 2322    assert_default(stream !== undefined);\n 2323    return WritableStreamAbort(stream, reason);\n 2324  }\n 2325: function WritableStreamDefaultWriterClose(writer) {\n 2326:   const stream = writer._ownerWritableStream;\n 2327    assert_default(stream !== undefined);\n 2328    return WritableStreamClose(stream);\n 2329  }\n 2330: function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n 2331:   const stream = writer._ownerWritableStream;\n 2332    assert_default(stream !== undefined);\n 2333    const state = stream._state;\n ....\n 2339    }\n 2340    assert_default(state === 'writable' || state === 'erroring');\n 2341:   return WritableStreamDefaultWriterClose(writer);\n 2342  }\n 2343: function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n 2344:   if(writer._closedPromiseState === 'pending') {\n 2345:     defaultWriterClosedPromiseReject(writer, error);\n 2346    } else {\n 2347:     defaultWriterClosedPromiseResetToRejected(writer, error);\n 2348    }\n 2349  }\n 2350: function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n 2351:   if(writer._readyPromiseState === 'pending') {\n 2352:     defaultWriterReadyPromiseReject(writer, error);\n 2353    } else {\n 2354:     defaultWriterReadyPromiseResetToRejected(writer, error);\n 2355    }\n 2356  }\n 2357: function WritableStreamDefaultWriterGetDesiredSize(writer) {\n 2358:   const stream = writer._ownerWritableStream;\n 2359    const state = stream._state;\n 2360    if(state === 'errored' || state === 'erroring') {\n ....\n 2366    return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n 2367  }\n 2368: function WritableStreamDefaultWriterRelease(writer) {\n 2369:   const stream = writer._ownerWritableStream;\n 2370    assert_default(stream !== undefined);\n 2371:   assert_default(stream._writer === writer);\n 2372    const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n 2373:   WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n 2374:   WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n 2375    stream._writer = undefined;\n 2376:   writer._ownerWritableStream = undefined;\n 2377  }\n 2378: function WritableStreamDefaultWriterWrite(writer, chunk) {\n 2379:   const stream = writer._ownerWritableStream;\n 2380    assert_default(stream !== undefined);\n 2381    const controller = stream._writableStreamController;\n 2382    const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n 2383:   if(stream !== writer._ownerWritableStream) {\n 2384:     return promiseRejectedWith(defaultWriterLockException('write to'));\n 2385    }\n 2386    const state = stream._state;\n ....\n 2470    return x instanceof WritableStreamDefaultController;\n 2471  }\n 2472: function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n 2473    assert_default(IsWritableStream(stream));\n 2474    assert_default(stream._writableStreamController === undefined);\n ....\n 2483    controller._strategySizeAlgorithm = sizeAlgorithm;\n 2484    controller._strategyHWM = highWaterMark;\n 2485:   controller._writeAlgorithm = writeAlgorithm;\n 2486    controller._closeAlgorithm = closeAlgorithm;\n 2487    controller._abortAlgorithm = abortAlgorithm;\n ....\n 2509    const controller = Object.create(WritableStreamDefaultController.prototype);\n 2510    let startAlgorithm;\n 2511:   let writeAlgorithm;\n 2512    let closeAlgorithm;\n 2513    let abortAlgorithm;\n ....\n 2519      };\n 2520    }\n 2521:   if(underlyingSink.write !== undefined) {\n 2522:     writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n 2523    } else {\n 2524:     writeAlgorithm = () => promiseResolvedWith(undefined);\n 2525    }\n 2526    if(underlyingSink.close !== undefined) {\n ....\n 2534      abortAlgorithm = () => promiseResolvedWith(undefined);\n 2535    }\n 2536:   SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n 2537  }\n 2538  function WritableStreamDefaultControllerClearAlgorithms(controller) {\n ....\n 2670  }\n 2671  function defaultWriterLockException(name) {\n 2672:   return new TypeError('Cannot ' + name + ' a stream using a released writer');\n 2673  }\n 2674: function defaultWriterClosedPromiseInitialize(writer) {\n 2675:   writer._closedPromise = newPromise((resolve, reject) => {\n 2676:     writer._closedPromise_resolve = resolve;\n 2677:     writer._closedPromise_reject = reject;\n 2678:     writer._closedPromiseState = 'pending';\n 2679    });\n 2680  }\n 2681: function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n 2682:   defaultWriterClosedPromiseInitialize(writer);\n 2683:   defaultWriterClosedPromiseReject(writer, reason);\n 2684  }\n 2685: function defaultWriterClosedPromiseInitializeAsResolved(writer) {\n 2686:   defaultWriterClosedPromiseInitialize(writer);\n 2687:   defaultWriterClosedPromiseResolve(writer);\n 2688  }\n 2689: function defaultWriterClosedPromiseReject(writer, reason) {\n 2690:   if(writer._closedPromise_reject === undefined) {\n 2691      return;\n 2692    }\n 2693:   assert_default(writer._closedPromiseState === 'pending');\n 2694:   setPromiseIsHandledToTrue(writer._closedPromise);\n 2695:   writer._closedPromise_reject(reason);\n 2696:   writer._closedPromise_resolve = undefined;\n 2697:   writer._closedPromise_reject = undefined;\n 2698:   writer._closedPromiseState = 'rejected';\n 2699  }\n 2700: function defaultWriterClosedPromiseResetToRejected(writer, reason) {\n 2701:   assert_default(writer._closedPromise_resolve === undefined);\n 2702:   assert_default(writer._closedPromise_reject === undefined);\n 2703:   assert_default(writer._closedPromiseState !== 'pending');\n 2704:   defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n 2705  }\n 2706: function defaultWriterClosedPromiseResolve(writer) {\n 2707:   if(writer._closedPromise_resolve === undefined) {\n 2708      return;\n 2709    }\n 2710:   assert_default(writer._closedPromiseState === 'pending');\n 2711:   writer._closedPromise_resolve(undefined);\n 2712:   writer._closedPromise_resolve = undefined;\n 2713:   writer._closedPromise_reject = undefined;\n 2714:   writer._closedPromiseState = 'resolved';\n 2715  }\n 2716: function defaultWriterReadyPromiseInitialize(writer) {\n 2717:   writer._readyPromise = newPromise((resolve, reject) => {\n 2718:     writer._readyPromise_resolve = resolve;\n 2719:     writer._readyPromise_reject = reject;\n 2720    });\n 2721:   writer._readyPromiseState = 'pending';\n 2722  }\n 2723: function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n 2724:   defaultWriterReadyPromiseInitialize(writer);\n 2725:   defaultWriterReadyPromiseReject(writer, reason);\n 2726  }\n 2727: function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n 2728:   defaultWriterReadyPromiseInitialize(writer);\n 2729:   defaultWriterReadyPromiseResolve(writer);\n 2730  }\n 2731: function defaultWriterReadyPromiseReject(writer, reason) {\n 2732:   if(writer._readyPromise_reject === undefined) {\n 2733      return;\n 2734    }\n 2735:   setPromiseIsHandledToTrue(writer._readyPromise);\n 2736:   writer._readyPromise_reject(reason);\n 2737:   writer._readyPromise_resolve = undefined;\n 2738:   writer._readyPromise_reject = undefined;\n 2739:   writer._readyPromiseState = 'rejected';\n 2740  }\n 2741: function defaultWriterReadyPromiseReset(writer) {\n 2742:   assert_default(writer._readyPromise_resolve === undefined);\n 2743:   assert_default(writer._readyPromise_reject === undefined);\n 2744:   defaultWriterReadyPromiseInitialize(writer);\n 2745  }\n 2746: function defaultWriterReadyPromiseResetToRejected(writer, reason) {\n 2747:   assert_default(writer._readyPromise_resolve === undefined);\n 2748:   assert_default(writer._readyPromise_reject === undefined);\n 2749:   defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n 2750  }\n 2751: function defaultWriterReadyPromiseResolve(writer) {\n 2752:   if(writer._readyPromise_resolve === undefined) {\n 2753      return;\n 2754    }\n 2755:   writer._readyPromise_resolve(undefined);\n 2756:   writer._readyPromise_resolve = undefined;\n 2757:   writer._readyPromise_reject = undefined;\n 2758:   writer._readyPromiseState = 'fulfilled';\n 2759  }\n 2760  \n ....\n 2806  var DOMException = getFromGlobal() || createPolyfill();\n 2807  \n 2808: // src/lib/readable-stream/pipe.ts\n 2809  function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n 2810    assert_default(IsReadableStream(source));\n ....\n 2816    assert_default(!IsReadableStreamLocked(source));\n 2817    assert_default(!IsWritableStreamLocked(dest));\n 2818:   const reader = AcquireReadableStreamDefaultReader(source);\n 2819:   const writer = AcquireWritableStreamDefaultWriter(dest);\n 2820    source._disturbed = true;\n 2821    let shuttingDown = false;\n ....\n 2837          if(!preventCancel) {\n 2838            actions.push(() => {\n 2839:             if(source._state === 'readable') {\n 2840                return ReadableStreamCancel(source, error);\n 2841              }\n ....\n 2867          return promiseResolvedWith(true);\n 2868        }\n 2869:       return PerformPromiseThen(writer._readyPromise, () => {\n 2870          return newPromise((resolveRead, rejectRead) => {\n 2871:           ReadableStreamDefaultReaderRead(reader, {\n 2872              _chunkSteps: chunk => {\n 2873:               currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n 2874                resolveRead(false);\n 2875              },\n ....\n 2880        });\n 2881      }\n 2882:     isOrBecomesErrored(source, reader._closedPromise, storedError => {\n 2883        if(!preventAbort) {\n 2884          shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n ....\n 2888        return null;\n 2889      });\n 2890:     isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n 2891        if(!preventCancel) {\n 2892          shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n ....\n 2896        return null;\n 2897      });\n 2898:     isOrBecomesClosed(source, reader._closedPromise, () => {\n 2899        if(!preventClose) {\n 2900:         shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n 2901        } else {\n 2902          shutdown();\n ....\n 2962      }\n 2963      function finalize(isError, error) {\n 2964:       WritableStreamDefaultWriterRelease(writer);\n 2965:       ReadableStreamReaderGenericRelease(reader);\n 2966        if(signal !== undefined) {\n 2967          signal.removeEventListener('abort', abortAlgorithm);\n ....\n 2977  }\n 2978  \n 2979: // src/lib/readable-stream/default-controller.ts\n 2980  class ReadableStreamDefaultController {\n 2981    _controlledReadableStream;\n ....\n 3029      return result;\n 3030    }\n 3031:   [PullSteps](readRequest) {\n 3032      const stream = this._controlledReadableStream;\n 3033      if(this._queue.length > 0) {\n ....\n 3039          ReadableStreamDefaultControllerCallPullIfNeeded(this);\n 3040        }\n 3041:       readRequest._chunkSteps(chunk);\n 3042      } else {\n 3043:       ReadableStreamAddReadRequest(stream, readRequest);\n 3044        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n 3045      }\n ....\n 3159  function ReadableStreamDefaultControllerError(controller, e) {\n 3160    const stream = controller._controlledReadableStream;\n 3161:   if(stream._state !== 'readable') {\n 3162      return;\n 3163    }\n ....\n 3184  function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n 3185    const state = controller._controlledReadableStream._state;\n 3186:   if(!controller._closeRequested && state === 'readable') {\n 3187      return true;\n 3188    }\n ....\n 3248  }\n 3249  \n 3250: // src/lib/readable-stream/tee.ts\n 3251  function ReadableStreamTee(stream, cloneForBranch2) {\n 3252    assert_default(IsReadableStream(stream));\n ....\n 3260    assert_default(IsReadableStream(stream));\n 3261    assert_default(typeof cloneForBranch2 === 'boolean');\n 3262:   const reader = AcquireReadableStreamDefaultReader(stream);\n 3263:   let reading = false;\n 3264:   let readAgain = false;\n 3265    let canceled1 = false;\n 3266    let canceled2 = false;\n ....\n 3274    });\n 3275    function pullAlgorithm() {\n 3276:     if(reading) {\n 3277:       readAgain = true;\n 3278        return promiseResolvedWith(undefined);\n 3279      }\n 3280:     reading = true;\n 3281:     const readRequest = {\n 3282        _chunkSteps: chunk => {\n 3283          _queueMicrotask(() => {\n 3284:           readAgain = false;\n 3285            const chunk1 = chunk;\n 3286            const chunk2 = chunk;\n ....\n 3291              ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n 3292            }\n 3293:           reading = false;\n 3294:           if(readAgain) {\n 3295              pullAlgorithm();\n 3296            }\n ....\n 3298        },\n 3299        _closeSteps: () => {\n 3300:         reading = false;\n 3301          if(!canceled1) {\n 3302            ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n ....\n 3310        },\n 3311        _errorSteps: () => {\n 3312:         reading = false;\n 3313        },\n 3314      };\n 3315:     ReadableStreamDefaultReaderRead(reader, readRequest);\n 3316      return promiseResolvedWith(undefined);\n 3317    }\n ....\n 3339    branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n 3340    branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n 3341:   uponRejection(reader._closedPromise, r => {\n 3342      ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n 3343      ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n ....\n 3352    assert_default(IsReadableStream(stream));\n 3353    assert_default(IsReadableByteStreamController(stream._readableStreamController));\n 3354:   let reader = AcquireReadableStreamDefaultReader(stream);\n 3355:   let reading = false;\n 3356:   let readAgainForBranch1 = false;\n 3357:   let readAgainForBranch2 = false;\n 3358    let canceled1 = false;\n 3359    let canceled2 = false;\n ....\n 3368    function forwardReaderError(thisReader) {\n 3369      uponRejection(thisReader._closedPromise, r => {\n 3370:       if(thisReader !== reader) {\n 3371          return null;\n 3372        }\n ....\n 3380    }\n 3381    function pullWithDefaultReader() {\n 3382:     if(IsReadableStreamBYOBReader(reader)) {\n 3383:       assert_default(reader._readIntoRequests.length === 0);\n 3384:       ReadableStreamReaderGenericRelease(reader);\n 3385:       reader = AcquireReadableStreamDefaultReader(stream);\n 3386:       forwardReaderError(reader);\n 3387      }\n 3388:     const readRequest = {\n 3389        _chunkSteps: chunk => {\n 3390          _queueMicrotask(() => {\n 3391:           readAgainForBranch1 = false;\n 3392:           readAgainForBranch2 = false;\n 3393            const chunk1 = chunk;\n 3394            let chunk2 = chunk;\n ....\n 3409              ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n 3410            }\n 3411:           reading = false;\n 3412:           if(readAgainForBranch1) {\n 3413              pull1Algorithm();\n 3414:           } else if(readAgainForBranch2) {\n 3415              pull2Algorithm();\n 3416            }\n ....\n 3418        },\n 3419        _closeSteps: () => {\n 3420:         reading = false;\n 3421          if(!canceled1) {\n 3422            ReadableByteStreamControllerClose(branch1._readableStreamController);\n ....\n 3436        },\n 3437        _errorSteps: () => {\n 3438:         reading = false;\n 3439        },\n 3440      };\n 3441:     ReadableStreamDefaultReaderRead(reader, readRequest);\n 3442    }\n 3443    function pullWithBYOBReader(view, forBranch2) {\n 3444:     if(IsReadableStreamDefaultReader(reader)) {\n 3445:       assert_default(reader._readRequests.length === 0);\n 3446:       ReadableStreamReaderGenericRelease(reader);\n 3447:       reader = AcquireReadableStreamBYOBReader(stream);\n 3448:       forwardReaderError(reader);\n 3449      }\n 3450      const byobBranch = forBranch2 ? branch2 : branch1;\n 3451      const otherBranch = forBranch2 ? branch1 : branch2;\n 3452:     const readIntoRequest = {\n 3453        _chunkSteps: chunk => {\n 3454          _queueMicrotask(() => {\n 3455:           readAgainForBranch1 = false;\n 3456:           readAgainForBranch2 = false;\n 3457            const byobCanceled = forBranch2 ? canceled2 : canceled1;\n 3458            const otherCanceled = forBranch2 ? canceled1 : canceled2;\n ....\n 3474              ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n 3475            }\n 3476:           reading = false;\n 3477:           if(readAgainForBranch1) {\n 3478              pull1Algorithm();\n 3479:           } else if(readAgainForBranch2) {\n 3480              pull2Algorithm();\n 3481            }\n ....\n 3483        },\n 3484        _closeSteps: chunk => {\n 3485:         reading = false;\n 3486          const byobCanceled = forBranch2 ? canceled2 : canceled1;\n 3487          const otherCanceled = forBranch2 ? canceled1 : canceled2;\n ....\n 3506        },\n 3507        _errorSteps: () => {\n 3508:         reading = false;\n 3509        },\n 3510      };\n 3511:     ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);\n 3512    }\n 3513    function pull1Algorithm() {\n 3514:     if(reading) {\n 3515:       readAgainForBranch1 = true;\n 3516        return promiseResolvedWith(undefined);\n 3517      }\n 3518:     reading = true;\n 3519      const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n 3520      if(byobRequest === null) {\n ....\n 3526    }\n 3527    function pull2Algorithm() {\n 3528:     if(reading) {\n 3529:       readAgainForBranch2 = true;\n 3530        return promiseResolvedWith(undefined);\n 3531      }\n 3532:     reading = true;\n 3533      const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n 3534      if(byobRequest === null) {\n ....\n 3564    branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n 3565    branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n 3566:   forwardReaderError(reader);\n 3567    return [branch1, branch2];\n 3568  }\n 3569  \n 3570: // src/lib/readable-stream/readable-stream-like.ts\n 3571  function isReadableStreamLike(stream) {\n 3572    return typeIsObject(stream) && typeof stream.getReader !== 'undefined';\n 3573  }\n 3574  \n 3575: // src/lib/readable-stream/from.ts\n 3576  function ReadableStreamFrom(source) {\n 3577    if(isReadableStreamLike(source)) {\n ....\n 3627    return stream;\n 3628  }\n 3629: function ReadableStreamFromDefaultReader(reader) {\n 3630    let stream;\n 3631    const startAlgorithm = noop;\n 3632    function pullAlgorithm() {\n 3633:     let readPromise;\n 3634      try {\n 3635:       readPromise = reader.read();\n 3636      } catch(e) {\n 3637        return promiseRejectedWith(e);\n 3638      }\n 3639:     return transformPromiseWith(readPromise, readResult => {\n 3640:       if(!typeIsObject(readResult)) {\n 3641:         throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\n 3642        }\n 3643:       if(readResult.done) {\n 3644          ReadableStreamDefaultControllerClose(stream._readableStreamController);\n 3645        } else {\n 3646:         const value = readResult.value;\n 3647          ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\n 3648        }\n ....\n 3651    function cancelAlgorithm(reason) {\n 3652      try {\n 3653:       return promiseResolvedWith(reader.cancel(reason));\n 3654      } catch(e) {\n 3655        return promiseRejectedWith(e);\n ....\n 3727  }\n 3728  \n 3729: // src/lib/validators/readable-writable-pair.ts\n 3730  function convertReadableWritablePair(pair, context) {\n 3731    assertDictionary(pair, context);\n 3732:   const readable = pair?.readable;\n 3733:   assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n 3734:   assertReadableStream(readable, `${context} has member 'readable' that`);\n 3735    const writable = pair?.writable;\n 3736    assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n 3737    assertWritableStream(writable, `${context} has member 'writable' that`);\n 3738:   return { readable, writable };\n 3739  }\n 3740  \n 3741: // src/lib/readable-stream.ts\n 3742  class ReadableStream7 {\n 3743    _state;\n ....\n 3779      }\n 3780      if(IsReadableStreamLocked(this)) {\n 3781:       return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n 3782      }\n 3783      return ReadableStreamCancel(this, reason);\n ....\n 3809      const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n 3810      setPromiseIsHandledToTrue(promise);\n 3811:     return transform.readable;\n 3812    }\n 3813    pipeTo(destination, rawOptions = {}) {\n ....\n 3902  }\n 3903  function InitializeReadableStream(stream) {\n 3904:   stream._state = 'readable';\n 3905    stream._reader = undefined;\n 3906    stream._storedError = undefined;\n ....\n 3932    }\n 3933    ReadableStreamClose(stream);\n 3934:   const reader = stream._reader;\n 3935:   if(reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n 3936:     const readIntoRequests = reader._readIntoRequests;\n 3937:     reader._readIntoRequests = new SimpleQueue();\n 3938:     readIntoRequests.forEach(readIntoRequest => {\n 3939:       readIntoRequest._closeSteps(undefined);\n 3940      });\n 3941    }\n ....\n 3944  }\n 3945  function ReadableStreamClose(stream) {\n 3946:   assert_default(stream._state === 'readable');\n 3947    stream._state = 'closed';\n 3948:   const reader = stream._reader;\n 3949:   if(reader === undefined) {\n 3950      return;\n 3951    }\n 3952:   defaultReaderClosedPromiseResolve(reader);\n 3953:   if(IsReadableStreamDefaultReader(reader)) {\n 3954:     const readRequests = reader._readRequests;\n 3955:     reader._readRequests = new SimpleQueue();\n 3956:     readRequests.forEach(readRequest => {\n 3957:       readRequest._closeSteps();\n 3958      });\n 3959    }\n ....\n 3961  function ReadableStreamError(stream, e) {\n 3962    assert_default(IsReadableStream(stream));\n 3963:   assert_default(stream._state === 'readable');\n 3964    stream._state = 'errored';\n 3965    stream._storedError = e;\n 3966:   const reader = stream._reader;\n 3967:   if(reader === undefined) {\n 3968      return;\n 3969    }\n 3970:   defaultReaderClosedPromiseReject(reader, e);\n 3971:   if(IsReadableStreamDefaultReader(reader)) {\n 3972:     ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n 3973    } else {\n 3974:     assert_default(IsReadableStreamBYOBReader(reader));\n 3975:     ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n 3976    }\n 3977  }\n ....\n 4090    const cancel = original?.cancel;\n 4091    const flush = original?.flush;\n 4092:   const readableType = original?.readableType;\n 4093    const start = original?.start;\n 4094    const transform = original?.transform;\n ....\n 4097      cancel: cancel === undefined ? undefined : convertTransformerCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n 4098      flush: flush === undefined ? undefined : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\n 4099:     readableType,\n 4100      start: start === undefined ? undefined : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),\n 4101      transform: transform === undefined ? undefined : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),\n ....\n 4133      }\n 4134      const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n 4135:     const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n 4136      const transformer = convertTransformer(rawTransformer, 'First parameter');\n 4137:     if(transformer.readableType !== undefined) {\n 4138:       throw new RangeError('Invalid readableType specified');\n 4139      }\n 4140      if(transformer.writableType !== undefined) {\n 4141        throw new RangeError('Invalid writableType specified');\n 4142      }\n 4143:     const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n 4144:     const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n 4145      const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n 4146      const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n ....\n 4149        startPromise_resolve = resolve;\n 4150      });\n 4151:     InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n 4152      SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n 4153      if(transformer.start !== undefined) {\n ....\n 4157      }\n 4158    }\n 4159:   get readable() {\n 4160      if(!IsTransformStream(this)) {\n 4161:       throw streamBrandCheckException3('readable');\n 4162      }\n 4163      return this._readable;\n ....\n 4171  }\n 4172  Object.defineProperties(TransformStream.prototype, {\n 4173:   readable: { enumerable: true },\n 4174    writable: { enumerable: true },\n 4175  });\n ....\n 4180    });\n 4181  }\n 4182: function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n 4183    function startAlgorithm() {\n 4184      return startPromise;\n 4185    }\n 4186:   function writeAlgorithm(chunk) {\n 4187      return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n 4188    }\n ....\n 4193      return TransformStreamDefaultSinkCloseAlgorithm(stream);\n 4194    }\n 4195:   stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n 4196    function pullAlgorithm() {\n 4197      return TransformStreamDefaultSourcePullAlgorithm(stream);\n ....\n 4200      return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);\n 4201    }\n 4202:   stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n 4203    stream._backpressure = undefined;\n 4204    stream._backpressureChangePromise = undefined;\n ....\n 4256        throw defaultControllerBrandCheckException3('desiredSize');\n 4257      }\n 4258:     const readableController = this._controlledTransformStream._readable._readableStreamController;\n 4259:     return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n 4260    }\n 4261    enqueue(chunk = undefined) {\n ....\n 4350  function TransformStreamDefaultControllerEnqueue(controller, chunk) {\n 4351    const stream = controller._controlledTransformStream;\n 4352:   const readableController = stream._readable._readableStreamController;\n 4353:   if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n 4354      throw new TypeError('Readable side is not in a state that permits enqueue');\n 4355    }\n 4356    try {\n 4357:     ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n 4358    } catch(e) {\n 4359      TransformStreamErrorWritableAndUnblockWrite(stream, e);\n 4360      throw stream._readable._storedError;\n 4361    }\n 4362:   const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n 4363    if(backpressure !== stream._backpressure) {\n 4364      assert_default(backpressure);\n ....\n 4378  function TransformStreamDefaultControllerTerminate(controller) {\n 4379    const stream = controller._controlledTransformStream;\n 4380:   const readableController = stream._readable._readableStreamController;\n 4381:   ReadableStreamDefaultControllerClose(readableController);\n 4382    const error = new TypeError('TransformStream terminated');\n 4383    TransformStreamErrorWritableAndUnblockWrite(stream, error);\n ....\n 4406      return controller._finishPromise;\n 4407    }\n 4408:   const readable = stream._readable;\n 4409    controller._finishPromise = newPromise((resolve, reject) => {\n 4410      controller._finishPromise_resolve = resolve;\n ....\n 4416      cancelPromise,\n 4417      () => {\n 4418:       if(readable._state === 'errored') {\n 4419:         defaultControllerFinishPromiseReject(controller, readable._storedError);\n 4420        } else {\n 4421:         ReadableStreamDefaultControllerError(readable._readableStreamController, reason);\n 4422          defaultControllerFinishPromiseResolve(controller);\n 4423        }\n ....\n 4425      },\n 4426      r => {\n 4427:       ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n 4428        defaultControllerFinishPromiseReject(controller, r);\n 4429        return null;\n ....\n 4437      return controller._finishPromise;\n 4438    }\n 4439:   const readable = stream._readable;\n 4440    controller._finishPromise = newPromise((resolve, reject) => {\n 4441      controller._finishPromise_resolve = resolve;\n ....\n 4447      flushPromise,\n 4448      () => {\n 4449:       if(readable._state === 'errored') {\n 4450:         defaultControllerFinishPromiseReject(controller, readable._storedError);\n 4451        } else {\n 4452:         ReadableStreamDefaultControllerClose(readable._readableStreamController);\n 4453          defaultControllerFinishPromiseResolve(controller);\n 4454        }\n ....\n 4456      },\n 4457      r => {\n 4458:       ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n 4459        defaultControllerFinishPromiseReject(controller, r);\n 4460        return null;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/index.module.js:\n    1: <skipped 88 characters> ...eStreamBYOBRequest, ReadableStreamDefaultController, ReadableStreamDefaultReader, } from './src/lib/readable-stream.js';\n    2  import { TransformStream } from './src/lib/transform-stream.js';\n    3  import { default as ByteLengthQueuingStrategy, IsByteLengthQueuingStrategy } from './src/lib/byte-length-queuing-strategy.js';\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/index.js:\n    1: <skipped 170 characters> ...eStreamBYOBRequest, ReadableStreamDefaultController, ReadableStreamDefaultReader, } from './src/lib/readable-stream.js';\n    2  import { WritableStreamDefaultController, WritableStreamDefaultWriter } from './src/lib/writable-stream.js';\n    3  import { TransformStreamDefaultController } from './src/lib/transform-stream.js';\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/simple-queue.js:\n   52      ++this._size;\n   53    }\n   54:   // Like push(), shift() follows the read -> calculate -> mutate pattern for\n   55    // exception safety.\n   56    shift() {\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/transform-stream.js:\n    1  import assert from '../stub/assert';\n    2  import { newPromise, promiseRejectedWith, promiseResolvedWith, setPromiseIsHandledToTrue, transformPromiseWith, uponPromise } from './helpers/webidl';\n    3: import { CreateReadableStream, ReadableStream } from './readable-stream';\n    4: <skipped 180 characters> ...bleStreamDefaultControllerGetDesiredSize, ReadableStreamDefaultControllerHasBackpressure, } from './readable-stream/default-controller';\n    5  import { CreateWritableStream, WritableStream, WritableStreamDefaultControllerErrorIfNeeded } from './writable-stream';\n    6  import { setFunctionName, typeIsObject } from './helpers/miscellaneous';\n    .\n   12  /**\n   13   * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n   14:  * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n   15:  * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n   16:  * made available for reading from the readable side.\n   17   *\n   18   * @public\n   ..\n   24      }\n   25      const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n   26:     const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n   27      const transformer = convertTransformer(rawTransformer, 'First parameter');\n   28:     if(transformer.readableType !== undefined) {\n   29:       throw new RangeError('Invalid readableType specified');\n   30      }\n   31      if(transformer.writableType !== undefined) {\n   32        throw new RangeError('Invalid writableType specified');\n   33      }\n   34:     const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n   35:     const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n   36      const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n   37      const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n   ..\n   40        startPromise_resolve = resolve;\n   41      });\n   42:     InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n   43      SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n   44      if(transformer.start !== undefined) {\n   ..\n   49    }\n   50    /**\n   51:    * The readable side of the transform stream.\n   52     */\n   53:   get readable() {\n   54      if(!IsTransformStream(this)) {\n   55:       throw streamBrandCheckException('readable');\n   56      }\n   57      return this._readable;\n   ..\n   68  }\n   69  Object.defineProperties(TransformStream.prototype, {\n   70:   readable: { enumerable: true },\n   71    writable: { enumerable: true },\n   72  });\n   ..\n   85    writableHighWaterMark = 1,\n   86    writableSizeAlgorithm = () => 1,\n   87:   readableHighWaterMark = 0,\n   88:   readableSizeAlgorithm = () => 1,\n   89  ) {\n   90    assert(IsNonNegativeNumber(writableHighWaterMark));\n   91:   assert(IsNonNegativeNumber(readableHighWaterMark));\n   92    const stream = Object.create(TransformStream.prototype);\n   93    let startPromise_resolve;\n   ..\n   95      startPromise_resolve = resolve;\n   96    });\n   97:   InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n   98    const controller = Object.create(TransformStreamDefaultController.prototype);\n   99    SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);\n  ...\n  102    return stream;\n  103  }\n  104: function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n  105    function startAlgorithm() {\n  106      return startPromise;\n  107    }\n  108:   function writeAlgorithm(chunk) {\n  109      return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  110    }\n  ...\n  115      return TransformStreamDefaultSinkCloseAlgorithm(stream);\n  116    }\n  117:   stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n  118    function pullAlgorithm() {\n  119      return TransformStreamDefaultSourcePullAlgorithm(stream);\n  ...\n  122      return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);\n  123    }\n  124:   stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n  125    // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n  126    stream._backpressure = undefined;\n  ...\n  151  function TransformStreamUnblockWrite(stream) {\n  152    if(stream._backpressure) {\n  153:     // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n  154      // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n  155      // _backpressure is set.\n  ...\n  179    }\n  180    /**\n  181:    * Returns the desired size to fill the readable sideâ€™s internal queue. It can be negative, if the queue is over-full.\n  182     */\n  183    get desiredSize() {\n  ...\n  185        throw defaultControllerBrandCheckException('desiredSize');\n  186      }\n  187:     const readableController = this._controlledTransformStream._readable._readableStreamController;\n  188:     return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n  189    }\n  190    enqueue(chunk = undefined) {\n  ...\n  195    }\n  196    /**\n  197:    * Errors both the readable side and the writable side of the controlled transform stream, making all future\n  198     * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n  199     */\n  ...\n  205    }\n  206    /**\n  207:    * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n  208     * transformer only needs to consume a portion of the chunks written to the writable side.\n  209     */\n  ...\n  288  function TransformStreamDefaultControllerEnqueue(controller, chunk) {\n  289    const stream = controller._controlledTransformStream;\n  290:   const readableController = stream._readable._readableStreamController;\n  291:   if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n  292      throw new TypeError('Readable side is not in a state that permits enqueue');\n  293    }\n  ...\n  295    // accept TransformStreamDefaultControllerEnqueue() calls.\n  296    try {\n  297:     ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n  298    } catch(e) {\n  299:     // This happens when readableStrategy.size() throws.\n  300      TransformStreamErrorWritableAndUnblockWrite(stream, e);\n  301      throw stream._readable._storedError;\n  302    }\n  303:   const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n  304    if(backpressure !== stream._backpressure) {\n  305      assert(backpressure);\n  ...\n  319  function TransformStreamDefaultControllerTerminate(controller) {\n  320    const stream = controller._controlledTransformStream;\n  321:   const readableController = stream._readable._readableStreamController;\n  322:   ReadableStreamDefaultControllerClose(readableController);\n  323    const error = new TypeError('TransformStream terminated');\n  324    TransformStreamErrorWritableAndUnblockWrite(stream, error);\n  ...\n  349    }\n  350    // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  351:   const readable = stream._readable;\n  352:   // Assign the _finishPromise now so that if _cancelAlgorithm calls readable.cancel() internally,\n  353    // we don't run the _cancelAlgorithm again.\n  354    controller._finishPromise = newPromise((resolve, reject) => {\n  ...\n  361      cancelPromise,\n  362      () => {\n  363:       if(readable._state === 'errored') {\n  364:         defaultControllerFinishPromiseReject(controller, readable._storedError);\n  365        } else {\n  366:         ReadableStreamDefaultControllerError(readable._readableStreamController, reason);\n  367          defaultControllerFinishPromiseResolve(controller);\n  368        }\n  ...\n  370      },\n  371      r => {\n  372:       ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n  373        defaultControllerFinishPromiseReject(controller, r);\n  374        return null;\n  ...\n  383    }\n  384    // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  385:   const readable = stream._readable;\n  386:   // Assign the _finishPromise now so that if _flushAlgorithm calls readable.cancel() internally,\n  387    // we don't also run the _cancelAlgorithm.\n  388    controller._finishPromise = newPromise((resolve, reject) => {\n  ...\n  395      flushPromise,\n  396      () => {\n  397:       if(readable._state === 'errored') {\n  398:         defaultControllerFinishPromiseReject(controller, readable._storedError);\n  399        } else {\n  400:         ReadableStreamDefaultControllerClose(readable._readableStreamController);\n  401          defaultControllerFinishPromiseResolve(controller);\n  402        }\n  ...\n  404      },\n  405      r => {\n  406:       ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n  407        defaultControllerFinishPromiseReject(controller, r);\n  408        return null;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/types/polyfill.d.ts:\n   11       * Asynchronously iterates over the chunks in the stream's internal queue.\n   12       *\n   13:      * Asynchronously iterating over the stream will lock it, preventing any other consumer from acquiring a reader.\n   14       * The lock will be released if the async iterator's {@link ReadableStreamAsyncIterator.return | return()} method\n   15       * is called, e.g. by breaking out of the loop.\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/benchmark/index.js:\n   22      }\n   23    });\n   24:   const reader = rs.getReader();\n   25:   return readLoop(count, reader)\n   26      .then(() => deferred.resolve());\n   27  }\n   28  \n   29: function readLoop(count, reader) {\n   30:   return reader.read().then((result) => {\n   31      if (result.done) {\n   32        return undefined;\n   33      }\n   34:     return readLoop(count, reader);\n   35    });\n   36  }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/types/transform-stream.ts:\n   24  );\n   25  const writable: polyfill.WritableStream<string> = transformStream.writable;\n   26: const readable: polyfill.ReadableStream<number> = transformStream.readable;\n   27  \n   28  // Compatibility with stream types from DOM\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/types/readable-stream.ts:\n   45  };\n   46  \n   47: const readableStream: polyfill.ReadableStream<string> = new polyfill.ReadableStream<string>(\n   48    underlyingSource,\n   49    { highWaterMark: 0, size: (chunk: string) => 1 }\n   50  );\n   51: const readableByteStream: polyfill.ReadableStream<Uint8Array> = new polyfill.ReadableStream(\n   52    underlyingByteSource,\n   53    { highWaterMark: 1024 }\n   54  );\n   55  \n   56: const locked: boolean = readableStream.locked;\n   57  \n   58: const defaultReader: polyfill.ReadableStreamDefaultReader<string> = readableStream.getReader();\n   59: const defaultReaderReadPromise: Promise<polyfill.ReadableStreamDefaultReadResult<string>> = defaultReader.read();\n   60  defaultReaderReadPromise.then((result) => {\n   61    const done: boolean = result.done;\n   ..\n   69  const defaultReaderReleaseLockResult: void = defaultReader.releaseLock();\n   70  \n   71: const byobReader: polyfill.ReadableStreamBYOBReader = readableByteStream.getReader({ mode: 'byob' });\n   72: const byobReaderReadUint32Promise: Promise<polyfill.ReadableStreamBYOBReadResult<Uint32Array>> = byobReader.read(new Uint32Array(3));\n   73: const byobReaderReadDataViewPromise: Promise<polyfill.ReadableStreamBYOBReadResult<DataView>> = byobReader.read(\n   74    new DataView(new ArrayBuffer(3))\n   75  );\n   ..\n   85  const byobReaderReleaseLockResult: void = byobReader.releaseLock();\n   86  \n   87: const cancelPromise: Promise<void> = readableStream.cancel('canceled');\n   88  \n   89: const teedStreams: [polyfill.ReadableStream<string>, polyfill.ReadableStream<string>] = readableStream.tee();\n   90  \n   91  const writableStream: polyfill.WritableStream<string> = new polyfill.WritableStream();\n   92: const pipePromise: Promise<void> = readableStream\n   93    .pipeTo(writableStream, {\n   94      preventAbort: true,\n   ..\n   97      signal: new AbortController().signal\n   98    });\n   99: const pipeThroughStream: polyfill.ReadableStream<Uint8Array> = readableStream\n  100:   .pipeThrough({ writable: writableStream, readable: readableByteStream }, {\n  101      preventAbort: undefined,\n  102      preventCancel: undefined,\n  ...\n  105    });\n  106  \n  107: const valuesResult: polyfill.ReadableStreamAsyncIterator<string> = readableStream.values({ preventCancel: true });\n  108  \n  109: const asyncIterator: polyfill.ReadableStreamAsyncIterator<string> = readableStream[Symbol.asyncIterator]();\n  110  const asyncIteratorNextResult: Promise<IteratorResult<string>> = asyncIterator.next();\n  111  const asyncIteratorReturnResult: Promise<IteratorResult<any>> = asyncIterator.return('returned');\n  112  \n  113  (async () => {\n  114:   for await (const chunk of readableStream) {\n  115      const chunkAsString: string = chunk;\n  116    }\n  ...\n  123  const domUnderlyingByteSource: UnderlyingByteSource = underlyingByteSource;\n  124  \n  125: const domReadableStream: ReadableStream<string> = readableStream;\n  126: const domReadableByteStream: ReadableStream<Uint8Array> = readableByteStream;\n  127  \n  128  const domDefaultController: ReadableStreamDefaultController<string> = defaultController;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/types/writable-stream.ts:\n    7      c.error(new TypeError('error'));\n    8    },\n    9:   write(chunk: string, c: polyfill.WritableStreamDefaultController) {\n   10      return Promise.resolve();\n   11    },\n   ..\n   28  const locked: boolean = writableStream.locked;\n   29  \n   30: const writer: polyfill.WritableStreamDefaultWriter<string> = writableStream.getWriter();\n   31: const writerDesiredSize: number | null = writer.desiredSize;\n   32: const writerClosedPromise: Promise<void> = writer.closed;\n   33: const writerReadyPromise: Promise<void> = writer.ready;\n   34: const writerWritePromise: Promise<void> = writer.write('a');\n   35: const writerClosePromise: Promise<void> = writer.close();\n   36: const writerAbortPromise: Promise<void> = writer.abort('aborted');\n   37: const writerReleaseLockResult: void = writer.releaseLock();\n   38  \n   39  const closePromise: Promise<void> = writableStream.close();\n   ..\n   51  const domWritableStream: WritableStream<string> = writableStream;\n   52  const domController: WritableStreamDefaultController = controller;\n   53: const domWriter: WritableStreamDefaultWriter<string> = writer;\n   54  \n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/types/polyfill.ts:\n    4  import 'web-streams-polyfill/polyfill';\n    5  \n    6: const readable = new ReadableStream<Uint8Array>({\n    7    // TODO Figure out a way to augment the type of \"declare var ReadableStream\"?\n    8    // type: 'bytes'\n    9  });\n   10  \n   11: const defaultReader = readable.getReader();\n   12  defaultReader.closed.catch(() => undefined);\n   13: defaultReader.read().then(result => {\n   14    const done: boolean = result.done;\n   15    if (result.done) {\n   ..\n   21  defaultReader.releaseLock();\n   22  \n   23: const byobReader = readable.getReader({ mode: 'byob' });\n   24  byobReader.closed.catch(() => undefined);\n   25: byobReader.read(new Uint32Array(3)).then(result => {\n   26    const done: boolean = result.done;\n   27    if (result.done) {\n   ..\n   33  byobReader.releaseLock();\n   34  \n   35: readable.pipeTo(new WritableStream(), {\n   36    preventAbort: true,\n   37    preventCancel: true,\n   ..\n   40  }).catch(() => undefined);\n   41  \n   42: readable.pipeThrough(new TransformStream());\n   43  \n   44: const [branch1, branch2] = readable.tee();\n   45  \n   46: const iterator1 = readable[Symbol.asyncIterator]();\n   47: const iterator2 = readable.values({ preventCancel: true });\n   48  \n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/webpack/src/index.js:\n    7    }\n    8  }).pipeTo(new WritableStream({\n    9:   write(chunk) {\n   10      console.log(chunk);\n   11    }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/unit/readable-stream/basic.spec.js:\n   11  \n   12    describe('getReader', () => {\n   13:     it('reads chunks from underlying source', async () => {\n   14        const rs = new ReadableStream({\n   15          start(c) {\n   ..\n   19          }\n   20        });\n   21:       const reader = rs.getReader();\n   22:       expect(await reader.read()).toEqual({ done: false, value: 'a' });\n   23:       expect(await reader.read()).toEqual({ done: false, value: 'b' });\n   24:       expect(await reader.read()).toEqual({ done: true, value: undefined });\n   25      });\n   26    });\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/unit/readable-stream/from.spec.js:\n   13      const wrapped = ReadableStream.from(native);\n   14      expect(wrapped instanceof ReadableStream).toBe(true);\n   15:     const reader = wrapped.getReader();\n   16:     await expectAsync(reader.read()).toBeResolvedTo({ done: false, value: 'a' });\n   17:     await expectAsync(reader.read()).toBeResolvedTo({ done: false, value: 'b' });\n   18:     await expectAsync(reader.read()).toBeResolvedTo({ done: true, value: undefined });\n   19    });\n   20  \n   ..\n   22      let i = 0;\n   23      const closedPromise = new Promise(() => {});\n   24:     const readerLike = {\n   25        get closed() { return closedPromise; },\n   26:       async read() { return { done: false, value: ++i }; },\n   27        async cancel() {},\n   28        releaseLock() {}\n   29      };\n   30      const streamLike = {\n   31:       getReader() { return readerLike; }\n   32      };\n   33      const wrapped = ReadableStream.from(streamLike);\n   34      expect(wrapped instanceof ReadableStream).toBe(true);\n   35:     const reader = wrapped.getReader();\n   36:     await expectAsync(reader.read()).toBeResolvedTo({ done: false, value: 1 });\n   37:     await expectAsync(reader.read()).toBeResolvedTo({ done: false, value: 2 });\n   38    });\n   39  });\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/unit/readable-stream/regression.spec.js:\n    4    // https://github.com/MattiasBuelens/web-streams-polyfill/issues/66\n    5    it('#66', async () => {\n    6:     const { readable, writable } = new TransformStream();\n    7  \n    8      const producer = (async () => {\n    9:       const writer = writable.getWriter();\n   10:       await writer.write('hello');\n   11:       // The async iterator releases its reader lock in the \"close steps\" of its pending read, which rejects the\n   12:       // reader's closed promise. However, ReadableStreamClose then tries to resolve that same closed promise.\n   13        // This *should* be ignored (since the promise is already rejected), but instead would cause a TypeError.\n   14:       await writer.close();\n   15      })();\n   16  \n   17      const consumer = (async () => {\n   18        const results = [];\n   19:       for await (const chunk of readable) {\n   20          results.push(chunk);\n   21        }\n   ..\n   50          _transformStreamController: {}\n   51        };\n   52:       const readableGetter = Object.getOwnPropertyDescriptor(TransformStream.prototype, 'readable');\n   53:       expect(() => readableGetter.call(fakeTransformStream)).toThrow(jasmine.any(TypeError));\n   54      });\n   55    });\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/rollup/src/index.js:\n    7    }\n    8  }).pipeTo(new WritableStream({\n    9:   write(chunk) {\n   10      console.log(chunk);\n   11    }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/ponyfill.js:\n    1: <skipped 83 characters> ...adableStreamBYOBRequest, ReadableStreamDefaultController, ReadableStreamDefaultReader } from './lib/readable-stream';\n    2  export { WritableStream, WritableStreamDefaultController, WritableStreamDefaultWriter } from './lib/writable-stream';\n    3  export { default as ByteLengthQueuingStrategy } from './lib/byte-length-queuing-strategy';\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/ponyfill.ts:\n   22    type UnderlyingSourcePullCallback,\n   23    type UnderlyingSourceStartCallback\n   24: } from './lib/readable-stream';\n   25  export {\n   26    type UnderlyingSink,\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/ponyfill.d.ts:\n    1: <skipped 619 characters> ...CancelCallback, type UnderlyingSourcePullCallback, type UnderlyingSourceStartCallback } from './lib/readable-stream';\n    2  export { type UnderlyingSink, type UnderlyingSinkAbortCallback, type UnderlyingSinkCloseCallback, ty... <skipped 74 characters> ...Stream, WritableStreamDefaultController, WritableStreamDefaultWriter } from './lib/writable-stream';\n    3  export type { QueuingStrategy, QueuingStrategyInit, QueuingStrategySizeCallback } from './lib/queuing-strategy';\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/count-queuing-strategy.ts:\n   17  export default class CountQueuingStrategy implements QueuingStrategy<any> {\n   18    /** @internal */\n   19:   readonly _countQueuingStrategyHighWaterMark!: number;\n   20  \n   21    constructor(options: QueuingStrategyInit) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream.js:\n    1  import assert from '../stub/assert';\n    2  import { promiseRejectedWith, promiseResolvedWith, setPromiseIsHandledToTrue, transformPromiseWith } from './helpers/webidl';\n    3: import { AcquireReadableStreamAsyncIterator } from './readable-stream/async-iterator';\n    4: import { defaultReaderClosedPromiseReject, defaultReaderClosedPromiseResolve } from './readable-stream/generic-reader';\n    5: <skipped 60 characters> ...mDefaultReader, ReadableStreamDefaultReader, ReadableStreamDefaultReaderErrorReadRequests } from './readable-stream/default-reader';\n    6: <skipped 52 characters> ...StreamBYOBReader, ReadableStreamBYOBReader, ReadableStreamBYOBReaderErrorReadIntoRequests } from './readable-stream/byob-reader';\n    7: import { ReadableStreamPipeTo } from './readable-stream/pipe';\n    8: import { ReadableStreamTee } from './readable-stream/tee';\n    9: import { ReadableStreamFrom } from './readable-stream/from';\n   10  import { IsWritableStream, IsWritableStreamLocked, WritableStream } from './writable-stream';\n   11  import { SimpleQueue } from './simple-queue';\n   12: <skipped 65 characters> ... SetUpReadableByteStreamController, SetUpReadableByteStreamControllerFromUnderlyingSource } from './readable-stream/byte-stream-controller';\n   13: <skipped 47 characters> ...ReadableStreamDefaultController, SetUpReadableStreamDefaultControllerFromUnderlyingSource } from './readable-stream/default-controller';\n   14  import { noop } from '../utils';\n   15  import { setFunctionName, typeIsObject } from './helpers/miscellaneous';\n   ..\n   21  import { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\n   22  import { convertUnderlyingDefaultOrByteSource } from './validators/underlying-source';\n   23: import { convertReaderOptions } from './validators/reader-options';\n   24  import { convertIteratorOptions } from './validators/iterator-options';\n   25  import { convertPipeOptions } from './validators/pipe-options';\n   26: import { convertReadableWritablePair } from './validators/readable-writable-pair';\n   27  /**\n   28:  * A readable stream represents a source of data, from which you can read.\n   29   *\n   30   * @public\n   ..\n   56      }\n   57      /**\n   58:      * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n   59       */\n   60      get locked() {\n   ..\n   75          }\n   76          if (IsReadableStreamLocked(this)) {\n   77:             return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n   78          }\n   79          return ReadableStreamCancel(this, reason);\n   ..\n  105          const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n  106          setPromiseIsHandledToTrue(promise);\n  107:         return transform.readable;\n  108      }\n  109      pipeTo(destination, rawOptions = {}) {\n  ...\n  133      }\n  134      /**\n  135:      * Tees this readable stream, returning a two-element array containing the two resulting branches as\n  136       * new {@link ReadableStream} instances.\n  137       *\n  138:      * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n  139       * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n  140       * propagated to the stream's underlying source.\n  ...\n  164       * Creates a new ReadableStream wrapping the provided iterable or async iterable.\n  165       *\n  166:      * This can be used to adapt various kinds of objects into a readable stream,\n  167:      * such as an array, an async generator, or a Node.js readable stream.\n  168       */\n  169      static from(asyncIterable) {\n  ...\n  220  }\n  221  function InitializeReadableStream(stream) {\n  222:     stream._state = 'readable';\n  223      stream._reader = undefined;\n  224      stream._storedError = undefined;\n  ...\n  255      }\n  256      ReadableStreamClose(stream);\n  257:     const reader = stream._reader;\n  258:     if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n  259:         const readIntoRequests = reader._readIntoRequests;\n  260:         reader._readIntoRequests = new SimpleQueue();\n  261:         readIntoRequests.forEach((readIntoRequest) => {\n  262:             readIntoRequest._closeSteps(undefined);\n  263          });\n  264      }\n  ...\n  267  }\n  268  export function ReadableStreamClose(stream) {\n  269:     assert(stream._state === 'readable');\n  270      stream._state = 'closed';\n  271:     const reader = stream._reader;\n  272:     if (reader === undefined) {\n  273          return;\n  274      }\n  275:     defaultReaderClosedPromiseResolve(reader);\n  276:     if (IsReadableStreamDefaultReader(reader)) {\n  277:         const readRequests = reader._readRequests;\n  278:         reader._readRequests = new SimpleQueue();\n  279:         readRequests.forEach((readRequest) => {\n  280:             readRequest._closeSteps();\n  281          });\n  282      }\n  ...\n  284  export function ReadableStreamError(stream, e) {\n  285      assert(IsReadableStream(stream));\n  286:     assert(stream._state === 'readable');\n  287      stream._state = 'errored';\n  288      stream._storedError = e;\n  289:     const reader = stream._reader;\n  290:     if (reader === undefined) {\n  291          return;\n  292      }\n  293:     defaultReaderClosedPromiseReject(reader, e);\n  294:     if (IsReadableStreamDefaultReader(reader)) {\n  295:         ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n  296      }\n  297      else {\n  298:         assert(IsReadableStreamBYOBReader(reader));\n  299:         ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n  300      }\n  301  }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/simple-queue.ts:\n   67    }\n   68  \n   69:   // Like push(), shift() follows the read -> calculate -> mutate pattern for\n   70    // exception safety.\n   71    shift(): T {\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream.d.ts:\n    1  import type { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\n    2: import { type ReadableStreamAsyncIterator } from './readable-stream/async-iterator';\n    3: import { ReadableStreamDefaultReader, type ReadableStreamDefaultReadResult } from './readable-stream/default-reader';\n    4: import { ReadableStreamBYOBReader, type ReadableStreamBYOBReadResult } from './readable-stream/byob-reader';\n    5  import { WritableStream } from './writable-stream';\n    6: import { ReadableByteStreamController, ReadableStreamBYOBRequest } from './readable-stream/byte-stream-controller';\n    7: import { ReadableStreamDefaultController } from './readable-stream/default-controller';\n    8: <skipped 125 characters> ...derlyingSourceCancelCallback, UnderlyingSourcePullCallback, UnderlyingSourceStartCallback } from './readable-stream/underlying-source';\n    9: import type { ReadableStreamBYOBReaderReadOptions } from './readable-stream/reader-options';\n   10: import type { StreamPipeOptions } from './readable-stream/pipe-options';\n   11: import type { ReadableStreamIteratorOptions } from './readable-stream/iterator-options';\n   12: import type { ReadableWritablePair } from './readable-stream/readable-writable-pair';\n   13: import type { ReadableStreamDefaultReaderLike, ReadableStreamLike } from './readable-stream/readable-stream-like';\n   14  import type { NonShared } from './helpers/array-buffer-view';\n   15  export type DefaultReadableStream<R = any> = ReadableStream<R> & {\n   ..\n   20  };\n   21  /**\n   22:  * A readable stream represents a source of data, from which you can read.\n   23   *\n   24   * @public\n   ..\n   31      constructor(underlyingSource?: UnderlyingSource<R>, strategy?: QueuingStrategy<R>);\n   32      /**\n   33:      * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n   34       */\n   35      get locked(): boolean;\n   ..\n   42      cancel(reason?: any): Promise<void>;\n   43      /**\n   44:      * Creates a {@link ReadableStreamBYOBReader} and locks the stream to the new reader.\n   45       *\n   46:      * This call behaves the same way as the no-argument variant, except that it only works on readable byte streams,\n   47:      * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n   48:      * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n   49:      * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n   50       * control over allocation.\n   51       */\n   ..\n   54      }): ReadableStreamBYOBReader;\n   55      /**\n   56:      * Creates a {@link ReadableStreamDefaultReader} and locks the stream to the new reader.\n   57:      * While the stream is locked, no other reader can be acquired until this one is released.\n   58       *\n   59       * This functionality is especially useful for creating abstractions that desire the ability to consume a stream\n   60:      * in its entirety. By getting a reader for the stream, you can ensure nobody else can interleave reads with yours\n   61       * or cancel the stream, which would interfere with your abstraction.\n   62       */\n   63      getReader(): ReadableStreamDefaultReader<R>;\n   64      /**\n   65:      * Provides a convenient, chainable way of piping this readable stream through a transform stream\n   66:      * (or any other `{ writable, readable }` pair). It simply {@link ReadableStream.pipeTo | pipes} the stream\n   67:      * into the writable side of the supplied pair, and returns the readable side for further use.\n   68       *\n   69:      * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n   70       */\n   71      pipeThrough<RS extends ReadableStream>(transform: {\n   72:         readable: RS;\n   73          writable: WritableStream<R>;\n   74      }, options?: StreamPipeOptions): RS;\n   75      /**\n   76:      * Pipes this readable stream to a given writable stream. The way in which the piping process behaves under\n   77       * various error conditions can be customized with a number of passed options. It returns a promise that fulfills\n   78       * when the piping process completes successfully, or rejects if any errors were encountered.\n   79       *\n   80:      * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n   81       */\n   82      pipeTo(destination: WritableStream<R>, options?: StreamPipeOptions): Promise<void>;\n   83      /**\n   84:      * Tees this readable stream, returning a two-element array containing the two resulting branches as\n   85       * new {@link ReadableStream} instances.\n   86       *\n   87:      * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n   88       * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n   89       * propagated to the stream's underlying source.\n   ..\n   96       * Asynchronously iterates over the chunks in the stream's internal queue.\n   97       *\n   98:      * Asynchronously iterating over the stream will lock it, preventing any other consumer from acquiring a reader.\n   99       * The lock will be released if the async iterator's {@link ReadableStreamAsyncIterator.return | return()} method\n  100       * is called, e.g. by breaking out of the loop.\n  ...\n  112       * Creates a new ReadableStream wrapping the provided iterable or async iterable.\n  113       *\n  114:      * This can be used to adapt various kinds of objects into a readable stream,\n  115:      * such as an array, an async generator, or a Node.js readable stream.\n  116       */\n  117      static from<R>(asyncIterable: Iterable<R> | AsyncIterable<R> | ReadableStreamLike<R>): ReadableStream<R>;\n  ...\n  129  export { ReadableStreamDefaultReader, ReadableStreamBYOBReader };\n  130  export { ReadableStreamDefaultController, ReadableStreamBYOBRequest, ReadableByteStreamController };\n  131: //# sourceMappingURL=readable-stream.d.ts.map\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/writable-stream.d.ts:\n    3  import { type AbortSignal } from './abort-signal';\n    4  /**\n    5:  * A writable stream represents a destination for data, into which you can write.\n    6   *\n    7   * @public\n    .\n   10      constructor(underlyingSink?: UnderlyingSink<W>, strategy?: QueuingStrategy<W>);\n   11      /**\n   12:      * Returns whether or not the writable stream is locked to a writer.\n   13       */\n   14      get locked(): boolean;\n   15      /**\n   16:      * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n   17:      * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n   18       * mechanism of the underlying sink.\n   19       *\n   ..\n   25      /**\n   26       * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n   27:      * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n   28       *\n   29       * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n   ..\n   33      close(): Promise<undefined>;\n   34      /**\n   35:      * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n   36:      * is locked, no other writer can be acquired until this one is released.\n   37       *\n   38:      * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n   39:      * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n   40       * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n   41       */\n   ..\n   45  export type { UnderlyingSink, UnderlyingSinkStartCallback, UnderlyingSinkWriteCallback, UnderlyingSinkCloseCallback, UnderlyingSinkAbortCallback };\n   46  declare function AcquireWritableStreamDefaultWriter<W>(stream: WritableStream<W>): WritableStreamDefaultWriter<W>;\n   47: declare function CreateWritableStream<W>(startAlgorithm: () => void | PromiseLike<void>, writeAlgorithm: (chunk: W) => Promise<void>, closeAlgorithm: () => Promise<void>, abortAlgorithm: (reason... <skipped 116 characters> ...\n   48  declare function IsWritableStream(x: unknown): x is WritableStream;\n   49  declare function IsWritableStreamLocked(stream: WritableStream): boolean;\n   ..\n   51  declare function WritableStreamCloseQueuedOrInFlight(stream: WritableStream): boolean;\n   52  /**\n   53:  * A default writer vended by a {@link WritableStream}.\n   54   *\n   55   * @public\n   ..\n   59      /**\n   60       * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n   61:      * the writerâ€™s lock is released before the stream finishes closing.\n   62       */\n   63      get closed(): Promise<undefined>;\n   64      /**\n   65       * Returns the desired size to fill the streamâ€™s internal queue. It can be negative, if the queue is over-full.\n   66:      * A producer can use this information to determine the right amount of data to write.\n   67       *\n   68       * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n   69       * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n   70:      * the writerâ€™s lock is released.\n   71       */\n   72      get desiredSize(): number | null;\n   ..\n   76       * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n   77       *\n   78:      * If the stream becomes errored or aborted, or the writerâ€™s lock is released, the returned promise will become\n   79       * rejected.\n   80       */\n   81:     get ready(): Promise<undefined>;\n   82      /**\n   83:      * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n   84       */\n   85      abort(reason?: any): Promise<void>;\n   86      /**\n   87:      * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n   88       */\n   89      close(): Promise<void>;\n   90      /**\n   91:      * Releases the writerâ€™s lock on the corresponding stream. After the lock is released, the writer is no longer active.\n   92:      * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n   93:      * now on; otherwise, the writer will appear closed.\n   94       *\n   95:      * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n   96:      * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n   97:      * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n   98       * other producers from writing in an interleaved manner.\n   99       */\n  100      releaseLock(): void;\n  101      /**\n  102:      * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n  103:      * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n  104:      * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n  105       * errored before the writing process is initiated.\n  106       *\n  ...\n  108       * accepted, and not necessarily that it is safely saved to its ultimate destination.\n  109       */\n  110:     write(chunk: W): Promise<void>;\n  111  }\n  112: declare function WritableStreamDefaultWriterCloseWithErrorPropagation(writer: WritableStreamDefaultWriter): Promise<undefined>;\n  113: declare function WritableStreamDefaultWriterRelease(writer: WritableStreamDefaultWriter): void;\n  114: declare function WritableStreamDefaultWriterWrite<W>(writer: WritableStreamDefaultWriter<W>, chunk: W): Promise<undefined>;\n  115  /**\n  116   * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n  ...\n  129      get abortReason(): any;\n  130      /**\n  131:      * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n  132       */\n  133      get signal(): AbortSignal;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/transform-stream.ts:\n    8    uponPromise\n    9  } from './helpers/webidl';\n   10: import { CreateReadableStream, type DefaultReadableStream, ReadableStream } from './readable-stream';\n   11  import {\n   12    ReadableStreamDefaultControllerCanCloseOrEnqueue,\n   ..\n   16    ReadableStreamDefaultControllerGetDesiredSize,\n   17    ReadableStreamDefaultControllerHasBackpressure\n   18: } from './readable-stream/default-controller';\n   19  import type { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\n   20  import { CreateWritableStream, WritableStream, WritableStreamDefaultControllerErrorIfNeeded } from './writable-stream';\n   ..\n   37  /**\n   38   * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n   39:  * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n   40:  * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n   41:  * made available for reading from the readable side.\n   42   *\n   43   * @public\n   ..\n   60      transformer?: Transformer<I, O>,\n   61      writableStrategy?: QueuingStrategy<I>,\n   62:     readableStrategy?: QueuingStrategy<O>\n   63    );\n   64    constructor(\n   ..\n   72  \n   73      const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n   74:     const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n   75  \n   76      const transformer = convertTransformer(rawTransformer, 'First parameter');\n   77:     if (transformer.readableType !== undefined) {\n   78:       throw new RangeError('Invalid readableType specified');\n   79      }\n   80      if (transformer.writableType !== undefined) {\n   ..\n   82      }\n   83  \n   84:     const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n   85:     const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n   86      const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n   87      const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n   ..\n   92      });\n   93  \n   94:     InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n   95      SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n   96  \n   ..\n  103  \n  104    /**\n  105:    * The readable side of the transform stream.\n  106     */\n  107:   get readable(): ReadableStream<O> {\n  108      if (!IsTransformStream(this)) {\n  109:       throw streamBrandCheckException('readable');\n  110      }\n  111  \n  ...\n  126  \n  127  Object.defineProperties(TransformStream.prototype, {\n  128:   readable: { enumerable: true },\n  129    writable: { enumerable: true }\n  130  });\n  ...\n  153    writableHighWaterMark = 1,\n  154    writableSizeAlgorithm: QueuingStrategySizeCallback<I> = () => 1,\n  155:   readableHighWaterMark = 0,\n  156:   readableSizeAlgorithm: QueuingStrategySizeCallback<O> = () => 1\n  157  ) {\n  158    assert(IsNonNegativeNumber(writableHighWaterMark));\n  159:   assert(IsNonNegativeNumber(readableHighWaterMark));\n  160  \n  161    const stream: TransformStream<I, O> = Object.create(TransformStream.prototype);\n  ...\n  167  \n  168    InitializeTransformStream(\n  169:     stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n  170:     readableSizeAlgorithm\n  171    );\n  172  \n  ...\n  185    writableHighWaterMark: number,\n  186    writableSizeAlgorithm: QueuingStrategySizeCallback<I>,\n  187:   readableHighWaterMark: number,\n  188:   readableSizeAlgorithm: QueuingStrategySizeCallback<O>\n  189  ) {\n  190    function startAlgorithm(): Promise<void> {\n  ...\n  192    }\n  193  \n  194:   function writeAlgorithm(chunk: I): Promise<void> {\n  195      return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  196    }\n  ...\n  205  \n  206    stream._writable = CreateWritableStream(\n  207:     startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm,\n  208      writableHighWaterMark, writableSizeAlgorithm\n  209    );\n  ...\n  218  \n  219    stream._readable = CreateReadableStream(\n  220:     startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark,\n  221:     readableSizeAlgorithm\n  222    );\n  223  \n  ...\n  257  function TransformStreamUnblockWrite(stream: TransformStream) {\n  258    if (stream._backpressure) {\n  259:     // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n  260      // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n  261      // _backpressure is set.\n  ...\n  307  \n  308    /**\n  309:    * Returns the desired size to fill the readable sideâ€™s internal queue. It can be negative, if the queue is over-full.\n  310     */\n  311    get desiredSize(): number | null {\n  ...\n  314      }\n  315  \n  316:     const readableController = this._controlledTransformStream._readable._readableStreamController;\n  317:     return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n  318    }\n  319  \n  320    /**\n  321:    * Enqueues the given chunk `chunk` in the readable side of the controlled transform stream.\n  322     */\n  323    enqueue(chunk: O): void;\n  ...\n  331  \n  332    /**\n  333:    * Errors both the readable side and the writable side of the controlled transform stream, making all future\n  334     * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n  335     */\n  ...\n  343  \n  344    /**\n  345:    * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n  346     * transformer only needs to consume a portion of the chunks written to the writable side.\n  347     */\n  ...\n  453  function TransformStreamDefaultControllerEnqueue<O>(controller: TransformStreamDefaultController<O>, chunk: O) {\n  454    const stream = controller._controlledTransformStream;\n  455:   const readableController = stream._readable._readableStreamController;\n  456:   if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n  457      throw new TypeError('Readable side is not in a state that permits enqueue');\n  458    }\n  ...\n  462  \n  463    try {\n  464:     ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n  465    } catch (e) {\n  466:     // This happens when readableStrategy.size() throws.\n  467      TransformStreamErrorWritableAndUnblockWrite(stream, e);\n  468  \n  ...\n  470    }\n  471  \n  472:   const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n  473    if (backpressure !== stream._backpressure) {\n  474      assert(backpressure);\n  ...\n  494  function TransformStreamDefaultControllerTerminate<O>(controller: TransformStreamDefaultController<O>) {\n  495    const stream = controller._controlledTransformStream;\n  496:   const readableController = stream._readable._readableStreamController;\n  497  \n  498:   ReadableStreamDefaultControllerClose(readableController);\n  499  \n  500    const error = new TypeError('TransformStream terminated');\n  ...\n  533  \n  534    // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  535:   const readable = stream._readable;\n  536  \n  537:   // Assign the _finishPromise now so that if _cancelAlgorithm calls readable.cancel() internally,\n  538    // we don't run the _cancelAlgorithm again.\n  539    controller._finishPromise = newPromise((resolve, reject) => {\n  ...\n  546  \n  547    uponPromise(cancelPromise, () => {\n  548:     if (readable._state === 'errored') {\n  549:       defaultControllerFinishPromiseReject(controller, readable._storedError);\n  550      } else {\n  551:       ReadableStreamDefaultControllerError(readable._readableStreamController, reason);\n  552        defaultControllerFinishPromiseResolve(controller);\n  553      }\n  554      return null;\n  555    }, (r) => {\n  556:     ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n  557      defaultControllerFinishPromiseReject(controller, r);\n  558      return null;\n  ...\n  569  \n  570    // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  571:   const readable = stream._readable;\n  572  \n  573:   // Assign the _finishPromise now so that if _flushAlgorithm calls readable.cancel() internally,\n  574    // we don't also run the _cancelAlgorithm.\n  575    controller._finishPromise = newPromise((resolve, reject) => {\n  ...\n  582  \n  583    uponPromise(flushPromise, () => {\n  584:     if (readable._state === 'errored') {\n  585:       defaultControllerFinishPromiseReject(controller, readable._storedError);\n  586      } else {\n  587:       ReadableStreamDefaultControllerClose(readable._readableStreamController);\n  588        defaultControllerFinishPromiseResolve(controller);\n  589      }\n  590      return null;\n  591    }, (r) => {\n  592:     ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n  593      defaultControllerFinishPromiseReject(controller, r);\n  594      return null;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/writable-stream.js:\n   13  import { createAbortController } from './abort-signal';\n   14  /**\n   15:  * A writable stream represents a destination for data, into which you can write.\n   16   *\n   17   * @public\n   ..\n   37      }\n   38      /**\n   39:      * Returns whether or not the writable stream is locked to a writer.\n   40       */\n   41      get locked() {\n   ..\n   46      }\n   47      /**\n   48:      * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n   49:      * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n   50       * mechanism of the underlying sink.\n   51       *\n   ..\n   59          }\n   60          if (IsWritableStreamLocked(this)) {\n   61:             return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n   62          }\n   63          return WritableStreamAbort(this, reason);\n   ..\n   65      /**\n   66       * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n   67:      * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n   68       *\n   69       * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n   ..\n   76          }\n   77          if (IsWritableStreamLocked(this)) {\n   78:             return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n   79          }\n   80          if (WritableStreamCloseQueuedOrInFlight(this)) {\n   ..\n   84      }\n   85      /**\n   86:      * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n   87:      * is locked, no other writer can be acquired until this one is released.\n   88       *\n   89:      * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n   90:      * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n   91       * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n   92       */\n   ..\n  119  }\n  120  // Throws if and only if startAlgorithm throws.\n  121: function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n  122      assert(IsNonNegativeNumber(highWaterMark));\n  123      const stream = Object.create(WritableStream.prototype);\n  124      InitializeWritableStream(stream);\n  125      const controller = Object.create(WritableStreamDefaultController.prototype);\n  126:     SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n  127      return stream;\n  128  }\n  ...\n  136      // variable to validate the caller.\n  137      stream._writableStreamController = undefined;\n  138:     // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n  139:     // producer without waiting for the queued writes to finish.\n  140      stream._writeRequests = new SimpleQueue();\n  141:     // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  142:     // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  143      stream._inFlightWriteRequest = undefined;\n  144:     // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  145      // has been detached.\n  146      stream._closeRequest = undefined;\n  ...\n  148      // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n  149      stream._inFlightCloseRequest = undefined;\n  150:     // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n  151      stream._pendingAbortRequest = undefined;\n  152      // The backpressure signal set by the controller.\n  ...\n  222          stream._closeRequest = closeRequest;\n  223      });\n  224:     const writer = stream._writer;\n  225:     if (writer !== undefined && stream._backpressure && state === 'writable') {\n  226:         defaultWriterReadyPromiseResolve(writer);\n  227      }\n  228      WritableStreamDefaultControllerClose(stream._writableStreamController);\n  ...\n  234      assert(stream._state === 'writable');\n  235      const promise = newPromise((resolve, reject) => {\n  236:         const writeRequest = {\n  237              _resolve: resolve,\n  238              _reject: reject\n  239          };\n  240:         stream._writeRequests.push(writeRequest);\n  241      });\n  242      return promise;\n  ...\n  258      stream._state = 'erroring';\n  259      stream._storedError = reason;\n  260:     const writer = stream._writer;\n  261:     if (writer !== undefined) {\n  262:         WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  263      }\n  264      if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n  ...\n  272      stream._writableStreamController[ErrorSteps]();\n  273      const storedError = stream._storedError;\n  274:     stream._writeRequests.forEach((writeRequest) => {\n  275:         writeRequest._reject(storedError);\n  276      });\n  277      stream._writeRequests = new SimpleQueue();\n  ...\n  325      }\n  326      stream._state = 'closed';\n  327:     const writer = stream._writer;\n  328:     if (writer !== undefined) {\n  329:         defaultWriterClosedPromiseResolve(writer);\n  330      }\n  331      assert(stream._pendingAbortRequest === undefined);\n  ...\n  375          stream._closeRequest = undefined;\n  376      }\n  377:     const writer = stream._writer;\n  378:     if (writer !== undefined) {\n  379:         defaultWriterClosedPromiseReject(writer, stream._storedError);\n  380      }\n  381  }\n  ...\n  383      assert(stream._state === 'writable');\n  384      assert(!WritableStreamCloseQueuedOrInFlight(stream));\n  385:     const writer = stream._writer;\n  386:     if (writer !== undefined && backpressure !== stream._backpressure) {\n  387          if (backpressure) {\n  388:             defaultWriterReadyPromiseReset(writer);\n  389          }\n  390          else {\n  391              assert(!backpressure);\n  392:             defaultWriterReadyPromiseResolve(writer);\n  393          }\n  394      }\n  ...\n  396  }\n  397  /**\n  398:  * A default writer vended by a {@link WritableStream}.\n  399   *\n  400   * @public\n  ...\n  405          assertWritableStream(stream, 'First parameter');\n  406          if (IsWritableStreamLocked(stream)) {\n  407:             throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n  408          }\n  409          this._ownerWritableStream = stream;\n  ...\n  436      /**\n  437       * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n  438:      * the writerâ€™s lock is released before the stream finishes closing.\n  439       */\n  440      get closed() {\n  ...\n  446      /**\n  447       * Returns the desired size to fill the streamâ€™s internal queue. It can be negative, if the queue is over-full.\n  448:      * A producer can use this information to determine the right amount of data to write.\n  449       *\n  450       * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n  451       * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n  452:      * the writerâ€™s lock is released.\n  453       */\n  454      get desiredSize() {\n  ...\n  466       * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n  467       *\n  468:      * If the stream becomes errored or aborted, or the writerâ€™s lock is released, the returned promise will become\n  469       * rejected.\n  470       */\n  471:     get ready() {\n  472          if (!IsWritableStreamDefaultWriter(this)) {\n  473:             return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n  474          }\n  475          return this._readyPromise;\n  476      }\n  477      /**\n  478:      * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n  479       */\n  480      abort(reason = undefined) {\n  ...\n  488      }\n  489      /**\n  490:      * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n  491       */\n  492      close() {\n  ...\n  504      }\n  505      /**\n  506:      * Releases the writerâ€™s lock on the corresponding stream. After the lock is released, the writer is no longer active.\n  507:      * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n  508:      * now on; otherwise, the writer will appear closed.\n  509       *\n  510:      * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n  511:      * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n  512:      * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n  513       * other producers from writing in an interleaved manner.\n  514       */\n  ...\n  524          WritableStreamDefaultWriterRelease(this);\n  525      }\n  526:     write(chunk = undefined) {\n  527          if (!IsWritableStreamDefaultWriter(this)) {\n  528:             return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n  529          }\n  530          if (this._ownerWritableStream === undefined) {\n  531:             return promiseRejectedWith(defaultWriterLockException('write to'));\n  532          }\n  533          return WritableStreamDefaultWriterWrite(this, chunk);\n  ...\n  538      close: { enumerable: true },\n  539      releaseLock: { enumerable: true },\n  540:     write: { enumerable: true },\n  541      closed: { enumerable: true },\n  542      desiredSize: { enumerable: true },\n  543:     ready: { enumerable: true }\n  544  });\n  545  setFunctionName(WritableStreamDefaultWriter.prototype.abort, 'abort');\n  546  setFunctionName(WritableStreamDefaultWriter.prototype.close, 'close');\n  547  setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, 'releaseLock');\n  548: setFunctionName(WritableStreamDefaultWriter.prototype.write, 'write');\n  549  if (typeof Symbol.toStringTag === 'symbol') {\n  550      Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {\n  ...\n  564  }\n  565  // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n  566: function WritableStreamDefaultWriterAbort(writer, reason) {\n  567:     const stream = writer._ownerWritableStream;\n  568      assert(stream !== undefined);\n  569      return WritableStreamAbort(stream, reason);\n  570  }\n  571: function WritableStreamDefaultWriterClose(writer) {\n  572:     const stream = writer._ownerWritableStream;\n  573      assert(stream !== undefined);\n  574      return WritableStreamClose(stream);\n  575  }\n  576: function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n  577:     const stream = writer._ownerWritableStream;\n  578      assert(stream !== undefined);\n  579      const state = stream._state;\n  ...\n  585      }\n  586      assert(state === 'writable' || state === 'erroring');\n  587:     return WritableStreamDefaultWriterClose(writer);\n  588  }\n  589: function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n  590:     if (writer._closedPromiseState === 'pending') {\n  591:         defaultWriterClosedPromiseReject(writer, error);\n  592      }\n  593      else {\n  594:         defaultWriterClosedPromiseResetToRejected(writer, error);\n  595      }\n  596  }\n  597: function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n  598:     if (writer._readyPromiseState === 'pending') {\n  599:         defaultWriterReadyPromiseReject(writer, error);\n  600      }\n  601      else {\n  602:         defaultWriterReadyPromiseResetToRejected(writer, error);\n  603      }\n  604  }\n  605: function WritableStreamDefaultWriterGetDesiredSize(writer) {\n  606:     const stream = writer._ownerWritableStream;\n  607      const state = stream._state;\n  608      if (state === 'errored' || state === 'erroring') {\n  ...\n  614      return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n  615  }\n  616: function WritableStreamDefaultWriterRelease(writer) {\n  617:     const stream = writer._ownerWritableStream;\n  618      assert(stream !== undefined);\n  619:     assert(stream._writer === writer);\n  620      const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n  621:     WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n  622:     // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n  623      // rejected until afterwards. This means that simply testing state will not work.\n  624:     WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n  625      stream._writer = undefined;\n  626:     writer._ownerWritableStream = undefined;\n  627  }\n  628: function WritableStreamDefaultWriterWrite(writer, chunk) {\n  629:     const stream = writer._ownerWritableStream;\n  630      assert(stream !== undefined);\n  631      const controller = stream._writableStreamController;\n  632      const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n  633:     if (stream !== writer._ownerWritableStream) {\n  634:         return promiseRejectedWith(defaultWriterLockException('write to'));\n  635      }\n  636      const state = stream._state;\n  ...\n  673      }\n  674      /**\n  675:      * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n  676       */\n  677      get signal() {\n  ...\n  738      return x instanceof WritableStreamDefaultController;\n  739  }\n  740: function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n  741      assert(IsWritableStream(stream));\n  742      assert(stream._writableStreamController === undefined);\n  ...\n  752      controller._strategySizeAlgorithm = sizeAlgorithm;\n  753      controller._strategyHWM = highWaterMark;\n  754:     controller._writeAlgorithm = writeAlgorithm;\n  755      controller._closeAlgorithm = closeAlgorithm;\n  756      controller._abortAlgorithm = abortAlgorithm;\n  ...\n  774      const controller = Object.create(WritableStreamDefaultController.prototype);\n  775      let startAlgorithm;\n  776:     let writeAlgorithm;\n  777      let closeAlgorithm;\n  778      let abortAlgorithm;\n  ...\n  783          startAlgorithm = () => undefined;\n  784      }\n  785:     if (underlyingSink.write !== undefined) {\n  786:         writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n  787      }\n  788      else {\n  789:         writeAlgorithm = () => promiseResolvedWith(undefined);\n  790      }\n  791      if (underlyingSink.close !== undefined) {\n  ...\n  801          abortAlgorithm = () => promiseResolvedWith(undefined);\n  802      }\n  803:     SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n  804  }\n  805  // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\n  ...\n  938  }\n  939  function defaultWriterLockException(name) {\n  940:     return new TypeError('Cannot ' + name + ' a stream using a released writer');\n  941  }\n  942: function defaultWriterClosedPromiseInitialize(writer) {\n  943:     writer._closedPromise = newPromise((resolve, reject) => {\n  944:         writer._closedPromise_resolve = resolve;\n  945:         writer._closedPromise_reject = reject;\n  946:         writer._closedPromiseState = 'pending';\n  947      });\n  948  }\n  949: function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n  950:     defaultWriterClosedPromiseInitialize(writer);\n  951:     defaultWriterClosedPromiseReject(writer, reason);\n  952  }\n  953: function defaultWriterClosedPromiseInitializeAsResolved(writer) {\n  954:     defaultWriterClosedPromiseInitialize(writer);\n  955:     defaultWriterClosedPromiseResolve(writer);\n  956  }\n  957: function defaultWriterClosedPromiseReject(writer, reason) {\n  958:     if (writer._closedPromise_reject === undefined) {\n  959          return;\n  960      }\n  961:     assert(writer._closedPromiseState === 'pending');\n  962:     setPromiseIsHandledToTrue(writer._closedPromise);\n  963:     writer._closedPromise_reject(reason);\n  964:     writer._closedPromise_resolve = undefined;\n  965:     writer._closedPromise_reject = undefined;\n  966:     writer._closedPromiseState = 'rejected';\n  967  }\n  968: function defaultWriterClosedPromiseResetToRejected(writer, reason) {\n  969:     assert(writer._closedPromise_resolve === undefined);\n  970:     assert(writer._closedPromise_reject === undefined);\n  971:     assert(writer._closedPromiseState !== 'pending');\n  972:     defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n  973  }\n  974: function defaultWriterClosedPromiseResolve(writer) {\n  975:     if (writer._closedPromise_resolve === undefined) {\n  976          return;\n  977      }\n  978:     assert(writer._closedPromiseState === 'pending');\n  979:     writer._closedPromise_resolve(undefined);\n  980:     writer._closedPromise_resolve = undefined;\n  981:     writer._closedPromise_reject = undefined;\n  982:     writer._closedPromiseState = 'resolved';\n  983  }\n  984: function defaultWriterReadyPromiseInitialize(writer) {\n  985:     writer._readyPromise = newPromise((resolve, reject) => {\n  986:         writer._readyPromise_resolve = resolve;\n  987:         writer._readyPromise_reject = reject;\n  988      });\n  989:     writer._readyPromiseState = 'pending';\n  990  }\n  991: function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n  992:     defaultWriterReadyPromiseInitialize(writer);\n  993:     defaultWriterReadyPromiseReject(writer, reason);\n  994  }\n  995: function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n  996:     defaultWriterReadyPromiseInitialize(writer);\n  997:     defaultWriterReadyPromiseResolve(writer);\n  998  }\n  999: function defaultWriterReadyPromiseReject(writer, reason) {\n 1000:     if (writer._readyPromise_reject === undefined) {\n 1001          return;\n 1002      }\n 1003:     setPromiseIsHandledToTrue(writer._readyPromise);\n 1004:     writer._readyPromise_reject(reason);\n 1005:     writer._readyPromise_resolve = undefined;\n 1006:     writer._readyPromise_reject = undefined;\n 1007:     writer._readyPromiseState = 'rejected';\n 1008  }\n 1009: function defaultWriterReadyPromiseReset(writer) {\n 1010:     assert(writer._readyPromise_resolve === undefined);\n 1011:     assert(writer._readyPromise_reject === undefined);\n 1012:     defaultWriterReadyPromiseInitialize(writer);\n 1013  }\n 1014: function defaultWriterReadyPromiseResetToRejected(writer, reason) {\n 1015:     assert(writer._readyPromise_resolve === undefined);\n 1016:     assert(writer._readyPromise_reject === undefined);\n 1017:     defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n 1018  }\n 1019: function defaultWriterReadyPromiseResolve(writer) {\n 1020:     if (writer._readyPromise_resolve === undefined) {\n 1021          return;\n 1022      }\n 1023:     writer._readyPromise_resolve(undefined);\n 1024:     writer._readyPromise_resolve = undefined;\n 1025:     writer._readyPromise_reject = undefined;\n 1026:     writer._readyPromiseState = 'fulfilled';\n 1027  }\n 1028  \n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream.ts:\n    7  } from './helpers/webidl';\n    8  import type { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\n    9: import { AcquireReadableStreamAsyncIterator, type ReadableStreamAsyncIterator } from './readable-stream/async-iterator';\n   10: import { defaultReaderClosedPromiseReject, defaultReaderClosedPromiseResolve } from './readable-stream/generic-reader';\n   11  import {\n   12    AcquireReadableStreamDefaultReader,\n   ..\n   15    ReadableStreamDefaultReaderErrorReadRequests,\n   16    type ReadableStreamDefaultReadResult\n   17: } from './readable-stream/default-reader';\n   18  import {\n   19    AcquireReadableStreamBYOBReader,\n   ..\n   22    ReadableStreamBYOBReaderErrorReadIntoRequests,\n   23    type ReadableStreamBYOBReadResult\n   24: } from './readable-stream/byob-reader';\n   25: import { ReadableStreamPipeTo } from './readable-stream/pipe';\n   26: import { ReadableStreamTee } from './readable-stream/tee';\n   27: import { ReadableStreamFrom } from './readable-stream/from';\n   28  import { IsWritableStream, IsWritableStreamLocked, WritableStream } from './writable-stream';\n   29  import { SimpleQueue } from './simple-queue';\n   ..\n   33    SetUpReadableByteStreamController,\n   34    SetUpReadableByteStreamControllerFromUnderlyingSource\n   35: } from './readable-stream/byte-stream-controller';\n   36  import {\n   37    ReadableStreamDefaultController,\n   38    SetUpReadableStreamDefaultController,\n   39    SetUpReadableStreamDefaultControllerFromUnderlyingSource\n   40: } from './readable-stream/default-controller';\n   41  import type {\n   42    UnderlyingByteSource,\n   ..\n   47    UnderlyingSourcePullCallback,\n   48    UnderlyingSourceStartCallback\n   49: } from './readable-stream/underlying-source';\n   50  import { noop } from '../utils';\n   51  import { setFunctionName, typeIsObject } from './helpers/miscellaneous';\n   ..\n   60    ReadableStreamBYOBReaderReadOptions,\n   61    ReadableStreamGetReaderOptions\n   62: } from './readable-stream/reader-options';\n   63: import { convertReaderOptions } from './validators/reader-options';\n   64: import type { StreamPipeOptions, ValidatedStreamPipeOptions } from './readable-stream/pipe-options';\n   65: import type { ReadableStreamIteratorOptions } from './readable-stream/iterator-options';\n   66  import { convertIteratorOptions } from './validators/iterator-options';\n   67  import { convertPipeOptions } from './validators/pipe-options';\n   68: import type { ReadableWritablePair } from './readable-stream/readable-writable-pair';\n   69: import { convertReadableWritablePair } from './validators/readable-writable-pair';\n   70: import type { ReadableStreamDefaultReaderLike, ReadableStreamLike } from './readable-stream/readable-stream-like';\n   71  import type { NonShared } from './helpers/array-buffer-view';\n   72  \n   ..\n   79  };\n   80  \n   81: type ReadableStreamState = 'readable' | 'closed' | 'errored';\n   82  \n   83  /**\n   84:  * A readable stream represents a source of data, from which you can read.\n   85   *\n   86   * @public\n   ..\n  139  \n  140    /**\n  141:    * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n  142     */\n  143    get locked(): boolean {\n  ...\n  161  \n  162      if (IsReadableStreamLocked(this)) {\n  163:       return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n  164      }\n  165  \n  ...\n  168  \n  169    /**\n  170:    * Creates a {@link ReadableStreamBYOBReader} and locks the stream to the new reader.\n  171     *\n  172:    * This call behaves the same way as the no-argument variant, except that it only works on readable byte streams,\n  173:    * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n  174:    * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n  175:    * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n  176     * control over allocation.\n  177     */\n  178    getReader({ mode }: { mode: 'byob' }): ReadableStreamBYOBReader;\n  179    /**\n  180:    * Creates a {@link ReadableStreamDefaultReader} and locks the stream to the new reader.\n  181:    * While the stream is locked, no other reader can be acquired until this one is released.\n  182     *\n  183     * This functionality is especially useful for creating abstractions that desire the ability to consume a stream\n  184:    * in its entirety. By getting a reader for the stream, you can ensure nobody else can interleave reads with yours\n  185     * or cancel the stream, which would interfere with your abstraction.\n  186     */\n  ...\n  202  \n  203    /**\n  204:    * Provides a convenient, chainable way of piping this readable stream through a transform stream\n  205:    * (or any other `{ writable, readable }` pair). It simply {@link ReadableStream.pipeTo | pipes} the stream\n  206:    * into the writable side of the supplied pair, and returns the readable side for further use.\n  207     *\n  208:    * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n  209     */\n  210    pipeThrough<RS extends ReadableStream>(\n  211:     transform: { readable: RS; writable: WritableStream<R> },\n  212      options?: StreamPipeOptions\n  213    ): RS;\n  214    pipeThrough<RS extends ReadableStream>(\n  215:     rawTransform: { readable: RS; writable: WritableStream<R> } | null | undefined,\n  216      rawOptions: StreamPipeOptions | null | undefined = {}\n  217    ): RS {\n  ...\n  235      setPromiseIsHandledToTrue(promise);\n  236  \n  237:     return transform.readable;\n  238    }\n  239  \n  240    /**\n  241:    * Pipes this readable stream to a given writable stream. The way in which the piping process behaves under\n  242     * various error conditions can be customized with a number of passed options. It returns a promise that fulfills\n  243     * when the piping process completes successfully, or rejects if any errors were encountered.\n  244     *\n  245:    * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n  246     */\n  247    pipeTo(destination: WritableStream<R>, options?: StreamPipeOptions): Promise<void>;\n  ...\n  279  \n  280    /**\n  281:    * Tees this readable stream, returning a two-element array containing the two resulting branches as\n  282     * new {@link ReadableStream} instances.\n  283     *\n  284:    * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n  285     * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n  286     * propagated to the stream's underlying source.\n  ...\n  301     * Asynchronously iterates over the chunks in the stream's internal queue.\n  302     *\n  303:    * Asynchronously iterating over the stream will lock it, preventing any other consumer from acquiring a reader.\n  304     * The lock will be released if the async iterator's {@link ReadableStreamAsyncIterator.return | return()} method\n  305     * is called, e.g. by breaking out of the loop.\n  ...\n  332     * Creates a new ReadableStream wrapping the provided iterable or async iterable.\n  333     *\n  334:    * This can be used to adapt various kinds of objects into a readable stream,\n  335:    * such as an array, an async generator, or a Node.js readable stream.\n  336     */\n  337    static from<R>(asyncIterable: Iterable<R> | AsyncIterable<R> | ReadableStreamLike<R>): ReadableStream<R> {\n  ...\n  427  \n  428  function InitializeReadableStream(stream: ReadableStream) {\n  429:   stream._state = 'readable';\n  430    stream._reader = undefined;\n  431    stream._storedError = undefined;\n  ...\n  475    ReadableStreamClose(stream);\n  476  \n  477:   const reader = stream._reader;\n  478:   if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n  479:     const readIntoRequests = reader._readIntoRequests;\n  480:     reader._readIntoRequests = new SimpleQueue();\n  481:     readIntoRequests.forEach((readIntoRequest) => {\n  482:       readIntoRequest._closeSteps(undefined);\n  483      });\n  484    }\n  ...\n  489  \n  490  export function ReadableStreamClose<R>(stream: ReadableStream<R>): void {\n  491:   assert(stream._state === 'readable');\n  492  \n  493    stream._state = 'closed';\n  494  \n  495:   const reader = stream._reader;\n  496  \n  497:   if (reader === undefined) {\n  498      return;\n  499    }\n  500  \n  501:   defaultReaderClosedPromiseResolve(reader);\n  502  \n  503:   if (IsReadableStreamDefaultReader<R>(reader)) {\n  504:     const readRequests = reader._readRequests;\n  505:     reader._readRequests = new SimpleQueue();\n  506:     readRequests.forEach((readRequest) => {\n  507:       readRequest._closeSteps();\n  508      });\n  509    }\n  ...\n  512  export function ReadableStreamError<R>(stream: ReadableStream<R>, e: any): void {\n  513    assert(IsReadableStream(stream));\n  514:   assert(stream._state === 'readable');\n  515  \n  516    stream._state = 'errored';\n  517    stream._storedError = e;\n  518  \n  519:   const reader = stream._reader;\n  520  \n  521:   if (reader === undefined) {\n  522      return;\n  523    }\n  524  \n  525:   defaultReaderClosedPromiseReject(reader, e);\n  526  \n  527:   if (IsReadableStreamDefaultReader<R>(reader)) {\n  528:     ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n  529    } else {\n  530:     assert(IsReadableStreamBYOBReader(reader));\n  531:     ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n  532    }\n  533  }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/transform-stream.d.ts:\n    1: import { ReadableStream } from './readable-stream';\n    2  import type { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\n    3  import { WritableStream } from './writable-stream';\n    .\n    5  /**\n    6   * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n    7:  * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n    8:  * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n    9:  * made available for reading from the readable side.\n   10   *\n   11   * @public\n   12   */\n   13  export declare class TransformStream<I = any, O = any> {\n   14:     constructor(transformer?: Transformer<I, O>, writableStrategy?: QueuingStrategy<I>, readableStrategy?: QueuingStrategy<O>);\n   15      /**\n   16:      * The readable side of the transform stream.\n   17       */\n   18:     get readable(): ReadableStream<O>;\n   19      /**\n   20       * The writable side of the transform stream.\n   ..\n   23  }\n   24  export type { Transformer, TransformerCancelCallback, TransformerStartCallback, TransformerFlushCallback, TransformerTransformCallback };\n   25: <skipped 223 characters> ...mise<void>, writableHighWaterMark?: number, writableSizeAlgorithm?: QueuingStrategySizeCallback<I>, readableHighWaterMark?: number, readableSizeAlgorithm?: QueuingStrategySizeCallback<O>): TransformStream<I, O>;\n   26  /**\n   27   * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n   ..\n   32      private constructor();\n   33      /**\n   34:      * Returns the desired size to fill the readable sideâ€™s internal queue. It can be negative, if the queue is over-full.\n   35       */\n   36      get desiredSize(): number | null;\n   37      /**\n   38:      * Enqueues the given chunk `chunk` in the readable side of the controlled transform stream.\n   39       */\n   40      enqueue(chunk: O): void;\n   41      /**\n   42:      * Errors both the readable side and the writable side of the controlled transform stream, making all future\n   43       * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n   44       */\n   45      error(reason?: any): void;\n   46      /**\n   47:      * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n   48       * transformer only needs to consume a portion of the chunks written to the writable side.\n   49       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/byte-length-queuing-strategy.ts:\n   17  export default class ByteLengthQueuingStrategy implements QueuingStrategy<ArrayBufferView> {\n   18    /** @internal */\n   19:   readonly _byteLengthQueuingStrategyHighWaterMark: number;\n   20  \n   21    constructor(options: QueuingStrategyInit) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/abort-signal.d.ts:\n   14  } ? T : {\n   15      aborted: boolean;\n   16:     readonly reason?: any;\n   17      addEventListener(type: 'abort', listener: () => void): void;\n   18      removeEventListener(type: 'abort', listener: () => void): void;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/writable-stream.ts:\n   53  \n   54  /**\n   55:  * A writable stream represents a destination for data, into which you can write.\n   56   *\n   57   * @public\n   ..\n  107  \n  108    /**\n  109:    * Returns whether or not the writable stream is locked to a writer.\n  110     */\n  111    get locked(): boolean {\n  ...\n  118  \n  119    /**\n  120:    * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n  121:    * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n  122     * mechanism of the underlying sink.\n  123     *\n  ...\n  132  \n  133      if (IsWritableStreamLocked(this)) {\n  134:       return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n  135      }\n  136  \n  ...\n  140    /**\n  141     * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n  142:    * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n  143     *\n  144     * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n  ...\n  152  \n  153      if (IsWritableStreamLocked(this)) {\n  154:       return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n  155      }\n  156  \n  ...\n  163  \n  164    /**\n  165:    * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n  166:    * is locked, no other writer can be acquired until this one is released.\n  167     *\n  168:    * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n  169:    * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n  170     * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n  171     */\n  ...\n  226  function CreateWritableStream<W>(\n  227    startAlgorithm: () => void | PromiseLike<void>,\n  228:   writeAlgorithm: (chunk: W) => Promise<void>,\n  229    closeAlgorithm: () => Promise<void>,\n  230    abortAlgorithm: (reason: any) => Promise<void>,\n  ...\n  240  \n  241    SetUpWritableStreamDefaultController(\n  242:     stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n  243      abortAlgorithm, highWaterMark, sizeAlgorithm\n  244    );\n  ...\n  259    stream._writableStreamController = undefined!;\n  260  \n  261:   // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n  262:   // producer without waiting for the queued writes to finish.\n  263    stream._writeRequests = new SimpleQueue();\n  264  \n  265:   // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  266:   // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  267    stream._inFlightWriteRequest = undefined;\n  268  \n  269:   // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  270    // has been detached.\n  271    stream._closeRequest = undefined;\n  ...\n  275    stream._inFlightCloseRequest = undefined;\n  276  \n  277:   // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n  278    stream._pendingAbortRequest = undefined;\n  279  \n  ...\n  368    });\n  369  \n  370:   const writer = stream._writer;\n  371:   if (writer !== undefined && stream._backpressure && state === 'writable') {\n  372:     defaultWriterReadyPromiseResolve(writer);\n  373    }\n  374  \n  ...\n  385  \n  386    const promise = newPromise<undefined>((resolve, reject) => {\n  387:     const writeRequest: WriteRequest = {\n  388        _resolve: resolve,\n  389        _reject: reject\n  390      };\n  391  \n  392:     stream._writeRequests.push(writeRequest);\n  393    });\n  394  \n  ...\n  417    stream._state = 'erroring';\n  418    stream._storedError = reason;\n  419:   const writer = stream._writer;\n  420:   if (writer !== undefined) {\n  421:     WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  422    }\n  423  \n  ...\n  434  \n  435    const storedError = stream._storedError;\n  436:   stream._writeRequests.forEach((writeRequest) => {\n  437:     writeRequest._reject(storedError);\n  438    });\n  439    stream._writeRequests = new SimpleQueue();\n  ...\n  505    stream._state = 'closed';\n  506  \n  507:   const writer = stream._writer;\n  508:   if (writer !== undefined) {\n  509:     defaultWriterClosedPromiseResolve(writer);\n  510    }\n  511  \n  ...\n  567      stream._closeRequest = undefined;\n  568    }\n  569:   const writer = stream._writer;\n  570:   if (writer !== undefined) {\n  571:     defaultWriterClosedPromiseReject(writer, stream._storedError);\n  572    }\n  573  }\n  ...\n  577    assert(!WritableStreamCloseQueuedOrInFlight(stream));\n  578  \n  579:   const writer = stream._writer;\n  580:   if (writer !== undefined && backpressure !== stream._backpressure) {\n  581      if (backpressure) {\n  582:       defaultWriterReadyPromiseReset(writer);\n  583      } else {\n  584        assert(!backpressure);\n  585  \n  586:       defaultWriterReadyPromiseResolve(writer);\n  587      }\n  588    }\n  ...\n  592  \n  593  /**\n  594:  * A default writer vended by a {@link WritableStream}.\n  595   *\n  596   * @public\n  ...\n  621  \n  622      if (IsWritableStreamLocked(stream)) {\n  623:       throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n  624      }\n  625  \n  ...\n  654    /**\n  655     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n  656:    * the writerâ€™s lock is released before the stream finishes closing.\n  657     */\n  658    get closed(): Promise<undefined> {\n  ...\n  666    /**\n  667     * Returns the desired size to fill the streamâ€™s internal queue. It can be negative, if the queue is over-full.\n  668:    * A producer can use this information to determine the right amount of data to write.\n  669     *\n  670     * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n  671     * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n  672:    * the writerâ€™s lock is released.\n  673     */\n  674    get desiredSize(): number | null {\n  ...\n  689     * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n  690     *\n  691:    * If the stream becomes errored or aborted, or the writerâ€™s lock is released, the returned promise will become\n  692     * rejected.\n  693     */\n  694:   get ready(): Promise<undefined> {\n  695      if (!IsWritableStreamDefaultWriter(this)) {\n  696:       return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n  697      }\n  698  \n  ...\n  701  \n  702    /**\n  703:    * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n  704     */\n  705    abort(reason: any = undefined): Promise<void> {\n  ...\n  716  \n  717    /**\n  718:    * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n  719     */\n  720    close(): Promise<void> {\n  ...\n  737  \n  738    /**\n  739:    * Releases the writerâ€™s lock on the corresponding stream. After the lock is released, the writer is no longer active.\n  740:    * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n  741:    * now on; otherwise, the writer will appear closed.\n  742     *\n  743:    * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n  744:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n  745:    * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n  746     * other producers from writing in an interleaved manner.\n  747     */\n  ...\n  763  \n  764    /**\n  765:    * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n  766:    * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n  767:    * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n  768     * errored before the writing process is initiated.\n  769     *\n  ...\n  771     * accepted, and not necessarily that it is safely saved to its ultimate destination.\n  772     */\n  773:   write(chunk: W): Promise<void>;\n  774:   write(chunk: W = undefined!): Promise<void> {\n  775      if (!IsWritableStreamDefaultWriter(this)) {\n  776:       return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n  777      }\n  778  \n  779      if (this._ownerWritableStream === undefined) {\n  780:       return promiseRejectedWith(defaultWriterLockException('write to'));\n  781      }\n  782  \n  ...\n  789    close: { enumerable: true },\n  790    releaseLock: { enumerable: true },\n  791:   write: { enumerable: true },\n  792    closed: { enumerable: true },\n  793    desiredSize: { enumerable: true },\n  794:   ready: { enumerable: true }\n  795  });\n  796  setFunctionName(WritableStreamDefaultWriter.prototype.abort, 'abort');\n  797  setFunctionName(WritableStreamDefaultWriter.prototype.close, 'close');\n  798  setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, 'releaseLock');\n  799: setFunctionName(WritableStreamDefaultWriter.prototype.write, 'write');\n  800  if (typeof Symbol.toStringTag === 'symbol') {\n  801    Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {\n  ...\n  821  // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n  822  \n  823: function WritableStreamDefaultWriterAbort(writer: WritableStreamDefaultWriter, reason: any) {\n  824:   const stream = writer._ownerWritableStream;\n  825  \n  826    assert(stream !== undefined);\n  ...\n  829  }\n  830  \n  831: function WritableStreamDefaultWriterClose(writer: WritableStreamDefaultWriter): Promise<undefined> {\n  832:   const stream = writer._ownerWritableStream;\n  833  \n  834    assert(stream !== undefined);\n  ...\n  837  }\n  838  \n  839: function WritableStreamDefaultWriterCloseWithErrorPropagation(writer: WritableStreamDefaultWriter): Promise<undefined> {\n  840:   const stream = writer._ownerWritableStream;\n  841  \n  842    assert(stream !== undefined);\n  ...\n  853    assert(state === 'writable' || state === 'erroring');\n  854  \n  855:   return WritableStreamDefaultWriterClose(writer);\n  856  }\n  857  \n  858: function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer: WritableStreamDefaultWriter, error: any) {\n  859:   if (writer._closedPromiseState === 'pending') {\n  860:     defaultWriterClosedPromiseReject(writer, error);\n  861    } else {\n  862:     defaultWriterClosedPromiseResetToRejected(writer, error);\n  863    }\n  864  }\n  865  \n  866: function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer: WritableStreamDefaultWriter, error: any) {\n  867:   if (writer._readyPromiseState === 'pending') {\n  868:     defaultWriterReadyPromiseReject(writer, error);\n  869    } else {\n  870:     defaultWriterReadyPromiseResetToRejected(writer, error);\n  871    }\n  872  }\n  873  \n  874: function WritableStreamDefaultWriterGetDesiredSize(writer: WritableStreamDefaultWriter): number | null {\n  875:   const stream = writer._ownerWritableStream;\n  876    const state = stream._state;\n  877  \n  ...\n  887  }\n  888  \n  889: function WritableStreamDefaultWriterRelease(writer: WritableStreamDefaultWriter) {\n  890:   const stream = writer._ownerWritableStream;\n  891    assert(stream !== undefined);\n  892:   assert(stream._writer === writer);\n  893  \n  894    const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n  895  \n  896:   WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n  897  \n  898:   // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n  899    // rejected until afterwards. This means that simply testing state will not work.\n  900:   WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n  901  \n  902    stream._writer = undefined;\n  903:   writer._ownerWritableStream = undefined!;\n  904  }\n  905  \n  906: function WritableStreamDefaultWriterWrite<W>(writer: WritableStreamDefaultWriter<W>, chunk: W): Promise<undefined> {\n  907:   const stream = writer._ownerWritableStream;\n  908  \n  909    assert(stream !== undefined);\n  ...\n  913    const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n  914  \n  915:   if (stream !== writer._ownerWritableStream) {\n  916:     return promiseRejectedWith(defaultWriterLockException('write to'));\n  917    }\n  918  \n  ...\n  989  \n  990    /**\n  991:    * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n  992     */\n  993    get signal(): AbortSignal {\n  ...\n 1068    controller: WritableStreamDefaultController<W>,\n 1069    startAlgorithm: () => void | PromiseLike<void>,\n 1070:   writeAlgorithm: (chunk: W) => Promise<void>,\n 1071    closeAlgorithm: () => Promise<void>,\n 1072    abortAlgorithm: (reason: any) => Promise<void>,\n ....\n 1092    controller._strategyHWM = highWaterMark;\n 1093  \n 1094:   controller._writeAlgorithm = writeAlgorithm;\n 1095    controller._closeAlgorithm = closeAlgorithm;\n 1096    controller._abortAlgorithm = abortAlgorithm;\n ....\n 1127  \n 1128    let startAlgorithm: () => void | PromiseLike<void>;\n 1129:   let writeAlgorithm: (chunk: W) => Promise<void>;\n 1130    let closeAlgorithm: () => Promise<void>;\n 1131    let abortAlgorithm: (reason: any) => Promise<void>;\n ....\n 1136      startAlgorithm = () => undefined;\n 1137    }\n 1138:   if (underlyingSink.write !== undefined) {\n 1139:     writeAlgorithm = chunk => underlyingSink.write!(chunk, controller);\n 1140    } else {\n 1141:     writeAlgorithm = () => promiseResolvedWith(undefined);\n 1142    }\n 1143    if (underlyingSink.close !== undefined) {\n ....\n 1152    }\n 1153  \n 1154:   SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n 1155  }\n 1156  \n ....\n 1340  \n 1341  function defaultWriterLockException(name: string): TypeError {\n 1342:   return new TypeError('Cannot ' + name + ' a stream using a released writer');\n 1343  }\n 1344  \n 1345: function defaultWriterClosedPromiseInitialize(writer: WritableStreamDefaultWriter) {\n 1346:   writer._closedPromise = newPromise((resolve, reject) => {\n 1347:     writer._closedPromise_resolve = resolve;\n 1348:     writer._closedPromise_reject = reject;\n 1349:     writer._closedPromiseState = 'pending';\n 1350    });\n 1351  }\n 1352  \n 1353: function defaultWriterClosedPromiseInitializeAsRejected(writer: WritableStreamDefaultWriter, reason: any) {\n 1354:   defaultWriterClosedPromiseInitialize(writer);\n 1355:   defaultWriterClosedPromiseReject(writer, reason);\n 1356  }\n 1357  \n 1358: function defaultWriterClosedPromiseInitializeAsResolved(writer: WritableStreamDefaultWriter) {\n 1359:   defaultWriterClosedPromiseInitialize(writer);\n 1360:   defaultWriterClosedPromiseResolve(writer);\n 1361  }\n 1362  \n 1363: function defaultWriterClosedPromiseReject(writer: WritableStreamDefaultWriter, reason: any) {\n 1364:   if (writer._closedPromise_reject === undefined) {\n 1365      return;\n 1366    }\n 1367:   assert(writer._closedPromiseState === 'pending');\n 1368  \n 1369:   setPromiseIsHandledToTrue(writer._closedPromise);\n 1370:   writer._closedPromise_reject(reason);\n 1371:   writer._closedPromise_resolve = undefined;\n 1372:   writer._closedPromise_reject = undefined;\n 1373:   writer._closedPromiseState = 'rejected';\n 1374  }\n 1375  \n 1376: function defaultWriterClosedPromiseResetToRejected(writer: WritableStreamDefaultWriter, reason: any) {\n 1377:   assert(writer._closedPromise_resolve === undefined);\n 1378:   assert(writer._closedPromise_reject === undefined);\n 1379:   assert(writer._closedPromiseState !== 'pending');\n 1380  \n 1381:   defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n 1382  }\n 1383  \n 1384: function defaultWriterClosedPromiseResolve(writer: WritableStreamDefaultWriter) {\n 1385:   if (writer._closedPromise_resolve === undefined) {\n 1386      return;\n 1387    }\n 1388:   assert(writer._closedPromiseState === 'pending');\n 1389  \n 1390:   writer._closedPromise_resolve(undefined);\n 1391:   writer._closedPromise_resolve = undefined;\n 1392:   writer._closedPromise_reject = undefined;\n 1393:   writer._closedPromiseState = 'resolved';\n 1394  }\n 1395  \n 1396: function defaultWriterReadyPromiseInitialize(writer: WritableStreamDefaultWriter) {\n 1397:   writer._readyPromise = newPromise((resolve, reject) => {\n 1398:     writer._readyPromise_resolve = resolve;\n 1399:     writer._readyPromise_reject = reject;\n 1400    });\n 1401:   writer._readyPromiseState = 'pending';\n 1402  }\n 1403  \n 1404: function defaultWriterReadyPromiseInitializeAsRejected(writer: WritableStreamDefaultWriter, reason: any) {\n 1405:   defaultWriterReadyPromiseInitialize(writer);\n 1406:   defaultWriterReadyPromiseReject(writer, reason);\n 1407  }\n 1408  \n 1409: function defaultWriterReadyPromiseInitializeAsResolved(writer: WritableStreamDefaultWriter) {\n 1410:   defaultWriterReadyPromiseInitialize(writer);\n 1411:   defaultWriterReadyPromiseResolve(writer);\n 1412  }\n 1413  \n 1414: function defaultWriterReadyPromiseReject(writer: WritableStreamDefaultWriter, reason: any) {\n 1415:   if (writer._readyPromise_reject === undefined) {\n 1416      return;\n 1417    }\n 1418  \n 1419:   setPromiseIsHandledToTrue(writer._readyPromise);\n 1420:   writer._readyPromise_reject(reason);\n 1421:   writer._readyPromise_resolve = undefined;\n 1422:   writer._readyPromise_reject = undefined;\n 1423:   writer._readyPromiseState = 'rejected';\n 1424  }\n 1425  \n 1426: function defaultWriterReadyPromiseReset(writer: WritableStreamDefaultWriter) {\n 1427:   assert(writer._readyPromise_resolve === undefined);\n 1428:   assert(writer._readyPromise_reject === undefined);\n 1429  \n 1430:   defaultWriterReadyPromiseInitialize(writer);\n 1431  }\n 1432  \n 1433: function defaultWriterReadyPromiseResetToRejected(writer: WritableStreamDefaultWriter, reason: any) {\n 1434:   assert(writer._readyPromise_resolve === undefined);\n 1435:   assert(writer._readyPromise_reject === undefined);\n 1436  \n 1437:   defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n 1438  }\n 1439  \n 1440: function defaultWriterReadyPromiseResolve(writer: WritableStreamDefaultWriter) {\n 1441:   if (writer._readyPromise_resolve === undefined) {\n 1442      return;\n 1443    }\n 1444  \n 1445:   writer._readyPromise_resolve(undefined);\n 1446:   writer._readyPromise_resolve = undefined;\n 1447:   writer._readyPromise_reject = undefined;\n 1448:   writer._readyPromiseState = 'fulfilled';\n 1449  }\n 1450  \n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/simple-queue.js:\n   52          ++this._size;\n   53      }\n   54:     // Like push(), shift() follows the read -> calculate -> mutate pattern for\n   55      // exception safety.\n   56      shift() {\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/abort-signal.ts:\n   10  export type AbortSignal = typeof globalThis extends { AbortSignal: { prototype: infer T } } ? T : {\n   11    aborted: boolean;\n   12:   readonly reason?: any;\n   13    addEventListener(type: 'abort', listener: () => void): void;\n   14    removeEventListener(type: 'abort', listener: () => void): void;\n   ..\n   38  // https://github.com/DefinitelyTyped/DefinitelyTyped/blob/0c370ead967cb97b1758d8fa15d09011fb3f58ea/types/node/globals.d.ts#L226\n   39  export type AbortController = typeof globalThis extends { AbortController: { prototype: infer T } } ? T : {\n   40:   readonly signal: AbortSignal;\n   41    abort(reason?: any): void;\n   42  };\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/transform-stream.js:\n    1  import assert from '../stub/assert';\n    2  import { newPromise, promiseRejectedWith, promiseResolvedWith, setPromiseIsHandledToTrue, transformPromiseWith, uponPromise } from './helpers/webidl';\n    3: import { CreateReadableStream, ReadableStream } from './readable-stream';\n    4: <skipped 179 characters> ...ableStreamDefaultControllerGetDesiredSize, ReadableStreamDefaultControllerHasBackpressure } from './readable-stream/default-controller';\n    5  import { CreateWritableStream, WritableStream, WritableStreamDefaultControllerErrorIfNeeded } from './writable-stream';\n    6  import { setFunctionName, typeIsObject } from './helpers/miscellaneous';\n    .\n   12  /**\n   13   * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n   14:  * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n   15:  * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n   16:  * made available for reading from the readable side.\n   17   *\n   18   * @public\n   ..\n   24          }\n   25          const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n   26:         const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n   27          const transformer = convertTransformer(rawTransformer, 'First parameter');\n   28:         if (transformer.readableType !== undefined) {\n   29:             throw new RangeError('Invalid readableType specified');\n   30          }\n   31          if (transformer.writableType !== undefined) {\n   32              throw new RangeError('Invalid writableType specified');\n   33          }\n   34:         const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n   35:         const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n   36          const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n   37          const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n   ..\n   40              startPromise_resolve = resolve;\n   41          });\n   42:         InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n   43          SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n   44          if (transformer.start !== undefined) {\n   ..\n   50      }\n   51      /**\n   52:      * The readable side of the transform stream.\n   53       */\n   54:     get readable() {\n   55          if (!IsTransformStream(this)) {\n   56:             throw streamBrandCheckException('readable');\n   57          }\n   58          return this._readable;\n   ..\n   69  }\n   70  Object.defineProperties(TransformStream.prototype, {\n   71:     readable: { enumerable: true },\n   72      writable: { enumerable: true }\n   73  });\n   ..\n   79  }\n   80  // Transform Stream Abstract Operations\n   81: <skipped 67 characters> ...rithm, flushAlgorithm, cancelAlgorithm, writableHighWaterMark = 1, writableSizeAlgorithm = () => 1, readableHighWaterMark = 0, readableSizeAlgorithm = () => 1) {\n   82      assert(IsNonNegativeNumber(writableHighWaterMark));\n   83:     assert(IsNonNegativeNumber(readableHighWaterMark));\n   84      const stream = Object.create(TransformStream.prototype);\n   85      let startPromise_resolve;\n   ..\n   87          startPromise_resolve = resolve;\n   88      });\n   89:     InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n   90      const controller = Object.create(TransformStreamDefaultController.prototype);\n   91      SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);\n   ..\n   94      return stream;\n   95  }\n   96: function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n   97      function startAlgorithm() {\n   98          return startPromise;\n   99      }\n  100:     function writeAlgorithm(chunk) {\n  101          return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  102      }\n  ...\n  107          return TransformStreamDefaultSinkCloseAlgorithm(stream);\n  108      }\n  109:     stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n  110      function pullAlgorithm() {\n  111          return TransformStreamDefaultSourcePullAlgorithm(stream);\n  ...\n  114          return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);\n  115      }\n  116:     stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n  117      // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n  118      stream._backpressure = undefined;\n  ...\n  143  function TransformStreamUnblockWrite(stream) {\n  144      if (stream._backpressure) {\n  145:         // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n  146          // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n  147          // _backpressure is set.\n  ...\n  171      }\n  172      /**\n  173:      * Returns the desired size to fill the readable sideâ€™s internal queue. It can be negative, if the queue is over-full.\n  174       */\n  175      get desiredSize() {\n  ...\n  177              throw defaultControllerBrandCheckException('desiredSize');\n  178          }\n  179:         const readableController = this._controlledTransformStream._readable._readableStreamController;\n  180:         return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n  181      }\n  182      enqueue(chunk = undefined) {\n  ...\n  187      }\n  188      /**\n  189:      * Errors both the readable side and the writable side of the controlled transform stream, making all future\n  190       * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n  191       */\n  ...\n  197      }\n  198      /**\n  199:      * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n  200       * transformer only needs to consume a portion of the chunks written to the writable side.\n  201       */\n  ...\n  284  function TransformStreamDefaultControllerEnqueue(controller, chunk) {\n  285      const stream = controller._controlledTransformStream;\n  286:     const readableController = stream._readable._readableStreamController;\n  287:     if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n  288          throw new TypeError('Readable side is not in a state that permits enqueue');\n  289      }\n  ...\n  291      // accept TransformStreamDefaultControllerEnqueue() calls.\n  292      try {\n  293:         ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n  294      }\n  295      catch (e) {\n  296:         // This happens when readableStrategy.size() throws.\n  297          TransformStreamErrorWritableAndUnblockWrite(stream, e);\n  298          throw stream._readable._storedError;\n  299      }\n  300:     const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n  301      if (backpressure !== stream._backpressure) {\n  302          assert(backpressure);\n  ...\n  316  function TransformStreamDefaultControllerTerminate(controller) {\n  317      const stream = controller._controlledTransformStream;\n  318:     const readableController = stream._readable._readableStreamController;\n  319:     ReadableStreamDefaultControllerClose(readableController);\n  320      const error = new TypeError('TransformStream terminated');\n  321      TransformStreamErrorWritableAndUnblockWrite(stream, error);\n  ...\n  346      }\n  347      // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  348:     const readable = stream._readable;\n  349:     // Assign the _finishPromise now so that if _cancelAlgorithm calls readable.cancel() internally,\n  350      // we don't run the _cancelAlgorithm again.\n  351      controller._finishPromise = newPromise((resolve, reject) => {\n  ...\n  356      TransformStreamDefaultControllerClearAlgorithms(controller);\n  357      uponPromise(cancelPromise, () => {\n  358:         if (readable._state === 'errored') {\n  359:             defaultControllerFinishPromiseReject(controller, readable._storedError);\n  360          }\n  361          else {\n  362:             ReadableStreamDefaultControllerError(readable._readableStreamController, reason);\n  363              defaultControllerFinishPromiseResolve(controller);\n  364          }\n  365          return null;\n  366      }, (r) => {\n  367:         ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n  368          defaultControllerFinishPromiseReject(controller, r);\n  369          return null;\n  ...\n  377      }\n  378      // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  379:     const readable = stream._readable;\n  380:     // Assign the _finishPromise now so that if _flushAlgorithm calls readable.cancel() internally,\n  381      // we don't also run the _cancelAlgorithm.\n  382      controller._finishPromise = newPromise((resolve, reject) => {\n  ...\n  387      TransformStreamDefaultControllerClearAlgorithms(controller);\n  388      uponPromise(flushPromise, () => {\n  389:         if (readable._state === 'errored') {\n  390:             defaultControllerFinishPromiseReject(controller, readable._storedError);\n  391          }\n  392          else {\n  393:             ReadableStreamDefaultControllerClose(readable._readableStreamController);\n  394              defaultControllerFinishPromiseResolve(controller);\n  395          }\n  396          return null;\n  397      }, (r) => {\n  398:         ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n  399          defaultControllerFinishPromiseReject(controller, r);\n  400          return null;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/transform-stream/transformer.ts:\n   25    start?: TransformerStartCallback<O>;\n   26    /**\n   27:    * A function called when a new chunk originally written to the writable side is ready to be transformed.\n   28     */\n   29    transform?: TransformerTransformCallback<I, O>;\n   ..\n   34    flush?: TransformerFlushCallback<O>;\n   35    /**\n   36:    * A function called when the readable side is cancelled, or when the writable side is aborted.\n   37     */\n   38    cancel?: TransformerCancelCallback;\n   39:   readableType?: undefined;\n   40    writableType?: undefined;\n   41  }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/transform-stream/transformer.d.ts:\n   19      start?: TransformerStartCallback<O>;\n   20      /**\n   21:      * A function called when a new chunk originally written to the writable side is ready to be transformed.\n   22       */\n   23      transform?: TransformerTransformCallback<I, O>;\n   ..\n   28      flush?: TransformerFlushCallback<O>;\n   29      /**\n   30:      * A function called when the readable side is cancelled, or when the writable side is aborted.\n   31       */\n   32      cancel?: TransformerCancelCallback;\n   33:     readableType?: undefined;\n   34      writableType?: undefined;\n   35  }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/helpers/array-buffer-view.d.ts:\n    5  export interface ArrayBufferViewConstructor<T extends ArrayBufferView = ArrayBufferView> {\n    6      new (buffer: ArrayBuffer, byteOffset: number, length?: number): T;\n    7:     readonly prototype: T;\n    8  }\n    9  export interface TypedArrayConstructor<T extends TypedArray = TypedArray> extends ArrayBufferViewConstructor<T> {\n   10:     readonly BYTES_PER_ELEMENT: number;\n   11  }\n   12  export type DataViewConstructor = ArrayBufferViewConstructor<DataView>;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/helpers/array-buffer-view.ts:\n   17    new(buffer: ArrayBuffer, byteOffset: number, length?: number): T;\n   18  \n   19:   readonly prototype: T;\n   20  }\n   21  \n   22  export interface TypedArrayConstructor<T extends TypedArray = TypedArray> extends ArrayBufferViewConstructor<T> {\n   23:   readonly BYTES_PER_ELEMENT: number;\n   24  }\n   25  \n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/abstract-ops/ecmascript.ts:\n   11  declare global {\n   12    interface ArrayBuffer {\n   13:     readonly detached: boolean;\n   14  \n   15      transfer(): ArrayBuffer;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/abstract-ops/ecmascript.d.ts:\n    1  declare global {\n    2      interface ArrayBuffer {\n    3:         readonly detached: boolean;\n    4          transfer(): ArrayBuffer;\n    5      }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/from.js:\n    1: import { CreateReadableStream } from '../readable-stream';\n    2: import { isReadableStreamLike } from './readable-stream-like';\n    3  import { ReadableStreamDefaultControllerClose, ReadableStreamDefaultControllerEnqueue } from './default-controller';\n    4  import { GetIterator, GetMethod, IteratorNext } from '../abstract-ops/ecmascript';\n    .\n   62      return stream;\n   63  }\n   64: export function ReadableStreamFromDefaultReader(reader) {\n   65      let stream;\n   66      const startAlgorithm = noop;\n   67      function pullAlgorithm() {\n   68:         let readPromise;\n   69          try {\n   70:             readPromise = reader.read();\n   71          }\n   72          catch (e) {\n   73              return promiseRejectedWith(e);\n   74          }\n   75:         return transformPromiseWith(readPromise, (readResult) => {\n   76:             if (!typeIsObject(readResult)) {\n   77:                 throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\n   78              }\n   79:             if (readResult.done) {\n   80                  ReadableStreamDefaultControllerClose(stream._readableStreamController);\n   81              }\n   82              else {\n   83:                 const value = readResult.value;\n   84                  ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\n   85              }\n   ..\n   88      function cancelAlgorithm(reason) {\n   89          try {\n   90:             return promiseResolvedWith(reader.cancel(reason));\n   91          }\n   92          catch (e) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/underlying-source.d.ts:\n   60      cancel?: UnderlyingSourceCancelCallback;\n   61      /**\n   62:      * Can be set to \"bytes\" to signal that the constructed {@link ReadableStream} is a readable byte stream.\n   63:      * This ensures that the resulting {@link ReadableStream} will successfully be able to vend BYOB readers via its\n   64       * {@link ReadableStream.(getReader:1) | getReader()} method.\n   65       * It also affects the controller argument passed to the {@link UnderlyingByteSource.start | start()}\n   ..\n   69      /**\n   70       * Can be set to a positive integer to cause the implementation to automatically allocate buffers for the\n   71:      * underlying source code to write into. In this case, when a consumer is using a default reader, the stream\n   72       * implementation will automatically allocate an ArrayBuffer of the given size, so that\n   73       * {@link ReadableByteStreamController.byobRequest | controller.byobRequest} is always present,\n   74:      * as if the consumer was using a BYOB reader.\n   75       */\n   76      autoAllocateChunkSize?: number;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/readable-writable-pair.ts:\n    1: import { ReadableStream } from '../readable-stream';\n    2  import { WritableStream } from '../writable-stream';\n    3  \n    4  /**\n    5:  * A pair of a {@link ReadableStream | readable stream} and {@link WritableStream | writable stream} that can be passed\n    6   * to {@link ReadableStream.pipeThrough}.\n    7   *\n    .\n    9   */\n   10  export interface ReadableWritablePair<R, W> {\n   11:   readable: ReadableStream<R>;\n   12    writable: WritableStream<W>;\n   13  }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/async-iterator.ts:\n    1: import { ReadableStream } from '../readable-stream';\n    2  import {\n    3    AcquireReadableStreamDefaultReader,\n    .\n    6    type ReadableStreamDefaultReadResult,\n    7    type ReadRequest\n    8: } from './default-reader';\n    9: import { ReadableStreamReaderGenericCancel, ReadableStreamReaderGenericRelease } from './generic-reader';\n   10  import assert from '../../stub/assert';\n   11  import { SymbolAsyncIterator } from '../abstract-ops/ecmascript';\n   ..\n   31  \n   32  export class ReadableStreamAsyncIteratorImpl<R> {\n   33:   private readonly _reader: ReadableStreamDefaultReader<R>;\n   34:   private readonly _preventCancel: boolean;\n   35    private _ongoingPromise: Promise<ReadableStreamDefaultReadResult<R>> | undefined = undefined;\n   36    private _isFinished = false;\n   37  \n   38:   constructor(reader: ReadableStreamDefaultReader<R>, preventCancel: boolean) {\n   39:     this._reader = reader;\n   40      this._preventCancel = preventCancel;\n   41    }\n   ..\n   62      }\n   63  \n   64:     const reader = this._reader;\n   65:     assert(reader._ownerReadableStream !== undefined);\n   66  \n   67      let resolvePromise!: (result: ReadableStreamDefaultReadResult<R>) => void;\n   ..\n   71        rejectPromise = reject;\n   72      });\n   73:     const readRequest: ReadRequest<R> = {\n   74        _chunkSteps: (chunk) => {\n   75          this._ongoingPromise = undefined;\n   ..\n   81          this._ongoingPromise = undefined;\n   82          this._isFinished = true;\n   83:         ReadableStreamReaderGenericRelease(reader);\n   84          resolvePromise({ value: undefined, done: true });\n   85        },\n   ..\n   87          this._ongoingPromise = undefined;\n   88          this._isFinished = true;\n   89:         ReadableStreamReaderGenericRelease(reader);\n   90          rejectPromise(reason);\n   91        }\n   92      };\n   93:     ReadableStreamDefaultReaderRead(reader, readRequest);\n   94      return promise;\n   95    }\n   ..\n  101      this._isFinished = true;\n  102  \n  103:     const reader = this._reader;\n  104:     assert(reader._ownerReadableStream !== undefined);\n  105:     assert(reader._readRequests.length === 0);\n  106  \n  107      if (!this._preventCancel) {\n  108:       const result = ReadableStreamReaderGenericCancel(reader, value);\n  109:       ReadableStreamReaderGenericRelease(reader);\n  110        return transformPromiseWith(result, () => ({ value, done: true }));\n  111      }\n  112  \n  113:     ReadableStreamReaderGenericRelease(reader);\n  114      return promiseResolvedWith({ value, done: true });\n  115    }\n  ...\n  157    preventCancel: boolean\n  158  ): ReadableStreamAsyncIterator<R> {\n  159:   const reader = AcquireReadableStreamDefaultReader<R>(stream);\n  160:   const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n  161    const iterator: ReadableStreamAsyncIteratorInstance<R> = Object.create(ReadableStreamAsyncIteratorPrototype);\n  162    iterator._asyncIteratorImpl = impl;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/underlying-source.ts:\n   73    cancel?: UnderlyingSourceCancelCallback;\n   74    /**\n   75:    * Can be set to \"bytes\" to signal that the constructed {@link ReadableStream} is a readable byte stream.\n   76:    * This ensures that the resulting {@link ReadableStream} will successfully be able to vend BYOB readers via its\n   77     * {@link ReadableStream.(getReader:1) | getReader()} method.\n   78     * It also affects the controller argument passed to the {@link UnderlyingByteSource.start | start()}\n   ..\n   82    /**\n   83     * Can be set to a positive integer to cause the implementation to automatically allocate buffers for the\n   84:    * underlying source code to write into. In this case, when a consumer is using a default reader, the stream\n   85     * implementation will automatically allocate an ArrayBuffer of the given size, so that\n   86     * {@link ReadableByteStreamController.byobRequest | controller.byobRequest} is always present,\n   87:    * as if the consumer was using a BYOB reader.\n   88     */\n   89    autoAllocateChunkSize?: number;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/tee.js:\n    1: import { CreateReadableByteStream, CreateReadableStream, IsReadableStream, ReadableStream, ReadableStreamCancel } from '../readable-stream';\n    2: import { ReadableStreamReaderGenericRelease } from './generic-reader';\n    3: import { AcquireReadableStreamDefaultReader, IsReadableStreamDefaultReader, ReadableStreamDefaultReaderRead } from './default-reader';\n    4: import { AcquireReadableStreamBYOBReader, IsReadableStreamBYOBReader, ReadableStreamBYOBReaderRead } from './byob-reader';\n    5  import assert from '../../stub/assert';\n    6  import { newPromise, promiseResolvedWith, queueMicrotask, uponRejection } from '../helpers/webidl';\n    .\n   20      assert(IsReadableStream(stream));\n   21      assert(typeof cloneForBranch2 === 'boolean');\n   22:     const reader = AcquireReadableStreamDefaultReader(stream);\n   23:     let reading = false;\n   24:     let readAgain = false;\n   25      let canceled1 = false;\n   26      let canceled2 = false;\n   ..\n   34      });\n   35      function pullAlgorithm() {\n   36:         if (reading) {\n   37:             readAgain = true;\n   38              return promiseResolvedWith(undefined);\n   39          }\n   40:         reading = true;\n   41:         const readRequest = {\n   42              _chunkSteps: (chunk) => {\n   43                  // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n   44:                 // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n   45:                 // successful synchronously-available reads get ahead of asynchronously-available errors.\n   46                  queueMicrotask(() => {\n   47:                     readAgain = false;\n   48                      const chunk1 = chunk;\n   49                      const chunk2 = chunk;\n   ..\n   59                          ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n   60                      }\n   61:                     reading = false;\n   62:                     if (readAgain) {\n   63                          pullAlgorithm();\n   64                      }\n   ..\n   66              },\n   67              _closeSteps: () => {\n   68:                 reading = false;\n   69                  if (!canceled1) {\n   70                      ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n   ..\n   78              },\n   79              _errorSteps: () => {\n   80:                 reading = false;\n   81              }\n   82          };\n   83:         ReadableStreamDefaultReaderRead(reader, readRequest);\n   84          return promiseResolvedWith(undefined);\n   85      }\n   ..\n  109      branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n  110      branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n  111:     uponRejection(reader._closedPromise, (r) => {\n  112          ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n  113          ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n  ...\n  122      assert(IsReadableStream(stream));\n  123      assert(IsReadableByteStreamController(stream._readableStreamController));\n  124:     let reader = AcquireReadableStreamDefaultReader(stream);\n  125:     let reading = false;\n  126:     let readAgainForBranch1 = false;\n  127:     let readAgainForBranch2 = false;\n  128      let canceled1 = false;\n  129      let canceled2 = false;\n  ...\n  138      function forwardReaderError(thisReader) {\n  139          uponRejection(thisReader._closedPromise, (r) => {\n  140:             if (thisReader !== reader) {\n  141                  return null;\n  142              }\n  ...\n  150      }\n  151      function pullWithDefaultReader() {\n  152:         if (IsReadableStreamBYOBReader(reader)) {\n  153:             assert(reader._readIntoRequests.length === 0);\n  154:             ReadableStreamReaderGenericRelease(reader);\n  155:             reader = AcquireReadableStreamDefaultReader(stream);\n  156:             forwardReaderError(reader);\n  157          }\n  158:         const readRequest = {\n  159              _chunkSteps: (chunk) => {\n  160                  // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n  161:                 // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n  162:                 // successful synchronously-available reads get ahead of asynchronously-available errors.\n  163                  queueMicrotask(() => {\n  164:                     readAgainForBranch1 = false;\n  165:                     readAgainForBranch2 = false;\n  166                      const chunk1 = chunk;\n  167                      let chunk2 = chunk;\n  ...\n  183                          ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n  184                      }\n  185:                     reading = false;\n  186:                     if (readAgainForBranch1) {\n  187                          pull1Algorithm();\n  188                      }\n  189:                     else if (readAgainForBranch2) {\n  190                          pull2Algorithm();\n  191                      }\n  ...\n  193              },\n  194              _closeSteps: () => {\n  195:                 reading = false;\n  196                  if (!canceled1) {\n  197                      ReadableByteStreamControllerClose(branch1._readableStreamController);\n  ...\n  211              },\n  212              _errorSteps: () => {\n  213:                 reading = false;\n  214              }\n  215          };\n  216:         ReadableStreamDefaultReaderRead(reader, readRequest);\n  217      }\n  218      function pullWithBYOBReader(view, forBranch2) {\n  219:         if (IsReadableStreamDefaultReader(reader)) {\n  220:             assert(reader._readRequests.length === 0);\n  221:             ReadableStreamReaderGenericRelease(reader);\n  222:             reader = AcquireReadableStreamBYOBReader(stream);\n  223:             forwardReaderError(reader);\n  224          }\n  225          const byobBranch = forBranch2 ? branch2 : branch1;\n  226          const otherBranch = forBranch2 ? branch1 : branch2;\n  227:         const readIntoRequest = {\n  228              _chunkSteps: (chunk) => {\n  229                  // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n  230:                 // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n  231:                 // successful synchronously-available reads get ahead of asynchronously-available errors.\n  232                  queueMicrotask(() => {\n  233:                     readAgainForBranch1 = false;\n  234:                     readAgainForBranch2 = false;\n  235                      const byobCanceled = forBranch2 ? canceled2 : canceled1;\n  236                      const otherCanceled = forBranch2 ? canceled1 : canceled2;\n  ...\n  254                          ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n  255                      }\n  256:                     reading = false;\n  257:                     if (readAgainForBranch1) {\n  258                          pull1Algorithm();\n  259                      }\n  260:                     else if (readAgainForBranch2) {\n  261                          pull2Algorithm();\n  262                      }\n  ...\n  264              },\n  265              _closeSteps: (chunk) => {\n  266:                 reading = false;\n  267                  const byobCanceled = forBranch2 ? canceled2 : canceled1;\n  268                  const otherCanceled = forBranch2 ? canceled1 : canceled2;\n  ...\n  287              },\n  288              _errorSteps: () => {\n  289:                 reading = false;\n  290              }\n  291          };\n  292:         ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);\n  293      }\n  294      function pull1Algorithm() {\n  295:         if (reading) {\n  296:             readAgainForBranch1 = true;\n  297              return promiseResolvedWith(undefined);\n  298          }\n  299:         reading = true;\n  300          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n  301          if (byobRequest === null) {\n  ...\n  308      }\n  309      function pull2Algorithm() {\n  310:         if (reading) {\n  311:             readAgainForBranch2 = true;\n  312              return promiseResolvedWith(undefined);\n  313          }\n  314:         reading = true;\n  315          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n  316          if (byobRequest === null) {\n  ...\n  347      branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n  348      branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n  349:     forwardReaderError(reader);\n  350      return [branch1, branch2];\n  351  }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byte-stream-controller.d.ts:\n    1: import { type ReadRequest } from './default-reader';\n    2: import { type ReadIntoRequest } from './byob-reader';\n    3: import { type ReadableByteStream } from '../readable-stream';\n    4  import type { ValidatedUnderlyingByteSource } from './underlying-source';\n    5  import { type NonShared } from '../helpers/array-buffer-view';\n    .\n   16      get view(): ArrayBufferView | null;\n   17      /**\n   18:      * Indicates to the associated readable byte stream that `bytesWritten` bytes were written into\n   19       * {@link ReadableStreamBYOBRequest.view | view}, causing the result be surfaced to the consumer.\n   20       *\n   ..\n   24      respond(bytesWritten: number): void;\n   25      /**\n   26:      * Indicates to the associated readable byte stream that instead of writing into\n   27       * {@link ReadableStreamBYOBRequest.view | view}, the underlying byte source is providing a new `ArrayBufferView`,\n   28:      * which will be given to the consumer of the readable byte stream.\n   29       *\n   30       * After this method is called, `view` will be transferred and no longer modifiable.\n   ..\n   33  }\n   34  /**\n   35:  * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n   36   *\n   37   * @public\n   ..\n   49      get desiredSize(): number | null;\n   50      /**\n   51:      * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n   52:      * the stream, but once those are read, the stream will become closed.\n   53       */\n   54      close(): void;\n   55      /**\n   56:      * Enqueues the given chunk chunk in the controlled readable stream.\n   57       * The chunk has to be an `ArrayBufferView` instance, or else a `TypeError` will be thrown.\n   58       */\n   59      enqueue(chunk: ArrayBufferView): void;\n   60      /**\n   61:      * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n   62       */\n   63      error(e?: any): void;\n   64  }\n   65  export declare function IsReadableByteStreamController(x: any): x is ReadableByteStreamController;\n   66: <skipped 63 characters> ...extends NonShared<ArrayBufferView>>(controller: ReadableByteStreamController, view: T, min: number, readIntoRequest: ReadIntoRequest<T>): void;\n   67  export declare function ReadableByteStreamControllerClose(controller: ReadableByteStreamController): void;\n   68  export declare function ReadableByteStreamControllerEnqueue(controller: ReadableByteStreamController, chunk: NonShared<ArrayBufferView>): void;\n   69  export declare function ReadableByteStreamControllerError(controller: ReadableByteStreamController, e: any): void;\n   70: export declare function ReadableByteStreamControllerFillReadRequestFromQueue(controller: ReadableByteStreamController, readRequest: ReadRequest<NonShared<Uint8Array>>): void;\n   71  export declare function ReadableByteStreamControllerGetBYOBRequest(controller: ReadableByteStreamController): ReadableStreamBYOBRequest | null;\n   72  export declare function ReadableByteStreamControllerRespond(controller: ReadableByteStreamController, bytesWritten: number): void;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/pipe.js:\n    1: import { IsReadableStream, IsReadableStreamLocked, ReadableStream, ReadableStreamCancel } from '../readable-stream';\n    2: import { AcquireReadableStreamDefaultReader, ReadableStreamDefaultReaderRead } from './default-reader';\n    3: import { ReadableStreamReaderGenericRelease } from './generic-reader';\n    4  import { AcquireWritableStreamDefaultWriter, IsWritableStream, IsWritableStreamLocked, WritableStrea... <skipped 112 characters> ...n, WritableStreamDefaultWriterRelease, WritableStreamDefaultWriterWrite } from '../writable-stream';\n    5  import assert from '../../stub/assert';\n    .\n   17      assert(!IsReadableStreamLocked(source));\n   18      assert(!IsWritableStreamLocked(dest));\n   19:     const reader = AcquireReadableStreamDefaultReader(source);\n   20:     const writer = AcquireWritableStreamDefaultWriter(dest);\n   21      source._disturbed = true;\n   22      let shuttingDown = false;\n   23:     // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n   24      let currentWrite = promiseResolvedWith(undefined);\n   25      return newPromise((resolve, reject) => {\n   ..\n   39                  if (!preventCancel) {\n   40                      actions.push(() => {\n   41:                         if (source._state === 'readable') {\n   42                              return ReadableStreamCancel(source, error);\n   43                          }\n   ..\n   53              signal.addEventListener('abort', abortAlgorithm);\n   54          }\n   55:         // Using reader and writer, read all chunks from this and write them to dest\n   56          // - Backpressure must be enforced\n   57          // - Shutdown must stop all activity\n   ..\n   75                  return promiseResolvedWith(true);\n   76              }\n   77:             return PerformPromiseThen(writer._readyPromise, () => {\n   78                  return newPromise((resolveRead, rejectRead) => {\n   79:                     ReadableStreamDefaultReaderRead(reader, {\n   80                          _chunkSteps: (chunk) => {\n   81:                             currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n   82                              resolveRead(false);\n   83                          },\n   ..\n   89          }\n   90          // Errors must be propagated forward\n   91:         isOrBecomesErrored(source, reader._closedPromise, (storedError) => {\n   92              if (!preventAbort) {\n   93                  shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n   ..\n   99          });\n  100          // Errors must be propagated backward\n  101:         isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {\n  102              if (!preventCancel) {\n  103                  shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n  ...\n  109          });\n  110          // Closing must be propagated forward\n  111:         isOrBecomesClosed(source, reader._closedPromise, () => {\n  112              if (!preventClose) {\n  113:                 shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n  114              }\n  115              else {\n  ...\n  130          setPromiseIsHandledToTrue(pipeLoop());\n  131          function waitForWritesToFinish() {\n  132:             // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n  133              // for that too.\n  134              const oldCurrentWrite = currentWrite;\n  ...\n  180          }\n  181          function finalize(isError, error) {\n  182:             WritableStreamDefaultWriterRelease(writer);\n  183:             ReadableStreamReaderGenericRelease(reader);\n  184              if (signal !== undefined) {\n  185                  signal.removeEventListener('abort', abortAlgorithm);\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/readable-stream-like.ts:\n    1  import { typeIsObject } from '../helpers/miscellaneous';\n    2: import type { ReadableStreamDefaultReadResult } from './default-reader';\n    3  \n    4  /**\n    .\n    8   */\n    9  export interface ReadableStreamLike<R = any> {\n   10:   readonly locked: boolean;\n   11  \n   12    getReader(): ReadableStreamDefaultReaderLike<R>;\n   ..\n   19   */\n   20  export interface ReadableStreamDefaultReaderLike<R = any> {\n   21:   readonly closed: Promise<undefined>;\n   22  \n   23    cancel(reason?: any): Promise<void>;\n   24  \n   25:   read(): Promise<ReadableStreamDefaultReadResult<R>>;\n   26  \n   27    releaseLock(): void;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/from.ts:\n    1: import { CreateReadableStream, type DefaultReadableStream } from '../readable-stream';\n    2  import {\n    3    isReadableStreamLike,\n    4    type ReadableStreamDefaultReaderLike,\n    5    type ReadableStreamLike\n    6: } from './readable-stream-like';\n    7  import { ReadableStreamDefaultControllerClose, ReadableStreamDefaultControllerEnqueue } from './default-controller';\n    8  import { GetIterator, GetMethod, IteratorNext } from '../abstract-ops/ecmascript';\n    .\n   70  }\n   71  \n   72: export function ReadableStreamFromDefaultReader<R>(reader: ReadableStreamDefaultReaderLike<R>): DefaultReadableStream<R> {\n   73    let stream: DefaultReadableStream<R>;\n   74  \n   ..\n   76  \n   77    function pullAlgorithm(): Promise<void> {\n   78:     let readPromise;\n   79      try {\n   80:       readPromise = reader.read();\n   81      } catch (e) {\n   82        return promiseRejectedWith(e);\n   83      }\n   84:     return transformPromiseWith(readPromise, (readResult) => {\n   85:       if (!typeIsObject(readResult)) {\n   86:         throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\n   87        }\n   88:       if (readResult.done) {\n   89          ReadableStreamDefaultControllerClose(stream._readableStreamController);\n   90        } else {\n   91:         const value = readResult.value;\n   92          ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\n   93        }\n   ..\n   97    function cancelAlgorithm(reason: any): Promise<void> {\n   98      try {\n   99:       return promiseResolvedWith(reader.cancel(reason));\n  100      } catch (e) {\n  101        return promiseRejectedWith(e);\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/generic-reader.d.ts:\n    1: import { ReadableStream, type ReadableStreamReader } from '../readable-stream';\n    2: export declare function ReadableStreamReaderGenericInitialize<R>(reader: ReadableStreamReader<R>, stream: ReadableStream<R>): void;\n    3: export declare function ReadableStreamReaderGenericCancel(reader: ReadableStreamReader<any>, reason: any): Promise<undefined>;\n    4: export declare function ReadableStreamReaderGenericRelease(reader: ReadableStreamReader<any>): void;\n    5: export declare function readerLockException(name: string): TypeError;\n    6: export declare function defaultReaderClosedPromiseInitialize(reader: ReadableStreamReader<any>): void;\n    7: export declare function defaultReaderClosedPromiseInitializeAsRejected(reader: ReadableStreamReader<any>, reason: any): void;\n    8: export declare function defaultReaderClosedPromiseInitializeAsResolved(reader: ReadableStreamReader<any>): void;\n    9: export declare function defaultReaderClosedPromiseReject(reader: ReadableStreamReader<any>, reason: any): void;\n   10: export declare function defaultReaderClosedPromiseResetToRejected(reader: ReadableStreamReader<any>, reason: any): void;\n   11: export declare function defaultReaderClosedPromiseResolve(reader: ReadableStreamReader<any>): void;\n   12: //# sourceMappingURL=generic-reader.d.ts.map\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byob-reader.d.ts:\n    1: import { type ReadableByteStream, type ReadableStream } from '../readable-stream';\n    2: import type { ReadableStreamBYOBReaderReadOptions } from './reader-options';\n    3  import { type NonShared } from '../helpers/array-buffer-view';\n    4  /**\n    5:  * A result returned by {@link ReadableStreamBYOBReader.read}.\n    6   *\n    7   * @public\n    .\n   15  };\n   16  export declare function AcquireReadableStreamBYOBReader(stream: ReadableByteStream): ReadableStreamBYOBReader;\n   17: export declare function ReadableStreamAddReadIntoRequest<T extends NonShared<ArrayBufferView>>(stream: ReadableByteStream, readIntoRequest: ReadIntoRequest<T>): void;\n   18  export declare function ReadableStreamFulfillReadIntoRequest(stream: ReadableByteStream, chunk: ArrayBufferView, done: boolean): void;\n   19  export declare function ReadableStreamGetNumReadIntoRequests(stream: ReadableByteStream): number;\n   ..\n   25  }\n   26  /**\n   27:  * A BYOB reader vended by a {@link ReadableStream}.\n   28   *\n   29   * @public\n   ..\n   33      /**\n   34       * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n   35:      * the reader's lock is released before the stream finishes closing.\n   36       */\n   37      get closed(): Promise<undefined>;\n   38      /**\n   39:      * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n   40       */\n   41      cancel(reason?: any): Promise<void>;\n   42      /**\n   43:      * Attempts to reads bytes into view, and returns a promise resolved with the result.\n   44       *\n   45:      * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   46       */\n   47:     read<T extends ArrayBufferView>(view: T, options?: ReadableStreamBYOBReaderReadOptions): Promise<ReadableStreamBYOBReadResult<T>>;\n   48      /**\n   49:      * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   50:      * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n   51:      * from now on; otherwise, the reader will appear closed.\n   52       *\n   53:      * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   54:      * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n   55:      * do so will throw a `TypeError` and leave the reader locked to the stream.\n   56       */\n   57      releaseLock(): void;\n   58  }\n   59  export declare function IsReadableStreamBYOBReader(x: any): x is ReadableStreamBYOBReader;\n   60: export declare function ReadableStreamBYOBReaderRead<T extends NonShared<ArrayBufferView>>(reader: ReadableStreamBYOBReader, view: T, min: number, readIntoRequest: ReadIntoRequest<T>): void;\n   61: export declare function ReadableStreamBYOBReaderRelease(reader: ReadableStreamBYOBReader): void;\n   62: export declare function ReadableStreamBYOBReaderErrorReadIntoRequests(reader: ReadableStreamBYOBReader, e: any): void;\n   63: //# sourceMappingURL=byob-reader.d.ts.map\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/tee.ts:\n    8    ReadableStreamCancel,\n    9    type ReadableStreamReader\n   10: } from '../readable-stream';\n   11: import { ReadableStreamReaderGenericRelease } from './generic-reader';\n   12  import {\n   13    AcquireReadableStreamDefaultReader,\n   ..\n   15    ReadableStreamDefaultReaderRead,\n   16    type ReadRequest\n   17: } from './default-reader';\n   18  import {\n   19    AcquireReadableStreamBYOBReader,\n   ..\n   21    ReadableStreamBYOBReaderRead,\n   22    type ReadIntoRequest\n   23: } from './byob-reader';\n   24  import assert from '../../stub/assert';\n   25  import { newPromise, promiseResolvedWith, queueMicrotask, uponRejection } from '../helpers/webidl';\n   ..\n   62    assert(typeof cloneForBranch2 === 'boolean');\n   63  \n   64:   const reader = AcquireReadableStreamDefaultReader<R>(stream);\n   65  \n   66:   let reading = false;\n   67:   let readAgain = false;\n   68    let canceled1 = false;\n   69    let canceled2 = false;\n   ..\n   79  \n   80    function pullAlgorithm(): Promise<void> {\n   81:     if (reading) {\n   82:       readAgain = true;\n   83        return promiseResolvedWith(undefined);\n   84      }\n   85  \n   86:     reading = true;\n   87  \n   88:     const readRequest: ReadRequest<R> = {\n   89        _chunkSteps: (chunk) => {\n   90          // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n   91:         // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n   92:         // successful synchronously-available reads get ahead of asynchronously-available errors.\n   93          queueMicrotask(() => {\n   94:           readAgain = false;\n   95            const chunk1 = chunk;\n   96            const chunk2 = chunk;\n   ..\n  109            }\n  110  \n  111:           reading = false;\n  112:           if (readAgain) {\n  113              pullAlgorithm();\n  114            }\n  ...\n  116        },\n  117        _closeSteps: () => {\n  118:         reading = false;\n  119          if (!canceled1) {\n  120            ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n  ...\n  129        },\n  130        _errorSteps: () => {\n  131:         reading = false;\n  132        }\n  133      };\n  134:     ReadableStreamDefaultReaderRead(reader, readRequest);\n  135  \n  136      return promiseResolvedWith(undefined);\n  ...\n  166    branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n  167  \n  168:   uponRejection(reader._closedPromise, (r: any) => {\n  169      ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n  170      ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n  ...\n  182    assert(IsReadableByteStreamController(stream._readableStreamController));\n  183  \n  184:   let reader: ReadableStreamReader<NonShared<Uint8Array>> = AcquireReadableStreamDefaultReader(stream);\n  185:   let reading = false;\n  186:   let readAgainForBranch1 = false;\n  187:   let readAgainForBranch2 = false;\n  188    let canceled1 = false;\n  189    let canceled2 = false;\n  ...\n  200    function forwardReaderError(thisReader: ReadableStreamReader<NonShared<Uint8Array>>) {\n  201      uponRejection(thisReader._closedPromise, (r) => {\n  202:       if (thisReader !== reader) {\n  203          return null;\n  204        }\n  ...\n  213  \n  214    function pullWithDefaultReader() {\n  215:     if (IsReadableStreamBYOBReader(reader)) {\n  216:       assert(reader._readIntoRequests.length === 0);\n  217:       ReadableStreamReaderGenericRelease(reader);\n  218  \n  219:       reader = AcquireReadableStreamDefaultReader(stream);\n  220:       forwardReaderError(reader);\n  221      }\n  222  \n  223:     const readRequest: ReadRequest<NonShared<Uint8Array>> = {\n  224        _chunkSteps: (chunk) => {\n  225          // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n  226:         // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n  227:         // successful synchronously-available reads get ahead of asynchronously-available errors.\n  228          queueMicrotask(() => {\n  229:           readAgainForBranch1 = false;\n  230:           readAgainForBranch2 = false;\n  231  \n  232            const chunk1 = chunk;\n  ...\n  250            }\n  251  \n  252:           reading = false;\n  253:           if (readAgainForBranch1) {\n  254              pull1Algorithm();\n  255:           } else if (readAgainForBranch2) {\n  256              pull2Algorithm();\n  257            }\n  ...\n  259        },\n  260        _closeSteps: () => {\n  261:         reading = false;\n  262          if (!canceled1) {\n  263            ReadableByteStreamControllerClose(branch1._readableStreamController);\n  ...\n  277        },\n  278        _errorSteps: () => {\n  279:         reading = false;\n  280        }\n  281      };\n  282:     ReadableStreamDefaultReaderRead(reader, readRequest);\n  283    }\n  284  \n  285    function pullWithBYOBReader(view: NonShared<ArrayBufferView>, forBranch2: boolean) {\n  286:     if (IsReadableStreamDefaultReader<NonShared<Uint8Array>>(reader)) {\n  287:       assert(reader._readRequests.length === 0);\n  288:       ReadableStreamReaderGenericRelease(reader);\n  289  \n  290:       reader = AcquireReadableStreamBYOBReader(stream);\n  291:       forwardReaderError(reader);\n  292      }\n  293  \n  ...\n  295      const otherBranch = forBranch2 ? branch1 : branch2;\n  296  \n  297:     const readIntoRequest: ReadIntoRequest<NonShared<ArrayBufferView>> = {\n  298        _chunkSteps: (chunk) => {\n  299          // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n  300:         // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n  301:         // successful synchronously-available reads get ahead of asynchronously-available errors.\n  302          queueMicrotask(() => {\n  303:           readAgainForBranch1 = false;\n  304:           readAgainForBranch2 = false;\n  305  \n  306            const byobCanceled = forBranch2 ? canceled2 : canceled1;\n  ...\n  325            }\n  326  \n  327:           reading = false;\n  328:           if (readAgainForBranch1) {\n  329              pull1Algorithm();\n  330:           } else if (readAgainForBranch2) {\n  331              pull2Algorithm();\n  332            }\n  ...\n  334        },\n  335        _closeSteps: (chunk) => {\n  336:         reading = false;\n  337  \n  338          const byobCanceled = forBranch2 ? canceled2 : canceled1;\n  ...\n  362        },\n  363        _errorSteps: () => {\n  364:         reading = false;\n  365        }\n  366      };\n  367:     ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);\n  368    }\n  369  \n  370    function pull1Algorithm(): Promise<void> {\n  371:     if (reading) {\n  372:       readAgainForBranch1 = true;\n  373        return promiseResolvedWith(undefined);\n  374      }\n  375  \n  376:     reading = true;\n  377  \n  378      const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n  ...\n  387  \n  388    function pull2Algorithm(): Promise<void> {\n  389:     if (reading) {\n  390:       readAgainForBranch2 = true;\n  391        return promiseResolvedWith(undefined);\n  392      }\n  393  \n  394:     reading = true;\n  395  \n  396      const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n  ...\n  433    branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n  434  \n  435:   forwardReaderError(reader);\n  436  \n  437    return [branch1, branch2];\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byte-stream-controller.ts:\n    9    ReadableStreamHasDefaultReader,\n   10    type ReadRequest\n   11: } from './default-reader';\n   12  import {\n   13    ReadableStreamAddReadIntoRequest,\n   ..\n   16    ReadableStreamHasBYOBReader,\n   17    type ReadIntoRequest\n   18: } from './byob-reader';\n   19  import NumberIsInteger from '../../stub/number-isinteger';\n   20  import {\n   ..\n   23    ReadableStreamClose,\n   24    ReadableStreamError\n   25: } from '../readable-stream';\n   26  import type { ValidatedUnderlyingByteSource } from './underlying-source';\n   27  import { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\n   ..\n   71  \n   72    /**\n   73:    * Indicates to the associated readable byte stream that `bytesWritten` bytes were written into\n   74     * {@link ReadableStreamBYOBRequest.view | view}, causing the result be surfaced to the consumer.\n   75     *\n   ..\n  100  \n  101    /**\n  102:    * Indicates to the associated readable byte stream that instead of writing into\n  103     * {@link ReadableStreamBYOBRequest.view | view}, the underlying byte source is providing a new `ArrayBufferView`,\n  104:    * which will be given to the consumer of the readable byte stream.\n  105     *\n  106     * After this method is called, `view` will be transferred and no longer modifiable.\n  ...\n  162    elementSize: number;\n  163    viewConstructor: TypedArrayConstructor<Uint8Array>;\n  164:   readerType: 'default' | 'none';\n  165  }\n  166  \n  ...\n  174    elementSize: number;\n  175    viewConstructor: ArrayBufferViewConstructor<T>;\n  176:   readerType: 'byob' | 'none';\n  177  }\n  178  \n  179  /**\n  180:  * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n  181   *\n  182   * @public\n  ...\n  238  \n  239    /**\n  240:    * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n  241:    * the stream, but once those are read, the stream will become closed.\n  242     */\n  243    close(): void {\n  ...\n  251  \n  252      const state = this._controlledReadableByteStream._state;\n  253:     if (state !== 'readable') {\n  254:       throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n  255      }\n  256  \n  ...\n  259  \n  260    /**\n  261:    * Enqueues the given chunk chunk in the controlled readable stream.\n  262     * The chunk has to be an `ArrayBufferView` instance, or else a `TypeError` will be thrown.\n  263     */\n  ...\n  284  \n  285      const state = this._controlledReadableByteStream._state;\n  286:     if (state !== 'readable') {\n  287:       throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n  288      }\n  289  \n  ...\n  292  \n  293    /**\n  294:    * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n  295     */\n  296    error(e: any = undefined): void {\n  ...\n  314  \n  315    /** @internal */\n  316:   [PullSteps](readRequest: ReadRequest<NonShared<Uint8Array>>): void {\n  317      const stream = this._controlledReadableByteStream;\n  318      assert(ReadableStreamHasDefaultReader(stream));\n  ...\n  321        assert(ReadableStreamGetNumReadRequests(stream) === 0);\n  322  \n  323:       ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);\n  324        return;\n  325      }\n  ...\n  331          buffer = new ArrayBuffer(autoAllocateChunkSize);\n  332        } catch (bufferE) {\n  333:         readRequest._errorSteps(bufferE);\n  334          return;\n  335        }\n  ...\n  344          elementSize: 1,\n  345          viewConstructor: Uint8Array,\n  346:         readerType: 'default'\n  347        };\n  348  \n  ...\n  350      }\n  351  \n  352:     ReadableStreamAddReadRequest(stream, readRequest);\n  353      ReadableByteStreamControllerCallPullIfNeeded(this);\n  354    }\n  ...\n  358      if (this._pendingPullIntos.length > 0) {\n  359        const firstPullInto = this._pendingPullIntos.peek();\n  360:       firstPullInto.readerType = 'none';\n  361  \n  362        this._pendingPullIntos = new SimpleQueue();\n  ...\n  455  ) {\n  456    assert(stream._state !== 'errored');\n  457:   assert(pullIntoDescriptor.readerType !== 'none');\n  458  \n  459    let done = false;\n  ...\n  464  \n  465    const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor<T>(pullIntoDescriptor);\n  466:   if (pullIntoDescriptor.readerType === 'default') {\n  467      ReadableStreamFulfillReadRequest(stream, filledView as unknown as NonShared<Uint8Array>, done);\n  468    } else {\n  469:     assert(pullIntoDescriptor.readerType === 'byob');\n  470      ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  471    }\n  ...\n  521    firstDescriptor: PullIntoDescriptor\n  522  ) {\n  523:   assert(firstDescriptor.readerType === 'none');\n  524    if (firstDescriptor.bytesFilled > 0) {\n  525      ReadableByteStreamControllerEnqueueClonedChunkToQueue(\n  ...\n  544  \n  545    let totalBytesToCopyRemaining = maxBytesToCopy;\n  546:   let ready = false;\n  547    assert(!IsDetachedBuffer(pullIntoDescriptor.buffer));\n  548    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n  549    const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\n  550    const maxAlignedBytes = maxBytesFilled - remainderBytes;\n  551:   // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  552    // of the queue, so the underlying source can keep filling it.\n  553    if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n  554      totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n  555:     ready = true;\n  556    }\n  557  \n  ...\n  580    }\n  581  \n  582:   if (!ready) {\n  583      assert(controller._queueTotalSize === 0);\n  584      assert(pullIntoDescriptor.bytesFilled > 0);\n  ...\n  586    }\n  587  \n  588:   return ready;\n  589  }\n  590  \n  ...\n  600  \n  601  function ReadableByteStreamControllerHandleQueueDrain(controller: ReadableByteStreamController) {\n  602:   assert(controller._controlledReadableByteStream._state === 'readable');\n  603  \n  604    if (controller._queueTotalSize === 0 && controller._closeRequested) {\n  ...\n  630  \n  631      const pullIntoDescriptor = controller._pendingPullIntos.peek();\n  632:     assert(pullIntoDescriptor.readerType !== 'none');\n  633  \n  634      if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n  ...\n  642  \n  643  function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller: ReadableByteStreamController) {\n  644:   const reader = controller._controlledReadableByteStream._reader;\n  645:   assert(IsReadableStreamDefaultReader(reader));\n  646:   while (reader._readRequests.length > 0) {\n  647      if (controller._queueTotalSize === 0) {\n  648        return;\n  649      }\n  650:     const readRequest = reader._readRequests.shift();\n  651:     ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);\n  652    }\n  653  }\n  ...\n  657    view: T,\n  658    min: number,\n  659:   readIntoRequest: ReadIntoRequest<T>\n  660  ): void {\n  661    const stream = controller._controlledReadableByteStream;\n  ...\n  674      buffer = TransferArrayBuffer(view.buffer);\n  675    } catch (e) {\n  676:     readIntoRequest._errorSteps(e);\n  677      return;\n  678    }\n  ...\n  687      elementSize,\n  688      viewConstructor: ctor,\n  689:     readerType: 'byob'\n  690    };\n  691  \n  ...\n  695      // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n  696      // - No change happens on desiredSize\n  697:     // - The source has already been notified of that there's at least 1 pending read(view)\n  698  \n  699:     ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n  700      return;\n  701    }\n  ...\n  703    if (stream._state === 'closed') {\n  704      const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n  705:     readIntoRequest._closeSteps(emptyView);\n  706      return;\n  707    }\n  ...\n  713        ReadableByteStreamControllerHandleQueueDrain(controller);\n  714  \n  715:       readIntoRequest._chunkSteps(filledView);\n  716        return;\n  717      }\n  ...\n  721        ReadableByteStreamControllerError(controller, e);\n  722  \n  723:       readIntoRequest._errorSteps(e);\n  724        return;\n  725      }\n  ...\n  728    controller._pendingPullIntos.push(pullIntoDescriptor);\n  729  \n  730:   ReadableStreamAddReadIntoRequest<T>(stream, readIntoRequest);\n  731    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  732  }\n  ...\n  738    assert(firstDescriptor.bytesFilled % firstDescriptor.elementSize === 0);\n  739  \n  740:   if (firstDescriptor.readerType === 'none') {\n  741      ReadableByteStreamControllerShiftPendingPullInto(controller);\n  742    }\n  ...\n  761    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n  762  \n  763:   if (pullIntoDescriptor.readerType === 'none') {\n  764      ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);\n  765      const filledPullIntos = ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  ...\n  769  \n  770    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\n  771:     // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  772      // of the queue, so the underlying source can keep filling it.\n  773      return;\n  ...\n  805      ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n  806    } else {\n  807:     assert(state === 'readable');\n  808      assert(bytesWritten > 0);\n  809      ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  ...\n  822    const stream = controller._controlledReadableByteStream;\n  823  \n  824:   if (stream._state !== 'readable') {\n  825      return false;\n  826    }\n  ...\n  861    const stream = controller._controlledReadableByteStream;\n  862  \n  863:   if (controller._closeRequested || stream._state !== 'readable') {\n  864      return;\n  865    }\n  ...\n  891    const stream = controller._controlledReadableByteStream;\n  892  \n  893:   if (controller._closeRequested || stream._state !== 'readable') {\n  894      return;\n  895    }\n  ...\n  908      ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  909      firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n  910:     if (firstPendingPullInto.readerType === 'none') {\n  911        ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);\n  912      }\n  ...\n  921        assert(controller._queue.length === 0);\n  922        if (controller._pendingPullIntos.length > 0) {\n  923:         assert(controller._pendingPullIntos.peek().readerType === 'default');\n  924          ReadableByteStreamControllerShiftPendingPullInto(controller);\n  925        }\n  ...\n  943    const stream = controller._controlledReadableByteStream;\n  944  \n  945:   if (stream._state !== 'readable') {\n  946      return;\n  947    }\n  ...\n  956  export function ReadableByteStreamControllerFillReadRequestFromQueue(\n  957    controller: ReadableByteStreamController,\n  958:   readRequest: ReadRequest<NonShared<Uint8Array>>\n  959  ) {\n  960    assert(controller._queueTotalSize > 0);\n  ...\n  966  \n  967    const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n  968:   readRequest._chunkSteps(view as NonShared<Uint8Array>);\n  969  }\n  970  \n  ...\n 1009      }\n 1010    } else {\n 1011:     assert(state === 'readable');\n 1012      if (bytesWritten === 0) {\n 1013:       throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');\n 1014      }\n 1015      if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n ....\n 1038      }\n 1039    } else {\n 1040:     assert(state === 'readable');\n 1041      if (view.byteLength === 0) {\n 1042:       throw new TypeError('The view\\'s length must be greater than 0 when calling respondWithNewView() on a readable stream');\n 1043      }\n 1044    }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/async-iterator.d.ts:\n    1: import { ReadableStream } from '../readable-stream';\n    2: import { ReadableStreamDefaultReader, type ReadableStreamDefaultReadResult } from './default-reader';\n    3  /**\n    4   * An async iterator returned by {@link ReadableStream.values}.\n    .\n   11  }\n   12  export declare class ReadableStreamAsyncIteratorImpl<R> {\n   13:     private readonly _reader;\n   14:     private readonly _preventCancel;\n   15      private _ongoingPromise;\n   16      private _isFinished;\n   17:     constructor(reader: ReadableStreamDefaultReader<R>, preventCancel: boolean);\n   18      next(): Promise<ReadableStreamDefaultReadResult<R>>;\n   19      return(value: any): Promise<ReadableStreamDefaultReadResult<any>>;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/readable-stream-like.d.ts:\n    1: import type { ReadableStreamDefaultReadResult } from './default-reader';\n    2  /**\n    3   * A common interface for a `ReadadableStream` implementation.\n    .\n    6   */\n    7  export interface ReadableStreamLike<R = any> {\n    8:     readonly locked: boolean;\n    9      getReader(): ReadableStreamDefaultReaderLike<R>;\n   10  }\n   ..\n   15   */\n   16  export interface ReadableStreamDefaultReaderLike<R = any> {\n   17:     readonly closed: Promise<undefined>;\n   18      cancel(reason?: any): Promise<void>;\n   19:     read(): Promise<ReadableStreamDefaultReadResult<R>>;\n   20      releaseLock(): void;\n   21  }\n   22  export declare function isReadableStreamLike<R>(stream: unknown): stream is ReadableStreamLike<R>;\n   23: //# sourceMappingURL=readable-stream-like.d.ts.map\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/default-reader.d.ts:\n    1: import { ReadableStream } from '../readable-stream';\n    2  /**\n    3:  * A result returned by {@link ReadableStreamDefaultReader.read}.\n    4   *\n    5   * @public\n    .\n   13  };\n   14  export declare function AcquireReadableStreamDefaultReader<R>(stream: ReadableStream): ReadableStreamDefaultReader<R>;\n   15: export declare function ReadableStreamAddReadRequest<R>(stream: ReadableStream<R>, readRequest: ReadRequest<R>): void;\n   16  export declare function ReadableStreamFulfillReadRequest<R>(stream: ReadableStream<R>, chunk: R | undefined, done: boolean): void;\n   17  export declare function ReadableStreamGetNumReadRequests<R>(stream: ReadableStream<R>): number;\n   ..\n   23  }\n   24  /**\n   25:  * A default reader vended by a {@link ReadableStream}.\n   26   *\n   27   * @public\n   ..\n   31      /**\n   32       * Returns a promise that will be fulfilled when the stream becomes closed,\n   33:      * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n   34       */\n   35      get closed(): Promise<undefined>;\n   36      /**\n   37:      * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n   38       */\n   39      cancel(reason?: any): Promise<void>;\n   ..\n   41       * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n   42       *\n   43:      * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   44       */\n   45:     read(): Promise<ReadableStreamDefaultReadResult<R>>;\n   46      /**\n   47:      * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   48:      * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n   49:      * from now on; otherwise, the reader will appear closed.\n   50       *\n   51:      * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   52:      * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n   53:      * do so will throw a `TypeError` and leave the reader locked to the stream.\n   54       */\n   55      releaseLock(): void;\n   56  }\n   57  export declare function IsReadableStreamDefaultReader<R = any>(x: any): x is ReadableStreamDefaultReader<R>;\n   58: export declare function ReadableStreamDefaultReaderRead<R>(reader: ReadableStreamDefaultReader<R>, readRequest: ReadRequest<R>): void;\n   59: export declare function ReadableStreamDefaultReaderRelease(reader: ReadableStreamDefaultReader): void;\n   60: export declare function ReadableStreamDefaultReaderErrorReadRequests(reader: ReadableStreamDefaultReader, e: any): void;\n   61: //# sourceMappingURL=default-reader.d.ts.map\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/pipe.ts:\n    1: import { IsReadableStream, IsReadableStreamLocked, ReadableStream, ReadableStreamCancel } from '../readable-stream';\n    2: import { AcquireReadableStreamDefaultReader, ReadableStreamDefaultReaderRead } from './default-reader';\n    3: import { ReadableStreamReaderGenericRelease } from './generic-reader';\n    4  import {\n    5    AcquireWritableStreamDefaultWriter,\n    .\n   44    assert(!IsWritableStreamLocked(dest));\n   45  \n   46:   const reader = AcquireReadableStreamDefaultReader<T>(source);\n   47:   const writer = AcquireWritableStreamDefaultWriter<T>(dest);\n   48  \n   49    source._disturbed = true;\n   ..\n   51    let shuttingDown = false;\n   52  \n   53:   // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n   54    let currentWrite = promiseResolvedWith<void>(undefined);\n   55  \n   ..\n   70          if (!preventCancel) {\n   71            actions.push(() => {\n   72:             if (source._state === 'readable') {\n   73                return ReadableStreamCancel(source, error);\n   74              }\n   ..\n   87      }\n   88  \n   89:     // Using reader and writer, read all chunks from this and write them to dest\n   90      // - Backpressure must be enforced\n   91      // - Shutdown must stop all activity\n   ..\n  111        }\n  112  \n  113:       return PerformPromiseThen(writer._readyPromise, () => {\n  114          return newPromise<boolean>((resolveRead, rejectRead) => {\n  115            ReadableStreamDefaultReaderRead(\n  116:             reader,\n  117              {\n  118                _chunkSteps: (chunk) => {\n  119:                 currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n  120                  resolveRead(false);\n  121                },\n  ...\n  129  \n  130      // Errors must be propagated forward\n  131:     isOrBecomesErrored(source, reader._closedPromise, (storedError) => {\n  132        if (!preventAbort) {\n  133          shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n  ...\n  139  \n  140      // Errors must be propagated backward\n  141:     isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {\n  142        if (!preventCancel) {\n  143          shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n  ...\n  149  \n  150      // Closing must be propagated forward\n  151:     isOrBecomesClosed(source, reader._closedPromise, () => {\n  152        if (!preventClose) {\n  153:         shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n  154        } else {\n  155          shutdown();\n  ...\n  172  \n  173      function waitForWritesToFinish(): Promise<void> {\n  174:       // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n  175        // for that too.\n  176        const oldCurrentWrite = currentWrite;\n  ...\n  237  \n  238      function finalize(isError?: boolean, error?: any): null {\n  239:       WritableStreamDefaultWriterRelease(writer);\n  240:       ReadableStreamReaderGenericRelease(reader);\n  241  \n  242        if (signal !== undefined) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/reader-options.ts:\n    4  \n    5  /**\n    6:  * Options for {@link ReadableStreamBYOBReader.read | reading} a stream\n    7:  * with a {@link ReadableStreamBYOBReader | BYOB reader}.\n    8   *\n    9   * @public\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/default-reader.ts:\n    5    ReadableStreamReaderGenericInitialize,\n    6    ReadableStreamReaderGenericRelease,\n    7:   readerLockException\n    8: } from './generic-reader';\n    9: import { IsReadableStreamLocked, ReadableStream } from '../readable-stream';\n   10  import { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\n   11  import { PullSteps } from '../abstract-ops/internal-methods';\n   12  import { newPromise, promiseRejectedWith } from '../helpers/webidl';\n   13  import { assertRequiredArgument } from '../validators/basic';\n   14: import { assertReadableStream } from '../validators/readable-stream';\n   15  \n   16  /**\n   17:  * A result returned by {@link ReadableStreamDefaultReader.read}.\n   18   *\n   19   * @public\n   ..\n   37  export function ReadableStreamAddReadRequest<R>(\n   38    stream: ReadableStream<R>,\n   39:   readRequest: ReadRequest<R>\n   40  ): void {\n   41    assert(IsReadableStreamDefaultReader(stream._reader));\n   42:   assert(stream._state === 'readable');\n   43  \n   44:   (stream._reader! as ReadableStreamDefaultReader<R>)._readRequests.push(readRequest);\n   45  }\n   46  \n   47  export function ReadableStreamFulfillReadRequest<R>(stream: ReadableStream<R>, chunk: R | undefined, done: boolean) {\n   48:   const reader = stream._reader as ReadableStreamDefaultReader<R>;\n   49  \n   50:   assert(reader._readRequests.length > 0);\n   51  \n   52:   const readRequest = reader._readRequests.shift()!;\n   53    if (done) {\n   54:     readRequest._closeSteps();\n   55    } else {\n   56:     readRequest._chunkSteps(chunk!);\n   57    }\n   58  }\n   ..\n   63  \n   64  export function ReadableStreamHasDefaultReader(stream: ReadableStream): boolean {\n   65:   const reader = stream._reader;\n   66  \n   67:   if (reader === undefined) {\n   68      return false;\n   69    }\n   70  \n   71:   if (!IsReadableStreamDefaultReader(reader)) {\n   72      return false;\n   73    }\n   ..\n   87  \n   88  /**\n   89:  * A default reader vended by a {@link ReadableStream}.\n   90   *\n   91   * @public\n   ..\n  108  \n  109      if (IsReadableStreamLocked(stream)) {\n  110:       throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n  111      }\n  112  \n  ...\n  118    /**\n  119     * Returns a promise that will be fulfilled when the stream becomes closed,\n  120:    * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n  121     */\n  122    get closed(): Promise<undefined> {\n  ...\n  129  \n  130    /**\n  131:    * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n  132     */\n  133    cancel(reason: any = undefined): Promise<void> {\n  ...\n  137  \n  138      if (this._ownerReadableStream === undefined) {\n  139:       return promiseRejectedWith(readerLockException('cancel'));\n  140      }\n  141  \n  ...\n  146     * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n  147     *\n  148:    * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  149     */\n  150:   read(): Promise<ReadableStreamDefaultReadResult<R>> {\n  151      if (!IsReadableStreamDefaultReader(this)) {\n  152:       return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  153      }\n  154  \n  155      if (this._ownerReadableStream === undefined) {\n  156:       return promiseRejectedWith(readerLockException('read from'));\n  157      }\n  158  \n  ...\n  163        rejectPromise = reject;\n  164      });\n  165:     const readRequest: ReadRequest<R> = {\n  166        _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n  167        _closeSteps: () => resolvePromise({ value: undefined, done: true }),\n  168        _errorSteps: e => rejectPromise(e)\n  169      };\n  170:     ReadableStreamDefaultReaderRead(this, readRequest);\n  171      return promise;\n  172    }\n  173  \n  174    /**\n  175:    * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n  176:    * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n  177:    * from now on; otherwise, the reader will appear closed.\n  178     *\n  179:    * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  180:    * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  181:    * do so will throw a `TypeError` and leave the reader locked to the stream.\n  182     */\n  183    releaseLock(): void {\n  ...\n  196  Object.defineProperties(ReadableStreamDefaultReader.prototype, {\n  197    cancel: { enumerable: true },\n  198:   read: { enumerable: true },\n  199    releaseLock: { enumerable: true },\n  200    closed: { enumerable: true }\n  201  });\n  202  setFunctionName(ReadableStreamDefaultReader.prototype.cancel, 'cancel');\n  203: setFunctionName(ReadableStreamDefaultReader.prototype.read, 'read');\n  204  setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, 'releaseLock');\n  205  if (typeof Symbol.toStringTag === 'symbol') {\n  ...\n  210  }\n  211  \n  212: // Abstract operations for the readers.\n  213  \n  214  export function IsReadableStreamDefaultReader<R = any>(x: any): x is ReadableStreamDefaultReader<R> {\n  ...\n  225  \n  226  export function ReadableStreamDefaultReaderRead<R>(\n  227:   reader: ReadableStreamDefaultReader<R>,\n  228:   readRequest: ReadRequest<R>\n  229  ): void {\n  230:   const stream = reader._ownerReadableStream;\n  231  \n  232    assert(stream !== undefined);\n  ...\n  235  \n  236    if (stream._state === 'closed') {\n  237:     readRequest._closeSteps();\n  238    } else if (stream._state === 'errored') {\n  239:     readRequest._errorSteps(stream._storedError);\n  240    } else {\n  241:     assert(stream._state === 'readable');\n  242:     stream._readableStreamController[PullSteps](readRequest as ReadRequest<any>);\n  243    }\n  244  }\n  245  \n  246: export function ReadableStreamDefaultReaderRelease(reader: ReadableStreamDefaultReader) {\n  247:   ReadableStreamReaderGenericRelease(reader);\n  248    const e = new TypeError('Reader was released');\n  249:   ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n  250  }\n  251  \n  252: export function ReadableStreamDefaultReaderErrorReadRequests(reader: ReadableStreamDefaultReader, e: any) {\n  253:   const readRequests = reader._readRequests;\n  254:   reader._readRequests = new SimpleQueue();\n  255:   readRequests.forEach((readRequest) => {\n  256:     readRequest._errorSteps(e);\n  257    });\n  258  }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/readable-writable-pair.js:\n    1: import { ReadableStream } from '../readable-stream';\n    2  import { WritableStream } from '../writable-stream';\n    3  \n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/from.d.ts:\n    1: import { type DefaultReadableStream } from '../readable-stream';\n    2: import { type ReadableStreamDefaultReaderLike, type ReadableStreamLike } from './readable-stream-like';\n    3  export declare function ReadableStreamFrom<R>(source: Iterable<R> | AsyncIterable<R> | ReadableStreamLike<R>): DefaultReadableStream<R>;\n    4  export declare function ReadableStreamFromIterable<R>(asyncIterable: Iterable<R> | AsyncIterable<R>): DefaultReadableStream<R>;\n    5: export declare function ReadableStreamFromDefaultReader<R>(reader: ReadableStreamDefaultReaderLike<R>): DefaultReadableStream<R>;\n    6  //# sourceMappingURL=from.d.ts.map\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/tee.d.ts:\n    1: import { type DefaultReadableStream, type ReadableByteStream, ReadableStream } from '../readable-stream';\n    2  export declare function ReadableStreamTee<R>(stream: ReadableStream<R>, cloneForBranch2: boolean): [ReadableStream<R>, ReadableStream<R>];\n    3  export declare function ReadableStreamDefaultTee<R>(stream: ReadableStream<R>, cloneForBranch2: boolean): [DefaultReadableStream<R>, DefaultReadableStream<R>];\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/default-controller.ts:\n    7    ReadableStreamGetNumReadRequests,\n    8    type ReadRequest\n    9: } from './default-reader';\n   10  import { SimpleQueue } from '../simple-queue';\n   11: import { IsReadableStreamLocked, ReadableStream, ReadableStreamClose, ReadableStreamError } from '../readable-stream';\n   12  import type { ValidatedUnderlyingSource } from './underlying-source';\n   13  import { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\n   ..\n   16  \n   17  /**\n   18:  * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n   19   *\n   20   * @public\n   ..\n   61  \n   62    /**\n   63:    * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n   64:    * the stream, but once those are read, the stream will become closed.\n   65     */\n   66    close(): void {\n   ..\n   77  \n   78    /**\n   79:    * Enqueues the given chunk `chunk` in the controlled readable stream.\n   80     */\n   81    enqueue(chunk: R): void;\n   ..\n   93  \n   94    /**\n   95:    * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n   96     */\n   97    error(e: any = undefined): void {\n   ..\n  112  \n  113    /** @internal */\n  114:   [PullSteps](readRequest: ReadRequest<R>): void {\n  115      const stream = this._controlledReadableStream;\n  116  \n  ...\n  125        }\n  126  \n  127:       readRequest._chunkSteps(chunk);\n  128      } else {\n  129:       ReadableStreamAddReadRequest(stream, readRequest);\n  130        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n  131      }\n  ...\n  285    const stream = controller._controlledReadableStream;\n  286  \n  287:   if (stream._state !== 'readable') {\n  288      return;\n  289    }\n  ...\n  320    const state = controller._controlledReadableStream._state;\n  321  \n  322:   if (!controller._closeRequested && state === 'readable') {\n  323      return true;\n  324    }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/default-controller.d.ts:\n    1  import type { QueuingStrategySizeCallback } from '../queuing-strategy';\n    2: import { ReadableStream } from '../readable-stream';\n    3  import type { ValidatedUnderlyingSource } from './underlying-source';\n    4  /**\n    5:  * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n    6   *\n    7   * @public\n    .\n   15      get desiredSize(): number | null;\n   16      /**\n   17:      * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n   18:      * the stream, but once those are read, the stream will become closed.\n   19       */\n   20      close(): void;\n   21      /**\n   22:      * Enqueues the given chunk `chunk` in the controlled readable stream.\n   23       */\n   24      enqueue(chunk: R): void;\n   25      /**\n   26:      * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n   27       */\n   28      error(e?: any): void;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/pipe-options.ts:\n    8  export interface StreamPipeOptions {\n    9    /**\n   10:    * If set to true, {@link ReadableStream.pipeTo} will not abort the writable stream if the readable stream errors.\n   11     */\n   12    preventAbort?: boolean;\n   13    /**\n   14:    * If set to true, {@link ReadableStream.pipeTo} will not cancel the readable stream if the writable stream closes\n   15     * or errors.\n   16     */\n   17    preventCancel?: boolean;\n   18    /**\n   19:    * If set to true, {@link ReadableStream.pipeTo} will not close the writable stream if the readable stream closes.\n   20     */\n   21    preventClose?: boolean;\n   22    /**\n   23     * Can be set to an {@link AbortSignal} to allow aborting an ongoing pipe operation via the corresponding\n   24:    * `AbortController`. In this case, the source readable stream will be canceled, and the destination writable stream\n   25     * aborted, unless the respective options `preventCancel` or `preventAbort` are set.\n   26     */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/reader-options.d.ts:\n    3  }\n    4  /**\n    5:  * Options for {@link ReadableStreamBYOBReader.read | reading} a stream\n    6:  * with a {@link ReadableStreamBYOBReader | BYOB reader}.\n    7   *\n    8   * @public\n    .\n   12  }\n   13  export type ValidatedReadableStreamBYOBReaderReadOptions = Required<ReadableStreamBYOBReaderReadOptions>;\n   14: //# sourceMappingURL=reader-options.d.ts.map\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/pipe-options.d.ts:\n    7  export interface StreamPipeOptions {\n    8      /**\n    9:      * If set to true, {@link ReadableStream.pipeTo} will not abort the writable stream if the readable stream errors.\n   10       */\n   11      preventAbort?: boolean;\n   12      /**\n   13:      * If set to true, {@link ReadableStream.pipeTo} will not cancel the readable stream if the writable stream closes\n   14       * or errors.\n   15       */\n   16      preventCancel?: boolean;\n   17      /**\n   18:      * If set to true, {@link ReadableStream.pipeTo} will not close the writable stream if the readable stream closes.\n   19       */\n   20      preventClose?: boolean;\n   21      /**\n   22       * Can be set to an {@link AbortSignal} to allow aborting an ongoing pipe operation via the corresponding\n   23:      * `AbortController`. In this case, the source readable stream will be canceled, and the destination writable stream\n   24       * aborted, unless the respective options `preventCancel` or `preventAbort` are set.\n   25       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byob-reader.js:\n    1  import assert from '../../stub/assert';\n    2  import { SimpleQueue } from '../simple-queue';\n    3: import { ReadableStreamReaderGenericCancel, ReadableStreamReaderGenericInitialize, ReadableStreamReaderGenericRelease, readerLockException } from './generic-reader';\n    4: import { IsReadableStreamLocked } from '../readable-stream';\n    5  import { IsReadableByteStreamController, ReadableByteStreamController, ReadableByteStreamControllerPullInto } from './byte-stream-controller';\n    6  import { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\n    7  import { newPromise, promiseRejectedWith } from '../helpers/webidl';\n    8  import { assertRequiredArgument } from '../validators/basic';\n    9: import { assertReadableStream } from '../validators/readable-stream';\n   10  import { IsDetachedBuffer } from '../abstract-ops/ecmascript';\n   11: import { convertByobReadOptions } from '../validators/reader-options';\n   12  import { isDataView } from '../helpers/array-buffer-view';\n   13  // Abstract operations for the ReadableStream.\n   ..\n   16  }\n   17  // ReadableStream API exposed for controllers.\n   18: export function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n   19      assert(IsReadableStreamBYOBReader(stream._reader));\n   20:     assert(stream._state === 'readable' || stream._state === 'closed');\n   21:     stream._reader._readIntoRequests.push(readIntoRequest);\n   22  }\n   23  export function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n   24:     const reader = stream._reader;\n   25:     assert(reader._readIntoRequests.length > 0);\n   26:     const readIntoRequest = reader._readIntoRequests.shift();\n   27      if (done) {\n   28:         readIntoRequest._closeSteps(chunk);\n   29      }\n   30      else {\n   31:         readIntoRequest._chunkSteps(chunk);\n   32      }\n   33  }\n   ..\n   36  }\n   37  export function ReadableStreamHasBYOBReader(stream) {\n   38:     const reader = stream._reader;\n   39:     if (reader === undefined) {\n   40          return false;\n   41      }\n   42:     if (!IsReadableStreamBYOBReader(reader)) {\n   43          return false;\n   44      }\n   ..\n   46  }\n   47  /**\n   48:  * A BYOB reader vended by a {@link ReadableStream}.\n   49   *\n   50   * @public\n   ..\n   55          assertReadableStream(stream, 'First parameter');\n   56          if (IsReadableStreamLocked(stream)) {\n   57:             throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n   58          }\n   59          if (!IsReadableByteStreamController(stream._readableStreamController)) {\n   ..\n   66      /**\n   67       * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n   68:      * the reader's lock is released before the stream finishes closing.\n   69       */\n   70      get closed() {\n   ..\n   75      }\n   76      /**\n   77:      * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n   78       */\n   79      cancel(reason = undefined) {\n   ..\n   82          }\n   83          if (this._ownerReadableStream === undefined) {\n   84:             return promiseRejectedWith(readerLockException('cancel'));\n   85          }\n   86          return ReadableStreamReaderGenericCancel(this, reason);\n   87      }\n   88:     read(view, rawOptions = {}) {\n   89          if (!IsReadableStreamBYOBReader(this)) {\n   90:             return promiseRejectedWith(byobReaderBrandCheckException('read'));\n   91          }\n   92          if (!ArrayBuffer.isView(view)) {\n   ..\n  122          }\n  123          if (this._ownerReadableStream === undefined) {\n  124:             return promiseRejectedWith(readerLockException('read from'));\n  125          }\n  126          let resolvePromise;\n  ...\n  130              rejectPromise = reject;\n  131          });\n  132:         const readIntoRequest = {\n  133              _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n  134              _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n  135              _errorSteps: e => rejectPromise(e)\n  136          };\n  137:         ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);\n  138          return promise;\n  139      }\n  140      /**\n  141:      * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n  142:      * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n  143:      * from now on; otherwise, the reader will appear closed.\n  144       *\n  145:      * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  146:      * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n  147:      * do so will throw a `TypeError` and leave the reader locked to the stream.\n  148       */\n  149      releaseLock() {\n  ...\n  159  Object.defineProperties(ReadableStreamBYOBReader.prototype, {\n  160      cancel: { enumerable: true },\n  161:     read: { enumerable: true },\n  162      releaseLock: { enumerable: true },\n  163      closed: { enumerable: true }\n  164  });\n  165  setFunctionName(ReadableStreamBYOBReader.prototype.cancel, 'cancel');\n  166: setFunctionName(ReadableStreamBYOBReader.prototype.read, 'read');\n  167  setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, 'releaseLock');\n  168  if (typeof Symbol.toStringTag === 'symbol') {\n  ...\n  172      });\n  173  }\n  174: // Abstract operations for the readers.\n  175  export function IsReadableStreamBYOBReader(x) {\n  176      if (!typeIsObject(x)) {\n  ...\n  182      return x instanceof ReadableStreamBYOBReader;\n  183  }\n  184: export function ReadableStreamBYOBReaderRead(reader, view, min, readIntoRequest) {\n  185:     const stream = reader._ownerReadableStream;\n  186      assert(stream !== undefined);\n  187      stream._disturbed = true;\n  188      if (stream._state === 'errored') {\n  189:         readIntoRequest._errorSteps(stream._storedError);\n  190      }\n  191      else {\n  192:         ReadableByteStreamControllerPullInto(stream._readableStreamController, view, min, readIntoRequest);\n  193      }\n  194  }\n  195: export function ReadableStreamBYOBReaderRelease(reader) {\n  196:     ReadableStreamReaderGenericRelease(reader);\n  197      const e = new TypeError('Reader was released');\n  198:     ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n  199  }\n  200: export function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e) {\n  201:     const readIntoRequests = reader._readIntoRequests;\n  202:     reader._readIntoRequests = new SimpleQueue();\n  203:     readIntoRequests.forEach((readIntoRequest) => {\n  204:         readIntoRequest._errorSteps(e);\n  205      });\n  206  }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/generic-reader.js:\n    1  import assert from '../../stub/assert';\n    2: import { ReadableStream, ReadableStreamCancel } from '../readable-stream';\n    3  import { newPromise, setPromiseIsHandledToTrue } from '../helpers/webidl';\n    4  import { ReleaseSteps } from '../abstract-ops/internal-methods';\n    5: export function ReadableStreamReaderGenericInitialize(reader, stream) {\n    6:     reader._ownerReadableStream = stream;\n    7:     stream._reader = reader;\n    8:     if (stream._state === 'readable') {\n    9:         defaultReaderClosedPromiseInitialize(reader);\n   10      }\n   11      else if (stream._state === 'closed') {\n   12:         defaultReaderClosedPromiseInitializeAsResolved(reader);\n   13      }\n   14      else {\n   15          assert(stream._state === 'errored');\n   16:         defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n   17      }\n   18  }\n   19  // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n   20  // check.\n   21: export function ReadableStreamReaderGenericCancel(reader, reason) {\n   22:     const stream = reader._ownerReadableStream;\n   23      assert(stream !== undefined);\n   24      return ReadableStreamCancel(stream, reason);\n   25  }\n   26: export function ReadableStreamReaderGenericRelease(reader) {\n   27:     const stream = reader._ownerReadableStream;\n   28      assert(stream !== undefined);\n   29:     assert(stream._reader === reader);\n   30:     if (stream._state === 'readable') {\n   31:         defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n   32      }\n   33      else {\n   34:         defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n   35      }\n   36      stream._readableStreamController[ReleaseSteps]();\n   37      stream._reader = undefined;\n   38:     reader._ownerReadableStream = undefined;\n   39  }\n   40: // Helper functions for the readers.\n   41: export function readerLockException(name) {\n   42:     return new TypeError('Cannot ' + name + ' a stream using a released reader');\n   43  }\n   44  // Helper functions for the ReadableStreamDefaultReader.\n   45: export function defaultReaderClosedPromiseInitialize(reader) {\n   46:     reader._closedPromise = newPromise((resolve, reject) => {\n   47:         reader._closedPromise_resolve = resolve;\n   48:         reader._closedPromise_reject = reject;\n   49      });\n   50  }\n   51: export function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n   52:     defaultReaderClosedPromiseInitialize(reader);\n   53:     defaultReaderClosedPromiseReject(reader, reason);\n   54  }\n   55: export function defaultReaderClosedPromiseInitializeAsResolved(reader) {\n   56:     defaultReaderClosedPromiseInitialize(reader);\n   57:     defaultReaderClosedPromiseResolve(reader);\n   58  }\n   59: export function defaultReaderClosedPromiseReject(reader, reason) {\n   60:     if (reader._closedPromise_reject === undefined) {\n   61          return;\n   62      }\n   63:     setPromiseIsHandledToTrue(reader._closedPromise);\n   64:     reader._closedPromise_reject(reason);\n   65:     reader._closedPromise_resolve = undefined;\n   66:     reader._closedPromise_reject = undefined;\n   67  }\n   68: export function defaultReaderClosedPromiseResetToRejected(reader, reason) {\n   69:     assert(reader._closedPromise_resolve === undefined);\n   70:     assert(reader._closedPromise_reject === undefined);\n   71:     defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n   72  }\n   73: export function defaultReaderClosedPromiseResolve(reader) {\n   74:     if (reader._closedPromise_resolve === undefined) {\n   75          return;\n   76      }\n   77:     reader._closedPromise_resolve(undefined);\n   78:     reader._closedPromise_resolve = undefined;\n   79:     reader._closedPromise_reject = undefined;\n   80  }\n   81  \n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/pipe.d.ts:\n    1: import { ReadableStream } from '../readable-stream';\n    2  import { WritableStream } from '../writable-stream';\n    3  import { type AbortSignal } from '../abort-signal';\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/readable-writable-pair.d.ts:\n    1: import { ReadableStream } from '../readable-stream';\n    2  import { WritableStream } from '../writable-stream';\n    3  /**\n    4:  * A pair of a {@link ReadableStream | readable stream} and {@link WritableStream | writable stream} that can be passed\n    5   * to {@link ReadableStream.pipeThrough}.\n    6   *\n    .\n    8   */\n    9  export interface ReadableWritablePair<R, W> {\n   10:     readable: ReadableStream<R>;\n   11      writable: WritableStream<W>;\n   12  }\n   13: //# sourceMappingURL=readable-writable-pair.d.ts.map\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byob-reader.ts:\n    5    ReadableStreamReaderGenericInitialize,\n    6    ReadableStreamReaderGenericRelease,\n    7:   readerLockException\n    8: } from './generic-reader';\n    9: import { IsReadableStreamLocked, type ReadableByteStream, type ReadableStream } from '../readable-stream';\n   10  import {\n   11    IsReadableByteStreamController,\n   ..\n   16  import { newPromise, promiseRejectedWith } from '../helpers/webidl';\n   17  import { assertRequiredArgument } from '../validators/basic';\n   18: import { assertReadableStream } from '../validators/readable-stream';\n   19  import { IsDetachedBuffer } from '../abstract-ops/ecmascript';\n   20  import type {\n   21    ReadableStreamBYOBReaderReadOptions,\n   22    ValidatedReadableStreamBYOBReaderReadOptions\n   23: } from './reader-options';\n   24: import { convertByobReadOptions } from '../validators/reader-options';\n   25  import { isDataView, type NonShared, type TypedArray } from '../helpers/array-buffer-view';\n   26  \n   27  /**\n   28:  * A result returned by {@link ReadableStreamBYOBReader.read}.\n   29   *\n   30   * @public\n   ..\n   48  export function ReadableStreamAddReadIntoRequest<T extends NonShared<ArrayBufferView>>(\n   49    stream: ReadableByteStream,\n   50:   readIntoRequest: ReadIntoRequest<T>\n   51  ): void {\n   52    assert(IsReadableStreamBYOBReader(stream._reader));\n   53:   assert(stream._state === 'readable' || stream._state === 'closed');\n   54  \n   55:   (stream._reader! as ReadableStreamBYOBReader)._readIntoRequests.push(readIntoRequest);\n   56  }\n   57  \n   ..\n   61    done: boolean\n   62  ) {\n   63:   const reader = stream._reader as ReadableStreamBYOBReader;\n   64  \n   65:   assert(reader._readIntoRequests.length > 0);\n   66  \n   67:   const readIntoRequest = reader._readIntoRequests.shift()!;\n   68    if (done) {\n   69:     readIntoRequest._closeSteps(chunk);\n   70    } else {\n   71:     readIntoRequest._chunkSteps(chunk);\n   72    }\n   73  }\n   ..\n   78  \n   79  export function ReadableStreamHasBYOBReader(stream: ReadableByteStream): boolean {\n   80:   const reader = stream._reader;\n   81  \n   82:   if (reader === undefined) {\n   83      return false;\n   84    }\n   85  \n   86:   if (!IsReadableStreamBYOBReader(reader)) {\n   87      return false;\n   88    }\n   ..\n  102  \n  103  /**\n  104:  * A BYOB reader vended by a {@link ReadableStream}.\n  105   *\n  106   * @public\n  ...\n  123  \n  124      if (IsReadableStreamLocked(stream)) {\n  125:       throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n  126      }\n  127  \n  ...\n  138    /**\n  139     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n  140:    * the reader's lock is released before the stream finishes closing.\n  141     */\n  142    get closed(): Promise<undefined> {\n  ...\n  149  \n  150    /**\n  151:    * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n  152     */\n  153    cancel(reason: any = undefined): Promise<void> {\n  ...\n  157  \n  158      if (this._ownerReadableStream === undefined) {\n  159:       return promiseRejectedWith(readerLockException('cancel'));\n  160      }\n  161  \n  ...\n  164  \n  165    /**\n  166:    * Attempts to reads bytes into view, and returns a promise resolved with the result.\n  167     *\n  168:    * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  169     */\n  170:   read<T extends ArrayBufferView>(\n  171      view: T,\n  172      options?: ReadableStreamBYOBReaderReadOptions\n  173    ): Promise<ReadableStreamBYOBReadResult<T>>;\n  174:   read<T extends NonShared<ArrayBufferView>>(\n  175      view: T,\n  176      rawOptions: ReadableStreamBYOBReaderReadOptions | null | undefined = {}\n  177    ): Promise<ReadableStreamBYOBReadResult<T>> {\n  178      if (!IsReadableStreamBYOBReader(this)) {\n  179:       return promiseRejectedWith(byobReaderBrandCheckException('read'));\n  180      }\n  181  \n  ...\n  212  \n  213      if (this._ownerReadableStream === undefined) {\n  214:       return promiseRejectedWith(readerLockException('read from'));\n  215      }\n  216  \n  ...\n  221        rejectPromise = reject;\n  222      });\n  223:     const readIntoRequest: ReadIntoRequest<T> = {\n  224        _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n  225        _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n  226        _errorSteps: e => rejectPromise(e)\n  227      };\n  228:     ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);\n  229      return promise;\n  230    }\n  231  \n  232    /**\n  233:    * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n  234:    * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n  235:    * from now on; otherwise, the reader will appear closed.\n  236     *\n  237:    * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  238:    * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n  239:    * do so will throw a `TypeError` and leave the reader locked to the stream.\n  240     */\n  241    releaseLock(): void {\n  ...\n  254  Object.defineProperties(ReadableStreamBYOBReader.prototype, {\n  255    cancel: { enumerable: true },\n  256:   read: { enumerable: true },\n  257    releaseLock: { enumerable: true },\n  258    closed: { enumerable: true }\n  259  });\n  260  setFunctionName(ReadableStreamBYOBReader.prototype.cancel, 'cancel');\n  261: setFunctionName(ReadableStreamBYOBReader.prototype.read, 'read');\n  262  setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, 'releaseLock');\n  263  if (typeof Symbol.toStringTag === 'symbol') {\n  ...\n  268  }\n  269  \n  270: // Abstract operations for the readers.\n  271  \n  272  export function IsReadableStreamBYOBReader(x: any): x is ReadableStreamBYOBReader {\n  ...\n  283  \n  284  export function ReadableStreamBYOBReaderRead<T extends NonShared<ArrayBufferView>>(\n  285:   reader: ReadableStreamBYOBReader,\n  286    view: T,\n  287    min: number,\n  288:   readIntoRequest: ReadIntoRequest<T>\n  289  ): void {\n  290:   const stream = reader._ownerReadableStream;\n  291  \n  292    assert(stream !== undefined);\n  ...\n  295  \n  296    if (stream._state === 'errored') {\n  297:     readIntoRequest._errorSteps(stream._storedError);\n  298    } else {\n  299      ReadableByteStreamControllerPullInto(\n  ...\n  301        view,\n  302        min,\n  303:       readIntoRequest\n  304      );\n  305    }\n  306  }\n  307  \n  308: export function ReadableStreamBYOBReaderRelease(reader: ReadableStreamBYOBReader) {\n  309:   ReadableStreamReaderGenericRelease(reader);\n  310    const e = new TypeError('Reader was released');\n  311:   ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n  312  }\n  313  \n  314: export function ReadableStreamBYOBReaderErrorReadIntoRequests(reader: ReadableStreamBYOBReader, e: any) {\n  315:   const readIntoRequests = reader._readIntoRequests;\n  316:   reader._readIntoRequests = new SimpleQueue();\n  317:   readIntoRequests.forEach((readIntoRequest) => {\n  318:     readIntoRequest._errorSteps(e);\n  319    });\n  320  }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/generic-reader.ts:\n    1  import assert from '../../stub/assert';\n    2: import { ReadableStream, ReadableStreamCancel, type ReadableStreamReader } from '../readable-stream';\n    3  import { newPromise, setPromiseIsHandledToTrue } from '../helpers/webidl';\n    4  import { ReleaseSteps } from '../abstract-ops/internal-methods';\n    5  \n    6: export function ReadableStreamReaderGenericInitialize<R>(reader: ReadableStreamReader<R>, stream: ReadableStream<R>) {\n    7:   reader._ownerReadableStream = stream;\n    8:   stream._reader = reader;\n    9  \n   10:   if (stream._state === 'readable') {\n   11:     defaultReaderClosedPromiseInitialize(reader);\n   12    } else if (stream._state === 'closed') {\n   13:     defaultReaderClosedPromiseInitializeAsResolved(reader);\n   14    } else {\n   15      assert(stream._state === 'errored');\n   16  \n   17:     defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n   18    }\n   19  }\n   ..\n   22  // check.\n   23  \n   24: export function ReadableStreamReaderGenericCancel(reader: ReadableStreamReader<any>, reason: any): Promise<undefined> {\n   25:   const stream = reader._ownerReadableStream;\n   26    assert(stream !== undefined);\n   27    return ReadableStreamCancel(stream, reason);\n   28  }\n   29  \n   30: export function ReadableStreamReaderGenericRelease(reader: ReadableStreamReader<any>) {\n   31:   const stream = reader._ownerReadableStream;\n   32    assert(stream !== undefined);\n   33:   assert(stream._reader === reader);\n   34  \n   35:   if (stream._state === 'readable') {\n   36      defaultReaderClosedPromiseReject(\n   37:       reader,\n   38        new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`)\n   39      );\n   40    } else {\n   41      defaultReaderClosedPromiseResetToRejected(\n   42:       reader,\n   43        new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`)\n   44      );\n   ..\n   48  \n   49    stream._reader = undefined;\n   50:   reader._ownerReadableStream = undefined!;\n   51  }\n   52  \n   53: // Helper functions for the readers.\n   54  \n   55: export function readerLockException(name: string): TypeError {\n   56:   return new TypeError('Cannot ' + name + ' a stream using a released reader');\n   57  }\n   58  \n   59  // Helper functions for the ReadableStreamDefaultReader.\n   60  \n   61: export function defaultReaderClosedPromiseInitialize(reader: ReadableStreamReader<any>) {\n   62:   reader._closedPromise = newPromise((resolve, reject) => {\n   63:     reader._closedPromise_resolve = resolve;\n   64:     reader._closedPromise_reject = reject;\n   65    });\n   66  }\n   67  \n   68: export function defaultReaderClosedPromiseInitializeAsRejected(reader: ReadableStreamReader<any>, reason: any) {\n   69:   defaultReaderClosedPromiseInitialize(reader);\n   70:   defaultReaderClosedPromiseReject(reader, reason);\n   71  }\n   72  \n   73: export function defaultReaderClosedPromiseInitializeAsResolved(reader: ReadableStreamReader<any>) {\n   74:   defaultReaderClosedPromiseInitialize(reader);\n   75:   defaultReaderClosedPromiseResolve(reader);\n   76  }\n   77  \n   78: export function defaultReaderClosedPromiseReject(reader: ReadableStreamReader<any>, reason: any) {\n   79:   if (reader._closedPromise_reject === undefined) {\n   80      return;\n   81    }\n   82  \n   83:   setPromiseIsHandledToTrue(reader._closedPromise);\n   84:   reader._closedPromise_reject(reason);\n   85:   reader._closedPromise_resolve = undefined;\n   86:   reader._closedPromise_reject = undefined;\n   87  }\n   88  \n   89: export function defaultReaderClosedPromiseResetToRejected(reader: ReadableStreamReader<any>, reason: any) {\n   90:   assert(reader._closedPromise_resolve === undefined);\n   91:   assert(reader._closedPromise_reject === undefined);\n   92  \n   93:   defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n   94  }\n   95  \n   96: export function defaultReaderClosedPromiseResolve(reader: ReadableStreamReader<any>) {\n   97:   if (reader._closedPromise_resolve === undefined) {\n   98      return;\n   99    }\n  100  \n  101:   reader._closedPromise_resolve(undefined);\n  102:   reader._closedPromise_resolve = undefined;\n  103:   reader._closedPromise_reject = undefined;\n  104  }\n  105  \n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/default-reader.js:\n    1  import assert from '../../stub/assert';\n    2  import { SimpleQueue } from '../simple-queue';\n    3: import { ReadableStreamReaderGenericCancel, ReadableStreamReaderGenericInitialize, ReadableStreamReaderGenericRelease, readerLockException } from './generic-reader';\n    4: import { IsReadableStreamLocked, ReadableStream } from '../readable-stream';\n    5  import { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\n    6  import { PullSteps } from '../abstract-ops/internal-methods';\n    7  import { newPromise, promiseRejectedWith } from '../helpers/webidl';\n    8  import { assertRequiredArgument } from '../validators/basic';\n    9: import { assertReadableStream } from '../validators/readable-stream';\n   10  // Abstract operations for the ReadableStream.\n   11  export function AcquireReadableStreamDefaultReader(stream) {\n   ..\n   13  }\n   14  // ReadableStream API exposed for controllers.\n   15: export function ReadableStreamAddReadRequest(stream, readRequest) {\n   16      assert(IsReadableStreamDefaultReader(stream._reader));\n   17:     assert(stream._state === 'readable');\n   18:     stream._reader._readRequests.push(readRequest);\n   19  }\n   20  export function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n   21:     const reader = stream._reader;\n   22:     assert(reader._readRequests.length > 0);\n   23:     const readRequest = reader._readRequests.shift();\n   24      if (done) {\n   25:         readRequest._closeSteps();\n   26      }\n   27      else {\n   28:         readRequest._chunkSteps(chunk);\n   29      }\n   30  }\n   ..\n   33  }\n   34  export function ReadableStreamHasDefaultReader(stream) {\n   35:     const reader = stream._reader;\n   36:     if (reader === undefined) {\n   37          return false;\n   38      }\n   39:     if (!IsReadableStreamDefaultReader(reader)) {\n   40          return false;\n   41      }\n   ..\n   43  }\n   44  /**\n   45:  * A default reader vended by a {@link ReadableStream}.\n   46   *\n   47   * @public\n   ..\n   52          assertReadableStream(stream, 'First parameter');\n   53          if (IsReadableStreamLocked(stream)) {\n   54:             throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n   55          }\n   56          ReadableStreamReaderGenericInitialize(this, stream);\n   ..\n   59      /**\n   60       * Returns a promise that will be fulfilled when the stream becomes closed,\n   61:      * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n   62       */\n   63      get closed() {\n   ..\n   68      }\n   69      /**\n   70:      * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n   71       */\n   72      cancel(reason = undefined) {\n   ..\n   75          }\n   76          if (this._ownerReadableStream === undefined) {\n   77:             return promiseRejectedWith(readerLockException('cancel'));\n   78          }\n   79          return ReadableStreamReaderGenericCancel(this, reason);\n   ..\n   82       * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n   83       *\n   84:      * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   85       */\n   86:     read() {\n   87          if (!IsReadableStreamDefaultReader(this)) {\n   88:             return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n   89          }\n   90          if (this._ownerReadableStream === undefined) {\n   91:             return promiseRejectedWith(readerLockException('read from'));\n   92          }\n   93          let resolvePromise;\n   ..\n   97              rejectPromise = reject;\n   98          });\n   99:         const readRequest = {\n  100              _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n  101              _closeSteps: () => resolvePromise({ value: undefined, done: true }),\n  102              _errorSteps: e => rejectPromise(e)\n  103          };\n  104:         ReadableStreamDefaultReaderRead(this, readRequest);\n  105          return promise;\n  106      }\n  107      /**\n  108:      * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n  109:      * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n  110:      * from now on; otherwise, the reader will appear closed.\n  111       *\n  112:      * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  113:      * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  114:      * do so will throw a `TypeError` and leave the reader locked to the stream.\n  115       */\n  116      releaseLock() {\n  ...\n  126  Object.defineProperties(ReadableStreamDefaultReader.prototype, {\n  127      cancel: { enumerable: true },\n  128:     read: { enumerable: true },\n  129      releaseLock: { enumerable: true },\n  130      closed: { enumerable: true }\n  131  });\n  132  setFunctionName(ReadableStreamDefaultReader.prototype.cancel, 'cancel');\n  133: setFunctionName(ReadableStreamDefaultReader.prototype.read, 'read');\n  134  setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, 'releaseLock');\n  135  if (typeof Symbol.toStringTag === 'symbol') {\n  ...\n  139      });\n  140  }\n  141: // Abstract operations for the readers.\n  142  export function IsReadableStreamDefaultReader(x) {\n  143      if (!typeIsObject(x)) {\n  ...\n  149      return x instanceof ReadableStreamDefaultReader;\n  150  }\n  151: export function ReadableStreamDefaultReaderRead(reader, readRequest) {\n  152:     const stream = reader._ownerReadableStream;\n  153      assert(stream !== undefined);\n  154      stream._disturbed = true;\n  155      if (stream._state === 'closed') {\n  156:         readRequest._closeSteps();\n  157      }\n  158      else if (stream._state === 'errored') {\n  159:         readRequest._errorSteps(stream._storedError);\n  160      }\n  161      else {\n  162:         assert(stream._state === 'readable');\n  163:         stream._readableStreamController[PullSteps](readRequest);\n  164      }\n  165  }\n  166: export function ReadableStreamDefaultReaderRelease(reader) {\n  167:     ReadableStreamReaderGenericRelease(reader);\n  168      const e = new TypeError('Reader was released');\n  169:     ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n  170  }\n  171: export function ReadableStreamDefaultReaderErrorReadRequests(reader, e) {\n  172:     const readRequests = reader._readRequests;\n  173:     reader._readRequests = new SimpleQueue();\n  174:     readRequests.forEach((readRequest) => {\n  175:         readRequest._errorSteps(e);\n  176      });\n  177  }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/default-controller.js:\n    1  import assert from '../../stub/assert';\n    2  import { DequeueValue, EnqueueValueWithSize, ResetQueue } from '../abstract-ops/queue-with-sizes';\n    3: import { ReadableStreamAddReadRequest, ReadableStreamFulfillReadRequest, ReadableStreamGetNumReadRequests } from './default-reader';\n    4  import { SimpleQueue } from '../simple-queue';\n    5: import { IsReadableStreamLocked, ReadableStream, ReadableStreamClose, ReadableStreamError } from '../readable-stream';\n    6  import { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\n    7  import { CancelSteps, PullSteps, ReleaseSteps } from '../abstract-ops/internal-methods';\n    8  import { promiseResolvedWith, uponPromise } from '../helpers/webidl';\n    9  /**\n   10:  * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n   11   *\n   12   * @public\n   ..\n   27      }\n   28      /**\n   29:      * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n   30:      * the stream, but once those are read, the stream will become closed.\n   31       */\n   32      close() {\n   ..\n   49      }\n   50      /**\n   51:      * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n   52       */\n   53      error(e = undefined) {\n   ..\n   65      }\n   66      /** @internal */\n   67:     [PullSteps](readRequest) {\n   68          const stream = this._controlledReadableStream;\n   69          if (this._queue.length > 0) {\n   ..\n   76                  ReadableStreamDefaultControllerCallPullIfNeeded(this);\n   77              }\n   78:             readRequest._chunkSteps(chunk);\n   79          }\n   80          else {\n   81:             ReadableStreamAddReadRequest(stream, readRequest);\n   82              ReadableStreamDefaultControllerCallPullIfNeeded(this);\n   83          }\n   ..\n  201  export function ReadableStreamDefaultControllerError(controller, e) {\n  202      const stream = controller._controlledReadableStream;\n  203:     if (stream._state !== 'readable') {\n  204          return;\n  205      }\n  ...\n  227  export function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n  228      const state = controller._controlledReadableStream._state;\n  229:     if (!controller._closeRequested && state === 'readable') {\n  230          return true;\n  231      }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byte-stream-controller.js:\n    2  import { SimpleQueue } from '../simple-queue';\n    3  import { ResetQueue } from '../abstract-ops/queue-with-sizes';\n    4: <skipped 87 characters> ...fillReadRequest, ReadableStreamGetNumReadRequests, ReadableStreamHasDefaultReader } from './default-reader';\n    5: <skipped 62 characters> ...llReadIntoRequest, ReadableStreamGetNumReadIntoRequests, ReadableStreamHasBYOBReader } from './byob-reader';\n    6  import NumberIsInteger from '../../stub/number-isinteger';\n    7: import { IsReadableStreamLocked, ReadableStreamClose, ReadableStreamError } from '../readable-stream';\n    8  import { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\n    9  import { ArrayBufferSlice, CanCopyDataBlockBytes, CanTransferArrayBuffer, CopyDataBlockBytes, IsDetachedBuffer, TransferArrayBuffer } from '../abstract-ops/ecmascript';\n   ..\n   77  }\n   78  /**\n   79:  * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n   80   *\n   81   * @public\n   ..\n  105      }\n  106      /**\n  107:      * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n  108:      * the stream, but once those are read, the stream will become closed.\n  109       */\n  110      close() {\n  ...\n  116          }\n  117          const state = this._controlledReadableByteStream._state;\n  118:         if (state !== 'readable') {\n  119:             throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n  120          }\n  121          ReadableByteStreamControllerClose(this);\n  ...\n  139          }\n  140          const state = this._controlledReadableByteStream._state;\n  141:         if (state !== 'readable') {\n  142:             throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n  143          }\n  144          ReadableByteStreamControllerEnqueue(this, chunk);\n  145      }\n  146      /**\n  147:      * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n  148       */\n  149      error(e = undefined) {\n  ...\n  162      }\n  163      /** @internal */\n  164:     [PullSteps](readRequest) {\n  165          const stream = this._controlledReadableByteStream;\n  166          assert(ReadableStreamHasDefaultReader(stream));\n  167          if (this._queueTotalSize > 0) {\n  168              assert(ReadableStreamGetNumReadRequests(stream) === 0);\n  169:             ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);\n  170              return;\n  171          }\n  ...\n  177              }\n  178              catch (bufferE) {\n  179:                 readRequest._errorSteps(bufferE);\n  180                  return;\n  181              }\n  ...\n  189                  elementSize: 1,\n  190                  viewConstructor: Uint8Array,\n  191:                 readerType: 'default'\n  192              };\n  193              this._pendingPullIntos.push(pullIntoDescriptor);\n  194          }\n  195:         ReadableStreamAddReadRequest(stream, readRequest);\n  196          ReadableByteStreamControllerCallPullIfNeeded(this);\n  197      }\n  ...\n  200          if (this._pendingPullIntos.length > 0) {\n  201              const firstPullInto = this._pendingPullIntos.peek();\n  202:             firstPullInto.readerType = 'none';\n  203              this._pendingPullIntos = new SimpleQueue();\n  204              this._pendingPullIntos.push(firstPullInto);\n  ...\n  272  function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n  273      assert(stream._state !== 'errored');\n  274:     assert(pullIntoDescriptor.readerType !== 'none');\n  275      let done = false;\n  276      if (stream._state === 'closed') {\n  ...\n  279      }\n  280      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n  281:     if (pullIntoDescriptor.readerType === 'default') {\n  282          ReadableStreamFulfillReadRequest(stream, filledView, done);\n  283      }\n  284      else {\n  285:         assert(pullIntoDescriptor.readerType === 'byob');\n  286          ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  287      }\n  ...\n  315  }\n  316  function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {\n  317:     assert(firstDescriptor.readerType === 'none');\n  318      if (firstDescriptor.bytesFilled > 0) {\n  319          ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);\n  ...\n  325      const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n  326      let totalBytesToCopyRemaining = maxBytesToCopy;\n  327:     let ready = false;\n  328      assert(!IsDetachedBuffer(pullIntoDescriptor.buffer));\n  329      assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n  330      const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\n  331      const maxAlignedBytes = maxBytesFilled - remainderBytes;\n  332:     // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  333      // of the queue, so the underlying source can keep filling it.\n  334      if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n  335          totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n  336:         ready = true;\n  337      }\n  338      const queue = controller._queue;\n  ...\n  354          totalBytesToCopyRemaining -= bytesToCopy;\n  355      }\n  356:     if (!ready) {\n  357          assert(controller._queueTotalSize === 0);\n  358          assert(pullIntoDescriptor.bytesFilled > 0);\n  359          assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n  360      }\n  361:     return ready;\n  362  }\n  363  function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n  ...\n  367  }\n  368  function ReadableByteStreamControllerHandleQueueDrain(controller) {\n  369:     assert(controller._controlledReadableByteStream._state === 'readable');\n  370      if (controller._queueTotalSize === 0 && controller._closeRequested) {\n  371          ReadableByteStreamControllerClearAlgorithms(controller);\n  ...\n  392          }\n  393          const pullIntoDescriptor = controller._pendingPullIntos.peek();\n  394:         assert(pullIntoDescriptor.readerType !== 'none');\n  395          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n  396              ReadableByteStreamControllerShiftPendingPullInto(controller);\n  ...\n  401  }\n  402  function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller) {\n  403:     const reader = controller._controlledReadableByteStream._reader;\n  404:     assert(IsReadableStreamDefaultReader(reader));\n  405:     while (reader._readRequests.length > 0) {\n  406          if (controller._queueTotalSize === 0) {\n  407              return;\n  408          }\n  409:         const readRequest = reader._readRequests.shift();\n  410:         ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);\n  411      }\n  412  }\n  413: export function ReadableByteStreamControllerPullInto(controller, view, min, readIntoRequest) {\n  414      const stream = controller._controlledReadableByteStream;\n  415      const ctor = view.constructor;\n  ...\n  424      }\n  425      catch (e) {\n  426:         readIntoRequest._errorSteps(e);\n  427          return;\n  428      }\n  ...\n  436          elementSize,\n  437          viewConstructor: ctor,\n  438:         readerType: 'byob'\n  439      };\n  440      if (controller._pendingPullIntos.length > 0) {\n  ...\n  442          // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n  443          // - No change happens on desiredSize\n  444:         // - The source has already been notified of that there's at least 1 pending read(view)\n  445:         ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n  446          return;\n  447      }\n  448      if (stream._state === 'closed') {\n  449          const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n  450:         readIntoRequest._closeSteps(emptyView);\n  451          return;\n  452      }\n  ...\n  455              const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n  456              ReadableByteStreamControllerHandleQueueDrain(controller);\n  457:             readIntoRequest._chunkSteps(filledView);\n  458              return;\n  459          }\n  ...\n  461              const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n  462              ReadableByteStreamControllerError(controller, e);\n  463:             readIntoRequest._errorSteps(e);\n  464              return;\n  465          }\n  466      }\n  467      controller._pendingPullIntos.push(pullIntoDescriptor);\n  468:     ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n  469      ReadableByteStreamControllerCallPullIfNeeded(controller);\n  470  }\n  471  function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n  472      assert(firstDescriptor.bytesFilled % firstDescriptor.elementSize === 0);\n  473:     if (firstDescriptor.readerType === 'none') {\n  474          ReadableByteStreamControllerShiftPendingPullInto(controller);\n  475      }\n  ...\n  486      assert(pullIntoDescriptor.bytesFilled + bytesWritten <= pullIntoDescriptor.byteLength);\n  487      ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n  488:     if (pullIntoDescriptor.readerType === 'none') {\n  489          ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);\n  490          const filledPullIntos = ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  ...\n  493      }\n  494      if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\n  495:         // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  496          // of the queue, so the underlying source can keep filling it.\n  497          return;\n  ...\n  518      }\n  519      else {\n  520:         assert(state === 'readable');\n  521          assert(bytesWritten > 0);\n  522          ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  ...\n  531  function ReadableByteStreamControllerShouldCallPull(controller) {\n  532      const stream = controller._controlledReadableByteStream;\n  533:     if (stream._state !== 'readable') {\n  534          return false;\n  535      }\n  ...\n  560  export function ReadableByteStreamControllerClose(controller) {\n  561      const stream = controller._controlledReadableByteStream;\n  562:     if (controller._closeRequested || stream._state !== 'readable') {\n  563          return;\n  564      }\n  ...\n  580  export function ReadableByteStreamControllerEnqueue(controller, chunk) {\n  581      const stream = controller._controlledReadableByteStream;\n  582:     if (controller._closeRequested || stream._state !== 'readable') {\n  583          return;\n  584      }\n  ...\n  595          ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  596          firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n  597:         if (firstPendingPullInto.readerType === 'none') {\n  598              ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);\n  599          }\n  ...\n  608              assert(controller._queue.length === 0);\n  609              if (controller._pendingPullIntos.length > 0) {\n  610:                 assert(controller._pendingPullIntos.peek().readerType === 'default');\n  611                  ReadableByteStreamControllerShiftPendingPullInto(controller);\n  612              }\n  ...\n  629  export function ReadableByteStreamControllerError(controller, e) {\n  630      const stream = controller._controlledReadableByteStream;\n  631:     if (stream._state !== 'readable') {\n  632          return;\n  633      }\n  ...\n  637      ReadableStreamError(stream, e);\n  638  }\n  639: export function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {\n  640      assert(controller._queueTotalSize > 0);\n  641      const entry = controller._queue.shift();\n  ...\n  643      ReadableByteStreamControllerHandleQueueDrain(controller);\n  644      const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n  645:     readRequest._chunkSteps(view);\n  646  }\n  647  export function ReadableByteStreamControllerGetBYOBRequest(controller) {\n  ...\n  675      }\n  676      else {\n  677:         assert(state === 'readable');\n  678          if (bytesWritten === 0) {\n  679:             throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');\n  680          }\n  681          if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n  ...\n  697      }\n  698      else {\n  699:         assert(state === 'readable');\n  700          if (view.byteLength === 0) {\n  701:             throw new TypeError('The view\\'s length must be greater than 0 when calling respondWithNewView() on a readable stream');\n  702          }\n  703      }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/async-iterator.js:\n    1: import { ReadableStream } from '../readable-stream';\n    2: import { AcquireReadableStreamDefaultReader, ReadableStreamDefaultReader, ReadableStreamDefaultReaderRead } from './default-reader';\n    3: import { ReadableStreamReaderGenericCancel, ReadableStreamReaderGenericRelease } from './generic-reader';\n    4  import assert from '../../stub/assert';\n    5  import { SymbolAsyncIterator } from '../abstract-ops/ecmascript';\n    .\n    7  import { newPromise, promiseRejectedWith, promiseResolvedWith, queueMicrotask, transformPromiseWith } from '../helpers/webidl';\n    8  export class ReadableStreamAsyncIteratorImpl {\n    9:     constructor(reader, preventCancel) {\n   10          this._ongoingPromise = undefined;\n   11          this._isFinished = false;\n   12:         this._reader = reader;\n   13          this._preventCancel = preventCancel;\n   14      }\n   ..\n   31              return Promise.resolve({ value: undefined, done: true });\n   32          }\n   33:         const reader = this._reader;\n   34:         assert(reader._ownerReadableStream !== undefined);\n   35          let resolvePromise;\n   36          let rejectPromise;\n   ..\n   39              rejectPromise = reject;\n   40          });\n   41:         const readRequest = {\n   42              _chunkSteps: (chunk) => {\n   43                  this._ongoingPromise = undefined;\n   ..\n   49                  this._ongoingPromise = undefined;\n   50                  this._isFinished = true;\n   51:                 ReadableStreamReaderGenericRelease(reader);\n   52                  resolvePromise({ value: undefined, done: true });\n   53              },\n   ..\n   55                  this._ongoingPromise = undefined;\n   56                  this._isFinished = true;\n   57:                 ReadableStreamReaderGenericRelease(reader);\n   58                  rejectPromise(reason);\n   59              }\n   60          };\n   61:         ReadableStreamDefaultReaderRead(reader, readRequest);\n   62          return promise;\n   63      }\n   ..\n   67          }\n   68          this._isFinished = true;\n   69:         const reader = this._reader;\n   70:         assert(reader._ownerReadableStream !== undefined);\n   71:         assert(reader._readRequests.length === 0);\n   72          if (!this._preventCancel) {\n   73:             const result = ReadableStreamReaderGenericCancel(reader, value);\n   74:             ReadableStreamReaderGenericRelease(reader);\n   75              return transformPromiseWith(result, () => ({ value, done: true }));\n   76          }\n   77:         ReadableStreamReaderGenericRelease(reader);\n   78          return promiseResolvedWith({ value, done: true });\n   79      }\n   ..\n  103  // Abstract operations for the ReadableStream.\n  104  export function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n  105:     const reader = AcquireReadableStreamDefaultReader(stream);\n  106:     const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n  107      const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n  108      iterator._asyncIteratorImpl = impl;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/writable-stream/underlying-sink.ts:\n   23    start?: UnderlyingSinkStartCallback;\n   24    /**\n   25:    * A function that is called when a new chunk of data is ready to be written to the underlying sink. The stream\n   26:    * implementation guarantees that this function will be called only after previous writes have succeeded, and never\n   27     * before {@link UnderlyingSink.start | start()} has succeeded or after {@link UnderlyingSink.close | close()} or\n   28     * {@link UnderlyingSink.abort | abort()} have been called.\n   29     *\n   30:    * This function is used to actually send the data to the resource presented by the underlying sink, for example by\n   31     * calling a lower-level API.\n   32     */\n   33:   write?: UnderlyingSinkWriteCallback<W>;\n   34    /**\n   35     * A function that is called after the producer signals, via\n   36:    * {@link WritableStreamDefaultWriter.close | writer.close()}, that they are done writing chunks to the stream, and\n   37:    * subsequently all queued-up writes have successfully completed.\n   38     *\n   39:    * This function can perform any actions necessary to finalize or flush writes to the underlying sink, and release\n   40     * access to any held resources.\n   41     */\n   ..\n   43    /**\n   44     * A function that is called after the producer signals, via {@link WritableStream.abort | stream.abort()} or\n   45:    * {@link WritableStreamDefaultWriter.abort | writer.abort()}, that they wish to abort the stream. It takes as its\n   46     * argument the same value as was passed to those methods by the producer.\n   47     *\n   ..\n   57  \n   58  export interface ValidatedUnderlyingSink<W = any> extends UnderlyingSink<W> {\n   59:   write?: (chunk: W, controller: WritableStreamDefaultController) => Promise<void>;\n   60    close?: () => Promise<void>;\n   61    abort?: (reason: any) => Promise<void>;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/writable-stream/underlying-sink.d.ts:\n   19      start?: UnderlyingSinkStartCallback;\n   20      /**\n   21:      * A function that is called when a new chunk of data is ready to be written to the underlying sink. The stream\n   22:      * implementation guarantees that this function will be called only after previous writes have succeeded, and never\n   23       * before {@link UnderlyingSink.start | start()} has succeeded or after {@link UnderlyingSink.close | close()} or\n   24       * {@link UnderlyingSink.abort | abort()} have been called.\n   25       *\n   26:      * This function is used to actually send the data to the resource presented by the underlying sink, for example by\n   27       * calling a lower-level API.\n   28       */\n   29:     write?: UnderlyingSinkWriteCallback<W>;\n   30      /**\n   31       * A function that is called after the producer signals, via\n   32:      * {@link WritableStreamDefaultWriter.close | writer.close()}, that they are done writing chunks to the stream, and\n   33:      * subsequently all queued-up writes have successfully completed.\n   34       *\n   35:      * This function can perform any actions necessary to finalize or flush writes to the underlying sink, and release\n   36       * access to any held resources.\n   37       */\n   ..\n   39      /**\n   40       * A function that is called after the producer signals, via {@link WritableStream.abort | stream.abort()} or\n   41:      * {@link WritableStreamDefaultWriter.abort | writer.abort()}, that they wish to abort the stream. It takes as its\n   42       * argument the same value as was passed to those methods by the producer.\n   43       *\n   ..\n   52  }\n   53  export interface ValidatedUnderlyingSink<W = any> extends UnderlyingSink<W> {\n   54:     write?: (chunk: W, controller: WritableStreamDefaultController) => Promise<void>;\n   55      close?: () => Promise<void>;\n   56      abort?: (reason: any) => Promise<void>;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/validators/underlying-source.d.ts:\n    1: import type { UnderlyingByteSource, UnderlyingSource, ValidatedUnderlyingDefaultOrByteSource } from '../readable-stream/underlying-source';\n    2  export declare function convertUnderlyingDefaultOrByteSource<R>(source: UnderlyingSource<R> | UnderlyingByteSource | null, context: string): ValidatedUnderlyingDefaultOrByteSource<R>;\n    3  //# sourceMappingURL=underlying-source.d.ts.map\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/validators/readable-stream.js:\n    1: import { IsReadableStream, ReadableStream } from '../readable-stream';\n    2  export function assertReadableStream(x, context) {\n    3      if (!IsReadableStream(x)) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/validators/readable-writable-pair.ts:\n    1  import { assertDictionary, assertRequiredField } from './basic';\n    2: import { ReadableStream } from '../readable-stream';\n    3  import { WritableStream } from '../writable-stream';\n    4: import { assertReadableStream } from './readable-stream';\n    5  import { assertWritableStream } from './writable-stream';\n    6  \n    7  export function convertReadableWritablePair<RS extends ReadableStream, WS extends WritableStream>(\n    8:   pair: { readable: RS; writable: WS } | null | undefined,\n    9    context: string\n   10: ): { readable: RS; writable: WS } {\n   11    assertDictionary(pair, context);\n   12  \n   13:   const readable = pair?.readable;\n   14:   assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n   15:   assertReadableStream(readable, `${context} has member 'readable' that`);\n   16  \n   17    const writable = pair?.writable;\n   ..\n   19    assertWritableStream(writable, `${context} has member 'writable' that`);\n   20  \n   21:   return { readable, writable };\n   22  }\n   23  \n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/validators/underlying-source.ts:\n    9    UnderlyingSourceCancelCallback,\n   10    ValidatedUnderlyingDefaultOrByteSource\n   11: } from '../readable-stream/underlying-source';\n   12  import { promiseCall, reflectCall } from '../helpers/webidl';\n   13  \n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/validators/underlying-sink.ts:\n   20    const start = original?.start;\n   21    const type = original?.type;\n   22:   const write = original?.write;\n   23    return {\n   24      abort: abort === undefined\n   ..\n   31        ? undefined\n   32        : convertUnderlyingSinkStartCallback(start, original!, `${context} has member 'start' that`),\n   33:     write: write === undefined\n   34        ? undefined\n   35:       : convertUnderlyingSinkWriteCallback(write, original!, `${context} has member 'write' that`),\n   36      type\n   37    };\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/validators/readable-stream.d.ts:\n    1: import { ReadableStream } from '../readable-stream';\n    2  export declare function assertReadableStream(x: unknown, context: string): asserts x is ReadableStream;\n    3: //# sourceMappingURL=readable-stream.d.ts.map\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/validators/iterator-options.d.ts:\n    1: import type { ReadableStreamIteratorOptions, ValidatedReadableStreamIteratorOptions } from '../readable-stream/iterator-options';\n    2  export declare function convertIteratorOptions(options: ReadableStreamIteratorOptions | null | undefined, context: string): ValidatedReadableStreamIteratorOptions;\n    3  //# sourceMappingURL=iterator-options.d.ts.map\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/validators/transformer.ts:\n   18    const cancel = original?.cancel;\n   19    const flush = original?.flush;\n   20:   const readableType = original?.readableType;\n   21    const start = original?.start;\n   22    const transform = original?.transform;\n   ..\n   29        ? undefined\n   30        : convertTransformerFlushCallback(flush, original!, `${context} has member 'flush' that`),\n   31:     readableType,\n   32      start: start === undefined\n   33        ? undefined\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/validators/reader-options.ts:\n    4    ReadableStreamGetReaderOptions,\n    5    ValidatedReadableStreamBYOBReaderReadOptions\n    6: } from '../readable-stream/reader-options';\n    7  \n    8  export function convertReaderOptions(\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/validators/readable-stream.ts:\n    1: import { IsReadableStream, ReadableStream } from '../readable-stream';\n    2  \n    3  export function assertReadableStream(x: unknown, context: string): asserts x is ReadableStream {\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/validators/readable-writable-pair.js:\n    1  import { assertDictionary, assertRequiredField } from './basic';\n    2: import { ReadableStream } from '../readable-stream';\n    3  import { WritableStream } from '../writable-stream';\n    4: import { assertReadableStream } from './readable-stream';\n    5  import { assertWritableStream } from './writable-stream';\n    6  export function convertReadableWritablePair(pair, context) {\n    7      assertDictionary(pair, context);\n    8:     const readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n    9:     assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n   10:     assertReadableStream(readable, `${context} has member 'readable' that`);\n   11      const writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n   12      assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n   13      assertWritableStream(writable, `${context} has member 'writable' that`);\n   14:     return { readable, writable };\n   15  }\n   16  \n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/validators/underlying-sink.js:\n    8      const start = original === null || original === void 0 ? void 0 : original.start;\n    9      const type = original === null || original === void 0 ? void 0 : original.type;\n   10:     const write = original === null || original === void 0 ? void 0 : original.write;\n   11      return {\n   12          abort: abort === undefined\n   ..\n   19              ? undefined\n   20              : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n   21:         write: write === undefined\n   22              ? undefined\n   23:             : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n   24          type\n   25      };\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/validators/iterator-options.ts:\n    3    ReadableStreamIteratorOptions,\n    4    ValidatedReadableStreamIteratorOptions\n    5: } from '../readable-stream/iterator-options';\n    6  \n    7  export function convertIteratorOptions(\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/validators/pipe-options.ts:\n    1  import { assertDictionary } from './basic';\n    2: import type { StreamPipeOptions, ValidatedStreamPipeOptions } from '../readable-stream/pipe-options';\n    3  import { type AbortSignal, isAbortSignal } from '../abort-signal';\n    4  \n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/validators/reader-options.d.ts:\n    1: <skipped 39 characters> ...eadOptions, ReadableStreamGetReaderOptions, ValidatedReadableStreamBYOBReaderReadOptions } from '../readable-stream/reader-options';\n    2  export declare function convertReaderOptions(options: ReadableStreamGetReaderOptions | null | undefined, context: string): ReadableStreamGetReaderOptions;\n    3  export declare function convertByobReadOptions(options: ReadableStreamBYOBReaderReadOptions | null | undefined, context: string): ValidatedReadableStreamBYOBReaderReadOptions;\n    4: //# sourceMappingURL=reader-options.d.ts.map\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/validators/pipe-options.d.ts:\n    1: import type { StreamPipeOptions, ValidatedStreamPipeOptions } from '../readable-stream/pipe-options';\n    2  export declare function convertPipeOptions(options: StreamPipeOptions | null | undefined, context: string): ValidatedStreamPipeOptions;\n    3  //# sourceMappingURL=pipe-options.d.ts.map\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/validators/readable-writable-pair.d.ts:\n    1: import { ReadableStream } from '../readable-stream';\n    2  import { WritableStream } from '../writable-stream';\n    3  export declare function convertReadableWritablePair<RS extends ReadableStream, WS extends WritableStream>(pair: {\n    4:     readable: RS;\n    5      writable: WS;\n    6  } | null | undefined, context: string): {\n    7:     readable: RS;\n    8      writable: WS;\n    9  };\n   10: //# sourceMappingURL=readable-writable-pair.d.ts.map\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/validators/transformer.js:\n    6      const cancel = original === null || original === void 0 ? void 0 : original.cancel;\n    7      const flush = original === null || original === void 0 ? void 0 : original.flush;\n    8:     const readableType = original === null || original === void 0 ? void 0 : original.readableType;\n    9      const start = original === null || original === void 0 ? void 0 : original.start;\n   10      const transform = original === null || original === void 0 ? void 0 : original.transform;\n   ..\n   17              ? undefined\n   18              : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\n   19:         readableType,\n   20          start: start === undefined\n   21              ? undefined\n\n~/Projects/plot-cv/quickjs/qjs-lws/tests/testharness.js:\n  445  \n  446  /**\n  447:  * Signal to the test environment that the tests are ready and the on-loaded\n  448   * callback should be run.\n  449   *\n  ...\n  453   *\n  454   * @param {Function} message_destination - a function that receives JSON-serializable\n  455:  * data to send to the incubating realm, in the same format as used by RemoteContext\n  456   */\n  457  ShadowRealmTestEnvironment.prototype.begin = function(message_destination) {\n  ...\n 1303  \n 1304  /**\n 1305:  * Convert a value to a nice, human-readable string\n 1306   *\n 1307   * When many JavaScript Object values are coerced to a String, the\n ....\n 1312   * representations of many kinds of objects, including arrays and\n 1313   * the more important DOM Node types. It also translates String\n 1314:  * values containing control characters to include human-readable\n 1315   * representations.\n 1316   *\n ....\n 1325   * format_value([-0, Infinity]);\n 1326   * @param {Any} val - The value to convert to a string.\n 1327:  * @returns {string} - A string representation of ``val``, optimised for human readability.\n 1328   */\n 1329  export function format_value(val, seen) {\n ....\n 1951  \n 1952  /**\n 1953:  * Assert that ``object`` has a property named ``property_name`` and that the property is readonly.\n 1954   *\n 1955   * Note: The implementation tries to update the named property, so\n ....\n 3752   * this more than once or in a non-Shadow Realm environment\n 3753   *\n 3754:  * @param {Function} postMessage - A function to send test updates to the\n 3755   * incubating realm-- accepts JSON-encoded messages in the format used by\n 3756   * RemoteContext\n ....\n 3909    let node = output_document.getElementById('log');\n 3910    if(!node) {\n 3911:     if(output_document.readyState === 'loading') {\n 3912        return;\n 3913      }\n\n~/Projects/plot-cv/quickjs/qjs-lws/doc/scripts/prettify/prettify.js:\n   17  j;var u=i.ownerDocument,v=u.createElement(\"SPAN\");v.className=d[a+1];var x=i.parentNode;x.replaceChi... <skipped 320 characters> ...o,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"],\n   18  \"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof\"],... <skipped 307 characters> ...lly,implements,import,instanceof,null,native,package,strictfp,super,synchronized,throws,transient\"],\n   19: <skipped 79 characters> ...h,from,group,implicit,in,interface,internal,into,is,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var\"],w=[w,\"debugg... <skipped 228 characters> ...\n   20  J=[v,\"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,r... <skipped 364 characters> ...cal,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END\"+\n   21  I,J,v],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),A={};k(O,[\"default-c... <skipped 306 characters> ...\"lang-css\",/^<style\\b[^>]*>([\\S\\s]*?)(<\\/style\\b[^>]*>)/i],[\"lang-in.tag\",/^(<\\/?[a-z][^<>]*>)/i]]),\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/fetch.js:\n    1: import { write, toString, toPointer, LWSContext, LWS_WRITE_HTTP_FINAL, LWS_WRITE_HTTP, LCCSCF_USE_SSL, LCCSCF_ALLO... <skipped 458 characters> ...\n    2  import { ReadableStream } from './lws/streams.js';\n    3  import { Headers } from './lws/headers.js';\n    .\n   26      new ReadableStream({\n   27        start(c) {\n   28:         controller.readable = c;\n   29        },\n   30      }),\n   ..\n   81              verbose('onClientHttpRedirect', wsi, url, status);\n   82              //globalThis.redir = url;\n   83:             //controller.readable.enqueue(url);\n   84  \n   85              const { headers } = wsi;\n   ..\n   99  \n  100              if(len !== undefined) {\n  101:               len += write('TEST\\r\\n', ab, len);\n  102                len += wsi.clientHttpMultipart('file', 'roman.txt', 'text/plain', ab, len);\n  103:               len += write('text file content\\r\\n\\r\\n', ab, len);\n  104                len += wsi.clientHttpMultipart(null, null, null, ab, len);\n  105  \n  106:               wsi.write(ab, len, LWS_WRITE_HTTP_FINAL);\n  107  \n  108                wsi.bodyPending = 0;\n  ...\n  110                console.log('clientHttpMultipart', { max_len: ab.byteLength, len, buf: toString(ab.slice(0, len ?? 0)) });\n  111              } else {\n  112:               wsi.write('TEST!\\r\\n');\n  113              }\n  114            },\n  115            onReceiveClientHttpRead(wsi, data) {\n  116              verbose('onReceiveClientHttpRead', wsi, data.byteLength);\n  117:             controller.readable.enqueue(new Uint8Array(data));\n  118            },\n  119            onReceiveClientHttp(wsi, buf, len) {\n  ...\n  132            onCompletedClientHttp(wsi) {\n  133              verbose('onCompletedClientHttp', wsi);\n  134:             controller.readable.close();\n  135            },\n  136            onClosedClientHttp(wsi) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/serve.js:\n  104            await waitWrite(wsi);\n  105  \n  106:           wsi.write(data);\n  107          },\n  108          onFilterHttpConnection(wsi, url) {\n  ...\n  132            obj.len = (obj.len ?? 0) + buf.byteLength;\n  133  \n  134:           Body.write(req, buf);\n  135          },\n  136          async onHttpBodyCompletion(wsi) {\n  ...\n  149            await waitWrite(wsi);\n  150  \n  151:           wsi.write(`Uploaded ${len} bytes\\r\\n`, LWS_WRITE_HTTP_FINAL);\n  152          },\n  153          onHttpWriteable(wsi) {\n  ...\n  184              await waitWrite(wsi);\n  185  \n  186:             wsi.write(`TEST\\r\\n`, LWS_WRITE_HTTP_FINAL);\n  187            }\n  188          },\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/websocket.js:\n   19        const protocols = Array.isArray(options_or_protocols) ? options_or_protocols : options_or_protocols?.protocols;\n   20  \n   21:       this.readyState = CONNECTING;\n   22  \n   23        this.#wsi = WebSocket.#create(this, options, ctx =>\n   ..\n   34    }\n   35  \n   36:   send(data) {\n   37:     return this.#wsi.write(data);\n   38    }\n   39  \n   ..\n   93  \n   94  define(WebSocket.prototype, { binaryType: 'arraybuffer' }, { writable: true });\n   95: define(WebSocket.prototype, { readyState: undefined }, { writable: true, enumerable: true });\n   96  \n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/tcpSocket.js:\n   28  \n   29      if((host || address) && port !== undefined) {\n   30:       this.readyState = CONNECTING;\n   31  \n   32        this.#wsi = TCPSocket.#create(this, ctx => ctx.clientConnect({ host, address, port, method: 'RAW', protocol: 'raw' }));\n   ..\n   51    }\n   52  \n   53:   send(data) {\n   54:     return this.#wsi.write(data);\n   55    }\n   56  \n   ..\n   75              const socket = new TCPSocket();\n   76              socket.#wsi = wsi;\n   77:             socket.readyState = OPEN;\n   78              act(wsi, actor(socket));\n   79              s.dispatchEvent({ type: 'accept', socket });\n   ..\n  113  \n  114  define(TCPSocket.prototype, { binaryType: 'arraybuffer' }, { writable: true });\n  115: define(TCPSocket.prototype, { readyState: undefined }, { writable: true, enumerable: true });\n  116  \n  117  /**\n  ...\n  134        /**\n  135         * A promise that resolves when the TCPSocket connection is opened. Among other features, this object contains a\n  136:        * ReadableStream and a WritableStream instance for receiving and sending data on the connection.\n  137         */\n  138        opened: new Promise((resolve, reject) => {\n  ...\n  143              localAddress: this.#sock.localAddress,\n  144              localPort: this.#sock.localPort,\n  145:             readable: new ReadableStream({\n  146                start: controller => {\n  147                  this.#sock.addEventListener('message', event => controller.enqueue(event.data));\n  ...\n  156              writable: new WritableStream({\n  157                start: controller => this.#sock.addEventListener('close', () => controller.error()),\n  158:               write: async chunk => {\n  159                  await ctor.waitWrite(this.#sock);\n  160  \n  161:                 return this.#sock.send(chunk);\n  162                },\n  163                close: () => this.#sock.close(),\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/websocketstream.js:\n   25        /**\n   26         * A promise that resolves when the WebSocket connection is opened. Among other features, this object contains a\n   27:        * ReadableStream and a WritableStream instance for receiving and sending data on the connection.\n   28         */\n   29        opened: new Promise((resolve, reject) => {\n   ..\n   32              extensions: this.#ws.extensions,\n   33              protocol: this.#ws.protocol,\n   34:             readable: new ReadableStream({\n   35                start: controller => {\n   36                  this.#ws.addEventListener('message', event => controller.enqueue(event.data));\n   ..\n   45              writable: new WritableStream({\n   46                start: controller => this.#ws.addEventListener('close', () => controller.error()),\n   47:               write: async chunk => {\n   48                  await ctor.waitWrite(this.#ws);\n   49  \n   50:                 return this.#ws.send(chunk);\n   51                },\n   52                close: () => this.#ws.close(),\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/lws/context.js:\n    1  import { CONTEXT_PORT_NO_LISTEN, LLL_ERR, LLL_WARN, LLL_USER, LWSContext, logLevel, getLogLevelName,... <skipped 259 characters> ...VER_OPTION_REDIRECT_HTTP_TO_HTTPS, LWS_SERVER_OPTION_ADOPT_APPLY_LISTEN_ACCEPT_CONFIG, } from 'lws';\n    2: import { existsSync, readFileSync } from 'fs';\n    3  \n    4  const { DEBUG, HOSTNAME } = process.env;\n    .\n   19    info.options ??= 0;\n   20    info.port ??= CONTEXT_PORT_NO_LISTEN;\n   21:   info.vhostName ??= HOSTNAME ?? readFileSync('/etc/hostname', 'utf-8')?.trimEnd();\n   22  \n   23:   if(empty(info.asyncDnsServers) && existsSync(resolvConf)) info.asyncDnsServers = [...readFileSync(resolvConf, 'utf-8').matchAll(/nameserver\\s+([\\w\\d.]+)/g)].map(m => m[1]);\n   24  \n   25    if(empty(info.asyncDnsServers)) info.asyncDnsServers = ['8.8.8.8', '8.8.4.4', '4.2.2.1'];\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/lws/body.js:\n    1  import { Blob } from 'blob';\n    2  import { ReadableStream } from './streams.js';\n    3: import { define, isPrototypeOf, isView, assign, readWholeStream, isAsyncIterable, isIterable, streamFromIterable } from './util.js';\n    4  \n    5  export class Body {\n    .\n   36          this,\n   37          {\n   38:           body: readableStreamCallback(streamFromIterable(stream), () => (this.bodyUsed = true)),\n   39          },\n   40          {},\n   ..\n   48     */\n   49    blob() {\n   50:     return readWholeStream(this.body).then(a => new Blob(a));\n   51    }\n   52  \n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/lws/util.js:\n   19  }\n   20  \n   21: /*export async function writeStream(wsi, stream) {\n   22    const rd = stream.getReader();\n   23    let result;\n   24  \n   25:   while((result = await rd.read())) {\n   26      const { value, done } = result;\n   27  \n   28      await waitWrite(wsi);\n   29:     let r = wsi.write(done ? '\\n' : value, done ? 1 : value.byteLength, done ? LWS_WRITE_HTTP_FINAL : LWS_WRITE_HTTP);\n   30      if(done) break;\n   31    }\n   ..\n   38   * @return {Array}               an Array of chunks.\n   39   */\n   40: export async function readWholeStream(st) {\n   41    const chunks = [];\n   42  \n   ..\n   50   * @returns {ArrayBuffer}         Data\n   51   */\n   52: export async function readStream(st) {\n   53    const rd = st.getReader();\n   54  \n   55:   const { value, done } = await rd.read();\n   56  \n   57    rd.releaseLock();\n   ..\n   64   * @param  {ArrayBuffer}    chunk  Data\n   65   */\n   66: export function writeStream(st, chunk) {\n   67:   if(chunk === undefined) return chunk => writeStream(st, chunk);\n   68  \n   69    const wr = st.getWriter();\n   ..\n   71    //if(wr.closed) throw new Error(`Stream closed`);\n   72  \n   73:   const result = wr.write(chunk);\n   74  \n   75    wr.releaseLock();\n   ..\n   82   * @param  {AsyncIterator}         Iterator\n   83   */\n   84: export function writeStreamIterator(st) {\n   85    return {\n   86      next: async chunk => {\n   87        try {\n   88:         return { done: false, value: await writeStream(st, chunk) };\n   89        } catch(error) {\n   90          return { done: true, error };\n   ..\n  121  /**\n  122   * @param  {AsyncIterable}   iterable\n  123:  * @return {ReadableStream}  A readable stream.\n  124   */\n  125  export function streamFromIterable(iterable) {\n  ...\n  152  /**\n  153   * @param  {ReadableStream}  st\n  154:  * @return {ReadableStream}  A readable stream.\n  155   */\n  156: export function readableStreamCallback(st, startCallback) {\n  157    return define(st, {\n  158:     getReader: wrapFunction(st.getReader, reader =>\n  159:       define(reader, {\n  160:         read: wrapFunction(reader.read, result => {\n  161            if(startCallback) {\n  162              startCallback();\n  ...\n  175  export function streamPipe() {\n  176    const obj = {};\n  177:   let writeController;\n  178  \n  179:   obj.readable = new ReadableStream({\n  180      start: controller =>\n  181        (obj.writable = new WritableStream({\n  182:         start: controller => (writeController = controller),\n  183:         write: chunk => controller.enqueue(chunk),\n  184          close: () => controller.close(),\n  185          abort: reason => controller.error(reason),\n  186        })),\n  187:     cancel: reason => writeController.error(reason),\n  188    });\n  189  \n  ...\n  277    return {\n  278      state(state) {\n  279:       ws.readyState = state;\n  280        if(log) log('actor.state', ws, ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'][state]);\n  281        return this;\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/lws/request.js:\n    9  \n   10      if(input instanceof Request) {\n   11:       if(input.bodyUsed) throw new TypeError('Already read');\n   12  \n   13        this.url = input.url;\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/lws/streams.js:\n  150  const ReleaseSteps = Symbol('[[ReleaseSteps]]');\n  151  \n  152: // src/lib/readable-stream/generic-reader.ts\n  153: function ReadableStreamReaderGenericInitialize(reader, stream) {\n  154:   assign(reader, { _ownerReadableStream: stream });\n  155:   assign(stream, { _reader: reader });\n  156:   if(stream._state == 'readable') {\n  157:     defaultReaderClosedPromiseInitialize(reader);\n  158    } else if(stream._state == 'closed') {\n  159:     defaultReaderClosedPromiseInitialize(reader);\n  160:     defaultReaderClosedPromiseResolve(reader);\n  161    } else {\n  162      assert(stream._state == 'errored');\n  163:     defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n  164    }\n  165  }\n  166  \n  167: function ReadableStreamReaderGenericCancel(reader, reason) {\n  168:   const stream = reader._ownerReadableStream;\n  169    assert(stream !== undefined);\n  170    return ReadableStreamCancel(stream, reason);\n  171  }\n  172  \n  173: function ReadableStreamReaderGenericRelease(reader) {\n  174:   const stream = reader._ownerReadableStream;\n  175    assert(stream !== undefined);\n  176:   assert(stream._reader === reader);\n  177:   if(stream._state == 'readable') {\n  178:     defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  179    } else {\n  180:     assert(reader._closedPromise_resolve === undefined);\n  181:     assert(reader._closedPromise_reject === undefined);\n  182:     defaultReaderClosedPromiseInitializeAsRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  183    }\n  184    stream._readableStreamController[ReleaseSteps]();\n  185    stream._reader = undefined;\n  186:   reader._ownerReadableStream = undefined;\n  187  }\n  188  \n  189: function readerLockException(name) {\n  190:   return new TypeError('Cannot ' + name + ' a stream using a released reader');\n  191  }\n  192  \n  193: function defaultReaderClosedPromiseInitialize(reader) {\n  194:   assign(reader, {\n  195      _closedPromise: newPromise((resolve, reject) => {\n  196:       assign(reader, { _closedPromise_resolve: resolve });\n  197:       assign(reader, { _closedPromise_reject: reject });\n  198      }),\n  199    });\n  200  }\n  201  \n  202: function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n  203:   defaultReaderClosedPromiseInitialize(reader);\n  204:   defaultReaderClosedPromiseReject(reader, reason);\n  205  }\n  206  \n  207: function defaultReaderClosedPromiseReject(reader, reason) {\n  208:   if(reader._closedPromise_reject === undefined) return;\n  209:   setPromiseIsHandledToTrue(reader._closedPromise);\n  210:   reader._closedPromise_reject(reason);\n  211:   reader._closedPromise_resolve = undefined;\n  212:   reader._closedPromise_reject = undefined;\n  213  }\n  214  \n  215: function defaultReaderClosedPromiseResolve(reader) {\n  216:   if(reader._closedPromise_resolve === undefined) return;\n  217:   reader._closedPromise_resolve(undefined);\n  218:   reader._closedPromise_resolve = undefined;\n  219:   reader._closedPromise_reject = undefined;\n  220  }\n  221  \n  222: // src/lib/validators/readable-stream.ts\n  223  function assertReadableStream(x, context) {\n  224    if(!IsReadableStream(x)) throw new TypeError(`${context} is not a ReadableStream.`);\n  225  }\n  226  \n  227: // src/lib/readable-stream/default-reader.ts\n  228  function AcquireReadableStreamDefaultReader(stream) {\n  229    return new ReadableStreamDefaultReader(stream);\n  230  }\n  231  \n  232: function ReadableStreamAddReadRequest(stream, readRequest) {\n  233    assert(IsReadableStreamDefaultReader(stream._reader));\n  234:   assert(stream._state == 'readable');\n  235:   stream._reader._readRequests.push(readRequest);\n  236  }\n  237  \n  238  function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n  239:   const reader = stream._reader;\n  240:   assert(reader._readRequests.length > 0);\n  241:   const readRequest = reader._readRequests.shift();\n  242:   if(done) readRequest._closeSteps();\n  243:   else readRequest._chunkSteps(chunk);\n  244  }\n  245  \n  ...\n  249  \n  250  function ReadableStreamHasDefaultReader(stream) {\n  251:   const reader = stream._reader;\n  252:   if(reader === undefined) return false;\n  253:   if(!IsReadableStreamDefaultReader(reader)) return false;\n  254    return true;\n  255  }\n  ...\n  259      assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');\n  260      assertReadableStream(stream, 'First parameter');\n  261:     if(IsReadableStreamLocked(stream)) throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n  262      ReadableStreamReaderGenericInitialize(this, stream);\n  263      assign(this, { _readRequests: new SimpleQueue() });\n  ...\n  266    /**\n  267     * Returns a promise that will be fulfilled when the stream becomes closed,\n  268:    * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n  269     */\n  270    get closed() {\n  ...\n  274  \n  275    /**\n  276:    * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n  277     */\n  278    cancel(reason = undefined) {\n  279      if(!IsReadableStreamDefaultReader(this)) return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n  280:     if(this._ownerReadableStream === undefined) return promiseRejectedWith(readerLockException('cancel'));\n  281      return ReadableStreamReaderGenericCancel(this, reason);\n  282    }\n  ...\n  285     * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n  286     *\n  287:    * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  288     */\n  289:   read() {\n  290:     if(!IsReadableStreamDefaultReader(this)) return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  291:     if(this._ownerReadableStream === undefined) return promiseRejectedWith(readerLockException('read from'));\n  292      let resolvePromise;\n  293      let rejectPromise;\n  ...\n  296        rejectPromise = reject;\n  297      });\n  298:     const readRequest = {\n  299        _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n  300        _closeSteps: () => resolvePromise({ value: undefined, done: true }),\n  301        _errorSteps: e => rejectPromise(e),\n  302      };\n  303:     ReadableStreamDefaultReaderRead(this, readRequest);\n  304      return promise;\n  305    }\n  306  \n  307    /**\n  308:    * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n  309:    * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n  310:    * from now on; otherwise, the reader will appear closed.\n  311     *\n  312:    * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  313:    * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  314:    * do so will throw a `TypeError` and leave the reader locked to the stream.\n  315     */\n  316    releaseLock() {\n  ...\n  325  /*Object.defineProperties(ReadableStreamDefaultReader.prototype, {\n  326    cancel: { enumerable: true },\n  327:   read: { enumerable: true },\n  328    releaseLock: { enumerable: true },\n  329    closed: { enumerable: true },\n  ...\n  331  \n  332  setFunctionName(ReadableStreamDefaultReader.prototype.cancel, 'cancel');\n  333: setFunctionName(ReadableStreamDefaultReader.prototype.read, 'read');\n  334  setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, 'releaseLock');\n  335  \n  ...\n  342  }\n  343  \n  344: function ReadableStreamDefaultReaderRead(reader, readRequest) {\n  345:   const stream = reader._ownerReadableStream;\n  346    assert(stream !== undefined);\n  347    stream._disturbed = true;\n  348    if(stream._state == 'closed') {\n  349:     readRequest._closeSteps();\n  350    } else if(stream._state == 'errored') {\n  351:     readRequest._errorSteps(stream._storedError);\n  352    } else {\n  353:     assert(stream._state == 'readable');\n  354:     stream._readableStreamController[PullSteps](readRequest);\n  355    }\n  356  }\n  357  \n  358: function ReadableStreamDefaultReaderErrorReadRequests(reader, e) {\n  359:   const readRequests = reader._readRequests;\n  360:   reader._readRequests = new SimpleQueue();\n  361:   readRequests.forEach(readRequest => readRequest._errorSteps(e));\n  362  }\n  363  \n  ...\n  481  }\n  482  \n  483: // src/lib/readable-stream/async-iterator.ts\n  484  export class ReadableStreamAsyncIteratorImpl {\n  485:   constructor(reader, preventCancel) {\n  486:     assign(this, { _ongoingPromise: undefined, _isFinished: false, _reader: reader, _preventCancel: preventCancel });\n  487    }\n  488  \n  ...\n  501    _nextSteps() {\n  502      if(this._isFinished) return Promise.resolve({ value: undefined, done: true });\n  503:     const reader = this._reader;\n  504:     assert(reader._ownerReadableStream !== undefined);\n  505      let resolvePromise;\n  506      let rejectPromise;\n  ...\n  509        rejectPromise = reject;\n  510      });\n  511:     const readRequest = {\n  512        _chunkSteps: chunk => {\n  513          this._ongoingPromise = undefined;\n  ...\n  517          this._ongoingPromise = undefined;\n  518          this._isFinished = true;\n  519:         ReadableStreamReaderGenericRelease(reader);\n  520          resolvePromise({ value: undefined, done: true });\n  521        },\n  ...\n  523          this._ongoingPromise = undefined;\n  524          this._isFinished = true;\n  525:         ReadableStreamReaderGenericRelease(reader);\n  526          rejectPromise(reason);\n  527        },\n  528      };\n  529:     ReadableStreamDefaultReaderRead(reader, readRequest);\n  530      return promise;\n  531    }\n  ...\n  534      if(this._isFinished) return Promise.resolve({ value, done: true });\n  535      this._isFinished = true;\n  536:     const reader = this._reader;\n  537:     assert(reader._ownerReadableStream !== undefined);\n  538:     assert(reader._readRequests.length === 0);\n  539      if(!this._preventCancel) {\n  540:       const result = ReadableStreamReaderGenericCancel(reader, value);\n  541:       ReadableStreamReaderGenericRelease(reader);\n  542        return transformPromiseWith(result, () => ({ value, done: true }));\n  543      }\n  544:     ReadableStreamReaderGenericRelease(reader);\n  545      return promiseResolvedWith({ value, done: true });\n  546    }\n  ...\n  568  \n  569  function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n  570:   const reader = AcquireReadableStreamDefaultReader(stream);\n  571:   const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n  572    const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n  573    iterator._asyncIteratorImpl = impl;\n  ...\n  649  }\n  650  \n  651: // src/lib/readable-stream/byte-stream-controller.ts\n  652  export class ReadableStreamBYOBRequest {\n  653    constructor() {\n  ...\n  718  \n  719    /**\n  720:    * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n  721:    * the stream, but once those are read, the stream will become closed.\n  722     */\n  723    close() {\n  ...\n  725      if(this._closeRequested) throw new TypeError('The stream has already been closed; do not close it again!');\n  726      const state = this._controlledReadableByteStream._state;\n  727:     if(state != 'readable') throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n  728      ReadableByteStreamControllerClose(this);\n  729    }\n  ...\n  737      if(this._closeRequested) throw new TypeError('stream is closed or draining');\n  738      const state = this._controlledReadableByteStream._state;\n  739:     if(state != 'readable') throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n  740      ReadableByteStreamControllerEnqueue(this, chunk);\n  741    }\n  742  \n  743    /**\n  744:    * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n  745     */\n  746    error(e = undefined) {\n  ...\n  759  \n  760    /** @internal */\n  761:   [PullSteps](readRequest) {\n  762      const stream = this._controlledReadableByteStream;\n  763      assert(ReadableStreamHasDefaultReader(stream));\n  764      if(this._queueTotalSize > 0) {\n  765        assert(ReadableStreamGetNumReadRequests(stream) === 0);\n  766:       ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);\n  767        return;\n  768      }\n  ...\n  773          buffer = new ArrayBuffer(autoAllocateChunkSize);\n  774        } catch(bufferE) {\n  775:         readRequest._errorSteps(bufferE);\n  776          return;\n  777        }\n  ...\n  785          elementSize: 1,\n  786          viewConstructor: Uint8Array,\n  787:         readerType: 'default',\n  788        };\n  789        this._pendingPullIntos.push(pullIntoDescriptor);\n  790      }\n  791:     ReadableStreamAddReadRequest(stream, readRequest);\n  792      ReadableByteStreamControllerCallPullIfNeeded(this);\n  793    }\n  ...\n  797      if(this._pendingPullIntos.length > 0) {\n  798        const firstPullInto = this._pendingPullIntos.peek();\n  799:       firstPullInto.readerType = 'none';\n  800        this._pendingPullIntos = new SimpleQueue();\n  801        this._pendingPullIntos.push(firstPullInto);\n  ...\n  832  function ReadableByteStreamControllerCallPullIfNeeded(controller) {\n  833    const stream = controller._controlledReadableByteStream;\n  834:   if(stream._state != 'readable') return false;\n  835    if(controller._closeRequested) return false;\n  836    if(!controller._started) return false;\n  ...\n  874  function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n  875    assert(stream._state != 'errored');\n  876:   assert(pullIntoDescriptor.readerType != 'none');\n  877    let done = false;\n  878    if(stream._state == 'closed') {\n  ...\n  882  \n  883    const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n  884:   if(pullIntoDescriptor.readerType == 'default') {\n  885      ReadableStreamFulfillReadRequest(stream, filledView, done);\n  886    } else {\n  887:     assert(pullIntoDescriptor.readerType == 'byob');\n  888  \n  889:     const reader = stream._reader;\n  890:     assert(reader._readIntoRequests.length > 0);\n  891:     const readIntoRequest = reader._readIntoRequests.shift();\n  892:     if(done) readIntoRequest._closeSteps(filledView);\n  893:     else readIntoRequest._chunkSteps(filledView);\n  894    }\n  895  }\n  ...\n  925  \n  926  function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {\n  927:   assert(firstDescriptor.readerType == 'none');\n  928    if(firstDescriptor.bytesFilled > 0) ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);\n  929    ReadableByteStreamControllerShiftPendingPullInto(controller);\n  ...\n  934    const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n  935    let totalBytesToCopyRemaining = maxBytesToCopy;\n  936:   let ready = false;\n  937    assert(!IsDetachedBuffer(pullIntoDescriptor.buffer));\n  938    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n  ...\n  941    if(maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n  942      totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n  943:     ready = true;\n  944    }\n  945  \n  ...\n  962    }\n  963  \n  964:   if(!ready) {\n  965      assert(controller._queueTotalSize === 0);\n  966      assert(pullIntoDescriptor.bytesFilled > 0);\n  ...\n  968    }\n  969  \n  970:   return ready;\n  971  }\n  972  \n  ...\n  978  \n  979  function ReadableByteStreamControllerHandleQueueDrain(controller) {\n  980:   assert(controller._controlledReadableByteStream._state == 'readable');\n  981    if(controller._queueTotalSize === 0 && controller._closeRequested) {\n  982      ReadableByteStreamControllerClearAlgorithms(controller);\n  ...\n 1000      if(controller._queueTotalSize === 0) break;\n 1001      const pullIntoDescriptor = controller._pendingPullIntos.peek();\n 1002:     assert(pullIntoDescriptor.readerType != 'none');\n 1003      if(ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n 1004        ReadableByteStreamControllerShiftPendingPullInto(controller);\n ....\n 1019  \n 1020      assert(firstDescriptor.bytesFilled % firstDescriptor.elementSize === 0);\n 1021:     if(firstDescriptor.readerType == 'none') ReadableByteStreamControllerShiftPendingPullInto(controller);\n 1022      const stream = controller._controlledReadableByteStream;\n 1023      if(ReadableStreamHasBYOBReader(stream)) {\n ....\n 1027      }\n 1028    } else {\n 1029:     assert(state == 'readable');\n 1030      assert(bytesWritten > 0);\n 1031  \n 1032      assert(firstDescriptor.bytesFilled + bytesWritten <= firstDescriptor.byteLength);\n 1033      ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, firstDescriptor);\n 1034:     if(firstDescriptor.readerType == 'none') {\n 1035        ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor);\n 1036        const filledPullIntos2 = ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n ....\n 1069  function ReadableByteStreamControllerClose(controller) {\n 1070    const stream = controller._controlledReadableByteStream;\n 1071:   if(controller._closeRequested || stream._state != 'readable') return;\n 1072    if(controller._queueTotalSize > 0) {\n 1073      controller._closeRequested = true;\n ....\n 1090  function ReadableByteStreamControllerEnqueue(controller, chunk) {\n 1091    const stream = controller._controlledReadableByteStream;\n 1092:   if(controller._closeRequested || stream._state != 'readable') return;\n 1093    const { buffer, byteOffset, byteLength } = chunk;\n 1094    if(IsDetachedBuffer(buffer)) throw new TypeError(\"chunk's buffer is detached and so cannot be enqueued\");\n ....\n 1099      ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n 1100      firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n 1101:     if(firstPendingPullInto.readerType == 'none') ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);\n 1102    }\n 1103  \n 1104    if(ReadableStreamHasDefaultReader(stream)) {\n 1105:     const reader = controller._controlledReadableByteStream._reader;\n 1106:     assert(IsReadableStreamDefaultReader(reader));\n 1107:     while(reader._readRequests.length > 0) {\n 1108        if(controller._queueTotalSize === 0) return;\n 1109:       const readRequest = reader._readRequests.shift();\n 1110:       ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);\n 1111      }\n 1112  \n ....\n 1117        assert(controller._queue.length === 0);\n 1118        if(controller._pendingPullIntos.length > 0) {\n 1119:         assert(controller._pendingPullIntos.peek().readerType == 'default');\n 1120          ReadableByteStreamControllerShiftPendingPullInto(controller);\n 1121        }\n ....\n 1137  function ReadableByteStreamControllerError(controller, e) {\n 1138    const stream = controller._controlledReadableByteStream;\n 1139:   if(stream._state != 'readable') return;\n 1140    ReadableByteStreamControllerClearPendingPullIntos(controller);\n 1141    ResetQueue(controller);\n ....\n 1144  }\n 1145  \n 1146: function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {\n 1147    assert(controller._queueTotalSize > 0);\n 1148    const entry = controller._queue.shift();\n ....\n 1150    ReadableByteStreamControllerHandleQueueDrain(controller);\n 1151    const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n 1152:   readRequest._chunkSteps(view);\n 1153  }\n 1154  \n ....\n 1186      if(bytesWritten !== 0) throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n 1187    } else {\n 1188:     assert(state == 'readable');\n 1189:     if(bytesWritten === 0) throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');\n 1190      if(firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) throw new RangeError('bytesWritten out of range');\n 1191    }\n ....\n 1203      if(view.byteLength !== 0) throw new TypeError(\"The view's length must be 0 when calling respondWithNewView() on a closed stream\");\n 1204    } else {\n 1205:     assert(state == 'readable');\n 1206: <skipped 31 characters> ...hrow new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");\n 1207    }\n 1208  \n ....\n 1261  }\n 1262  \n 1263: // src/lib/validators/reader-options.ts\n 1264  \n 1265  function convertReadableStreamReaderMode(mode, context) {\n ....\n 1269  }\n 1270  \n 1271: // src/lib/readable-stream/byob-reader.ts\n 1272  function AcquireReadableStreamBYOBReader(stream) {\n 1273    return new ReadableStreamBYOBReader(stream);\n 1274  }\n 1275  \n 1276: function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n 1277    assert(IsReadableStreamBYOBReader(stream._reader));\n 1278:   assert(stream._state == 'readable' || stream._state == 'closed');\n 1279:   stream._reader._readIntoRequests.push(readIntoRequest);\n 1280  }\n 1281  \n ....\n 1285  \n 1286  function ReadableStreamHasBYOBReader(stream) {\n 1287:   const reader = stream._reader;\n 1288:   if(reader === undefined) return false;\n 1289:   if(!IsReadableStreamBYOBReader(reader)) return false;\n 1290    return true;\n 1291  }\n ....\n 1295      assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');\n 1296      assertReadableStream(stream, 'First parameter');\n 1297:     if(IsReadableStreamLocked(stream)) throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n 1298      if(!IsReadableByteStreamController(stream._readableStreamController)) throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source');\n 1299      ReadableStreamReaderGenericInitialize(this, stream);\n ....\n 1303    /**\n 1304     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n 1305:    * the reader's lock is released before the stream finishes closing.\n 1306     */\n 1307    get closed() {\n ....\n 1311  \n 1312    /**\n 1313:    * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n 1314     */\n 1315    cancel(reason = undefined) {\n 1316      if(!IsReadableStreamBYOBReader(this)) return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n 1317:     if(this._ownerReadableStream === undefined) return promiseRejectedWith(readerLockException('cancel'));\n 1318      return ReadableStreamReaderGenericCancel(this, reason);\n 1319    }\n 1320  \n 1321:   read(view, rawOptions = {}) {\n 1322:     if(!IsReadableStreamBYOBReader(this)) return promiseRejectedWith(byobReaderBrandCheckException('read'));\n 1323      if(!ArrayBuffer.isView(view)) return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n 1324      if(view.byteLength === 0) return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n ....\n 1343        if(min > view.length) return promiseRejectedWith(new RangeError(\"options.min must be less than or equal to view's length\"));\n 1344        else if(min > view.byteLength) return promiseRejectedWith(new RangeError(\"options.min must be less than or equal to view's byteLength\"));\n 1345:     if(this._ownerReadableStream === undefined) return promiseRejectedWith(readerLockException('read from'));\n 1346      let resolvePromise;\n 1347      let rejectPromise;\n ....\n 1350        rejectPromise = reject;\n 1351      });\n 1352:     const readIntoRequest = {\n 1353        _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n 1354        _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n 1355        _errorSteps: e => rejectPromise(e),\n 1356      };\n 1357:     ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);\n 1358      return promise;\n 1359    }\n 1360  \n 1361    /**\n 1362:    * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n 1363:    * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n 1364:    * from now on; otherwise, the reader will appear closed.\n 1365     *\n 1366:    * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n 1367:    * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n 1368:    * do so will throw a `TypeError` and leave the reader locked to the stream.\n 1369     */\n 1370    releaseLock() {\n ....\n 1380  /*Object.defineProperties(ReadableStreamBYOBReader.prototype, {\n 1381    cancel: { enumerable: true },\n 1382:   read: { enumerable: true },\n 1383    releaseLock: { enumerable: true },\n 1384    closed: { enumerable: true },\n ....\n 1386  \n 1387  setFunctionName(ReadableStreamBYOBReader.prototype.cancel, 'cancel');\n 1388: setFunctionName(ReadableStreamBYOBReader.prototype.read, 'read');\n 1389  setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, 'releaseLock');\n 1390  \n ....\n 1397  }\n 1398  \n 1399: function ReadableStreamBYOBReaderRead(reader, view, min, readIntoRequest) {\n 1400:   const stream = reader._ownerReadableStream;\n 1401    assert(stream !== undefined);\n 1402    stream._disturbed = true;\n 1403:   if(stream._state == 'errored') readIntoRequest._errorSteps(stream._storedError);\n 1404    else {\n 1405      const ctor = view.constructor;\n ....\n 1413        buffer = TransferArrayBuffer(view.buffer);\n 1414      } catch(e) {\n 1415:       readIntoRequest._errorSteps(e);\n 1416        return;\n 1417      }\n ....\n 1426        elementSize,\n 1427        viewConstructor: ctor,\n 1428:       readerType: 'byob',\n 1429      };\n 1430      if(stream._readableStreamController._pendingPullIntos.length > 0) {\n 1431        stream._readableStreamController._pendingPullIntos.push(pullIntoDescriptor);\n 1432:       ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n 1433        return;\n 1434      }\n ....\n 1436      if(stream._state == 'closed') {\n 1437        const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n 1438:       readIntoRequest._closeSteps(emptyView);\n 1439        return;\n 1440      }\n ....\n 1444          const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n 1445          ReadableByteStreamControllerHandleQueueDrain(stream._readableStreamController);\n 1446:         readIntoRequest._chunkSteps(filledView);\n 1447          return;\n 1448        }\n ....\n 1450          const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n 1451          ReadableByteStreamControllerError(stream._readableStreamController, e);\n 1452:         readIntoRequest._errorSteps(e);\n 1453          return;\n 1454        }\n ....\n 1456  \n 1457      stream._readableStreamController._pendingPullIntos.push(pullIntoDescriptor);\n 1458:     ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n 1459      ReadableByteStreamControllerCallPullIfNeeded(stream._readableStreamController);\n 1460    }\n 1461  }\n 1462  \n 1463: function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e) {\n 1464:   const readIntoRequests = reader._readIntoRequests;\n 1465:   reader._readIntoRequests = new SimpleQueue();\n 1466:   readIntoRequests.forEach(readIntoRequest => readIntoRequest._errorSteps(e));\n 1467  }\n 1468  \n ....\n 1529        const start = original == null ? undefined : original.start;\n 1530        const type = original == null ? undefined : original.type;\n 1531:       const write = original == null ? undefined : original.write;\n 1532        return {\n 1533          abort: abort === undefined ? undefined : (assertFunction(abort, `${context} has member 'abort' that`), reason => promiseCall(abort, original, [reason])),\n 1534          close: close === undefined ? undefined : (assertFunction(close, `${context} has member 'close' that`), () => promiseCall(close, original, [])),\n 1535          start: start === undefined ? undefined : (assertFunction(start, `${context} has member 'start' that`), controller => reflectCall(start, original, [controller])),\n 1536:         write: write === undefined ? undefined : (assertFunction(write, `${context} has member 'write' that`), (chunk, controller) => promiseCall(write, original, [chunk, controller])),\n 1537          type,\n 1538        };\n ....\n 1546      const controller = Object.create(WritableStreamDefaultController.prototype);\n 1547      const startAlgorithm = underlyingSink.start !== undefined ? () => underlyingSink.start(controller) : () => undefined;\n 1548:     const writeAlgorithm = underlyingSink.write !== undefined ? chunk => underlyingSink.write(chunk, controller) : () => promiseResolvedWith(undefined);\n 1549      const closeAlgorithm = underlyingSink.close !== undefined ? () => underlyingSink.close() : () => promiseResolvedWith(undefined);\n 1550      const abortAlgorithm = underlyingSink.abort !== undefined ? reason => underlyingSink.abort(reason) : () => promiseResolvedWith(undefined);\n 1551:     SetUpWritableStreamDefaultController(this, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n 1552    }\n 1553  \n 1554    /**\n 1555:    * Returns whether or not the writable stream is locked to a writer.\n 1556     */\n 1557    get locked() {\n ....\n 1561  \n 1562    /**\n 1563:    * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n 1564:    * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n 1565     * mechanism of the underlying sink.\n 1566     *\n ....\n 1571    abort(reason = undefined) {\n 1572      if(!IsWritableStream(this)) return promiseRejectedWith(streamBrandCheckException('abort'));\n 1573:     if(IsWritableStreamLocked(this)) return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n 1574      return WritableStreamAbort(this, reason);\n 1575    }\n ....\n 1577    /**\n 1578     * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n 1579:    * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n 1580     *\n 1581     * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n ....\n 1585    close() {\n 1586      if(!IsWritableStream(this)) return promiseRejectedWith(streamBrandCheckException('close'));\n 1587:     if(IsWritableStreamLocked(this)) return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n 1588      if(WritableStreamCloseQueuedOrInFlight(this)) return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n 1589      return WritableStreamClose(this);\n ....\n 1591  \n 1592    /**\n 1593:    * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n 1594:    * is locked, no other writer can be acquired until this one is released.\n 1595     *\n 1596:    * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n 1597:    * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n 1598     * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n 1599     */\n ....\n 1636  }\n 1637  \n 1638: function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n 1639    assert(IsNonNegativeNumber(highWaterMark));\n 1640    const stream = Object.create(WritableStream.prototype);\n 1641    InitializeWritableStream(stream);\n 1642    const controller = Object.create(WritableStreamDefaultController.prototype);\n 1643:   SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n 1644    return stream;\n 1645  }\n ....\n 1698      stream._closeRequest = closeRequest;\n 1699    });\n 1700:   const writer = stream._writer;\n 1701:   if(writer !== undefined && stream._backpressure && state == 'writable') defaultWriterReadyPromiseResolve(writer);\n 1702  \n 1703    EnqueueValueWithSize(stream._writableStreamController, closeSentinel, 0);\n ....\n 1725    stream._state = 'erroring';\n 1726    stream._storedError = reason;\n 1727:   const writer = stream._writer;\n 1728:   if(writer !== undefined) WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n 1729    if(!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) WritableStreamFinishErroring(stream);\n 1730  }\n ....\n 1736    stream._writableStreamController[ErrorSteps]();\n 1737    const storedError = stream._storedError;\n 1738:   stream._writeRequests.forEach(writeRequest => writeRequest._reject(storedError));\n 1739    stream._writeRequests = new SimpleQueue();\n 1740    if(stream._pendingAbortRequest === undefined) {\n ....\n 1785    }\n 1786  \n 1787:   const writer = stream._writer;\n 1788:   if(writer !== undefined) defaultWriterClosedPromiseReject(writer, stream._storedError);\n 1789  }\n 1790  \n ....\n 1792    assert(stream._state == 'writable');\n 1793    assert(!WritableStreamCloseQueuedOrInFlight(stream));\n 1794:   const writer = stream._writer;\n 1795:   if(writer !== undefined && backpressure !== stream._backpressure) {\n 1796      if(backpressure) {\n 1797:       assert(writer._readyPromise_resolve === undefined);\n 1798:       assert(writer._readyPromise_reject === undefined);\n 1799:       defaultWriterReadyPromiseInitialize(writer);\n 1800      } else {\n 1801        assert(!backpressure);\n 1802:       defaultWriterReadyPromiseResolve(writer);\n 1803      }\n 1804    }\n ....\n 1811      assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');\n 1812      assertWritableStream(stream, 'First parameter');\n 1813: <skipped 29 characters> ...(stream)) throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n 1814      assign(this, { _ownerWritableStream: stream });\n 1815      assign(stream, { _writer: this });\n ....\n 1837    /**\n 1838     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n 1839:    * the writerâ€™s lock is released before the stream finishes closing.\n 1840     */\n 1841    get closed() {\n ....\n 1846    /**\n 1847     * Returns the desired size to fill the streamâ€™s internal queue. It can be negative, if the queue is over-full.\n 1848:    * A producer can use this information to determine the right amount of data to write.\n 1849     *\n 1850     * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n 1851     * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n 1852:    * the writerâ€™s lock is released.\n 1853     */\n 1854    get desiredSize() {\n ....\n 1868     * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n 1869     *\n 1870:    * If the stream becomes errored or aborted, or the writerâ€™s lock is released, the returned promise will become\n 1871     * rejected.\n 1872     */\n 1873:   get ready() {\n 1874:     if(!IsWritableStreamDefaultWriter(this)) return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n 1875      return this._readyPromise;\n 1876    }\n 1877  \n 1878    /**\n 1879:    * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n 1880     */\n 1881    abort(reason = undefined) {\n ....\n 1889  \n 1890    /**\n 1891:    * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n 1892     */\n 1893    close() {\n ....\n 1900  \n 1901    /**\n 1902:    * Releases the writerâ€™s lock on the corresponding stream. After the lock is released, the writer is no longer active.\n 1903:    * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n 1904:    * now on; otherwise, the writer will appear closed.\n 1905     *\n 1906:    * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n 1907:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n 1908:    * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n 1909     * other producers from writing in an interleaved manner.\n 1910     */\n ....\n 1917    }\n 1918  \n 1919:   write(chunk = undefined) {\n 1920:     if(!IsWritableStreamDefaultWriter(this)) return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n 1921:     if(this._ownerWritableStream === undefined) return promiseRejectedWith(defaultWriterLockException('write to'));\n 1922      return WritableStreamDefaultWriterWrite(this, chunk);\n 1923    }\n ....\n 1928    close: { enumerable: true },\n 1929    releaseLock: { enumerable: true },\n 1930:   write: { enumerable: true },\n 1931    closed: { enumerable: true },\n 1932    desiredSize: { enumerable: true },\n 1933:   ready: { enumerable: true },\n 1934  });*/\n 1935  \n ....\n 1937  setFunctionName(WritableStreamDefaultWriter.prototype.close, 'close');\n 1938  setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, 'releaseLock');\n 1939: setFunctionName(WritableStreamDefaultWriter.prototype.write, 'write');\n 1940  \n 1941  define(WritableStreamDefaultWriter.prototype, { [Symbol.toStringTag]: 'WritableStreamDefaultWriter' });\n ....\n 1947  }\n 1948  \n 1949: function WritableStreamDefaultWriterClose(writer) {\n 1950:   const stream = writer._ownerWritableStream;\n 1951    assert(stream !== undefined);\n 1952    return WritableStreamClose(stream);\n 1953  }\n 1954  \n 1955: function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n 1956:   if(writer._readyPromiseState == 'pending') {\n 1957:     defaultWriterReadyPromiseReject(writer, error);\n 1958    } else {\n 1959:     assert(writer._readyPromise_resolve === undefined);\n 1960:     assert(writer._readyPromise_reject === undefined);\n 1961:     defaultWriterReadyPromiseInitializeAsRejected(writer, error);\n 1962    }\n 1963  }\n 1964  \n 1965: function WritableStreamDefaultWriterRelease(writer) {\n 1966:   const stream = writer._ownerWritableStream;\n 1967    assert(stream !== undefined);\n 1968:   assert(stream._writer === writer);\n 1969    const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n 1970:   WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n 1971  \n 1972:   if(writer._closedPromiseState == 'pending') defaultWriterClosedPromiseReject(writer, releasedError);\n 1973    else {\n 1974:     assert(writer._closedPromise_resolve === undefined);\n 1975:     assert(writer._closedPromise_reject === undefined);\n 1976:     assert(writer._closedPromiseState != 'pending');\n 1977:     defaultWriterClosedPromiseInitializeAsRejected(writer, releasedError);\n 1978    }\n 1979  \n 1980    stream._writer = undefined;\n 1981:   writer._ownerWritableStream = undefined;\n 1982  }\n 1983  \n 1984: function WritableStreamDefaultWriterWrite(writer, chunk) {\n 1985:   const stream = writer._ownerWritableStream;\n 1986    assert(stream !== undefined);\n 1987    const controller = stream._writableStreamController;\n ....\n 2000    }\n 2001  \n 2002:   if(stream !== writer._ownerWritableStream) return promiseRejectedWith(defaultWriterLockException('write to'));\n 2003    const state = stream._state;\n 2004    if(state == 'errored') return promiseRejectedWith(stream._storedError);\n ....\n 2052  \n 2053    /**\n 2054:    * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n 2055     */\n 2056    get signal() {\n ....\n 2101  }\n 2102  \n 2103: function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n 2104    assert(IsWritableStream(stream));\n 2105    assert(stream._writableStreamController === undefined);\n ....\n 2114    controller._strategySizeAlgorithm = sizeAlgorithm;\n 2115    controller._strategyHWM = highWaterMark;\n 2116:   controller._writeAlgorithm = writeAlgorithm;\n 2117    controller._closeAlgorithm = closeAlgorithm;\n 2118    controller._abortAlgorithm = abortAlgorithm;\n ....\n 2194  \n 2195          stream._state = 'closed';\n 2196:         const writer = stream._writer;\n 2197:         if(writer !== undefined) defaultWriterClosedPromiseResolve(writer);\n 2198          assert(stream._pendingAbortRequest === undefined);\n 2199          assert(stream._storedError === undefined);\n ....\n 2282  \n 2283  function defaultWriterLockException(name) {\n 2284:   return new TypeError('Cannot ' + name + ' a stream using a released writer');\n 2285  }\n 2286  \n 2287: function defaultWriterClosedPromiseInitialize(writer) {\n 2288:   assign(writer, {\n 2289      _closedPromise: newPromise((resolve, reject) => {\n 2290:       assign(writer, { _closedPromise_resolve: resolve });\n 2291:       assign(writer, { _closedPromise_reject: reject });\n 2292:       assign(writer, { _closedPromiseState: 'pending' });\n 2293      }),\n 2294    });\n 2295  }\n 2296  \n 2297: function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n 2298:   defaultWriterClosedPromiseInitialize(writer);\n 2299:   defaultWriterClosedPromiseReject(writer, reason);\n 2300  }\n 2301  \n 2302: function defaultWriterClosedPromiseReject(writer, reason) {\n 2303:   if(writer._closedPromise_reject === undefined) return;\n 2304:   assert(writer._closedPromiseState == 'pending');\n 2305:   setPromiseIsHandledToTrue(writer._closedPromise);\n 2306:   writer._closedPromise_reject(reason);\n 2307:   writer._closedPromise_resolve = undefined;\n 2308:   writer._closedPromise_reject = undefined;\n 2309:   writer._closedPromiseState = 'rejected';\n 2310  }\n 2311  \n 2312: function defaultWriterClosedPromiseResolve(writer) {\n 2313:   if(writer._closedPromise_resolve === undefined) return;\n 2314:   assert(writer._closedPromiseState == 'pending');\n 2315:   writer._closedPromise_resolve(undefined);\n 2316:   writer._closedPromise_resolve = undefined;\n 2317:   writer._closedPromise_reject = undefined;\n 2318:   writer._closedPromiseState = 'resolved';\n 2319  }\n 2320  \n 2321: function defaultWriterReadyPromiseInitialize(writer) {\n 2322:   assign(writer, {\n 2323:     _readyPromise: newPromise((resolve, reject) => assign(writer, { _readyPromise_resolve: resolve, _readyPromise_reject: reject })),\n 2324      _readyPromiseState: 'pending',\n 2325    });\n 2326  }\n 2327  \n 2328: function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n 2329:   defaultWriterReadyPromiseInitialize(writer);\n 2330:   defaultWriterReadyPromiseReject(writer, reason);\n 2331  }\n 2332  \n 2333: function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n 2334:   defaultWriterReadyPromiseInitialize(writer);\n 2335:   defaultWriterReadyPromiseResolve(writer);\n 2336  }\n 2337  \n 2338: function defaultWriterReadyPromiseReject(writer, reason) {\n 2339:   if(writer._readyPromise_reject === undefined) return;\n 2340:   setPromiseIsHandledToTrue(writer._readyPromise);\n 2341:   writer._readyPromise_reject(reason);\n 2342:   writer._readyPromise_resolve = undefined;\n 2343:   writer._readyPromise_reject = undefined;\n 2344:   writer._readyPromiseState = 'rejected';\n 2345  }\n 2346  \n 2347: function defaultWriterReadyPromiseResolve(writer) {\n 2348:   if(writer._readyPromise_resolve === undefined) return;\n 2349:   writer._readyPromise_resolve(undefined);\n 2350:   writer._readyPromise_resolve = undefined;\n 2351:   writer._readyPromise_reject = undefined;\n 2352:   writer._readyPromiseState = 'fulfilled';\n 2353  }\n 2354  \n ....\n 2395  const DOMException = getFromGlobal() ?? createPolyfill();\n 2396  \n 2397: // src/lib/readable-stream/pipe.ts\n 2398  function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n 2399    assert(IsReadableStream(source));\n ....\n 2405    assert(!IsReadableStreamLocked(source));\n 2406    assert(!IsWritableStreamLocked(dest));\n 2407:   const reader = AcquireReadableStreamDefaultReader(source);\n 2408:   const writer = AcquireWritableStreamDefaultWriter(dest);\n 2409    source._disturbed = true;\n 2410    let shuttingDown = false;\n ....\n 2424          if(!preventCancel) {\n 2425            actions.push(() => {\n 2426:             if(source._state == 'readable') return ReadableStreamCancel(source, error);\n 2427              return promiseResolvedWith(undefined);\n 2428            });\n ....\n 2447      function pipeStep() {\n 2448        if(shuttingDown) return promiseResolvedWith(true);\n 2449:       return PerformPromiseThen(writer._readyPromise, () => {\n 2450          return newPromise((resolveRead, rejectRead) => {\n 2451:           ReadableStreamDefaultReaderRead(reader, {\n 2452              _chunkSteps: chunk => {\n 2453:               currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n 2454                resolveRead(false);\n 2455              },\n ....\n 2460        });\n 2461      }\n 2462:     isOrBecomesErrored(source, reader._closedPromise, storedError => {\n 2463        if(!preventAbort) shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n 2464        else shutdown(true, storedError);\n 2465        return null;\n 2466      });\n 2467:     isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n 2468        if(!preventCancel) shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n 2469        else shutdown(true, storedError);\n 2470        return null;\n 2471      });\n 2472:     isOrBecomesClosed(source, reader._closedPromise, () => {\n 2473        if(!preventClose)\n 2474          shutdownWithAction(() => {\n 2475:           const stream = writer._ownerWritableStream;\n 2476            assert(stream !== undefined);\n 2477            const state = stream._state;\n ....\n 2479            if(state == 'errored') return promiseRejectedWith(stream._storedError);\n 2480            assert(state == 'writable' || state == 'erroring');\n 2481:           return WritableStreamDefaultWriterClose(writer);\n 2482          });\n 2483        else shutdown();\n ....\n 2523      }\n 2524      function finalize(isError, error) {\n 2525:       WritableStreamDefaultWriterRelease(writer);\n 2526:       ReadableStreamReaderGenericRelease(reader);\n 2527        if(signal !== undefined) signal.removeEventListener('abort', abortAlgorithm);\n 2528        if(isError) reject(error);\n ....\n 2533  }\n 2534  \n 2535: // src/lib/readable-stream/default-controller.ts\n 2536  export class ReadableStreamDefaultController {\n 2537    constructor() {\n ....\n 2549  \n 2550    /**\n 2551:    * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n 2552:    * the stream, but once those are read, the stream will become closed.\n 2553     */\n 2554    close() {\n ....\n 2565  \n 2566    /**\n 2567:    * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n 2568     */\n 2569    error(e = undefined) {\n ....\n 2581  \n 2582    /** @internal */\n 2583:   [PullSteps](readRequest) {\n 2584      const stream = this._controlledReadableStream;\n 2585      if(this._queue.length > 0) {\n ....\n 2591          ReadableStreamDefaultControllerCallPullIfNeeded(this);\n 2592        }\n 2593:       readRequest._chunkSteps(chunk);\n 2594      } else {\n 2595:       ReadableStreamAddReadRequest(stream, readRequest);\n 2596        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n 2597      }\n ....\n 2701  function ReadableStreamDefaultControllerError(controller, e) {\n 2702    const stream = controller._controlledReadableStream;\n 2703:   if(stream._state != 'readable') return;\n 2704    ResetQueue(controller);\n 2705    ReadableStreamDefaultControllerClearAlgorithms(controller);\n ....\n 2720  function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n 2721    const state = controller._controlledReadableStream._state;\n 2722:   if(!controller._closeRequested && state == 'readable') return true;\n 2723    return false;\n 2724  }\n ....\n 2760  }\n 2761  \n 2762: // src/lib/readable-stream/tee.ts\n 2763  \n 2764  function ReadableStreamDefaultTee(stream, cloneForBranch2) {\n 2765    assert(IsReadableStream(stream));\n 2766    assert(typeof cloneForBranch2 == 'boolean');\n 2767:   const reader = AcquireReadableStreamDefaultReader(stream);\n 2768:   let reading = false;\n 2769:   let readAgain = false;\n 2770    let canceled1 = false;\n 2771    let canceled2 = false;\n ....\n 2777    const cancelPromise = newPromise(resolve => (resolveCancelPromise = resolve));\n 2778    function pullAlgorithm() {\n 2779:     if(reading) {\n 2780:       readAgain = true;\n 2781        return promiseResolvedWith(undefined);\n 2782      }\n 2783:     reading = true;\n 2784:     const readRequest = {\n 2785        _chunkSteps: chunk => {\n 2786          _queueMicrotask(() => {\n 2787:           readAgain = false;\n 2788            const chunk1 = chunk;\n 2789            const chunk2 = chunk;\n 2790            if(!canceled1) ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);\n 2791            if(!canceled2) ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n 2792:           reading = false;\n 2793:           if(readAgain) pullAlgorithm();\n 2794          });\n 2795        },\n 2796        _closeSteps: () => {\n 2797:         reading = false;\n 2798          if(!canceled1) ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n 2799          if(!canceled2) ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n 2800          if(!canceled1 || !canceled2) resolveCancelPromise(undefined);\n 2801        },\n 2802:       _errorSteps: () => (reading = false),\n 2803      };\n 2804:     ReadableStreamDefaultReaderRead(reader, readRequest);\n 2805      return promiseResolvedWith(undefined);\n 2806    }\n ....\n 2831    branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n 2832    branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n 2833:   uponRejection(reader._closedPromise, r => {\n 2834      ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n 2835      ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n ....\n 2843    assert(IsReadableStream(stream));\n 2844    assert(IsReadableByteStreamController(stream._readableStreamController));\n 2845:   let reader = AcquireReadableStreamDefaultReader(stream);\n 2846:   let reading = false;\n 2847:   let readAgainForBranch1 = false;\n 2848:   let readAgainForBranch2 = false;\n 2849    let canceled1 = false;\n 2850    let canceled2 = false;\n ....\n 2857    function forwardReaderError(thisReader) {\n 2858      uponRejection(thisReader._closedPromise, r => {\n 2859:       if(thisReader !== reader) return null;\n 2860        ReadableByteStreamControllerError(branch1._readableStreamController, r);\n 2861        ReadableByteStreamControllerError(branch2._readableStreamController, r);\n ....\n 2866  \n 2867    function pullWithDefaultReader() {\n 2868:     if(IsReadableStreamBYOBReader(reader)) {\n 2869:       assert(reader._readIntoRequests.length === 0);\n 2870:       ReadableStreamReaderGenericRelease(reader);\n 2871:       reader = AcquireReadableStreamDefaultReader(stream);\n 2872:       forwardReaderError(reader);\n 2873      }\n 2874:     const readRequest = {\n 2875        _chunkSteps: chunk => {\n 2876          _queueMicrotask(() => {\n 2877:           readAgainForBranch1 = false;\n 2878:           readAgainForBranch2 = false;\n 2879            const chunk1 = chunk;\n 2880            let chunk2 = chunk;\n ....\n 2891            if(!canceled1) ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n 2892            if(!canceled2) ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n 2893:           reading = false;\n 2894:           if(readAgainForBranch1) pull1Algorithm();\n 2895:           else if(readAgainForBranch2) pull2Algorithm();\n 2896          });\n 2897        },\n 2898        _closeSteps: () => {\n 2899:         reading = false;\n 2900          if(!canceled1) ReadableByteStreamControllerClose(branch1._readableStreamController);\n 2901          if(!canceled2) ReadableByteStreamControllerClose(branch2._readableStreamController);\n ....\n 2904          if(!canceled1 || !canceled2) resolveCancelPromise(undefined);\n 2905        },\n 2906:       _errorSteps: () => (reading = false),\n 2907      };\n 2908:     ReadableStreamDefaultReaderRead(reader, readRequest);\n 2909    }\n 2910  \n 2911    function pullWithBYOBReader(view, forBranch2) {\n 2912:     if(IsReadableStreamDefaultReader(reader)) {\n 2913:       assert(reader._readRequests.length === 0);\n 2914:       ReadableStreamReaderGenericRelease(reader);\n 2915:       reader = AcquireReadableStreamBYOBReader(stream);\n 2916:       forwardReaderError(reader);\n 2917      }\n 2918      const byobBranch = forBranch2 ? branch2 : branch1;\n 2919      const otherBranch = forBranch2 ? branch1 : branch2;\n 2920:     const readIntoRequest = {\n 2921        _chunkSteps: chunk => {\n 2922          _queueMicrotask(() => {\n 2923:           readAgainForBranch1 = false;\n 2924:           readAgainForBranch2 = false;\n 2925            const byobCanceled = forBranch2 ? canceled2 : canceled1;\n 2926            const otherCanceled = forBranch2 ? canceled1 : canceled2;\n ....\n 2940              ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n 2941            }\n 2942:           reading = false;\n 2943:           if(readAgainForBranch1) pull1Algorithm();\n 2944:           else if(readAgainForBranch2) pull2Algorithm();\n 2945          });\n 2946        },\n 2947        _closeSteps: chunk => {\n 2948:         reading = false;\n 2949          const byobCanceled = forBranch2 ? canceled2 : canceled1;\n 2950          const otherCanceled = forBranch2 ? canceled1 : canceled2;\n ....\n 2958          if(!byobCanceled || !otherCanceled) resolveCancelPromise(undefined);\n 2959        },\n 2960:       _errorSteps: () => (reading = false),\n 2961      };\n 2962:     ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);\n 2963    }\n 2964  \n 2965    function pull1Algorithm() {\n 2966:     if(reading) {\n 2967:       readAgainForBranch1 = true;\n 2968        return promiseResolvedWith(undefined);\n 2969      }\n 2970:     reading = true;\n 2971      const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n 2972      if(byobRequest === null) pullWithDefaultReader();\n ....\n 2976  \n 2977    function pull2Algorithm() {\n 2978:     if(reading) {\n 2979:       readAgainForBranch2 = true;\n 2980        return promiseResolvedWith(undefined);\n 2981      }\n 2982:     reading = true;\n 2983      const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n 2984      if(byobRequest === null) pullWithDefaultReader();\n ....\n 3015    branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n 3016    branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n 3017:   forwardReaderError(reader);\n 3018    return [branch1, branch2];\n 3019  }\n ....\n 3047  }\n 3048  \n 3049: // src/lib/readable-stream.ts\n 3050  export class ReadableStream {\n 3051    constructor(rawUnderlyingSource = {}, rawStrategy = {}) {\n ....\n 3097  \n 3098    /**\n 3099:    * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n 3100     */\n 3101    get locked() {\n ....\n 3112    cancel(reason = undefined) {\n 3113      if(!IsReadableStream(this)) return promiseRejectedWith(streamBrandCheckException2('cancel'));\n 3114:     if(IsReadableStreamLocked(this)) return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n 3115      return ReadableStreamCancel(this, reason);\n 3116    }\n ....\n 3135      const transform = ((pair, context) => {\n 3136        assertDictionary(pair, context);\n 3137:       const readable = pair == null ? undefined : pair.readable;\n 3138:       assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n 3139:       assertReadableStream(readable, `${context} has member 'readable' that`);\n 3140        const writable = pair == null ? undefined : pair.writable;\n 3141        assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n 3142        assertWritableStream(writable, `${context} has member 'writable' that`);\n 3143:       return { readable, writable };\n 3144      })(rawTransform, 'First parameter');\n 3145      const options = convertPipeOptions(rawOptions, 'Second parameter');\n ....\n 3148      const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n 3149      setPromiseIsHandledToTrue(promise);\n 3150:     return transform.readable;\n 3151    }\n 3152  \n ....\n 3167  \n 3168    /**\n 3169:    * Tees this readable stream, returning a two-element array containing the two resulting branches as\n 3170     * new {@link ReadableStream} instances.\n 3171     *\n 3172:    * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n 3173     * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n 3174     * propagated to the stream's underlying source.\n ....\n 3199      })(rawOptions, 'First parameter');\n 3200  \n 3201:     const reader = AcquireReadableStreamDefaultReader(this);\n 3202:     const impl = new ReadableStreamAsyncIteratorImpl(reader, options.preventCancel);\n 3203      const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n 3204      iterator._asyncIteratorImpl = impl;\n ....\n 3213     * Creates a new ReadableStream wrapping the provided iterable or async iterable.\n 3214     *\n 3215:    * This can be used to adapt various kinds of objects into a readable stream,\n 3216:    * such as an array, an async generator, or a Node.js readable stream.\n 3217     */\n 3218    static from(asyncIterable) {\n 3219      if(typeIsObject(asyncIterable) && typeof asyncIterable.getReader != 'undefined') {\n 3220:       const reader = asyncIterable.getReader();\n 3221  \n 3222        let stream;\n 3223        const startAlgorithm = noop;\n 3224        function pullAlgorithm() {\n 3225:         let readPromise;\n 3226          try {\n 3227:           readPromise = reader.read();\n 3228          } catch(e) {\n 3229            return promiseRejectedWith(e);\n 3230          }\n 3231:         return transformPromiseWith(readPromise, readResult => {\n 3232:           if(!typeIsObject(readResult)) throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\n 3233:           if(readResult.done) {\n 3234              ReadableStreamDefaultControllerClose(stream._readableStreamController);\n 3235            } else {\n 3236:             const value = readResult.value;\n 3237              ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\n 3238            }\n ....\n 3242        function cancelAlgorithm(reason) {\n 3243          try {\n 3244:           return promiseResolvedWith(reader.cancel(reason));\n 3245          } catch(e) {\n 3246            return promiseRejectedWith(e);\n ....\n 3345  \n 3346  function InitializeReadableStream(stream) {\n 3347:   assign(stream, { _state: 'readable', _reader: undefined, _storedError: undefined, _disturbed: false });\n 3348  }\n 3349  \n ....\n 3365    if(stream._state == 'errored') return promiseRejectedWith(stream._storedError);\n 3366    ReadableStreamClose(stream);\n 3367:   const reader = stream._reader;\n 3368:   if(reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n 3369:     const readIntoRequests = reader._readIntoRequests;\n 3370:     reader._readIntoRequests = new SimpleQueue();\n 3371:     readIntoRequests.forEach(readIntoRequest => readIntoRequest._closeSteps(undefined));\n 3372    }\n 3373  \n ....\n 3377  \n 3378  function ReadableStreamClose(stream) {\n 3379:   assert(stream._state == 'readable');\n 3380    stream._state = 'closed';\n 3381:   const reader = stream._reader;\n 3382:   if(reader === undefined) return;\n 3383:   defaultReaderClosedPromiseResolve(reader);\n 3384:   if(IsReadableStreamDefaultReader(reader)) {\n 3385:     const readRequests = reader._readRequests;\n 3386:     reader._readRequests = new SimpleQueue();\n 3387:     readRequests.forEach(readRequest => readRequest._closeSteps());\n 3388    }\n 3389  }\n ....\n 3391  function ReadableStreamError(stream, e) {\n 3392    assert(IsReadableStream(stream));\n 3393:   assert(stream._state == 'readable');\n 3394    stream._state = 'errored';\n 3395    stream._storedError = e;\n 3396:   const reader = stream._reader;\n 3397:   if(reader === undefined) return;\n 3398:   defaultReaderClosedPromiseReject(reader, e);\n 3399:   if(IsReadableStreamDefaultReader(reader)) {\n 3400:     ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n 3401    } else {\n 3402:     assert(IsReadableStreamBYOBReader(reader));\n 3403:     ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n 3404    }\n 3405  }\n ....\n 3517      if(rawTransformer === undefined) rawTransformer = null;\n 3518      const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n 3519:     const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n 3520      const transformer = ((original, context) => {\n 3521        assertDictionary(original, context);\n 3522        const cancel = original == null ? undefined : original.cancel;\n 3523        const flush = original == null ? undefined : original.flush;\n 3524:       const readableType = original == null ? undefined : original.readableType;\n 3525        const start = original == null ? undefined : original.start;\n 3526        const transform = original == null ? undefined : original.transform;\n ....\n 3529          cancel: cancel === undefined ? undefined : (assertFunction(cancel, `${context} has member 'cancel' that`), reason => promiseCall(cancel, original, [reason])),\n 3530          flush: flush === undefined ? undefined : (assertFunction(flush, `${context} has member 'flush' that`), controller => promiseCall(flush, original, [controller])),\n 3531:         readableType,\n 3532          start: start === undefined ? undefined : (assertFunction(start, `${context} has member 'start' that`), controller => reflectCall(start, original, [controller])),\n 3533          transform:\n ....\n 3536        };\n 3537      })(rawTransformer, 'First parameter');\n 3538:     if(transformer.readableType !== undefined) throw new RangeError('Invalid readableType specified');\n 3539      if(transformer.writableType !== undefined) throw new RangeError('Invalid writableType specified');\n 3540:     const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n 3541:     const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n 3542      const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n 3543      const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n ....\n 3552        }\n 3553  \n 3554:       function writeAlgorithm(chunk) {\n 3555          assert(stream._writable._state == 'writable');\n 3556          const controller = stream._transformStreamController;\n ....\n 3572          const controller = stream._transformStreamController;\n 3573          if(controller._finishPromise !== undefined) return controller._finishPromise;\n 3574:         const readable = stream._readable;\n 3575          controller._finishPromise = newPromise((resolve, reject) => {\n 3576            controller._finishPromise_resolve = resolve;\n ....\n 3582            cancelPromise,\n 3583            () => {\n 3584:             if(readable._state == 'errored') {\n 3585:               defaultControllerFinishPromiseReject(controller, readable._storedError);\n 3586              } else {\n 3587:               ReadableStreamDefaultControllerError(readable._readableStreamController, reason);\n 3588                defaultControllerFinishPromiseResolve(controller);\n 3589              }\n ....\n 3591            },\n 3592            r => {\n 3593:             ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n 3594              defaultControllerFinishPromiseReject(controller, r);\n 3595              return null;\n ....\n 3602          const controller = stream._transformStreamController;\n 3603          if(controller._finishPromise !== undefined) return controller._finishPromise;\n 3604:         const readable = stream._readable;\n 3605          controller._finishPromise = newPromise((resolve, reject) => {\n 3606            controller._finishPromise_resolve = resolve;\n ....\n 3612            flushPromise,\n 3613            () => {\n 3614:             if(readable._state == 'errored') {\n 3615:               defaultControllerFinishPromiseReject(controller, readable._storedError);\n 3616              } else {\n 3617:               ReadableStreamDefaultControllerClose(readable._readableStreamController);\n 3618                defaultControllerFinishPromiseResolve(controller);\n 3619              }\n ....\n 3621            },\n 3622            r => {\n 3623:             ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n 3624              defaultControllerFinishPromiseReject(controller, r);\n 3625              return null;\n ....\n 3629        }\n 3630  \n 3631:       this._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n 3632  \n 3633        function pullAlgorithm() {\n ....\n 3670        }\n 3671        assign(this, {\n 3672:         _readable: CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm),\n 3673          _backpressure: undefined,\n 3674          _backpressureChangePromise: undefined,\n ....\n 3701    }\n 3702    /**\n 3703:    * The readable side of the transform stream.\n 3704     */\n 3705:   get readable() {\n 3706:     if(!IsTransformStream(this)) throw streamBrandCheckException3('readable');\n 3707      return this._readable;\n 3708    }\n ....\n 3718  \n 3719  /*Object.defineProperties(TransformStream.prototype, {\n 3720:   readable: { enumerable: true },\n 3721    writable: { enumerable: true },\n 3722  });*/\n ....\n 3758  \n 3759    /**\n 3760:    * Returns the desired size to fill the readable sideâ€™s internal queue. It can be negative, if the queue is over-full.\n 3761     */\n 3762    get desiredSize() {\n 3763      if(!IsTransformStreamDefaultController(this)) throw defaultControllerBrandCheckException3('desiredSize');\n 3764:     const readableController = this._controlledTransformStream._readable._readableStreamController;\n 3765:     return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n 3766    }\n 3767  \n ....\n 3772  \n 3773    /**\n 3774:    * Errors both the readable side and the writable side of the controlled transform stream, making all future\n 3775     * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n 3776     */\n ....\n 3782  \n 3783    /**\n 3784:    * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n 3785     * transformer only needs to consume a portion of the chunks written to the writable side.\n 3786     */\n ....\n 3789  \n 3790      const stream = this._controlledTransformStream;\n 3791:     const readableController = stream._readable._readableStreamController;\n 3792:     ReadableStreamDefaultControllerClose(readableController);\n 3793      const error = new TypeError('TransformStream terminated');\n 3794      TransformStreamErrorWritableAndUnblockWrite(stream, error);\n ....\n 3823  function TransformStreamDefaultControllerEnqueue(controller, chunk) {\n 3824    const stream = controller._controlledTransformStream;\n 3825:   const readableController = stream._readable._readableStreamController;\n 3826:   if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) throw new TypeError('Readable side is not in a state that permits enqueue');\n 3827    try {\n 3828:     ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n 3829    } catch(e) {\n 3830      TransformStreamErrorWritableAndUnblockWrite(stream, e);\n ....\n 3832    }\n 3833  \n 3834:   const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n 3835    if(backpressure !== stream._backpressure) {\n 3836      assert(backpressure);\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/lws/body.old.js:\n    2  import { ReadableStream } from './streams.js';\n    3  import { LinkedList } from './list.js';\n    4: import { isPrototypeOf, assign, readWholeStream } from './util.js';\n    5  import { Blob } from 'blob';\n    6  \n    7  /**\n    8   * @class ReadError\n    9:  * @description Error during reading\n   10   */\n   11  export class ReadError extends Error {}\n   ..\n   38      if(this.#bodyBlob) return Promise.resolve(this.#bodyBlob);\n   39      if(this.#bodyArrayBuffer) return Promise.resolve(new Blob([this.#bodyArrayBuffer]));\n   40:     if(this.#bodyFormData) return Promise.reject(new Error('could not read FormData body as blob'));\n   41      if(this.#bodyText) return Promise.resolve(new Blob([this.#bodyText]));\n   42:     if(this.#chunks || this.#queue || this.#bodyStream) return readWholeStream(this.body).then(arr => Promise.resolve(new Blob(arr)));\n   43    }\n   44  \n   ..\n   60            : this.#bodyArrayBuffer,\n   61        );\n   62:     if(this.#bodyFormData) return Promise.reject(new Error('could not read FormData body as ArrayBuffer'));\n   63      if(this.#bodyText) return Promise.resolve(toArrayBuffer(this.#bodyText));\n   64:     if(this.#chunks || this.#queue || this.#bodyStream) return readWholeStream(this.body).then(arr => Promise.resolve(new Blob(arr).arrayBuffer()));\n   65    }\n   66  \n   ..\n   77      if(this.#bodyBlob) return this.#bodyBlob.text();\n   78      if(this.#bodyArrayBuffer) return Promise.resolve(toString(this.#bodyArrayBuffer));\n   79:     if(this.#bodyFormData) return Promise.reject(new Error('could not read FormData body as text'));\n   80      if(this.#bodyText) return Promise.resolve(this.#bodyText);\n   81:     if(this.#chunks || this.#queue || this.#bodyStream) return readWholeStream(this.body).then(arr => Promise.resolve(new Blob(arr).text()));\n   82    }\n   83  \n   ..\n  219  \n  220        if(last === null) throw new Error('stream already completed');\n  221:       if(isPrototypeOf(ReadError.prototype, last)) throw new Error('stream had read error');\n  222      }\n  223    }\n  ...\n  229     * @param  {ArrayBuffer} chunk     Chunk of data.\n  230     */\n  231:   static write(instance, chunk) {\n  232:     console.log('Body.write', chunk);\n  233      if(instance.#chunks) {\n  234        if(!instance.#chunks.empty) {\n  ...\n  236  \n  237          if(last === null) throw new Error('stream already completed');\n  238:         if(isPrototypeOf(ReadError.prototype, last)) throw new Error('stream had read error');\n  239        }\n  240  \n  ...\n  255    static close(instance) {\n  256      console.log('Body.close');\n  257:     this.write(instance, null);\n  258    }\n  259  \n  ...\n  266    static error(instance, error) {\n  267      console.log('Body.error', error);\n  268:     this.write(instance, new ReadError(error));\n  269    }\n  270  }\n  ...\n  285  /**\n  286   * @param  {Request|Response} body  Body object\n  287:  * @return {undefined|Promise}      If already read, return a rejected Promise\n  288   */\n  289  function consumed(body) {\n  290    if(body._noBody) return;\n  291  \n  292:   if(body.bodyUsed) return Promise.reject(new TypeError('Already read'));\n  293  \n  294    body.bodyUsed = true;\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/lws/simple-queue.js:\n   72  \n   73    /*\n   74:    * Like push(), shift() follows the read -> calculate -> mutate pattern for exception safety.\n   75     */\n   76    shift() {\n\n6948 matches across 312 files\n\n\nSearching 681 files for \"\\b(read|recv|write|send)(|to)\\(\" (regex, case sensitive)\n\n~/Projects/plot-cv/quickjs/qjs-lws/test-client.js:\n   28        },\n   29        onRawWriteable(wsi) {\n   30:         wsi.write(toArrayBuffer('GET / HTTP/1.0\\r\\n\\r\\n'));\n   31        },\n   32        onRawRx(wsi, data) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/test.js:\n   50  \n   51          verbose('onReceive', wsi, data, len);\n   52:         wsi.write(data);\n   53        },\n   54        onFilterHttpConnection(wsi, url) {\n   ..\n   85  \n   86            wsi.respond(200, { 'content-type': 'text/html', test: 'blah' }, b.byteLength);\n   87:           wsi.write(b, LWS_WRITE_HTTP_FINAL);\n   88  \n   89            return -1;\n   ..\n  108          }\n  109  \n  110:         wsi.write(obj.lines[obj.index] + '\\n', obj.lines[++obj.index] ? LWS_WRITE_HTTP : LWS_WRITE_HTTP_FINAL);\n  111  \n  112          if(obj.lines[obj.index]) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/out/web.js:\n 1042      {\n 1043        key: 'write',\n 1044:       value: function write() {\n 1045          var chunk = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : undefined;\n 1046          if(!IsWritableStreamDefaultWriter(this)) return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n ....\n 1271    if(underlyingSink.write !== undefined)\n 1272      writeAlgorithm = function(chunk) {\n 1273:       return underlyingSink.write(chunk, controller);\n 1274      };\n 1275    else\n ....\n 2647      {\n 2648        key: 'read',\n 2649:       value: function read() {\n 2650          if(!IsReadableStreamDefaultReader(this)) return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n 2651          if(this._ownerReadableStream === undefined) return promiseRejectedWith(readerLockException('read from'));\n ....\n 3387      {\n 3388        key: 'read',\n 3389:       value: function read(view) {\n 3390          var rawOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n 3391          if(!IsReadableStreamBYOBReader(this)) return promiseRejectedWith(byobReaderBrandCheckException('read'));\n ....\n 3822      var readPromise;\n 3823      try {\n 3824:       readPromise = reader.read();\n 3825      } catch(e) {\n 3826        return promiseRejectedWith(e);\n 3827      }\n 3828      return transformPromiseWith(readPromise, function(readResult) {\n 3829:       if(!typeIsObject(readResult)) throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\n 3830        if(readResult.done) ReadableStreamDefaultControllerClose(stream._readableStreamController);\n 3831        else {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets.h:\n  478  #endif\n  479  \n  480: ssize_t recv(int sockfd, void *buf, size_t len, int flags);\n  481: ssize_t send(int sockfd, const void *buf, size_t len, int flags);\n  482: ssize_t read(int fd, void *buf, size_t count);\n  483  int getsockopt(int sockfd, int level, int optname,\n  484                        void *optval, socklen_t *optlen);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-ring.h:\n   59   *  - lws_ring_bump_head()\n   60   *\n   61:  *  which let you, eg, read() directly into the ringbuffer without needing\n   62   *  an intermediate bounce buffer.\n   63   *\n   ..\n  179   *\n  180   * Points to the next element that tail would consume, directly in the\n  181:  * ringbuffer.  This lets you write() or otherwise use the element without\n  182   * having to copy it out somewhere first.\n  183   *\n  ...\n  227   * The api reports the position and length of the next linear range that can\n  228   * be written in the ringbuffer, ie, up to the point it would wrap, and sets\n  229:  * *start and *bytes accordingly.  You can then, eg, directly read() into\n  230   * *start for up to *bytes, and use lws_ring_bump_head() to update the lws_ring\n  231   * with what you have done.\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-writeable.h:\n  194   * lws_get_socket_fd() - returns the socket file descriptor\n  195   *\n  196:  * This is needed to use sendto() on UDP raw sockets\n  197   *\n  198   * \\param wsi:\tWebsocket connection instance\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-protocols-plugins.h:\n   74  \t\t\there it can later access from the protocol callback */\n   75  \tsize_t tx_packet_size;\n   76: \t/**< 0 indicates restrict send() size to .rx_buffer_size for backwards-\n   77  \t * compatibility.\n   78: \t * If greater than zero, a single send() is restricted to this amount\n   79  \t * and any remainder is buffered by lws and sent afterwards also in\n   80  \t * these size chunks.  Since that is expensive, it's preferable\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/wol.c:\n   83  \n   84  \t/* arg2 is normally const void *, on mingw it's const char * */\n   85:         if (sendto(fd, (const char *)pkt, sizeof(pkt), 0, (struct sockaddr *)&addr,\n   86                          sizeof(addr)) < 0) {\n   87                  lwsl_cx_err(cx, \"failed to sendto broadcast ads, errno %d\\n\",\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/dummy-callback.c:\n  675  \t\t\tif (n < 0)\n  676  \t\t\t\tbreak;\n  677: \t\t\tn = (int)read(n, buf, sizeof(buf) - 2);\n  678  \t\t\tif (n > 0) {\n  679  \t\t\t\tif (buf[n - 1] != '\\n')\n  ...\n  766  \t\t\t\t\tint written;\n  767  \n  768: \t\t\t\t\twritten = (int)write(args->stdwsi[LWS_STDIN]->desc.filefd,\n  769  \t\t\t\t\t\twsi->http.cgi->inflate_buf,\n  770  \t\t\t\t\t\tsizeof(wsi->http.cgi->inflate_buf) -\n  ...\n  800  #endif /* WITH_ZLIB */\n  801  \n  802: \t\tn = (int)write(n, args->data, (unsigned int)args->len);\n  803  //\t\tlwsl_hexdump_notice(args->data, args->len);\n  804  \t\tif (n < args->len)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/output.c:\n  262  \t} else\n  263  #endif\n  264: \t\tn = (int)recv(wsi->desc.sockfd, (char *)buf,\n  265  #if defined(WIN32)\n  266  \t\t\t\t(int)\n  ...\n  310  \tint n = 0;\n  311  #if defined(LWS_PLAT_OPTEE)\n  312: \tssize_t send(int sockfd, const void *buf, size_t len, int flags);\n  313  #endif\n  314  \n  ...\n  323  \n  324  \t\tif (lws_has_buffered_out(wsi))\n  325: \t\t\tn = (int)sendto(wsi->desc.sockfd, (const char *)buf,\n  326  #if defined(WIN32)\n  327  \t\t\t\t(int)\n  ...\n  330  \t\t\t\t   sa46_socklen(&wsi->udp->sa46_pending));\n  331  \t\telse\n  332: \t\t\tn = (int)sendto(wsi->desc.sockfd, (const char *)buf,\n  333  #if defined(WIN32)\n  334  \t\t\t\t(int)\n  ...\n  339  #endif\n  340  \t\tif (wsi->role_ops->file_handle)\n  341: \t\t\tn = (int)write((int)(lws_intptr_t)wsi->desc.filefd, buf,\n  342  #if defined(WIN32)\n  343  \t\t\t\t(int)\n  ...\n  345  \t\t\t\t\tlen);\n  346  \t\telse\n  347: \t\t\tn = (int)send(wsi->desc.sockfd, (char *)buf,\n  348  #if defined(WIN32)\n  349  \t\t\t\t(int)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/socks5-client.c:\n  236  \t}\n  237  \t// lwsl_hexdump_notice(pt->serv_buf, plen);\n  238: \tn = (int)send(wsi->desc.sockfd, (char *)pt->serv_buf, (size_t)plen,\n  239  \t\t      MSG_NOSIGNAL);\n  240  \tif (n < 0) {\n  ...\n  269  \t}\n  270  \n  271: \tn = (int)recv(wsi->desc.sockfd, (void *)pt->serv_buf,\n  272  \t\t wsi->a.context->pt_serv_buf_size, 0);\n  273  \tif (n < 0) {\n  ...\n  332  socks_send:\n  333  \t\t// lwsl_hexdump_notice(pt->serv_buf, len);\n  334: \t\tn = (int)send(wsi->desc.sockfd, (char *)pt->serv_buf,\n  335  \t\t\t      (size_t)len, MSG_NOSIGNAL);\n  336  \t\tif (n < 0) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/client/connect4.c:\n   96  \t\twsi->c_port = (uint16_t)wsi->a.vhost->http.http_proxy_port;\n   97  \n   98: \t\tn = (int)send(wsi->desc.sockfd, (char *)pt->serv_buf,\n   99  \t\t\t      (unsigned int)plen,\n  100  \t\t\t MSG_NOSIGNAL);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core/logs.c:\n  326  \n  327  \tif (fd >= 0)\n  328: \t\tif (write(fd, line, (unsigned int)len) != (ssize_t)len)\n  329  \t\t\tfprintf(stderr, \"Unable to write log to file\\n\");\n  330  }\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/tls.c:\n   52  \t/* the first item in the chunk */\n   53  \tif (!strncmp(line, \"SERVER_HANDSHAKE_TRAFFIC_SECRET\", 31)) {\n   54: \t\tw += (size_t)write(fd, \"\\n# \", 3);\n   55  \t\twx += 3;\n   56  \t\tt = lwsl_timestamp(LLL_WARN, ts, sizeof(ts));\n   57  \t\twx += (size_t)t;\n   58: \t\tw += (size_t)write(fd, ts, (size_t)t);\n   59  \n   60  \t\tt = lws_snprintf(hdr, sizeof(hdr), \"%s\\n\", wsi->lc.gutag);\n   61: \t\tw += (size_t)write(fd, hdr, (size_t)t);\n   62  \t\twx += (size_t)t;\n   63  \n   ..\n   66  \n   67  \twx += strlen(line) + 1;\n   68: \tw += (size_t)write(fd, line, \n   69  #if defined(WIN32)\n   70  \t\t\t(unsigned int)\n   71  #endif\n   72  \t\t\tstrlen(line));\n   73: \tw += (size_t)write(fd, \"\\n\", 1);\n   74  \tclose(fd);\n   75  \n   ..\n  502  \n  503  \t/* and we can read at least one byte out of it */\n  504: \tn = read(fd, buf, 1);\n  505  \tclose(fd);\n  506  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/tls-server.c:\n  192  \t\t\t */\n  193  \n  194: \t\t\ts = recv(wsi->desc.sockfd, (char *)pt->serv_buf,\n  195  \t\t\t\t context->pt_serv_buf_size, MSG_PEEK);\n  196  \t\t\t/*\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/windows/windows-pipe.c:\n  114  \t */\n  115  \n  116: \tn = sendto(fd[1], &u, 1, 0, (struct sockaddr *)si, sizeof(*si));\n  117  \n  118  \treturn n != 1;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/windows/windows-sockets.c:\n  618  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  619  \n  620: \tret = send(fd, (const char *)buf, (unsigned int)len, 0);\n  621  \tif (ret >= 0)\n  622  \t\treturn ret;\n  ...\n  643  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  644  \n  645: \tret = (int)recv(fd, (char *)buf, (unsigned int)len, 0);\n  646  \tif (ret >= 0)\n  647  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/windows/windows-file.c:\n  160  \tint n;\n  161  \n  162: \tn = (int)write(fd, buf, (unsigned int)len);\n  163  \n  164  \tlseek(fd, 0, SEEK_SET);\n  ...\n  177  \t\treturn -1;\n  178  \n  179: \tm = (int)write(fd, buf, (unsigned int)len);\n  180  \tclose(fd);\n  181  \n  ...\n  190  \t\treturn -1;\n  191  \n  192: \tn = (int)read(fd, buf, (unsigned int)len);\n  193  \tclose(fd);\n  194  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-pipe.c:\n   74  \tint n;\n   75  \n   76: \tn = (int)write(pt->dummy_pipe_fds[1], &buf, 1);\n   77  \n   78  \treturn n != 1;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-misc.c:\n   68  #else\n   69  \t/* coverity[tainted_scalar] */\n   70: \treturn (size_t)read(context->fd_random, (char *)buf, len);\n   71  #endif\n   72  }\n   ..\n  100  \tssize_t n;\n  101  \n  102: \tn = write(fd, buf, len);\n  103  \n  104  \tif (n < 0 || fsync(fd))\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-sockets.c:\n  500  \tmemset(sll.sll_addr, 0xff, 6);\n  501  \n  502: \treturn (int)sendto(fd, p, n, 0, (struct sockaddr *)&sll, sizeof(sll));\n  503  #else\n  504  \tlwsl_err(\"%s: UNIMPLEMENTED on this platform\\n\", __func__);\n  ...\n  643  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  644  \n  645: \tret = (int)write(fd, buf, len);\n  646  \tif (ret >= 0)\n  647  \t\treturn ret;\n  ...\n  668  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  669  \n  670: \tret = (int)read(fd, buf, len);\n  671  \tif (ret >= 0)\n  672  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-spawn.c:\n  354  \t}\n  355  \n  356: \tr = read(fd, s, sizeof(s) - 1);\n  357  \tclose(fd);\n  358  \tif (r < 0) {\n  ...\n  547  \t\t\t\tcfd = lws_open(pth, LWS_O_WRONLY);\n  548  \t\t\t\tif (cfd >= 0) {\n  549: \t\t\t\t\tif (write(cfd, \"threaded\", 8) != 8)\n  550  \t\t\t\t\t\tlwsl_warn(\"%s: failed to write threaded\\n\", __func__);\n  551  \n  ...\n  558  \t\t\t\tcfd = lws_open(pth, LWS_O_WRONLY);\n  559  \t\t\t\tif (cfd >= 0) {\n  560: \t\t\t\t\tif (write(cfd, \"max\", 3) != 3)\n  561  \t\t\t\t\t\tlwsl_warn(\"%s: failed to write max\\n\", __func__);\n  562  \n  ...\n  652  \t\tif (fd >= 0) {\n  653  \t\t\tlen = lws_snprintf(pid_str, sizeof(pid_str) - 1, \"%d\", (int)getpid());\n  654: \t\t\tif (write(fd, pid_str, (size_t)len) != (ssize_t)len) {\n  655  \t\t\t\t/*\n  656  \t\t\t\t * using lwsl_err here is unsafe in vfork()\n  ...\n  817  \t}\n  818  \n  819: \tif (write(fd, \"+cpu +memory +pids +io\", 22) != 22)\n  820  \t\t/* ignore, may be there already or fail due to perms */\n  821  \t\tlwsl_debug(\"%s: setting admin cgroup options failed\\n\", __func__);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-resolv.c:\n   45  \t\treturn LADNS_CONF_SERVER_UNKNOWN;\n   46  \n   47: \tn = read(fd, r, context->pt_serv_buf_size - 1);\n   48  \tclose(fd);\n   49  \tif (n < 0)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-file.c:\n   55  \t\treturn 1;\n   56  \n   57: \tm = write(fd, buf, len);\n   58  \tclose(fd);\n   59  \n   ..\n   73  \t\treturn -1;\n   74  \n   75: \tn = read(fd, buf, len);\n   76  \tclose(fd);\n   77  \n   ..\n  152  \tssize_t n;\n  153  \n  154: \tn = read((int)fop_fd->fd, buf, (size_t)len);\n  155  \tif (n == -1l) {\n  156  \t\t*amount = 0;\n  ...\n  172  \tssize_t n;\n  173  \n  174: \tn = write((int)fop_fd->fd, buf, (size_t)len);\n  175  \tif (n == -1) {\n  176  \t\t*amount = 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-file.c:\n   88  \tlong n;\n   89  \n   90: \tn = read(fops_fd->fd, buf, len);\n   91  \tif (n == -1) {\n   92  \t\t*amount = 0;\n   ..\n  105  \tlong n;\n  106  \n  107: \tn = write(fops_fd->fd, buf, len);\n  108  \tif (n == -1) {\n  109  \t\t*amount = 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-sockets.c:\n  355  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  356  \n  357: \tret = write(fd, buf, len);\n  358  \tif (ret >= 0)\n  359  \t\treturn ret;\n  ...\n  380  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  381  \n  382: \tret = (int)read(fd, buf, len);\n  383  \tif (ret >= 0)\n  384  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/optee/network.c:\n  176  #if 0\n  177  \t\tif (pt->fds[n].fd == pt->dummy_pipe_fds[0]) {\n  178: \t\t\tif (read(pt->fds[n].fd, &buf, 1) != 1)\n  179  \t\t\t\tlwsl_err(\"Cannot read from dummy pipe.\");\n  180  \t\t\tcontinue;\n  ...\n  285  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  286  \n  287: \tret = write(fd, buf, len);\n  288  \tif (ret >= 0)\n  289  \t\treturn ret;\n  ...\n  310  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  311  \n  312: \tret = (int)read(fd, buf, len);\n  313  \tif (ret >= 0)\n  314  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/drivers/spi/bitbang/lws-bb-spi.c:\n   83  \t\tfor (n = 0; n < 8; n++) {\n   84  \t\t\tctx->gpio->set(ctx->clk, inv);\n   85: \t\t\tu = (u << 1) | !!ctx->gpio->read(ctx->miso);\n   86  \t\t\tctx->gpio->set(ctx->mosi, !!(u & 0x80));\n   87  \t\t\tctx->gpio->set(ctx->clk, !inv);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/drivers/i2c/lws-i2c.c:\n   35  \t\treturn 1;\n   36  \n   37: \tif (ctx->write(ctx, ads7 << 1)) {\n   38  \t\tctx->stop(ctx);\n   39  \n   ..\n   41  \t}\n   42  \n   43: \tctx->write(ctx, 0);\n   44: \tctx->write(ctx, c);\n   45  \tctx->stop(ctx);\n   46  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/drivers/i2c/bitbang/lws-bb-i2c.c:\n   47  \tctx->delay();\n   48  \n   49: \tif (!ctx->gpio->read(ctx->sda))\n   50  \t\treturn 1;\n   51  \n   ..\n   66  \tctx->delay();\n   67  \n   68: \twhile (!ctx->gpio->read(ctx->scl))\n   69  \t\t;\n   70  \n   ..\n   92  \tctx->gpio->set(ctx->scl, 1);\n   93  \tctx->delay();\n   94: \tn = ctx->gpio->read(ctx->sda);\n   95  \tctx->gpio->set(ctx->scl, 0);\n   96  \tctx->delay();\n   ..\n  112  \t\tctx->gpio->set(ctx->scl, 1);\n  113  \t\tctx->delay();\n  114: \t\tif (ctx->gpio->read(ctx->sda))\n  115  \t\t\tr |= 1 << n;\n  116  \t}\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/drivers/display/spd1656-spi.c:\n  121  \tconst lws_display_spd1656_spi_t *ea = lds_to_disp(priv->lds);\n  122  \n  123: \tif (ea->gpio->read(ea->busy_gpio) == level)\n  124  \t\treturn 0; /* good */\n  125  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/drivers/display/uc8176-spi.c:\n  387  \tconst lws_display_uc8176_spi_t *ea = lds_to_disp(priv->lds);\n  388  \n  389: \tif (ea->gpio->read(ea->busy_gpio) == level)\n  390  \t\treturn 0; /* good */\n  391  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/drivers/display/ssd1675b-spi.c:\n  193  \tconst lws_display_ssd1675b_spi_t *ea = lds_to_disp(priv->lds);\n  194  \n  195: \tif (ea->gpio->read(ea->busy_gpio) == level)\n  196  \t\treturn 0; /* good */\n  197  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/drivers/button/lws-button.c:\n  230  \t\t\t\tLWS_BUTTON_MON_TIMER_MS;\n  231  \n  232: \t\tactive = bc->gpio_ops->read(bc->button_map[n].gpio) ^\n  233  \t\t\t       (!(bc->active_state_bitmap & (1 << n)));\n  234  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/client/client-http.c:\n  113  \t\t}\n  114  \n  115: \t\tn = (int)recv(wsi->desc.sockfd, sb, context->pt_serv_buf_size, 0);\n  116  \t\tif (n < 0) {\n  117  \t\t\tif (LWS_ERRNO == LWS_EAGAIN) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/server/access-log.c:\n  188  \tass[sizeof(ass) - 1] = '\\0';\n  189  \n  190: \tif ((int)write(wsi->a.vhost->log_fd, ass, (size_t)l) != l)\n  191  \t\tlwsl_err(\"Failed to write log\\n\");\n  192  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/server/lejp-conf.c:\n 1028  \n 1029  \tdo {\n 1030: \t\tn = (int)read(fd, buf, sizeof(buf));\n 1031  \t\tif (!n)\n 1032  \t\t\tbreak;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/server/server.c:\n 1051  \twhile (1) {\n 1052  \t\tif (pos == n) {\n 1053: \t\t\tn = (int)read(fd, buf, sizeof(buf));\n 1054  \t\t\tif (n <= 0) {\n 1055  \t\t\t\tif (match == stringlen)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/cgi/cgi-server.c:\n  705  \t\tif (n < 0)\n  706  \t\t\treturn -1;\n  707: \t\tn = (int)read(n, &c, 1);\n  708  \t\tif (n < 0) {\n  709  \t\t\tif (errno != EAGAIN) {\n  ...\n  856  \tif (n < 0)\n  857  \t\treturn -1;\n  858: \tn = (int)read(n, start, sizeof(buf) - LWS_PRE - 16);\n  859  \n  860  \tif (n < 0 && errno != EAGAIN) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/pipe/ops-pipe.c:\n   48  \t * thinks we should.\n   49  \t */\n   50: \tn = (int)read(wsi->desc.sockfd, s, sizeof(s));\n   51  \t(void)n;\n   52  \tif (n < 0)\n   ..\n   56  \tint n;\n   57  \n   58: \tn = recv(wsi->desc.sockfd, s, sizeof(s), 0);\n   59  \tif (n == SOCKET_ERROR)\n   60  \t\treturn LWS_HPI_RET_PLEASE_CLOSE_ME;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/system/async-dns/async-dns.c:\n  878  \t\ts = _read(fd, buf, sizeof(buf) - 1);\n  879  #else\n  880: \t\ts = read(fd, buf, sizeof(buf) - 1);\n  881  #endif\n  882  \t\tif (s <= 0) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/policy-json.c:\n 1240  \n 1241  \tdo {\n 1242: \t\tn = (int)read(fd, buf, sizeof(buf));\n 1243  \t\tif (n < 0) {\n 1244  \t\t\tm = -1;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/protocols/ss-raw.c:\n  124         case LWS_CALLBACK_RAW_RX_FILE:\n  125                 in = p;\n  126:                f = (int)read((int)(intptr_t)wsi->desc.filefd, p, sizeof(buf) - LWS_PRE);\n  127                 if (f < 0)\n  128                         return 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/daemonize.c:\n   65  \t\t}\n   66  \t\tlen = sprintf(sz, \"%u\", (unsigned int)pid_daemon);\n   67: \t\tsent = (int)write(fd, sz, (size_t)len);\n   68  \t\tif (sent != len)\n   69  \t\t\tfprintf(stderr,\n   ..\n  118  \t\t\tchar buf[10];\n  119  \n  120: \t\t\tn = (int)read(fd, buf, sizeof(buf));\n  121  \t\t\tclose(fd);\n  122  \t\t\tif (n) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/cache-ttl/file.c:\n  179  \t\t\t * Removing this function from Coverity\n  180  \t\t\t */\n  181: \t\t\tn1s = read(fd, temp + n, sizeof(temp) - (size_t)n);\n  182  \n  183  \t\tlwsl_debug(\"%s: n1 %d\\n\", __func__, (int)n1s);\n  ...\n  615  \tcache->cache.current_footprint += (uint64_t)size;\n  616  \n  617: \tif (write(ctx->fdt, buf, /*msvc*/(unsigned int)size) != (ssize_t)size)\n  618  \t\treturn NIR_FINISH_ERROR;\n  619  \n  620  \tif (flags & LCN_EOL)\n  621: \t\tif ((size_t)write(ctx->fdt, \"\\n\", 1) != 1)\n  622  \t\t\treturn NIR_FINISH_ERROR;\n  623  \n  ...\n  657  \tif (lws_fi(&cache->cache.info.cx->fic, \"cache_regen_temp_write\") ||\n  658  \t/* other consumers insist to see this at start of cookie jar */\n  659: \t    write(ctx.fdt, \"# Netscape HTTP Cookie File\\n\", 28) != 28)\n  660  \t\tgoto bail1;\n  661  \n  ...\n  663  \n  664  \tif (pay &&\n  665: \t    write(ctx.fdt, pay, /*msvc*/(unsigned int)pay_size) !=\n  666  \t\t\t\t\t\t    (ssize_t)pay_size)\n  667  \t\tgoto bail1;\n  668: \tif (pay && write(ctx.fdt, \"\\n\", 1u) != (ssize_t)1)\n  669  \t\tgoto bail1;\n  670  \n  ...\n  809  \n  810  \t*ctx->psize = size;\n  811: \tif (ctx->l1->info.ops->write(ctx->l1,\n  812  \t\t\t\t     ctx->specific_key, (const uint8_t *)buf,\n  813  \t\t\t\t     size, ctx->expiry, (void **)ctx->pdata))\n  ...\n  832  \n  833  \t*ctx->psize = size;\n  834: \tif (ctx->l1->info.ops->write(ctx->l1, ctx->specific_key, NULL,\n  835  \t\t\t\t     lws_buflist_total_len(&ctx->buflist),\n  836  \t\t\t\t     ctx->expiry, (void **)&q))\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/cache-ttl/lws-cache-ttl.c:\n   74  \twhile (n) {\n   75  \t\tn--;\n   76: \t\tr = levels[n]->info.ops->write(levels[n], specific_key,\n   77  \t\t\t\t\t\tsource, size, expiry, ppay);\n   78  \t}\n   ..\n  185  \t */\n  186  \n  187: \tn = l1->info.ops->write(l1, meta_key, temp, sum, expiry, (void **)&p);\n  188  \t/* done with temp */\n  189  \tlws_free(temp);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/lwsac/cached-file.c:\n  192  \ta[s.st_size] = '\\0';\n  193  \n  194: \trd = read(fd, a, (unsigned long)s.st_size);\n  195  \tif (rd != s.st_size) {\n  196  \t\tlwsl_err(\"%s: cannot read %s (%d)\\n\", __func__, filepath,\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/fts/trie.c:\n  170  #define spill(margin, force) \\\n  171  \tif (bp && ((uint32_t)bp >= (sizeof(buf) - (size_t)(margin)) || (force))) { \\\n  172: \t\tif ((int)write(t->fd, buf, (size_t)bp) != bp) { \\\n  173  \t\t\tlwsl_err(\"%s: write %d failed (%d)\\n\", __func__, \\\n  174  \t\t\t\t bp, errno); \\\n  ...\n  296  \tg32(&buf[0x10], 0);\n  297  \n  298: \tif (write(t->fd, buf, TRIE_FILE_HDR_SIZE) != TRIE_FILE_HDR_SIZE) {\n  299  \t\tlwsl_err(\"%s: trie header write failed\\n\", __func__);\n  300  \t\tgoto unwind;\n  ...\n  404  \tbp += g16(&buf[bp], 0);\n  405  \tbp += g32(&buf[bp], 0);\n  406: \tif ((int)write(t->fd, buf, (size_t)bp) != bp)\n  407  \t\treturn 1;\n  408  \tt->c += (unsigned int)bp;\n  ...\n  592  \t\t\tbp += wq32(&linetable[bp], (uint32_t)t->chars_in_line);\n  593  \t\t\tif ((unsigned int)bp > sizeof(linetable) - 6) {\n  594: \t\t\t\tif ((int)write(t->fd, linetable, (unsigned int)bp) != bp) {\n  595  \t\t\t\t\tlwsl_err(\"%s: linetable write failed\\n\",\n  596  \t\t\t\t\t\t\t__func__);\n  ...\n 1039  \t\t\tif (!strcmp(ne, \"describ\")) {\n 1040  \t\t\t\tlwsl_err(\"     %s %d\\n\", ne, t->str_match_pos);\n 1041: \t\t\t\twrite(1, buf - 10, 20);\n 1042  \t\t\t}\n 1043  \t\t}\n ....\n 1051  \n 1052  \tif (bp) {\n 1053: \t\tif ((int)write(t->fd, linetable, (size_t)bp) != bp)\n 1054  \t\t\treturn 1;\n 1055  \t\tt->c += (unsigned int)bp;\n ....\n 1066  \tg16(linetable + 2, (uint16_t)(t->line_number - sline));\n 1067  \tg32(linetable + 4, (uint32_t)chars);\n 1068: \tif ((int)write(t->fd, linetable, 8) != 8) {\n 1069  \t\tlwsl_err(\"%s: write linetable header failed\\n\", __func__);\n 1070  \t\treturn 1;\n ....\n 1188  \tg32(buf, t->c + (unsigned int)bp);\n 1189  \tg32(buf + 4, (uint32_t)t->next_file_index);\n 1190: \tif ((int)write(t->fd, buf, 8) != 8)\n 1191  \t\tgoto bail;\n 1192  \n ....\n 1347  \tg32(buf, t->root->ofs);\n 1348  \tg32(buf + 4, t->c);\n 1349: \tif (write(t->fd, buf, 0x8) != 0x8)\n 1350  \t\tgoto bail;\n 1351  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/fts/trie-fd.c:\n  102  \t}\n  103  \n  104: \tra = (int)read(jtf->fd, buf, 4);\n  105  \tif (ra < 0)\n  106  \t\treturn 1;\n  ...\n  113  \t}\n  114  \n  115: \tra = (int)read(jtf->fd, buf, sizeof(buf));\n  116  \tif (ra < 0)\n  117  \t\treturn 1;\n  ...\n  151  \toff_t ot;\n  152  \n  153: \tif (read(jtf->fd, buf, TRIE_FILE_HDR_SIZE) != TRIE_FILE_HDR_SIZE) {\n  154  \t\tlwsl_err(\"%s: unable to read file header\\n\", __func__);\n  155  \t\tgoto bail;\n  ...\n  231  \t\t} \\\n  232  \\\n  233: \t\tra = (int)read(jtf->fd, buf, (size_t)(_size)); \\\n  234  \t\tif (ra < 0) \\\n  235  \t\t\tgoto bail; \\\n  ...\n  714  \t\t\t\t\tcontinue;\n  715  \n  716: \t\t\t\tm = (int)read(ofd, lbuf, sizeof(lbuf) - 1);\n  717  \t\t\t\tif (m < 0)\n  718  \t\t\t\t\tcontinue;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/readable-stream.js:\n  518       * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  519       */\n  520:     read() {\n  521          if (!IsReadableStreamDefaultReader(this)) {\n  522              return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  ...\n  545       *\n  546       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  547:      * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  548       * do so will throw a `TypeError` and leave the reader locked to the stream.\n  549       */\n  ...\n 1316      const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\n 1317      const maxAlignedBytes = maxBytesFilled - remainderBytes;\n 1318:     // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n 1319      // of the queue, so the underlying source can keep filling it.\n 1320      if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n ....\n 1428          // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n 1429          // - No change happens on desiredSize\n 1430:         // - The source has already been notified of that there's at least 1 pending read(view)\n 1431          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n 1432          return;\n ....\n 1479      }\n 1480      if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\n 1481:         // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n 1482          // of the queue, so the underlying source can keep filling it.\n 1483          return;\n ....\n 1886          return ReadableStreamReaderGenericCancel(this, reason);\n 1887      }\n 1888:     read(view, rawOptions = {}) {\n 1889          if (!IsReadableStreamBYOBReader(this)) {\n 1890              return promiseRejectedWith(byobReaderBrandCheckException('read'));\n ....\n 1944       *\n 1945       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n 1946:      * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n 1947       * do so will throw a `TypeError` and leave the reader locked to the stream.\n 1948       */\n ....\n 2263      // producer without waiting for the queued writes to finish.\n 2264      stream._writeRequests = new SimpleQueue();\n 2265:     // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n 2266:     // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n 2267      stream._inFlightWriteRequest = undefined;\n 2268      // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n ....\n 2633       *\n 2634       * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n 2635:      * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n 2636       * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n 2637       * other producers from writing in an interleaved manner.\n ....\n 2648          WritableStreamDefaultWriterRelease(this);\n 2649      }\n 2650:     write(chunk = undefined) {\n 2651          if (!IsWritableStreamDefaultWriter(this)) {\n 2652              return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n ....\n 2908      }\n 2909      if (underlyingSink.write !== undefined) {\n 2910:         writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n 2911      }\n 2912      else {\n ....\n 4118          let readPromise;\n 4119          try {\n 4120:             readPromise = reader.read();\n 4121          }\n 4122          catch (e) {\n ....\n 4125          return transformPromiseWith(readPromise, (readResult) => {\n 4126              if (!typeIsObject(readResult)) {\n 4127:                 throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\n 4128              }\n 4129              if (readResult.done) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/ponyfill.js:\n  425     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  426     */\n  427:   read() {\n  428      if(!IsReadableStreamDefaultReader(this)) {\n  429        return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  ...\n  452     *\n  453     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  454:    * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  455     * do so will throw a `TypeError` and leave the reader locked to the stream.\n  456     */\n  ...\n 1682      return ReadableStreamReaderGenericCancel(this, reason);\n 1683    }\n 1684:   read(view, rawOptions = {}) {\n 1685      if(!IsReadableStreamBYOBReader(this)) {\n 1686        return promiseRejectedWith(byobReaderBrandCheckException('read'));\n ....\n 1738     *\n 1739     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n 1740:    * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n 1741     * do so will throw a `TypeError` and leave the reader locked to the stream.\n 1742     */\n ....\n 2354     *\n 2355     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n 2356:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n 2357     * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n 2358     * other producers from writing in an interleaved manner.\n ....\n 2369      WritableStreamDefaultWriterRelease(this);\n 2370    }\n 2371:   write(chunk = void 0) {\n 2372      if(!IsWritableStreamDefaultWriter(this)) {\n 2373        return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n ....\n 2614    }\n 2615    if(underlyingSink.write !== void 0) {\n 2616:     writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n 2617    } else {\n 2618      writeAlgorithm = () => promiseResolvedWith(void 0);\n ....\n 3729      let readPromise;\n 3730      try {\n 3731:       readPromise = reader.read();\n 3732      } catch(e) {\n 3733        return promiseRejectedWith(e);\n ....\n 3735      return transformPromiseWith(readPromise, readResult => {\n 3736        if(!typeIsObject(readResult)) {\n 3737:         throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\n 3738        }\n 3739        if(readResult.done) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/out.js:\n  425     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  426     */\n  427:   read() {\n  428      if(!IsReadableStreamDefaultReader(this)) {\n  429        return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  ...\n  452     *\n  453     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  454:    * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  455     * do so will throw a `TypeError` and leave the reader locked to the stream.\n  456     */\n  ...\n 1566      return ReadableStreamReaderGenericCancel(this, reason);\n 1567    }\n 1568:   read(view, rawOptions = {}) {\n 1569      if(!IsReadableStreamBYOBReader(this)) {\n 1570        return promiseRejectedWith(byobReaderBrandCheckException('read'));\n ....\n 1622     *\n 1623     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n 1624:    * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n 1625     * do so will throw a `TypeError` and leave the reader locked to the stream.\n 1626     */\n ....\n 2237     *\n 2238     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n 2239:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n 2240     * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n 2241     * other producers from writing in an interleaved manner.\n ....\n 2252      WritableStreamDefaultWriterRelease(this);\n 2253    }\n 2254:   write(chunk = void 0) {\n 2255      if(!IsWritableStreamDefaultWriter(this)) {\n 2256        return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n ....\n 2497    }\n 2498    if(underlyingSink.write !== void 0) {\n 2499:     writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n 2500    } else {\n 2501      writeAlgorithm = () => promiseResolvedWith(void 0);\n ....\n 3611      let readPromise;\n 3612      try {\n 3613:       readPromise = reader.read();\n 3614      } catch(e) {\n 3615        return promiseRejectedWith(e);\n ....\n 3617      return transformPromiseWith(readPromise, readResult => {\n 3618        if(!typeIsObject(readResult)) {\n 3619:         throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\n 3620        }\n 3621        if(readResult.done) {\n ....\n 5746     *\n 5747     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n 5748:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n 5749     * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n 5750     * other producers from writing in an interleaved manner.\n ....\n 5761      WritableStreamDefaultWriterRelease2(this);\n 5762    }\n 5763:   write(chunk = void 0) {\n 5764      if(!IsWritableStreamDefaultWriter2(this)) {\n 5765        return promiseRejectedWith(defaultWriterBrandCheckException2('write'));\n ....\n 5993    }\n 5994    if(underlyingSink.write !== void 0) {\n 5995:     writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n 5996    } else {\n 5997      writeAlgorithm = () => promiseResolvedWith(void 0);\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/writable-stream.js:\n  150    // producer without waiting for the queued writes to finish.\n  151    stream._writeRequests = new SimpleQueue();\n  152:   // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  153:   // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  154    stream._inFlightWriteRequest = undefined;\n  155    // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  ...\n  519     *\n  520     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n  521:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n  522     * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n  523     * other producers from writing in an interleaved manner.\n  ...\n  534      WritableStreamDefaultWriterRelease(this);\n  535    }\n  536:   write(chunk = undefined) {\n  537      if(!IsWritableStreamDefaultWriter(this)) {\n  538        return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n  ...\n  795    }\n  796    if(underlyingSink.write !== undefined) {\n  797:     writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n  798    } else {\n  799      writeAlgorithm = () => promiseResolvedWith(undefined);\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/bun.js:\n  407      return ReadableStreamReaderGenericCancel(this, reason);\n  408    }\n  409:   read() {\n  410      if(!IsReadableStreamDefaultReader(this)) {\n  411        return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  ...\n 1647      return ReadableStreamReaderGenericCancel(this, reason);\n 1648    }\n 1649:   read(view, rawOptions = {}) {\n 1650      if(!IsReadableStreamBYOBReader(this)) {\n 1651        return promiseRejectedWith(byobReaderBrandCheckException('read'));\n ....\n 2280      WritableStreamDefaultWriterRelease(this);\n 2281    }\n 2282:   write(chunk = undefined) {\n 2283      if(!IsWritableStreamDefaultWriter(this)) {\n 2284        return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n ....\n 2520    }\n 2521    if(underlyingSink.write !== undefined) {\n 2522:     writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n 2523    } else {\n 2524      writeAlgorithm = () => promiseResolvedWith(undefined);\n ....\n 3633      let readPromise;\n 3634      try {\n 3635:       readPromise = reader.read();\n 3636      } catch(e) {\n 3637        return promiseRejectedWith(e);\n ....\n 3639      return transformPromiseWith(readPromise, readResult => {\n 3640        if(!typeIsObject(readResult)) {\n 3641:         throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\n 3642        }\n 3643        if(readResult.done) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/transform-stream.js:\n  151  function TransformStreamUnblockWrite(stream) {\n  152    if(stream._backpressure) {\n  153:     // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n  154      // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n  155      // _backpressure is set.\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/benchmark/index.js:\n   28  \n   29  function readLoop(count, reader) {\n   30:   return reader.read().then((result) => {\n   31      if (result.done) {\n   32        return undefined;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/types/readable-stream.ts:\n   57  \n   58  const defaultReader: polyfill.ReadableStreamDefaultReader<string> = readableStream.getReader();\n   59: const defaultReaderReadPromise: Promise<polyfill.ReadableStreamDefaultReadResult<string>> = defaultReader.read();\n   60  defaultReaderReadPromise.then((result) => {\n   61    const done: boolean = result.done;\n   ..\n   70  \n   71  const byobReader: polyfill.ReadableStreamBYOBReader = readableByteStream.getReader({ mode: 'byob' });\n   72: const byobReaderReadUint32Promise: Promise<polyfill.ReadableStreamBYOBReadResult<Uint32Array>> = byobReader.read(new Uint32Array(3));\n   73: const byobReaderReadDataViewPromise: Promise<polyfill.ReadableStreamBYOBReadResult<DataView>> = byobReader.read(\n   74    new DataView(new ArrayBuffer(3))\n   75  );\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/types/writable-stream.ts:\n    7      c.error(new TypeError('error'));\n    8    },\n    9:   write(chunk: string, c: polyfill.WritableStreamDefaultController) {\n   10      return Promise.resolve();\n   11    },\n   ..\n   32  const writerClosedPromise: Promise<void> = writer.closed;\n   33  const writerReadyPromise: Promise<void> = writer.ready;\n   34: const writerWritePromise: Promise<void> = writer.write('a');\n   35  const writerClosePromise: Promise<void> = writer.close();\n   36  const writerAbortPromise: Promise<void> = writer.abort('aborted');\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/types/polyfill.ts:\n   11  const defaultReader = readable.getReader();\n   12  defaultReader.closed.catch(() => undefined);\n   13: defaultReader.read().then(result => {\n   14    const done: boolean = result.done;\n   15    if (result.done) {\n   ..\n   23  const byobReader = readable.getReader({ mode: 'byob' });\n   24  byobReader.closed.catch(() => undefined);\n   25: byobReader.read(new Uint32Array(3)).then(result => {\n   26    const done: boolean = result.done;\n   27    if (result.done) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/webpack/src/index.js:\n    7    }\n    8  }).pipeTo(new WritableStream({\n    9:   write(chunk) {\n   10      console.log(chunk);\n   11    }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/unit/readable-stream/basic.spec.js:\n   20        });\n   21        const reader = rs.getReader();\n   22:       expect(await reader.read()).toEqual({ done: false, value: 'a' });\n   23:       expect(await reader.read()).toEqual({ done: false, value: 'b' });\n   24:       expect(await reader.read()).toEqual({ done: true, value: undefined });\n   25      });\n   26    });\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/unit/readable-stream/from.spec.js:\n   14      expect(wrapped instanceof ReadableStream).toBe(true);\n   15      const reader = wrapped.getReader();\n   16:     await expectAsync(reader.read()).toBeResolvedTo({ done: false, value: 'a' });\n   17:     await expectAsync(reader.read()).toBeResolvedTo({ done: false, value: 'b' });\n   18:     await expectAsync(reader.read()).toBeResolvedTo({ done: true, value: undefined });\n   19    });\n   20  \n   ..\n   24      const readerLike = {\n   25        get closed() { return closedPromise; },\n   26:       async read() { return { done: false, value: ++i }; },\n   27        async cancel() {},\n   28        releaseLock() {}\n   ..\n   34      expect(wrapped instanceof ReadableStream).toBe(true);\n   35      const reader = wrapped.getReader();\n   36:     await expectAsync(reader.read()).toBeResolvedTo({ done: false, value: 1 });\n   37:     await expectAsync(reader.read()).toBeResolvedTo({ done: false, value: 2 });\n   38    });\n   39  });\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/unit/readable-stream/regression.spec.js:\n    8      const producer = (async () => {\n    9        const writer = writable.getWriter();\n   10:       await writer.write('hello');\n   11        // The async iterator releases its reader lock in the \"close steps\" of its pending read, which rejects the\n   12        // reader's closed promise. However, ReadableStreamClose then tries to resolve that same closed promise.\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/rollup/src/index.js:\n    7    }\n    8  }).pipeTo(new WritableStream({\n    9:   write(chunk) {\n   10      console.log(chunk);\n   11    }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream.d.ts:\n   47       * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n   48       * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n   49:      * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n   50       * control over allocation.\n   51       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/writable-stream.d.ts:\n   94       *\n   95       * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n   96:      * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n   97       * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n   98       * other producers from writing in an interleaved manner.\n   ..\n  101      /**\n  102       * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n  103:      * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n  104       * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n  105       * errored before the writing process is initiated.\n  ...\n  108       * accepted, and not necessarily that it is safely saved to its ultimate destination.\n  109       */\n  110:     write(chunk: W): Promise<void>;\n  111  }\n  112  declare function WritableStreamDefaultWriterCloseWithErrorPropagation(writer: WritableStreamDefaultWriter): Promise<undefined>;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/transform-stream.ts:\n  257  function TransformStreamUnblockWrite(stream: TransformStream) {\n  258    if (stream._backpressure) {\n  259:     // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n  260      // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n  261      // _backpressure is set.\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/writable-stream.js:\n  139      // producer without waiting for the queued writes to finish.\n  140      stream._writeRequests = new SimpleQueue();\n  141:     // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  142:     // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  143      stream._inFlightWriteRequest = undefined;\n  144      // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  ...\n  509       *\n  510       * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n  511:      * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n  512       * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n  513       * other producers from writing in an interleaved manner.\n  ...\n  524          WritableStreamDefaultWriterRelease(this);\n  525      }\n  526:     write(chunk = undefined) {\n  527          if (!IsWritableStreamDefaultWriter(this)) {\n  528              return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n  ...\n  784      }\n  785      if (underlyingSink.write !== undefined) {\n  786:         writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n  787      }\n  788      else {\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream.ts:\n  173     * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n  174     * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n  175:    * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n  176     * control over allocation.\n  177     */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/writable-stream.ts:\n  263    stream._writeRequests = new SimpleQueue();\n  264  \n  265:   // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  266:   // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  267    stream._inFlightWriteRequest = undefined;\n  268  \n  ...\n  742     *\n  743     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n  744:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n  745     * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n  746     * other producers from writing in an interleaved manner.\n  ...\n  764    /**\n  765     * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n  766:    * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n  767     * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n  768     * errored before the writing process is initiated.\n  ...\n  771     * accepted, and not necessarily that it is safely saved to its ultimate destination.\n  772     */\n  773:   write(chunk: W): Promise<void>;\n  774:   write(chunk: W = undefined!): Promise<void> {\n  775      if (!IsWritableStreamDefaultWriter(this)) {\n  776        return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/transform-stream.js:\n  143  function TransformStreamUnblockWrite(stream) {\n  144      if (stream._backpressure) {\n  145:         // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n  146          // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n  147          // _backpressure is set.\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/from.js:\n   68          let readPromise;\n   69          try {\n   70:             readPromise = reader.read();\n   71          }\n   72          catch (e) {\n   ..\n   75          return transformPromiseWith(readPromise, (readResult) => {\n   76              if (!typeIsObject(readResult)) {\n   77:                 throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\n   78              }\n   79              if (readResult.done) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/readable-stream-like.ts:\n   23    cancel(reason?: any): Promise<void>;\n   24  \n   25:   read(): Promise<ReadableStreamDefaultReadResult<R>>;\n   26  \n   27    releaseLock(): void;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/from.ts:\n   78      let readPromise;\n   79      try {\n   80:       readPromise = reader.read();\n   81      } catch (e) {\n   82        return promiseRejectedWith(e);\n   ..\n   84      return transformPromiseWith(readPromise, (readResult) => {\n   85        if (!typeIsObject(readResult)) {\n   86:         throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\n   87        }\n   88        if (readResult.done) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byob-reader.d.ts:\n   52       *\n   53       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   54:      * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n   55       * do so will throw a `TypeError` and leave the reader locked to the stream.\n   56       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byte-stream-controller.ts:\n  549    const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\n  550    const maxAlignedBytes = maxBytesFilled - remainderBytes;\n  551:   // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  552    // of the queue, so the underlying source can keep filling it.\n  553    if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n  ...\n  695      // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n  696      // - No change happens on desiredSize\n  697:     // - The source has already been notified of that there's at least 1 pending read(view)\n  698  \n  699      ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n  ...\n  769  \n  770    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\n  771:     // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  772      // of the queue, so the underlying source can keep filling it.\n  773      return;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/readable-stream-like.d.ts:\n   17      readonly closed: Promise<undefined>;\n   18      cancel(reason?: any): Promise<void>;\n   19:     read(): Promise<ReadableStreamDefaultReadResult<R>>;\n   20      releaseLock(): void;\n   21  }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/default-reader.d.ts:\n   43       * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   44       */\n   45:     read(): Promise<ReadableStreamDefaultReadResult<R>>;\n   46      /**\n   47       * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   ..\n   50       *\n   51       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   52:      * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n   53       * do so will throw a `TypeError` and leave the reader locked to the stream.\n   54       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/default-reader.ts:\n  148     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  149     */\n  150:   read(): Promise<ReadableStreamDefaultReadResult<R>> {\n  151      if (!IsReadableStreamDefaultReader(this)) {\n  152        return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  ...\n  178     *\n  179     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  180:    * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  181     * do so will throw a `TypeError` and leave the reader locked to the stream.\n  182     */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byob-reader.js:\n   86          return ReadableStreamReaderGenericCancel(this, reason);\n   87      }\n   88:     read(view, rawOptions = {}) {\n   89          if (!IsReadableStreamBYOBReader(this)) {\n   90              return promiseRejectedWith(byobReaderBrandCheckException('read'));\n   ..\n  144       *\n  145       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  146:      * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n  147       * do so will throw a `TypeError` and leave the reader locked to the stream.\n  148       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byob-reader.ts:\n  236     *\n  237     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  238:    * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n  239     * do so will throw a `TypeError` and leave the reader locked to the stream.\n  240     */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/default-reader.js:\n   84       * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   85       */\n   86:     read() {\n   87          if (!IsReadableStreamDefaultReader(this)) {\n   88              return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n   ..\n  111       *\n  112       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  113:      * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  114       * do so will throw a `TypeError` and leave the reader locked to the stream.\n  115       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byte-stream-controller.js:\n  330      const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\n  331      const maxAlignedBytes = maxBytesFilled - remainderBytes;\n  332:     // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  333      // of the queue, so the underlying source can keep filling it.\n  334      if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n  ...\n  442          // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n  443          // - No change happens on desiredSize\n  444:         // - The source has already been notified of that there's at least 1 pending read(view)\n  445          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n  446          return;\n  ...\n  493      }\n  494      if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\n  495:         // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  496          // of the queue, so the underlying source can keep filling it.\n  497          return;\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/fetch.js:\n   99  \n  100              if(len !== undefined) {\n  101:               len += write('TEST\\r\\n', ab, len);\n  102                len += wsi.clientHttpMultipart('file', 'roman.txt', 'text/plain', ab, len);\n  103:               len += write('text file content\\r\\n\\r\\n', ab, len);\n  104                len += wsi.clientHttpMultipart(null, null, null, ab, len);\n  105  \n  106:               wsi.write(ab, len, LWS_WRITE_HTTP_FINAL);\n  107  \n  108                wsi.bodyPending = 0;\n  ...\n  110                console.log('clientHttpMultipart', { max_len: ab.byteLength, len, buf: toString(ab.slice(0, len ?? 0)) });\n  111              } else {\n  112:               wsi.write('TEST!\\r\\n');\n  113              }\n  114            },\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/serve.js:\n  104            await waitWrite(wsi);\n  105  \n  106:           wsi.write(data);\n  107          },\n  108          onFilterHttpConnection(wsi, url) {\n  ...\n  132            obj.len = (obj.len ?? 0) + buf.byteLength;\n  133  \n  134:           Body.write(req, buf);\n  135          },\n  136          async onHttpBodyCompletion(wsi) {\n  ...\n  149            await waitWrite(wsi);\n  150  \n  151:           wsi.write(`Uploaded ${len} bytes\\r\\n`, LWS_WRITE_HTTP_FINAL);\n  152          },\n  153          onHttpWriteable(wsi) {\n  ...\n  184              await waitWrite(wsi);\n  185  \n  186:             wsi.write(`TEST\\r\\n`, LWS_WRITE_HTTP_FINAL);\n  187            }\n  188          },\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/websocket.js:\n   34    }\n   35  \n   36:   send(data) {\n   37:     return this.#wsi.write(data);\n   38    }\n   39  \n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/tcpSocket.js:\n   51    }\n   52  \n   53:   send(data) {\n   54:     return this.#wsi.write(data);\n   55    }\n   56  \n   ..\n  159                  await ctor.waitWrite(this.#sock);\n  160  \n  161:                 return this.#sock.send(chunk);\n  162                },\n  163                close: () => this.#sock.close(),\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/websocketstream.js:\n   48                  await ctor.waitWrite(this.#ws);\n   49  \n   50:                 return this.#ws.send(chunk);\n   51                },\n   52                close: () => this.#ws.close(),\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/lws/util.js:\n   23    let result;\n   24  \n   25:   while((result = await rd.read())) {\n   26      const { value, done } = result;\n   27  \n   28      await waitWrite(wsi);\n   29:     let r = wsi.write(done ? '\\n' : value, done ? 1 : value.byteLength, done ? LWS_WRITE_HTTP_FINAL : LWS_WRITE_HTTP);\n   30      if(done) break;\n   31    }\n   ..\n   53    const rd = st.getReader();\n   54  \n   55:   const { value, done } = await rd.read();\n   56  \n   57    rd.releaseLock();\n   ..\n   71    //if(wr.closed) throw new Error(`Stream closed`);\n   72  \n   73:   const result = wr.write(chunk);\n   74  \n   75    wr.releaseLock();\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/lws/streams.js:\n  287     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  288     */\n  289:   read() {\n  290      if(!IsReadableStreamDefaultReader(this)) return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  291      if(this._ownerReadableStream === undefined) return promiseRejectedWith(readerLockException('read from'));\n  ...\n  311     *\n  312     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  313:    * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  314     * do so will throw a `TypeError` and leave the reader locked to the stream.\n  315     */\n  ...\n 1319    }\n 1320  \n 1321:   read(view, rawOptions = {}) {\n 1322      if(!IsReadableStreamBYOBReader(this)) return promiseRejectedWith(byobReaderBrandCheckException('read'));\n 1323      if(!ArrayBuffer.isView(view)) return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n ....\n 1365     *\n 1366     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n 1367:    * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n 1368     * do so will throw a `TypeError` and leave the reader locked to the stream.\n 1369     */\n ....\n 1546      const controller = Object.create(WritableStreamDefaultController.prototype);\n 1547      const startAlgorithm = underlyingSink.start !== undefined ? () => underlyingSink.start(controller) : () => undefined;\n 1548:     const writeAlgorithm = underlyingSink.write !== undefined ? chunk => underlyingSink.write(chunk, controller) : () => promiseResolvedWith(undefined);\n 1549      const closeAlgorithm = underlyingSink.close !== undefined ? () => underlyingSink.close() : () => promiseResolvedWith(undefined);\n 1550      const abortAlgorithm = underlyingSink.abort !== undefined ? reason => underlyingSink.abort(reason) : () => promiseResolvedWith(undefined);\n ....\n 1905     *\n 1906     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n 1907:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n 1908     * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n 1909     * other producers from writing in an interleaved manner.\n ....\n 1917    }\n 1918  \n 1919:   write(chunk = undefined) {\n 1920      if(!IsWritableStreamDefaultWriter(this)) return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n 1921      if(this._ownerWritableStream === undefined) return promiseRejectedWith(defaultWriterLockException('write to'));\n ....\n 3225          let readPromise;\n 3226          try {\n 3227:           readPromise = reader.read();\n 3228          } catch(e) {\n 3229            return promiseRejectedWith(e);\n 3230          }\n 3231          return transformPromiseWith(readPromise, readResult => {\n 3232:           if(!typeIsObject(readResult)) throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\n 3233            if(readResult.done) {\n 3234              ReadableStreamDefaultControllerClose(stream._readableStreamController);\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/lws/body.old.js:\n  229     * @param  {ArrayBuffer} chunk     Chunk of data.\n  230     */\n  231:   static write(instance, chunk) {\n  232      console.log('Body.write', chunk);\n  233      if(instance.#chunks) {\n  ...\n  255    static close(instance) {\n  256      console.log('Body.close');\n  257:     this.write(instance, null);\n  258    }\n  259  \n  ...\n  266    static error(instance, error) {\n  267      console.log('Body.error', error);\n  268:     this.write(instance, new ReadError(error));\n  269    }\n  270  }\n\n257 matches across 91 files\n\n\nSearching 681 files for \"\\s\\b(read|recv|write|send)(|to)\\(\" (regex, case sensitive)\n\n~/Projects/plot-cv/quickjs/qjs-lws/out/web.js:\n 1042      {\n 1043        key: 'write',\n 1044:       value: function write() {\n 1045          var chunk = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : undefined;\n 1046          if(!IsWritableStreamDefaultWriter(this)) return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n ....\n 2647      {\n 2648        key: 'read',\n 2649:       value: function read() {\n 2650          if(!IsReadableStreamDefaultReader(this)) return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n 2651          if(this._ownerReadableStream === undefined) return promiseRejectedWith(readerLockException('read from'));\n ....\n 3387      {\n 3388        key: 'read',\n 3389:       value: function read(view) {\n 3390          var rawOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n 3391          if(!IsReadableStreamBYOBReader(this)) return promiseRejectedWith(byobReaderBrandCheckException('read'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets.h:\n  478  #endif\n  479  \n  480: ssize_t recv(int sockfd, void *buf, size_t len, int flags);\n  481: ssize_t send(int sockfd, const void *buf, size_t len, int flags);\n  482: ssize_t read(int fd, void *buf, size_t count);\n  483  int getsockopt(int sockfd, int level, int optname,\n  484                        void *optval, socklen_t *optlen);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-ring.h:\n   59   *  - lws_ring_bump_head()\n   60   *\n   61:  *  which let you, eg, read() directly into the ringbuffer without needing\n   62   *  an intermediate bounce buffer.\n   63   *\n   ..\n  179   *\n  180   * Points to the next element that tail would consume, directly in the\n  181:  * ringbuffer.  This lets you write() or otherwise use the element without\n  182   * having to copy it out somewhere first.\n  183   *\n  ...\n  227   * The api reports the position and length of the next linear range that can\n  228   * be written in the ringbuffer, ie, up to the point it would wrap, and sets\n  229:  * *start and *bytes accordingly.  You can then, eg, directly read() into\n  230   * *start for up to *bytes, and use lws_ring_bump_head() to update the lws_ring\n  231   * with what you have done.\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-writeable.h:\n  194   * lws_get_socket_fd() - returns the socket file descriptor\n  195   *\n  196:  * This is needed to use sendto() on UDP raw sockets\n  197   *\n  198   * \\param wsi:\tWebsocket connection instance\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-protocols-plugins.h:\n   74  \t\t\there it can later access from the protocol callback */\n   75  \tsize_t tx_packet_size;\n   76: \t/**< 0 indicates restrict send() size to .rx_buffer_size for backwards-\n   77  \t * compatibility.\n   78: \t * If greater than zero, a single send() is restricted to this amount\n   79  \t * and any remainder is buffered by lws and sent afterwards also in\n   80  \t * these size chunks.  Since that is expensive, it's preferable\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/output.c:\n  310  \tint n = 0;\n  311  #if defined(LWS_PLAT_OPTEE)\n  312: \tssize_t send(int sockfd, const void *buf, size_t len, int flags);\n  313  #endif\n  314  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/tls.c:\n  502  \n  503  \t/* and we can read at least one byte out of it */\n  504: \tn = read(fd, buf, 1);\n  505  \tclose(fd);\n  506  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/tls-server.c:\n  192  \t\t\t */\n  193  \n  194: \t\t\ts = recv(wsi->desc.sockfd, (char *)pt->serv_buf,\n  195  \t\t\t\t context->pt_serv_buf_size, MSG_PEEK);\n  196  \t\t\t/*\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/windows/windows-pipe.c:\n  114  \t */\n  115  \n  116: \tn = sendto(fd[1], &u, 1, 0, (struct sockaddr *)si, sizeof(*si));\n  117  \n  118  \treturn n != 1;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/windows/windows-sockets.c:\n  618  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  619  \n  620: \tret = send(fd, (const char *)buf, (unsigned int)len, 0);\n  621  \tif (ret >= 0)\n  622  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-misc.c:\n  100  \tssize_t n;\n  101  \n  102: \tn = write(fd, buf, len);\n  103  \n  104  \tif (n < 0 || fsync(fd))\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-spawn.c:\n  354  \t}\n  355  \n  356: \tr = read(fd, s, sizeof(s) - 1);\n  357  \tclose(fd);\n  358  \tif (r < 0) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-resolv.c:\n   45  \t\treturn LADNS_CONF_SERVER_UNKNOWN;\n   46  \n   47: \tn = read(fd, r, context->pt_serv_buf_size - 1);\n   48  \tclose(fd);\n   49  \tif (n < 0)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-file.c:\n   55  \t\treturn 1;\n   56  \n   57: \tm = write(fd, buf, len);\n   58  \tclose(fd);\n   59  \n   ..\n   73  \t\treturn -1;\n   74  \n   75: \tn = read(fd, buf, len);\n   76  \tclose(fd);\n   77  \n   ..\n  152  \tssize_t n;\n  153  \n  154: \tn = read((int)fop_fd->fd, buf, (size_t)len);\n  155  \tif (n == -1l) {\n  156  \t\t*amount = 0;\n  ...\n  172  \tssize_t n;\n  173  \n  174: \tn = write((int)fop_fd->fd, buf, (size_t)len);\n  175  \tif (n == -1) {\n  176  \t\t*amount = 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-file.c:\n   88  \tlong n;\n   89  \n   90: \tn = read(fops_fd->fd, buf, len);\n   91  \tif (n == -1) {\n   92  \t\t*amount = 0;\n   ..\n  105  \tlong n;\n  106  \n  107: \tn = write(fops_fd->fd, buf, len);\n  108  \tif (n == -1) {\n  109  \t\t*amount = 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-sockets.c:\n  355  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  356  \n  357: \tret = write(fd, buf, len);\n  358  \tif (ret >= 0)\n  359  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/optee/network.c:\n  285  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  286  \n  287: \tret = write(fd, buf, len);\n  288  \tif (ret >= 0)\n  289  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/pipe/ops-pipe.c:\n   56  \tint n;\n   57  \n   58: \tn = recv(wsi->desc.sockfd, s, sizeof(s), 0);\n   59  \tif (n == SOCKET_ERROR)\n   60  \t\treturn LWS_HPI_RET_PLEASE_CLOSE_ME;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/system/async-dns/async-dns.c:\n  878  \t\ts = _read(fd, buf, sizeof(buf) - 1);\n  879  #else\n  880: \t\ts = read(fd, buf, sizeof(buf) - 1);\n  881  #endif\n  882  \t\tif (s <= 0) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/cache-ttl/file.c:\n  179  \t\t\t * Removing this function from Coverity\n  180  \t\t\t */\n  181: \t\t\tn1s = read(fd, temp + n, sizeof(temp) - (size_t)n);\n  182  \n  183  \t\tlwsl_debug(\"%s: n1 %d\\n\", __func__, (int)n1s);\n  ...\n  657  \tif (lws_fi(&cache->cache.info.cx->fic, \"cache_regen_temp_write\") ||\n  658  \t/* other consumers insist to see this at start of cookie jar */\n  659: \t    write(ctx.fdt, \"# Netscape HTTP Cookie File\\n\", 28) != 28)\n  660  \t\tgoto bail1;\n  661  \n  ...\n  663  \n  664  \tif (pay &&\n  665: \t    write(ctx.fdt, pay, /*msvc*/(unsigned int)pay_size) !=\n  666  \t\t\t\t\t\t    (ssize_t)pay_size)\n  667  \t\tgoto bail1;\n  668: \tif (pay && write(ctx.fdt, \"\\n\", 1u) != (ssize_t)1)\n  669  \t\tgoto bail1;\n  670  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/lwsac/cached-file.c:\n  192  \ta[s.st_size] = '\\0';\n  193  \n  194: \trd = read(fd, a, (unsigned long)s.st_size);\n  195  \tif (rd != s.st_size) {\n  196  \t\tlwsl_err(\"%s: cannot read %s (%d)\\n\", __func__, filepath,\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/fts/trie.c:\n 1039  \t\t\tif (!strcmp(ne, \"describ\")) {\n 1040  \t\t\t\tlwsl_err(\"     %s %d\\n\", ne, t->str_match_pos);\n 1041: \t\t\t\twrite(1, buf - 10, 20);\n 1042  \t\t\t}\n 1043  \t\t}\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/readable-stream.js:\n  518       * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  519       */\n  520:     read() {\n  521          if (!IsReadableStreamDefaultReader(this)) {\n  522              return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  ...\n  545       *\n  546       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  547:      * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  548       * do so will throw a `TypeError` and leave the reader locked to the stream.\n  549       */\n  ...\n 1316      const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\n 1317      const maxAlignedBytes = maxBytesFilled - remainderBytes;\n 1318:     // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n 1319      // of the queue, so the underlying source can keep filling it.\n 1320      if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n ....\n 1428          // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n 1429          // - No change happens on desiredSize\n 1430:         // - The source has already been notified of that there's at least 1 pending read(view)\n 1431          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n 1432          return;\n ....\n 1479      }\n 1480      if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\n 1481:         // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n 1482          // of the queue, so the underlying source can keep filling it.\n 1483          return;\n ....\n 1886          return ReadableStreamReaderGenericCancel(this, reason);\n 1887      }\n 1888:     read(view, rawOptions = {}) {\n 1889          if (!IsReadableStreamBYOBReader(this)) {\n 1890              return promiseRejectedWith(byobReaderBrandCheckException('read'));\n ....\n 1944       *\n 1945       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n 1946:      * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n 1947       * do so will throw a `TypeError` and leave the reader locked to the stream.\n 1948       */\n ....\n 2263      // producer without waiting for the queued writes to finish.\n 2264      stream._writeRequests = new SimpleQueue();\n 2265:     // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n 2266:     // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n 2267      stream._inFlightWriteRequest = undefined;\n 2268      // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n ....\n 2633       *\n 2634       * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n 2635:      * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n 2636       * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n 2637       * other producers from writing in an interleaved manner.\n ....\n 2648          WritableStreamDefaultWriterRelease(this);\n 2649      }\n 2650:     write(chunk = undefined) {\n 2651          if (!IsWritableStreamDefaultWriter(this)) {\n 2652              return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/ponyfill.js:\n  425     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  426     */\n  427:   read() {\n  428      if(!IsReadableStreamDefaultReader(this)) {\n  429        return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  ...\n  452     *\n  453     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  454:    * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  455     * do so will throw a `TypeError` and leave the reader locked to the stream.\n  456     */\n  ...\n 1682      return ReadableStreamReaderGenericCancel(this, reason);\n 1683    }\n 1684:   read(view, rawOptions = {}) {\n 1685      if(!IsReadableStreamBYOBReader(this)) {\n 1686        return promiseRejectedWith(byobReaderBrandCheckException('read'));\n ....\n 1738     *\n 1739     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n 1740:    * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n 1741     * do so will throw a `TypeError` and leave the reader locked to the stream.\n 1742     */\n ....\n 2354     *\n 2355     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n 2356:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n 2357     * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n 2358     * other producers from writing in an interleaved manner.\n ....\n 2369      WritableStreamDefaultWriterRelease(this);\n 2370    }\n 2371:   write(chunk = void 0) {\n 2372      if(!IsWritableStreamDefaultWriter(this)) {\n 2373        return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/out.js:\n  425     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  426     */\n  427:   read() {\n  428      if(!IsReadableStreamDefaultReader(this)) {\n  429        return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  ...\n  452     *\n  453     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  454:    * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  455     * do so will throw a `TypeError` and leave the reader locked to the stream.\n  456     */\n  ...\n 1566      return ReadableStreamReaderGenericCancel(this, reason);\n 1567    }\n 1568:   read(view, rawOptions = {}) {\n 1569      if(!IsReadableStreamBYOBReader(this)) {\n 1570        return promiseRejectedWith(byobReaderBrandCheckException('read'));\n ....\n 1622     *\n 1623     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n 1624:    * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n 1625     * do so will throw a `TypeError` and leave the reader locked to the stream.\n 1626     */\n ....\n 2237     *\n 2238     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n 2239:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n 2240     * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n 2241     * other producers from writing in an interleaved manner.\n ....\n 2252      WritableStreamDefaultWriterRelease(this);\n 2253    }\n 2254:   write(chunk = void 0) {\n 2255      if(!IsWritableStreamDefaultWriter(this)) {\n 2256        return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n ....\n 5746     *\n 5747     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n 5748:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n 5749     * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n 5750     * other producers from writing in an interleaved manner.\n ....\n 5761      WritableStreamDefaultWriterRelease2(this);\n 5762    }\n 5763:   write(chunk = void 0) {\n 5764      if(!IsWritableStreamDefaultWriter2(this)) {\n 5765        return promiseRejectedWith(defaultWriterBrandCheckException2('write'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/writable-stream.js:\n  150    // producer without waiting for the queued writes to finish.\n  151    stream._writeRequests = new SimpleQueue();\n  152:   // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  153:   // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  154    stream._inFlightWriteRequest = undefined;\n  155    // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  ...\n  519     *\n  520     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n  521:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n  522     * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n  523     * other producers from writing in an interleaved manner.\n  ...\n  534      WritableStreamDefaultWriterRelease(this);\n  535    }\n  536:   write(chunk = undefined) {\n  537      if(!IsWritableStreamDefaultWriter(this)) {\n  538        return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/bun.js:\n  407      return ReadableStreamReaderGenericCancel(this, reason);\n  408    }\n  409:   read() {\n  410      if(!IsReadableStreamDefaultReader(this)) {\n  411        return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  ...\n 1647      return ReadableStreamReaderGenericCancel(this, reason);\n 1648    }\n 1649:   read(view, rawOptions = {}) {\n 1650      if(!IsReadableStreamBYOBReader(this)) {\n 1651        return promiseRejectedWith(byobReaderBrandCheckException('read'));\n ....\n 2280      WritableStreamDefaultWriterRelease(this);\n 2281    }\n 2282:   write(chunk = undefined) {\n 2283      if(!IsWritableStreamDefaultWriter(this)) {\n 2284        return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/transform-stream.js:\n  151  function TransformStreamUnblockWrite(stream) {\n  152    if(stream._backpressure) {\n  153:     // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n  154      // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n  155      // _backpressure is set.\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/types/writable-stream.ts:\n    7      c.error(new TypeError('error'));\n    8    },\n    9:   write(chunk: string, c: polyfill.WritableStreamDefaultController) {\n   10      return Promise.resolve();\n   11    },\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/webpack/src/index.js:\n    7    }\n    8  }).pipeTo(new WritableStream({\n    9:   write(chunk) {\n   10      console.log(chunk);\n   11    }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/unit/readable-stream/from.spec.js:\n   24      const readerLike = {\n   25        get closed() { return closedPromise; },\n   26:       async read() { return { done: false, value: ++i }; },\n   27        async cancel() {},\n   28        releaseLock() {}\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/rollup/src/index.js:\n    7    }\n    8  }).pipeTo(new WritableStream({\n    9:   write(chunk) {\n   10      console.log(chunk);\n   11    }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream.d.ts:\n   47       * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n   48       * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n   49:      * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n   50       * control over allocation.\n   51       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/writable-stream.d.ts:\n   94       *\n   95       * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n   96:      * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n   97       * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n   98       * other producers from writing in an interleaved manner.\n   ..\n  101      /**\n  102       * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n  103:      * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n  104       * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n  105       * errored before the writing process is initiated.\n  ...\n  108       * accepted, and not necessarily that it is safely saved to its ultimate destination.\n  109       */\n  110:     write(chunk: W): Promise<void>;\n  111  }\n  112  declare function WritableStreamDefaultWriterCloseWithErrorPropagation(writer: WritableStreamDefaultWriter): Promise<undefined>;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/transform-stream.ts:\n  257  function TransformStreamUnblockWrite(stream: TransformStream) {\n  258    if (stream._backpressure) {\n  259:     // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n  260      // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n  261      // _backpressure is set.\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/writable-stream.js:\n  139      // producer without waiting for the queued writes to finish.\n  140      stream._writeRequests = new SimpleQueue();\n  141:     // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  142:     // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  143      stream._inFlightWriteRequest = undefined;\n  144      // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  ...\n  509       *\n  510       * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n  511:      * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n  512       * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n  513       * other producers from writing in an interleaved manner.\n  ...\n  524          WritableStreamDefaultWriterRelease(this);\n  525      }\n  526:     write(chunk = undefined) {\n  527          if (!IsWritableStreamDefaultWriter(this)) {\n  528              return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream.ts:\n  173     * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n  174     * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n  175:    * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n  176     * control over allocation.\n  177     */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/writable-stream.ts:\n  263    stream._writeRequests = new SimpleQueue();\n  264  \n  265:   // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  266:   // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  267    stream._inFlightWriteRequest = undefined;\n  268  \n  ...\n  742     *\n  743     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n  744:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n  745     * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n  746     * other producers from writing in an interleaved manner.\n  ...\n  764    /**\n  765     * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n  766:    * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n  767     * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n  768     * errored before the writing process is initiated.\n  ...\n  771     * accepted, and not necessarily that it is safely saved to its ultimate destination.\n  772     */\n  773:   write(chunk: W): Promise<void>;\n  774:   write(chunk: W = undefined!): Promise<void> {\n  775      if (!IsWritableStreamDefaultWriter(this)) {\n  776        return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/transform-stream.js:\n  143  function TransformStreamUnblockWrite(stream) {\n  144      if (stream._backpressure) {\n  145:         // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n  146          // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n  147          // _backpressure is set.\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/readable-stream-like.ts:\n   23    cancel(reason?: any): Promise<void>;\n   24  \n   25:   read(): Promise<ReadableStreamDefaultReadResult<R>>;\n   26  \n   27    releaseLock(): void;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byob-reader.d.ts:\n   52       *\n   53       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   54:      * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n   55       * do so will throw a `TypeError` and leave the reader locked to the stream.\n   56       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byte-stream-controller.ts:\n  549    const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\n  550    const maxAlignedBytes = maxBytesFilled - remainderBytes;\n  551:   // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  552    // of the queue, so the underlying source can keep filling it.\n  553    if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n  ...\n  695      // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n  696      // - No change happens on desiredSize\n  697:     // - The source has already been notified of that there's at least 1 pending read(view)\n  698  \n  699      ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n  ...\n  769  \n  770    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\n  771:     // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  772      // of the queue, so the underlying source can keep filling it.\n  773      return;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/readable-stream-like.d.ts:\n   17      readonly closed: Promise<undefined>;\n   18      cancel(reason?: any): Promise<void>;\n   19:     read(): Promise<ReadableStreamDefaultReadResult<R>>;\n   20      releaseLock(): void;\n   21  }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/default-reader.d.ts:\n   43       * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   44       */\n   45:     read(): Promise<ReadableStreamDefaultReadResult<R>>;\n   46      /**\n   47       * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   ..\n   50       *\n   51       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   52:      * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n   53       * do so will throw a `TypeError` and leave the reader locked to the stream.\n   54       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/default-reader.ts:\n  148     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  149     */\n  150:   read(): Promise<ReadableStreamDefaultReadResult<R>> {\n  151      if (!IsReadableStreamDefaultReader(this)) {\n  152        return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  ...\n  178     *\n  179     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  180:    * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  181     * do so will throw a `TypeError` and leave the reader locked to the stream.\n  182     */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byob-reader.js:\n   86          return ReadableStreamReaderGenericCancel(this, reason);\n   87      }\n   88:     read(view, rawOptions = {}) {\n   89          if (!IsReadableStreamBYOBReader(this)) {\n   90              return promiseRejectedWith(byobReaderBrandCheckException('read'));\n   ..\n  144       *\n  145       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  146:      * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n  147       * do so will throw a `TypeError` and leave the reader locked to the stream.\n  148       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byob-reader.ts:\n  236     *\n  237     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  238:    * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n  239     * do so will throw a `TypeError` and leave the reader locked to the stream.\n  240     */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/default-reader.js:\n   84       * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   85       */\n   86:     read() {\n   87          if (!IsReadableStreamDefaultReader(this)) {\n   88              return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n   ..\n  111       *\n  112       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  113:      * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  114       * do so will throw a `TypeError` and leave the reader locked to the stream.\n  115       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byte-stream-controller.js:\n  330      const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\n  331      const maxAlignedBytes = maxBytesFilled - remainderBytes;\n  332:     // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  333      // of the queue, so the underlying source can keep filling it.\n  334      if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n  ...\n  442          // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n  443          // - No change happens on desiredSize\n  444:         // - The source has already been notified of that there's at least 1 pending read(view)\n  445          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n  446          return;\n  ...\n  493      }\n  494      if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\n  495:         // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  496          // of the queue, so the underlying source can keep filling it.\n  497          return;\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/fetch.js:\n   99  \n  100              if(len !== undefined) {\n  101:               len += write('TEST\\r\\n', ab, len);\n  102                len += wsi.clientHttpMultipart('file', 'roman.txt', 'text/plain', ab, len);\n  103:               len += write('text file content\\r\\n\\r\\n', ab, len);\n  104                len += wsi.clientHttpMultipart(null, null, null, ab, len);\n  105  \n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/websocket.js:\n   34    }\n   35  \n   36:   send(data) {\n   37      return this.#wsi.write(data);\n   38    }\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/tcpSocket.js:\n   51    }\n   52  \n   53:   send(data) {\n   54      return this.#wsi.write(data);\n   55    }\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/lws/streams.js:\n  287     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  288     */\n  289:   read() {\n  290      if(!IsReadableStreamDefaultReader(this)) return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  291      if(this._ownerReadableStream === undefined) return promiseRejectedWith(readerLockException('read from'));\n  ...\n  311     *\n  312     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  313:    * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  314     * do so will throw a `TypeError` and leave the reader locked to the stream.\n  315     */\n  ...\n 1319    }\n 1320  \n 1321:   read(view, rawOptions = {}) {\n 1322      if(!IsReadableStreamBYOBReader(this)) return promiseRejectedWith(byobReaderBrandCheckException('read'));\n 1323      if(!ArrayBuffer.isView(view)) return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n ....\n 1365     *\n 1366     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n 1367:    * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n 1368     * do so will throw a `TypeError` and leave the reader locked to the stream.\n 1369     */\n ....\n 1905     *\n 1906     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n 1907:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n 1908     * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n 1909     * other producers from writing in an interleaved manner.\n ....\n 1917    }\n 1918  \n 1919:   write(chunk = undefined) {\n 1920      if(!IsWritableStreamDefaultWriter(this)) return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n 1921      if(this._ownerWritableStream === undefined) return promiseRejectedWith(defaultWriterLockException('write to'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/lws/body.old.js:\n  229     * @param  {ArrayBuffer} chunk     Chunk of data.\n  230     */\n  231:   static write(instance, chunk) {\n  232      console.log('Body.write', chunk);\n  233      if(instance.#chunks) {\n\n119 matches across 54 files\n\n\nSearching 681 files for \"\\s\\b(read|recv|write|send)(|to)\\(\" (regex, case sensitive)\n\n~/Projects/plot-cv/quickjs/qjs-lws/out/web.js:\n 1042      {\n 1043        key: 'write',\n 1044:       value: function write() {\n 1045          var chunk = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : undefined;\n 1046          if(!IsWritableStreamDefaultWriter(this)) return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n ....\n 2647      {\n 2648        key: 'read',\n 2649:       value: function read() {\n 2650          if(!IsReadableStreamDefaultReader(this)) return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n 2651          if(this._ownerReadableStream === undefined) return promiseRejectedWith(readerLockException('read from'));\n ....\n 3387      {\n 3388        key: 'read',\n 3389:       value: function read(view) {\n 3390          var rawOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n 3391          if(!IsReadableStreamBYOBReader(this)) return promiseRejectedWith(byobReaderBrandCheckException('read'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets.h:\n  478  #endif\n  479  \n  480: ssize_t recv(int sockfd, void *buf, size_t len, int flags);\n  481: ssize_t send(int sockfd, const void *buf, size_t len, int flags);\n  482: ssize_t read(int fd, void *buf, size_t count);\n  483  int getsockopt(int sockfd, int level, int optname,\n  484                        void *optval, socklen_t *optlen);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-ring.h:\n   59   *  - lws_ring_bump_head()\n   60   *\n   61:  *  which let you, eg, read() directly into the ringbuffer without needing\n   62   *  an intermediate bounce buffer.\n   63   *\n   ..\n  179   *\n  180   * Points to the next element that tail would consume, directly in the\n  181:  * ringbuffer.  This lets you write() or otherwise use the element without\n  182   * having to copy it out somewhere first.\n  183   *\n  ...\n  227   * The api reports the position and length of the next linear range that can\n  228   * be written in the ringbuffer, ie, up to the point it would wrap, and sets\n  229:  * *start and *bytes accordingly.  You can then, eg, directly read() into\n  230   * *start for up to *bytes, and use lws_ring_bump_head() to update the lws_ring\n  231   * with what you have done.\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-writeable.h:\n  194   * lws_get_socket_fd() - returns the socket file descriptor\n  195   *\n  196:  * This is needed to use sendto() on UDP raw sockets\n  197   *\n  198   * \\param wsi:\tWebsocket connection instance\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-protocols-plugins.h:\n   74  \t\t\there it can later access from the protocol callback */\n   75  \tsize_t tx_packet_size;\n   76: \t/**< 0 indicates restrict send() size to .rx_buffer_size for backwards-\n   77  \t * compatibility.\n   78: \t * If greater than zero, a single send() is restricted to this amount\n   79  \t * and any remainder is buffered by lws and sent afterwards also in\n   80  \t * these size chunks.  Since that is expensive, it's preferable\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/output.c:\n  310  \tint n = 0;\n  311  #if defined(LWS_PLAT_OPTEE)\n  312: \tssize_t send(int sockfd, const void *buf, size_t len, int flags);\n  313  #endif\n  314  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/tls.c:\n  502  \n  503  \t/* and we can read at least one byte out of it */\n  504: \tn = read(fd, buf, 1);\n  505  \tclose(fd);\n  506  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/tls-server.c:\n  192  \t\t\t */\n  193  \n  194: \t\t\ts = recv(wsi->desc.sockfd, (char *)pt->serv_buf,\n  195  \t\t\t\t context->pt_serv_buf_size, MSG_PEEK);\n  196  \t\t\t/*\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/windows/windows-pipe.c:\n  114  \t */\n  115  \n  116: \tn = sendto(fd[1], &u, 1, 0, (struct sockaddr *)si, sizeof(*si));\n  117  \n  118  \treturn n != 1;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/windows/windows-sockets.c:\n  618  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  619  \n  620: \tret = send(fd, (const char *)buf, (unsigned int)len, 0);\n  621  \tif (ret >= 0)\n  622  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-misc.c:\n  100  \tssize_t n;\n  101  \n  102: \tn = write(fd, buf, len);\n  103  \n  104  \tif (n < 0 || fsync(fd))\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-spawn.c:\n  354  \t}\n  355  \n  356: \tr = read(fd, s, sizeof(s) - 1);\n  357  \tclose(fd);\n  358  \tif (r < 0) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-resolv.c:\n   45  \t\treturn LADNS_CONF_SERVER_UNKNOWN;\n   46  \n   47: \tn = read(fd, r, context->pt_serv_buf_size - 1);\n   48  \tclose(fd);\n   49  \tif (n < 0)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-file.c:\n   55  \t\treturn 1;\n   56  \n   57: \tm = write(fd, buf, len);\n   58  \tclose(fd);\n   59  \n   ..\n   73  \t\treturn -1;\n   74  \n   75: \tn = read(fd, buf, len);\n   76  \tclose(fd);\n   77  \n   ..\n  152  \tssize_t n;\n  153  \n  154: \tn = read((int)fop_fd->fd, buf, (size_t)len);\n  155  \tif (n == -1l) {\n  156  \t\t*amount = 0;\n  ...\n  172  \tssize_t n;\n  173  \n  174: \tn = write((int)fop_fd->fd, buf, (size_t)len);\n  175  \tif (n == -1) {\n  176  \t\t*amount = 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-file.c:\n   88  \tlong n;\n   89  \n   90: \tn = read(fops_fd->fd, buf, len);\n   91  \tif (n == -1) {\n   92  \t\t*amount = 0;\n   ..\n  105  \tlong n;\n  106  \n  107: \tn = write(fops_fd->fd, buf, len);\n  108  \tif (n == -1) {\n  109  \t\t*amount = 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-sockets.c:\n  355  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  356  \n  357: \tret = write(fd, buf, len);\n  358  \tif (ret >= 0)\n  359  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/optee/network.c:\n  285  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  286  \n  287: \tret = write(fd, buf, len);\n  288  \tif (ret >= 0)\n  289  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/pipe/ops-pipe.c:\n   56  \tint n;\n   57  \n   58: \tn = recv(wsi->desc.sockfd, s, sizeof(s), 0);\n   59  \tif (n == SOCKET_ERROR)\n   60  \t\treturn LWS_HPI_RET_PLEASE_CLOSE_ME;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/system/async-dns/async-dns.c:\n  878  \t\ts = _read(fd, buf, sizeof(buf) - 1);\n  879  #else\n  880: \t\ts = read(fd, buf, sizeof(buf) - 1);\n  881  #endif\n  882  \t\tif (s <= 0) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/cache-ttl/file.c:\n  179  \t\t\t * Removing this function from Coverity\n  180  \t\t\t */\n  181: \t\t\tn1s = read(fd, temp + n, sizeof(temp) - (size_t)n);\n  182  \n  183  \t\tlwsl_debug(\"%s: n1 %d\\n\", __func__, (int)n1s);\n  ...\n  657  \tif (lws_fi(&cache->cache.info.cx->fic, \"cache_regen_temp_write\") ||\n  658  \t/* other consumers insist to see this at start of cookie jar */\n  659: \t    write(ctx.fdt, \"# Netscape HTTP Cookie File\\n\", 28) != 28)\n  660  \t\tgoto bail1;\n  661  \n  ...\n  663  \n  664  \tif (pay &&\n  665: \t    write(ctx.fdt, pay, /*msvc*/(unsigned int)pay_size) !=\n  666  \t\t\t\t\t\t    (ssize_t)pay_size)\n  667  \t\tgoto bail1;\n  668: \tif (pay && write(ctx.fdt, \"\\n\", 1u) != (ssize_t)1)\n  669  \t\tgoto bail1;\n  670  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/lwsac/cached-file.c:\n  192  \ta[s.st_size] = '\\0';\n  193  \n  194: \trd = read(fd, a, (unsigned long)s.st_size);\n  195  \tif (rd != s.st_size) {\n  196  \t\tlwsl_err(\"%s: cannot read %s (%d)\\n\", __func__, filepath,\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/fts/trie.c:\n 1039  \t\t\tif (!strcmp(ne, \"describ\")) {\n 1040  \t\t\t\tlwsl_err(\"     %s %d\\n\", ne, t->str_match_pos);\n 1041: \t\t\t\twrite(1, buf - 10, 20);\n 1042  \t\t\t}\n 1043  \t\t}\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/readable-stream.js:\n  518       * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  519       */\n  520:     read() {\n  521          if (!IsReadableStreamDefaultReader(this)) {\n  522              return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  ...\n  545       *\n  546       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  547:      * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  548       * do so will throw a `TypeError` and leave the reader locked to the stream.\n  549       */\n  ...\n 1316      const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\n 1317      const maxAlignedBytes = maxBytesFilled - remainderBytes;\n 1318:     // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n 1319      // of the queue, so the underlying source can keep filling it.\n 1320      if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n ....\n 1428          // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n 1429          // - No change happens on desiredSize\n 1430:         // - The source has already been notified of that there's at least 1 pending read(view)\n 1431          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n 1432          return;\n ....\n 1479      }\n 1480      if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\n 1481:         // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n 1482          // of the queue, so the underlying source can keep filling it.\n 1483          return;\n ....\n 1886          return ReadableStreamReaderGenericCancel(this, reason);\n 1887      }\n 1888:     read(view, rawOptions = {}) {\n 1889          if (!IsReadableStreamBYOBReader(this)) {\n 1890              return promiseRejectedWith(byobReaderBrandCheckException('read'));\n ....\n 1944       *\n 1945       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n 1946:      * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n 1947       * do so will throw a `TypeError` and leave the reader locked to the stream.\n 1948       */\n ....\n 2263      // producer without waiting for the queued writes to finish.\n 2264      stream._writeRequests = new SimpleQueue();\n 2265:     // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n 2266:     // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n 2267      stream._inFlightWriteRequest = undefined;\n 2268      // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n ....\n 2633       *\n 2634       * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n 2635:      * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n 2636       * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n 2637       * other producers from writing in an interleaved manner.\n ....\n 2648          WritableStreamDefaultWriterRelease(this);\n 2649      }\n 2650:     write(chunk = undefined) {\n 2651          if (!IsWritableStreamDefaultWriter(this)) {\n 2652              return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/ponyfill.js:\n  425     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  426     */\n  427:   read() {\n  428      if(!IsReadableStreamDefaultReader(this)) {\n  429        return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  ...\n  452     *\n  453     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  454:    * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  455     * do so will throw a `TypeError` and leave the reader locked to the stream.\n  456     */\n  ...\n 1682      return ReadableStreamReaderGenericCancel(this, reason);\n 1683    }\n 1684:   read(view, rawOptions = {}) {\n 1685      if(!IsReadableStreamBYOBReader(this)) {\n 1686        return promiseRejectedWith(byobReaderBrandCheckException('read'));\n ....\n 1738     *\n 1739     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n 1740:    * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n 1741     * do so will throw a `TypeError` and leave the reader locked to the stream.\n 1742     */\n ....\n 2354     *\n 2355     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n 2356:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n 2357     * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n 2358     * other producers from writing in an interleaved manner.\n ....\n 2369      WritableStreamDefaultWriterRelease(this);\n 2370    }\n 2371:   write(chunk = void 0) {\n 2372      if(!IsWritableStreamDefaultWriter(this)) {\n 2373        return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/out.js:\n  425     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  426     */\n  427:   read() {\n  428      if(!IsReadableStreamDefaultReader(this)) {\n  429        return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  ...\n  452     *\n  453     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  454:    * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  455     * do so will throw a `TypeError` and leave the reader locked to the stream.\n  456     */\n  ...\n 1566      return ReadableStreamReaderGenericCancel(this, reason);\n 1567    }\n 1568:   read(view, rawOptions = {}) {\n 1569      if(!IsReadableStreamBYOBReader(this)) {\n 1570        return promiseRejectedWith(byobReaderBrandCheckException('read'));\n ....\n 1622     *\n 1623     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n 1624:    * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n 1625     * do so will throw a `TypeError` and leave the reader locked to the stream.\n 1626     */\n ....\n 2237     *\n 2238     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n 2239:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n 2240     * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n 2241     * other producers from writing in an interleaved manner.\n ....\n 2252      WritableStreamDefaultWriterRelease(this);\n 2253    }\n 2254:   write(chunk = void 0) {\n 2255      if(!IsWritableStreamDefaultWriter(this)) {\n 2256        return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n ....\n 5746     *\n 5747     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n 5748:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n 5749     * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n 5750     * other producers from writing in an interleaved manner.\n ....\n 5761      WritableStreamDefaultWriterRelease2(this);\n 5762    }\n 5763:   write(chunk = void 0) {\n 5764      if(!IsWritableStreamDefaultWriter2(this)) {\n 5765        return promiseRejectedWith(defaultWriterBrandCheckException2('write'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/writable-stream.js:\n  150    // producer without waiting for the queued writes to finish.\n  151    stream._writeRequests = new SimpleQueue();\n  152:   // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  153:   // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  154    stream._inFlightWriteRequest = undefined;\n  155    // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  ...\n  519     *\n  520     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n  521:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n  522     * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n  523     * other producers from writing in an interleaved manner.\n  ...\n  534      WritableStreamDefaultWriterRelease(this);\n  535    }\n  536:   write(chunk = undefined) {\n  537      if(!IsWritableStreamDefaultWriter(this)) {\n  538        return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/bun.js:\n  407      return ReadableStreamReaderGenericCancel(this, reason);\n  408    }\n  409:   read() {\n  410      if(!IsReadableStreamDefaultReader(this)) {\n  411        return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  ...\n 1647      return ReadableStreamReaderGenericCancel(this, reason);\n 1648    }\n 1649:   read(view, rawOptions = {}) {\n 1650      if(!IsReadableStreamBYOBReader(this)) {\n 1651        return promiseRejectedWith(byobReaderBrandCheckException('read'));\n ....\n 2280      WritableStreamDefaultWriterRelease(this);\n 2281    }\n 2282:   write(chunk = undefined) {\n 2283      if(!IsWritableStreamDefaultWriter(this)) {\n 2284        return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/transform-stream.js:\n  151  function TransformStreamUnblockWrite(stream) {\n  152    if(stream._backpressure) {\n  153:     // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n  154      // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n  155      // _backpressure is set.\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/types/writable-stream.ts:\n    7      c.error(new TypeError('error'));\n    8    },\n    9:   write(chunk: string, c: polyfill.WritableStreamDefaultController) {\n   10      return Promise.resolve();\n   11    },\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/webpack/src/index.js:\n    7    }\n    8  }).pipeTo(new WritableStream({\n    9:   write(chunk) {\n   10      console.log(chunk);\n   11    }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/unit/readable-stream/from.spec.js:\n   24      const readerLike = {\n   25        get closed() { return closedPromise; },\n   26:       async read() { return { done: false, value: ++i }; },\n   27        async cancel() {},\n   28        releaseLock() {}\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/rollup/src/index.js:\n    7    }\n    8  }).pipeTo(new WritableStream({\n    9:   write(chunk) {\n   10      console.log(chunk);\n   11    }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream.d.ts:\n   47       * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n   48       * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n   49:      * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n   50       * control over allocation.\n   51       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/writable-stream.d.ts:\n   94       *\n   95       * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n   96:      * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n   97       * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n   98       * other producers from writing in an interleaved manner.\n   ..\n  101      /**\n  102       * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n  103:      * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n  104       * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n  105       * errored before the writing process is initiated.\n  ...\n  108       * accepted, and not necessarily that it is safely saved to its ultimate destination.\n  109       */\n  110:     write(chunk: W): Promise<void>;\n  111  }\n  112  declare function WritableStreamDefaultWriterCloseWithErrorPropagation(writer: WritableStreamDefaultWriter): Promise<undefined>;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/transform-stream.ts:\n  257  function TransformStreamUnblockWrite(stream: TransformStream) {\n  258    if (stream._backpressure) {\n  259:     // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n  260      // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n  261      // _backpressure is set.\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/writable-stream.js:\n  139      // producer without waiting for the queued writes to finish.\n  140      stream._writeRequests = new SimpleQueue();\n  141:     // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  142:     // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  143      stream._inFlightWriteRequest = undefined;\n  144      // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  ...\n  509       *\n  510       * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n  511:      * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n  512       * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n  513       * other producers from writing in an interleaved manner.\n  ...\n  524          WritableStreamDefaultWriterRelease(this);\n  525      }\n  526:     write(chunk = undefined) {\n  527          if (!IsWritableStreamDefaultWriter(this)) {\n  528              return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream.ts:\n  173     * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n  174     * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n  175:    * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n  176     * control over allocation.\n  177     */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/writable-stream.ts:\n  263    stream._writeRequests = new SimpleQueue();\n  264  \n  265:   // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  266:   // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  267    stream._inFlightWriteRequest = undefined;\n  268  \n  ...\n  742     *\n  743     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n  744:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n  745     * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n  746     * other producers from writing in an interleaved manner.\n  ...\n  764    /**\n  765     * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n  766:    * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n  767     * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n  768     * errored before the writing process is initiated.\n  ...\n  771     * accepted, and not necessarily that it is safely saved to its ultimate destination.\n  772     */\n  773:   write(chunk: W): Promise<void>;\n  774:   write(chunk: W = undefined!): Promise<void> {\n  775      if (!IsWritableStreamDefaultWriter(this)) {\n  776        return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/transform-stream.js:\n  143  function TransformStreamUnblockWrite(stream) {\n  144      if (stream._backpressure) {\n  145:         // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n  146          // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n  147          // _backpressure is set.\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/readable-stream-like.ts:\n   23    cancel(reason?: any): Promise<void>;\n   24  \n   25:   read(): Promise<ReadableStreamDefaultReadResult<R>>;\n   26  \n   27    releaseLock(): void;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byob-reader.d.ts:\n   52       *\n   53       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   54:      * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n   55       * do so will throw a `TypeError` and leave the reader locked to the stream.\n   56       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byte-stream-controller.ts:\n  549    const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\n  550    const maxAlignedBytes = maxBytesFilled - remainderBytes;\n  551:   // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  552    // of the queue, so the underlying source can keep filling it.\n  553    if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n  ...\n  695      // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n  696      // - No change happens on desiredSize\n  697:     // - The source has already been notified of that there's at least 1 pending read(view)\n  698  \n  699      ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n  ...\n  769  \n  770    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\n  771:     // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  772      // of the queue, so the underlying source can keep filling it.\n  773      return;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/readable-stream-like.d.ts:\n   17      readonly closed: Promise<undefined>;\n   18      cancel(reason?: any): Promise<void>;\n   19:     read(): Promise<ReadableStreamDefaultReadResult<R>>;\n   20      releaseLock(): void;\n   21  }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/default-reader.d.ts:\n   43       * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   44       */\n   45:     read(): Promise<ReadableStreamDefaultReadResult<R>>;\n   46      /**\n   47       * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   ..\n   50       *\n   51       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   52:      * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n   53       * do so will throw a `TypeError` and leave the reader locked to the stream.\n   54       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/default-reader.ts:\n  148     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  149     */\n  150:   read(): Promise<ReadableStreamDefaultReadResult<R>> {\n  151      if (!IsReadableStreamDefaultReader(this)) {\n  152        return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  ...\n  178     *\n  179     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  180:    * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  181     * do so will throw a `TypeError` and leave the reader locked to the stream.\n  182     */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byob-reader.js:\n   86          return ReadableStreamReaderGenericCancel(this, reason);\n   87      }\n   88:     read(view, rawOptions = {}) {\n   89          if (!IsReadableStreamBYOBReader(this)) {\n   90              return promiseRejectedWith(byobReaderBrandCheckException('read'));\n   ..\n  144       *\n  145       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  146:      * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n  147       * do so will throw a `TypeError` and leave the reader locked to the stream.\n  148       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byob-reader.ts:\n  236     *\n  237     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  238:    * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n  239     * do so will throw a `TypeError` and leave the reader locked to the stream.\n  240     */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/default-reader.js:\n   84       * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   85       */\n   86:     read() {\n   87          if (!IsReadableStreamDefaultReader(this)) {\n   88              return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n   ..\n  111       *\n  112       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  113:      * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  114       * do so will throw a `TypeError` and leave the reader locked to the stream.\n  115       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byte-stream-controller.js:\n  330      const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\n  331      const maxAlignedBytes = maxBytesFilled - remainderBytes;\n  332:     // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  333      // of the queue, so the underlying source can keep filling it.\n  334      if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n  ...\n  442          // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n  443          // - No change happens on desiredSize\n  444:         // - The source has already been notified of that there's at least 1 pending read(view)\n  445          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n  446          return;\n  ...\n  493      }\n  494      if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\n  495:         // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  496          // of the queue, so the underlying source can keep filling it.\n  497          return;\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/fetch.js:\n   99  \n  100              if(len !== undefined) {\n  101:               len += write('TEST\\r\\n', ab, len);\n  102                len += wsi.clientHttpMultipart('file', 'roman.txt', 'text/plain', ab, len);\n  103:               len += write('text file content\\r\\n\\r\\n', ab, len);\n  104                len += wsi.clientHttpMultipart(null, null, null, ab, len);\n  105  \n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/websocket.js:\n   34    }\n   35  \n   36:   send(data) {\n   37      return this.#wsi.write(data);\n   38    }\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/tcpSocket.js:\n   51    }\n   52  \n   53:   send(data) {\n   54      return this.#wsi.write(data);\n   55    }\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/lws/streams.js:\n  287     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  288     */\n  289:   read() {\n  290      if(!IsReadableStreamDefaultReader(this)) return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  291      if(this._ownerReadableStream === undefined) return promiseRejectedWith(readerLockException('read from'));\n  ...\n  311     *\n  312     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  313:    * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  314     * do so will throw a `TypeError` and leave the reader locked to the stream.\n  315     */\n  ...\n 1319    }\n 1320  \n 1321:   read(view, rawOptions = {}) {\n 1322      if(!IsReadableStreamBYOBReader(this)) return promiseRejectedWith(byobReaderBrandCheckException('read'));\n 1323      if(!ArrayBuffer.isView(view)) return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n ....\n 1365     *\n 1366     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n 1367:    * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n 1368     * do so will throw a `TypeError` and leave the reader locked to the stream.\n 1369     */\n ....\n 1905     *\n 1906     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n 1907:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n 1908     * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n 1909     * other producers from writing in an interleaved manner.\n ....\n 1917    }\n 1918  \n 1919:   write(chunk = undefined) {\n 1920      if(!IsWritableStreamDefaultWriter(this)) return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n 1921      if(this._ownerWritableStream === undefined) return promiseRejectedWith(defaultWriterLockException('write to'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/lib/lws/body.old.js:\n  229     * @param  {ArrayBuffer} chunk     Chunk of data.\n  230     */\n  231:   static write(instance, chunk) {\n  232      console.log('Body.write', chunk);\n  233      if(instance.#chunks) {\n\n119 matches across 54 files\n\n\nSearching 574 files for \"\\s\\b(read|recv|write|send)(|to)\\(\" (regex, case sensitive)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets.h:\n  478  #endif\n  479  \n  480: ssize_t recv(int sockfd, void *buf, size_t len, int flags);\n  481: ssize_t send(int sockfd, const void *buf, size_t len, int flags);\n  482: ssize_t read(int fd, void *buf, size_t count);\n  483  int getsockopt(int sockfd, int level, int optname,\n  484                        void *optval, socklen_t *optlen);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-ring.h:\n   59   *  - lws_ring_bump_head()\n   60   *\n   61:  *  which let you, eg, read() directly into the ringbuffer without needing\n   62   *  an intermediate bounce buffer.\n   63   *\n   ..\n  179   *\n  180   * Points to the next element that tail would consume, directly in the\n  181:  * ringbuffer.  This lets you write() or otherwise use the element without\n  182   * having to copy it out somewhere first.\n  183   *\n  ...\n  227   * The api reports the position and length of the next linear range that can\n  228   * be written in the ringbuffer, ie, up to the point it would wrap, and sets\n  229:  * *start and *bytes accordingly.  You can then, eg, directly read() into\n  230   * *start for up to *bytes, and use lws_ring_bump_head() to update the lws_ring\n  231   * with what you have done.\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-writeable.h:\n  194   * lws_get_socket_fd() - returns the socket file descriptor\n  195   *\n  196:  * This is needed to use sendto() on UDP raw sockets\n  197   *\n  198   * \\param wsi:\tWebsocket connection instance\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-protocols-plugins.h:\n   74  \t\t\there it can later access from the protocol callback */\n   75  \tsize_t tx_packet_size;\n   76: \t/**< 0 indicates restrict send() size to .rx_buffer_size for backwards-\n   77  \t * compatibility.\n   78: \t * If greater than zero, a single send() is restricted to this amount\n   79  \t * and any remainder is buffered by lws and sent afterwards also in\n   80  \t * these size chunks.  Since that is expensive, it's preferable\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/output.c:\n  310  \tint n = 0;\n  311  #if defined(LWS_PLAT_OPTEE)\n  312: \tssize_t send(int sockfd, const void *buf, size_t len, int flags);\n  313  #endif\n  314  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/tls.c:\n  502  \n  503  \t/* and we can read at least one byte out of it */\n  504: \tn = read(fd, buf, 1);\n  505  \tclose(fd);\n  506  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/tls-server.c:\n  192  \t\t\t */\n  193  \n  194: \t\t\ts = recv(wsi->desc.sockfd, (char *)pt->serv_buf,\n  195  \t\t\t\t context->pt_serv_buf_size, MSG_PEEK);\n  196  \t\t\t/*\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/windows/windows-pipe.c:\n  114  \t */\n  115  \n  116: \tn = sendto(fd[1], &u, 1, 0, (struct sockaddr *)si, sizeof(*si));\n  117  \n  118  \treturn n != 1;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/windows/windows-sockets.c:\n  618  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  619  \n  620: \tret = send(fd, (const char *)buf, (unsigned int)len, 0);\n  621  \tif (ret >= 0)\n  622  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-misc.c:\n  100  \tssize_t n;\n  101  \n  102: \tn = write(fd, buf, len);\n  103  \n  104  \tif (n < 0 || fsync(fd))\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-spawn.c:\n  354  \t}\n  355  \n  356: \tr = read(fd, s, sizeof(s) - 1);\n  357  \tclose(fd);\n  358  \tif (r < 0) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-resolv.c:\n   45  \t\treturn LADNS_CONF_SERVER_UNKNOWN;\n   46  \n   47: \tn = read(fd, r, context->pt_serv_buf_size - 1);\n   48  \tclose(fd);\n   49  \tif (n < 0)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-file.c:\n   55  \t\treturn 1;\n   56  \n   57: \tm = write(fd, buf, len);\n   58  \tclose(fd);\n   59  \n   ..\n   73  \t\treturn -1;\n   74  \n   75: \tn = read(fd, buf, len);\n   76  \tclose(fd);\n   77  \n   ..\n  152  \tssize_t n;\n  153  \n  154: \tn = read((int)fop_fd->fd, buf, (size_t)len);\n  155  \tif (n == -1l) {\n  156  \t\t*amount = 0;\n  ...\n  172  \tssize_t n;\n  173  \n  174: \tn = write((int)fop_fd->fd, buf, (size_t)len);\n  175  \tif (n == -1) {\n  176  \t\t*amount = 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-file.c:\n   88  \tlong n;\n   89  \n   90: \tn = read(fops_fd->fd, buf, len);\n   91  \tif (n == -1) {\n   92  \t\t*amount = 0;\n   ..\n  105  \tlong n;\n  106  \n  107: \tn = write(fops_fd->fd, buf, len);\n  108  \tif (n == -1) {\n  109  \t\t*amount = 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-sockets.c:\n  355  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  356  \n  357: \tret = write(fd, buf, len);\n  358  \tif (ret >= 0)\n  359  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/optee/network.c:\n  285  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  286  \n  287: \tret = write(fd, buf, len);\n  288  \tif (ret >= 0)\n  289  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/pipe/ops-pipe.c:\n   56  \tint n;\n   57  \n   58: \tn = recv(wsi->desc.sockfd, s, sizeof(s), 0);\n   59  \tif (n == SOCKET_ERROR)\n   60  \t\treturn LWS_HPI_RET_PLEASE_CLOSE_ME;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/system/async-dns/async-dns.c:\n  878  \t\ts = _read(fd, buf, sizeof(buf) - 1);\n  879  #else\n  880: \t\ts = read(fd, buf, sizeof(buf) - 1);\n  881  #endif\n  882  \t\tif (s <= 0) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/cache-ttl/file.c:\n  179  \t\t\t * Removing this function from Coverity\n  180  \t\t\t */\n  181: \t\t\tn1s = read(fd, temp + n, sizeof(temp) - (size_t)n);\n  182  \n  183  \t\tlwsl_debug(\"%s: n1 %d\\n\", __func__, (int)n1s);\n  ...\n  657  \tif (lws_fi(&cache->cache.info.cx->fic, \"cache_regen_temp_write\") ||\n  658  \t/* other consumers insist to see this at start of cookie jar */\n  659: \t    write(ctx.fdt, \"# Netscape HTTP Cookie File\\n\", 28) != 28)\n  660  \t\tgoto bail1;\n  661  \n  ...\n  663  \n  664  \tif (pay &&\n  665: \t    write(ctx.fdt, pay, /*msvc*/(unsigned int)pay_size) !=\n  666  \t\t\t\t\t\t    (ssize_t)pay_size)\n  667  \t\tgoto bail1;\n  668: \tif (pay && write(ctx.fdt, \"\\n\", 1u) != (ssize_t)1)\n  669  \t\tgoto bail1;\n  670  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/lwsac/cached-file.c:\n  192  \ta[s.st_size] = '\\0';\n  193  \n  194: \trd = read(fd, a, (unsigned long)s.st_size);\n  195  \tif (rd != s.st_size) {\n  196  \t\tlwsl_err(\"%s: cannot read %s (%d)\\n\", __func__, filepath,\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/fts/trie.c:\n 1039  \t\t\tif (!strcmp(ne, \"describ\")) {\n 1040  \t\t\t\tlwsl_err(\"     %s %d\\n\", ne, t->str_match_pos);\n 1041: \t\t\t\twrite(1, buf - 10, 20);\n 1042  \t\t\t}\n 1043  \t\t}\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/types/writable-stream.ts:\n    7      c.error(new TypeError('error'));\n    8    },\n    9:   write(chunk: string, c: polyfill.WritableStreamDefaultController) {\n   10      return Promise.resolve();\n   11    },\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream.d.ts:\n   47       * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n   48       * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n   49:      * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n   50       * control over allocation.\n   51       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/writable-stream.d.ts:\n   94       *\n   95       * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n   96:      * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n   97       * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n   98       * other producers from writing in an interleaved manner.\n   ..\n  101      /**\n  102       * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n  103:      * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n  104       * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n  105       * errored before the writing process is initiated.\n  ...\n  108       * accepted, and not necessarily that it is safely saved to its ultimate destination.\n  109       */\n  110:     write(chunk: W): Promise<void>;\n  111  }\n  112  declare function WritableStreamDefaultWriterCloseWithErrorPropagation(writer: WritableStreamDefaultWriter): Promise<undefined>;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/transform-stream.ts:\n  257  function TransformStreamUnblockWrite(stream: TransformStream) {\n  258    if (stream._backpressure) {\n  259:     // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n  260      // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n  261      // _backpressure is set.\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream.ts:\n  173     * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n  174     * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n  175:    * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n  176     * control over allocation.\n  177     */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/writable-stream.ts:\n  263    stream._writeRequests = new SimpleQueue();\n  264  \n  265:   // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  266:   // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  267    stream._inFlightWriteRequest = undefined;\n  268  \n  ...\n  742     *\n  743     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n  744:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n  745     * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n  746     * other producers from writing in an interleaved manner.\n  ...\n  764    /**\n  765     * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n  766:    * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n  767     * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n  768     * errored before the writing process is initiated.\n  ...\n  771     * accepted, and not necessarily that it is safely saved to its ultimate destination.\n  772     */\n  773:   write(chunk: W): Promise<void>;\n  774:   write(chunk: W = undefined!): Promise<void> {\n  775      if (!IsWritableStreamDefaultWriter(this)) {\n  776        return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/readable-stream-like.ts:\n   23    cancel(reason?: any): Promise<void>;\n   24  \n   25:   read(): Promise<ReadableStreamDefaultReadResult<R>>;\n   26  \n   27    releaseLock(): void;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byob-reader.d.ts:\n   52       *\n   53       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   54:      * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n   55       * do so will throw a `TypeError` and leave the reader locked to the stream.\n   56       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byte-stream-controller.ts:\n  549    const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\n  550    const maxAlignedBytes = maxBytesFilled - remainderBytes;\n  551:   // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  552    // of the queue, so the underlying source can keep filling it.\n  553    if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n  ...\n  695      // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n  696      // - No change happens on desiredSize\n  697:     // - The source has already been notified of that there's at least 1 pending read(view)\n  698  \n  699      ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n  ...\n  769  \n  770    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\n  771:     // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  772      // of the queue, so the underlying source can keep filling it.\n  773      return;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/readable-stream-like.d.ts:\n   17      readonly closed: Promise<undefined>;\n   18      cancel(reason?: any): Promise<void>;\n   19:     read(): Promise<ReadableStreamDefaultReadResult<R>>;\n   20      releaseLock(): void;\n   21  }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/default-reader.d.ts:\n   43       * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   44       */\n   45:     read(): Promise<ReadableStreamDefaultReadResult<R>>;\n   46      /**\n   47       * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   ..\n   50       *\n   51       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   52:      * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n   53       * do so will throw a `TypeError` and leave the reader locked to the stream.\n   54       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/default-reader.ts:\n  148     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  149     */\n  150:   read(): Promise<ReadableStreamDefaultReadResult<R>> {\n  151      if (!IsReadableStreamDefaultReader(this)) {\n  152        return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  ...\n  178     *\n  179     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  180:    * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  181     * do so will throw a `TypeError` and leave the reader locked to the stream.\n  182     */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byob-reader.ts:\n  236     *\n  237     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  238:    * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n  239     * do so will throw a `TypeError` and leave the reader locked to the stream.\n  240     */\n\n57 matches across 34 files\n\n\nSearching 574 files for \"\\s\\b(read|recv|write|send)(|to)\\(\" (regex, case sensitive)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets.h:\n  478  #endif\n  479  \n  480: ssize_t recv(int sockfd, void *buf, size_t len, int flags);\n  481: ssize_t send(int sockfd, const void *buf, size_t len, int flags);\n  482: ssize_t read(int fd, void *buf, size_t count);\n  483  int getsockopt(int sockfd, int level, int optname,\n  484                        void *optval, socklen_t *optlen);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-ring.h:\n   59   *  - lws_ring_bump_head()\n   60   *\n   61:  *  which let you, eg, read() directly into the ringbuffer without needing\n   62   *  an intermediate bounce buffer.\n   63   *\n   ..\n  179   *\n  180   * Points to the next element that tail would consume, directly in the\n  181:  * ringbuffer.  This lets you write() or otherwise use the element without\n  182   * having to copy it out somewhere first.\n  183   *\n  ...\n  227   * The api reports the position and length of the next linear range that can\n  228   * be written in the ringbuffer, ie, up to the point it would wrap, and sets\n  229:  * *start and *bytes accordingly.  You can then, eg, directly read() into\n  230   * *start for up to *bytes, and use lws_ring_bump_head() to update the lws_ring\n  231   * with what you have done.\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-writeable.h:\n  194   * lws_get_socket_fd() - returns the socket file descriptor\n  195   *\n  196:  * This is needed to use sendto() on UDP raw sockets\n  197   *\n  198   * \\param wsi:\tWebsocket connection instance\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-protocols-plugins.h:\n   74  \t\t\there it can later access from the protocol callback */\n   75  \tsize_t tx_packet_size;\n   76: \t/**< 0 indicates restrict send() size to .rx_buffer_size for backwards-\n   77  \t * compatibility.\n   78: \t * If greater than zero, a single send() is restricted to this amount\n   79  \t * and any remainder is buffered by lws and sent afterwards also in\n   80  \t * these size chunks.  Since that is expensive, it's preferable\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/output.c:\n  310  \tint n = 0;\n  311  #if defined(LWS_PLAT_OPTEE)\n  312: \tssize_t send(int sockfd, const void *buf, size_t len, int flags);\n  313  #endif\n  314  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/tls.c:\n  502  \n  503  \t/* and we can read at least one byte out of it */\n  504: \tn = read(fd, buf, 1);\n  505  \tclose(fd);\n  506  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/tls-server.c:\n  192  \t\t\t */\n  193  \n  194: \t\t\ts = recv(wsi->desc.sockfd, (char *)pt->serv_buf,\n  195  \t\t\t\t context->pt_serv_buf_size, MSG_PEEK);\n  196  \t\t\t/*\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/windows/windows-pipe.c:\n  114  \t */\n  115  \n  116: \tn = sendto(fd[1], &u, 1, 0, (struct sockaddr *)si, sizeof(*si));\n  117  \n  118  \treturn n != 1;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/windows/windows-sockets.c:\n  618  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  619  \n  620: \tret = send(fd, (const char *)buf, (unsigned int)len, 0);\n  621  \tif (ret >= 0)\n  622  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-misc.c:\n  100  \tssize_t n;\n  101  \n  102: \tn = write(fd, buf, len);\n  103  \n  104  \tif (n < 0 || fsync(fd))\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-spawn.c:\n  354  \t}\n  355  \n  356: \tr = read(fd, s, sizeof(s) - 1);\n  357  \tclose(fd);\n  358  \tif (r < 0) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-resolv.c:\n   45  \t\treturn LADNS_CONF_SERVER_UNKNOWN;\n   46  \n   47: \tn = read(fd, r, context->pt_serv_buf_size - 1);\n   48  \tclose(fd);\n   49  \tif (n < 0)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-file.c:\n   55  \t\treturn 1;\n   56  \n   57: \tm = write(fd, buf, len);\n   58  \tclose(fd);\n   59  \n   ..\n   73  \t\treturn -1;\n   74  \n   75: \tn = read(fd, buf, len);\n   76  \tclose(fd);\n   77  \n   ..\n  152  \tssize_t n;\n  153  \n  154: \tn = read((int)fop_fd->fd, buf, (size_t)len);\n  155  \tif (n == -1l) {\n  156  \t\t*amount = 0;\n  ...\n  172  \tssize_t n;\n  173  \n  174: \tn = write((int)fop_fd->fd, buf, (size_t)len);\n  175  \tif (n == -1) {\n  176  \t\t*amount = 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-file.c:\n   88  \tlong n;\n   89  \n   90: \tn = read(fops_fd->fd, buf, len);\n   91  \tif (n == -1) {\n   92  \t\t*amount = 0;\n   ..\n  105  \tlong n;\n  106  \n  107: \tn = write(fops_fd->fd, buf, len);\n  108  \tif (n == -1) {\n  109  \t\t*amount = 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-sockets.c:\n  355  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  356  \n  357: \tret = write(fd, buf, len);\n  358  \tif (ret >= 0)\n  359  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/optee/network.c:\n  285  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  286  \n  287: \tret = write(fd, buf, len);\n  288  \tif (ret >= 0)\n  289  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/pipe/ops-pipe.c:\n   56  \tint n;\n   57  \n   58: \tn = recv(wsi->desc.sockfd, s, sizeof(s), 0);\n   59  \tif (n == SOCKET_ERROR)\n   60  \t\treturn LWS_HPI_RET_PLEASE_CLOSE_ME;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/system/async-dns/async-dns.c:\n  878  \t\ts = _read(fd, buf, sizeof(buf) - 1);\n  879  #else\n  880: \t\ts = read(fd, buf, sizeof(buf) - 1);\n  881  #endif\n  882  \t\tif (s <= 0) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/cache-ttl/file.c:\n  179  \t\t\t * Removing this function from Coverity\n  180  \t\t\t */\n  181: \t\t\tn1s = read(fd, temp + n, sizeof(temp) - (size_t)n);\n  182  \n  183  \t\tlwsl_debug(\"%s: n1 %d\\n\", __func__, (int)n1s);\n  ...\n  657  \tif (lws_fi(&cache->cache.info.cx->fic, \"cache_regen_temp_write\") ||\n  658  \t/* other consumers insist to see this at start of cookie jar */\n  659: \t    write(ctx.fdt, \"# Netscape HTTP Cookie File\\n\", 28) != 28)\n  660  \t\tgoto bail1;\n  661  \n  ...\n  663  \n  664  \tif (pay &&\n  665: \t    write(ctx.fdt, pay, /*msvc*/(unsigned int)pay_size) !=\n  666  \t\t\t\t\t\t    (ssize_t)pay_size)\n  667  \t\tgoto bail1;\n  668: \tif (pay && write(ctx.fdt, \"\\n\", 1u) != (ssize_t)1)\n  669  \t\tgoto bail1;\n  670  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/lwsac/cached-file.c:\n  192  \ta[s.st_size] = '\\0';\n  193  \n  194: \trd = read(fd, a, (unsigned long)s.st_size);\n  195  \tif (rd != s.st_size) {\n  196  \t\tlwsl_err(\"%s: cannot read %s (%d)\\n\", __func__, filepath,\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/fts/trie.c:\n 1039  \t\t\tif (!strcmp(ne, \"describ\")) {\n 1040  \t\t\t\tlwsl_err(\"     %s %d\\n\", ne, t->str_match_pos);\n 1041: \t\t\t\twrite(1, buf - 10, 20);\n 1042  \t\t\t}\n 1043  \t\t}\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/types/writable-stream.ts:\n    7      c.error(new TypeError('error'));\n    8    },\n    9:   write(chunk: string, c: polyfill.WritableStreamDefaultController) {\n   10      return Promise.resolve();\n   11    },\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream.d.ts:\n   47       * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n   48       * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n   49:      * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n   50       * control over allocation.\n   51       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/writable-stream.d.ts:\n   94       *\n   95       * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n   96:      * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n   97       * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n   98       * other producers from writing in an interleaved manner.\n   ..\n  101      /**\n  102       * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n  103:      * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n  104       * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n  105       * errored before the writing process is initiated.\n  ...\n  108       * accepted, and not necessarily that it is safely saved to its ultimate destination.\n  109       */\n  110:     write(chunk: W): Promise<void>;\n  111  }\n  112  declare function WritableStreamDefaultWriterCloseWithErrorPropagation(writer: WritableStreamDefaultWriter): Promise<undefined>;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/transform-stream.ts:\n  257  function TransformStreamUnblockWrite(stream: TransformStream) {\n  258    if (stream._backpressure) {\n  259:     // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n  260      // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n  261      // _backpressure is set.\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream.ts:\n  173     * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n  174     * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n  175:    * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n  176     * control over allocation.\n  177     */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/writable-stream.ts:\n  263    stream._writeRequests = new SimpleQueue();\n  264  \n  265:   // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  266:   // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  267    stream._inFlightWriteRequest = undefined;\n  268  \n  ...\n  742     *\n  743     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n  744:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n  745     * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n  746     * other producers from writing in an interleaved manner.\n  ...\n  764    /**\n  765     * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n  766:    * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n  767     * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n  768     * errored before the writing process is initiated.\n  ...\n  771     * accepted, and not necessarily that it is safely saved to its ultimate destination.\n  772     */\n  773:   write(chunk: W): Promise<void>;\n  774:   write(chunk: W = undefined!): Promise<void> {\n  775      if (!IsWritableStreamDefaultWriter(this)) {\n  776        return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/readable-stream-like.ts:\n   23    cancel(reason?: any): Promise<void>;\n   24  \n   25:   read(): Promise<ReadableStreamDefaultReadResult<R>>;\n   26  \n   27    releaseLock(): void;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byob-reader.d.ts:\n   52       *\n   53       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   54:      * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n   55       * do so will throw a `TypeError` and leave the reader locked to the stream.\n   56       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byte-stream-controller.ts:\n  549    const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\n  550    const maxAlignedBytes = maxBytesFilled - remainderBytes;\n  551:   // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  552    // of the queue, so the underlying source can keep filling it.\n  553    if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n  ...\n  695      // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n  696      // - No change happens on desiredSize\n  697:     // - The source has already been notified of that there's at least 1 pending read(view)\n  698  \n  699      ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n  ...\n  769  \n  770    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\n  771:     // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  772      // of the queue, so the underlying source can keep filling it.\n  773      return;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/readable-stream-like.d.ts:\n   17      readonly closed: Promise<undefined>;\n   18      cancel(reason?: any): Promise<void>;\n   19:     read(): Promise<ReadableStreamDefaultReadResult<R>>;\n   20      releaseLock(): void;\n   21  }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/default-reader.d.ts:\n   43       * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   44       */\n   45:     read(): Promise<ReadableStreamDefaultReadResult<R>>;\n   46      /**\n   47       * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   ..\n   50       *\n   51       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   52:      * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n   53       * do so will throw a `TypeError` and leave the reader locked to the stream.\n   54       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/default-reader.ts:\n  148     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  149     */\n  150:   read(): Promise<ReadableStreamDefaultReadResult<R>> {\n  151      if (!IsReadableStreamDefaultReader(this)) {\n  152        return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  ...\n  178     *\n  179     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  180:    * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  181     * do so will throw a `TypeError` and leave the reader locked to the stream.\n  182     */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byob-reader.ts:\n  236     *\n  237     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  238:    * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n  239     * do so will throw a `TypeError` and leave the reader locked to the stream.\n  240     */\n\n57 matches across 34 files\n\n\nSearching 574 files for \"= \\b(read|recv|write|send)(|to)\\(\" (regex, case sensitive)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/tls.c:\n  502  \n  503  \t/* and we can read at least one byte out of it */\n  504: \tn = read(fd, buf, 1);\n  505  \tclose(fd);\n  506  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/tls-server.c:\n  192  \t\t\t */\n  193  \n  194: \t\t\ts = recv(wsi->desc.sockfd, (char *)pt->serv_buf,\n  195  \t\t\t\t context->pt_serv_buf_size, MSG_PEEK);\n  196  \t\t\t/*\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/windows/windows-pipe.c:\n  114  \t */\n  115  \n  116: \tn = sendto(fd[1], &u, 1, 0, (struct sockaddr *)si, sizeof(*si));\n  117  \n  118  \treturn n != 1;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/windows/windows-sockets.c:\n  618  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  619  \n  620: \tret = send(fd, (const char *)buf, (unsigned int)len, 0);\n  621  \tif (ret >= 0)\n  622  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-misc.c:\n  100  \tssize_t n;\n  101  \n  102: \tn = write(fd, buf, len);\n  103  \n  104  \tif (n < 0 || fsync(fd))\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-spawn.c:\n  354  \t}\n  355  \n  356: \tr = read(fd, s, sizeof(s) - 1);\n  357  \tclose(fd);\n  358  \tif (r < 0) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-resolv.c:\n   45  \t\treturn LADNS_CONF_SERVER_UNKNOWN;\n   46  \n   47: \tn = read(fd, r, context->pt_serv_buf_size - 1);\n   48  \tclose(fd);\n   49  \tif (n < 0)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-file.c:\n   55  \t\treturn 1;\n   56  \n   57: \tm = write(fd, buf, len);\n   58  \tclose(fd);\n   59  \n   ..\n   73  \t\treturn -1;\n   74  \n   75: \tn = read(fd, buf, len);\n   76  \tclose(fd);\n   77  \n   ..\n  152  \tssize_t n;\n  153  \n  154: \tn = read((int)fop_fd->fd, buf, (size_t)len);\n  155  \tif (n == -1l) {\n  156  \t\t*amount = 0;\n  ...\n  172  \tssize_t n;\n  173  \n  174: \tn = write((int)fop_fd->fd, buf, (size_t)len);\n  175  \tif (n == -1) {\n  176  \t\t*amount = 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-file.c:\n   88  \tlong n;\n   89  \n   90: \tn = read(fops_fd->fd, buf, len);\n   91  \tif (n == -1) {\n   92  \t\t*amount = 0;\n   ..\n  105  \tlong n;\n  106  \n  107: \tn = write(fops_fd->fd, buf, len);\n  108  \tif (n == -1) {\n  109  \t\t*amount = 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-sockets.c:\n  355  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  356  \n  357: \tret = write(fd, buf, len);\n  358  \tif (ret >= 0)\n  359  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/optee/network.c:\n  285  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  286  \n  287: \tret = write(fd, buf, len);\n  288  \tif (ret >= 0)\n  289  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/pipe/ops-pipe.c:\n   56  \tint n;\n   57  \n   58: \tn = recv(wsi->desc.sockfd, s, sizeof(s), 0);\n   59  \tif (n == SOCKET_ERROR)\n   60  \t\treturn LWS_HPI_RET_PLEASE_CLOSE_ME;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/system/async-dns/async-dns.c:\n  878  \t\ts = _read(fd, buf, sizeof(buf) - 1);\n  879  #else\n  880: \t\ts = read(fd, buf, sizeof(buf) - 1);\n  881  #endif\n  882  \t\tif (s <= 0) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/cache-ttl/file.c:\n  179  \t\t\t * Removing this function from Coverity\n  180  \t\t\t */\n  181: \t\t\tn1s = read(fd, temp + n, sizeof(temp) - (size_t)n);\n  182  \n  183  \t\tlwsl_debug(\"%s: n1 %d\\n\", __func__, (int)n1s);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/lwsac/cached-file.c:\n  192  \ta[s.st_size] = '\\0';\n  193  \n  194: \trd = read(fd, a, (unsigned long)s.st_size);\n  195  \tif (rd != s.st_size) {\n  196  \t\tlwsl_err(\"%s: cannot read %s (%d)\\n\", __func__, filepath,\n\n19 matches across 15 files\n\n\nSearching 574 files for \"\\b(read|recv|write|send)(|to)\\(\" (regex, case sensitive)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets.h:\n  478  #endif\n  479  \n  480: ssize_t recv(int sockfd, void *buf, size_t len, int flags);\n  481: ssize_t send(int sockfd, const void *buf, size_t len, int flags);\n  482: ssize_t read(int fd, void *buf, size_t count);\n  483  int getsockopt(int sockfd, int level, int optname,\n  484                        void *optval, socklen_t *optlen);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-ring.h:\n   59   *  - lws_ring_bump_head()\n   60   *\n   61:  *  which let you, eg, read() directly into the ringbuffer without needing\n   62   *  an intermediate bounce buffer.\n   63   *\n   ..\n  179   *\n  180   * Points to the next element that tail would consume, directly in the\n  181:  * ringbuffer.  This lets you write() or otherwise use the element without\n  182   * having to copy it out somewhere first.\n  183   *\n  ...\n  227   * The api reports the position and length of the next linear range that can\n  228   * be written in the ringbuffer, ie, up to the point it would wrap, and sets\n  229:  * *start and *bytes accordingly.  You can then, eg, directly read() into\n  230   * *start for up to *bytes, and use lws_ring_bump_head() to update the lws_ring\n  231   * with what you have done.\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-writeable.h:\n  194   * lws_get_socket_fd() - returns the socket file descriptor\n  195   *\n  196:  * This is needed to use sendto() on UDP raw sockets\n  197   *\n  198   * \\param wsi:\tWebsocket connection instance\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-protocols-plugins.h:\n   74  \t\t\there it can later access from the protocol callback */\n   75  \tsize_t tx_packet_size;\n   76: \t/**< 0 indicates restrict send() size to .rx_buffer_size for backwards-\n   77  \t * compatibility.\n   78: \t * If greater than zero, a single send() is restricted to this amount\n   79  \t * and any remainder is buffered by lws and sent afterwards also in\n   80  \t * these size chunks.  Since that is expensive, it's preferable\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/wol.c:\n   83  \n   84  \t/* arg2 is normally const void *, on mingw it's const char * */\n   85:         if (sendto(fd, (const char *)pkt, sizeof(pkt), 0, (struct sockaddr *)&addr,\n   86                          sizeof(addr)) < 0) {\n   87                  lwsl_cx_err(cx, \"failed to sendto broadcast ads, errno %d\\n\",\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/dummy-callback.c:\n  675  \t\t\tif (n < 0)\n  676  \t\t\t\tbreak;\n  677: \t\t\tn = (int)read(n, buf, sizeof(buf) - 2);\n  678  \t\t\tif (n > 0) {\n  679  \t\t\t\tif (buf[n - 1] != '\\n')\n  ...\n  766  \t\t\t\t\tint written;\n  767  \n  768: \t\t\t\t\twritten = (int)write(args->stdwsi[LWS_STDIN]->desc.filefd,\n  769  \t\t\t\t\t\twsi->http.cgi->inflate_buf,\n  770  \t\t\t\t\t\tsizeof(wsi->http.cgi->inflate_buf) -\n  ...\n  800  #endif /* WITH_ZLIB */\n  801  \n  802: \t\tn = (int)write(n, args->data, (unsigned int)args->len);\n  803  //\t\tlwsl_hexdump_notice(args->data, args->len);\n  804  \t\tif (n < args->len)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/output.c:\n  262  \t} else\n  263  #endif\n  264: \t\tn = (int)recv(wsi->desc.sockfd, (char *)buf,\n  265  #if defined(WIN32)\n  266  \t\t\t\t(int)\n  ...\n  310  \tint n = 0;\n  311  #if defined(LWS_PLAT_OPTEE)\n  312: \tssize_t send(int sockfd, const void *buf, size_t len, int flags);\n  313  #endif\n  314  \n  ...\n  323  \n  324  \t\tif (lws_has_buffered_out(wsi))\n  325: \t\t\tn = (int)sendto(wsi->desc.sockfd, (const char *)buf,\n  326  #if defined(WIN32)\n  327  \t\t\t\t(int)\n  ...\n  330  \t\t\t\t   sa46_socklen(&wsi->udp->sa46_pending));\n  331  \t\telse\n  332: \t\t\tn = (int)sendto(wsi->desc.sockfd, (const char *)buf,\n  333  #if defined(WIN32)\n  334  \t\t\t\t(int)\n  ...\n  339  #endif\n  340  \t\tif (wsi->role_ops->file_handle)\n  341: \t\t\tn = (int)write((int)(lws_intptr_t)wsi->desc.filefd, buf,\n  342  #if defined(WIN32)\n  343  \t\t\t\t(int)\n  ...\n  345  \t\t\t\t\tlen);\n  346  \t\telse\n  347: \t\t\tn = (int)send(wsi->desc.sockfd, (char *)buf,\n  348  #if defined(WIN32)\n  349  \t\t\t\t(int)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/socks5-client.c:\n  236  \t}\n  237  \t// lwsl_hexdump_notice(pt->serv_buf, plen);\n  238: \tn = (int)send(wsi->desc.sockfd, (char *)pt->serv_buf, (size_t)plen,\n  239  \t\t      MSG_NOSIGNAL);\n  240  \tif (n < 0) {\n  ...\n  269  \t}\n  270  \n  271: \tn = (int)recv(wsi->desc.sockfd, (void *)pt->serv_buf,\n  272  \t\t wsi->a.context->pt_serv_buf_size, 0);\n  273  \tif (n < 0) {\n  ...\n  332  socks_send:\n  333  \t\t// lwsl_hexdump_notice(pt->serv_buf, len);\n  334: \t\tn = (int)send(wsi->desc.sockfd, (char *)pt->serv_buf,\n  335  \t\t\t      (size_t)len, MSG_NOSIGNAL);\n  336  \t\tif (n < 0) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/client/connect4.c:\n   96  \t\twsi->c_port = (uint16_t)wsi->a.vhost->http.http_proxy_port;\n   97  \n   98: \t\tn = (int)send(wsi->desc.sockfd, (char *)pt->serv_buf,\n   99  \t\t\t      (unsigned int)plen,\n  100  \t\t\t MSG_NOSIGNAL);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core/logs.c:\n  326  \n  327  \tif (fd >= 0)\n  328: \t\tif (write(fd, line, (unsigned int)len) != (ssize_t)len)\n  329  \t\t\tfprintf(stderr, \"Unable to write log to file\\n\");\n  330  }\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/tls.c:\n   52  \t/* the first item in the chunk */\n   53  \tif (!strncmp(line, \"SERVER_HANDSHAKE_TRAFFIC_SECRET\", 31)) {\n   54: \t\tw += (size_t)write(fd, \"\\n# \", 3);\n   55  \t\twx += 3;\n   56  \t\tt = lwsl_timestamp(LLL_WARN, ts, sizeof(ts));\n   57  \t\twx += (size_t)t;\n   58: \t\tw += (size_t)write(fd, ts, (size_t)t);\n   59  \n   60  \t\tt = lws_snprintf(hdr, sizeof(hdr), \"%s\\n\", wsi->lc.gutag);\n   61: \t\tw += (size_t)write(fd, hdr, (size_t)t);\n   62  \t\twx += (size_t)t;\n   63  \n   ..\n   66  \n   67  \twx += strlen(line) + 1;\n   68: \tw += (size_t)write(fd, line, \n   69  #if defined(WIN32)\n   70  \t\t\t(unsigned int)\n   71  #endif\n   72  \t\t\tstrlen(line));\n   73: \tw += (size_t)write(fd, \"\\n\", 1);\n   74  \tclose(fd);\n   75  \n   ..\n  502  \n  503  \t/* and we can read at least one byte out of it */\n  504: \tn = read(fd, buf, 1);\n  505  \tclose(fd);\n  506  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/tls-server.c:\n  192  \t\t\t */\n  193  \n  194: \t\t\ts = recv(wsi->desc.sockfd, (char *)pt->serv_buf,\n  195  \t\t\t\t context->pt_serv_buf_size, MSG_PEEK);\n  196  \t\t\t/*\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/windows/windows-pipe.c:\n  114  \t */\n  115  \n  116: \tn = sendto(fd[1], &u, 1, 0, (struct sockaddr *)si, sizeof(*si));\n  117  \n  118  \treturn n != 1;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/windows/windows-sockets.c:\n  618  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  619  \n  620: \tret = send(fd, (const char *)buf, (unsigned int)len, 0);\n  621  \tif (ret >= 0)\n  622  \t\treturn ret;\n  ...\n  643  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  644  \n  645: \tret = (int)recv(fd, (char *)buf, (unsigned int)len, 0);\n  646  \tif (ret >= 0)\n  647  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/windows/windows-file.c:\n  160  \tint n;\n  161  \n  162: \tn = (int)write(fd, buf, (unsigned int)len);\n  163  \n  164  \tlseek(fd, 0, SEEK_SET);\n  ...\n  177  \t\treturn -1;\n  178  \n  179: \tm = (int)write(fd, buf, (unsigned int)len);\n  180  \tclose(fd);\n  181  \n  ...\n  190  \t\treturn -1;\n  191  \n  192: \tn = (int)read(fd, buf, (unsigned int)len);\n  193  \tclose(fd);\n  194  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-pipe.c:\n   74  \tint n;\n   75  \n   76: \tn = (int)write(pt->dummy_pipe_fds[1], &buf, 1);\n   77  \n   78  \treturn n != 1;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-misc.c:\n   68  #else\n   69  \t/* coverity[tainted_scalar] */\n   70: \treturn (size_t)read(context->fd_random, (char *)buf, len);\n   71  #endif\n   72  }\n   ..\n  100  \tssize_t n;\n  101  \n  102: \tn = write(fd, buf, len);\n  103  \n  104  \tif (n < 0 || fsync(fd))\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-sockets.c:\n  500  \tmemset(sll.sll_addr, 0xff, 6);\n  501  \n  502: \treturn (int)sendto(fd, p, n, 0, (struct sockaddr *)&sll, sizeof(sll));\n  503  #else\n  504  \tlwsl_err(\"%s: UNIMPLEMENTED on this platform\\n\", __func__);\n  ...\n  643  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  644  \n  645: \tret = (int)write(fd, buf, len);\n  646  \tif (ret >= 0)\n  647  \t\treturn ret;\n  ...\n  668  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  669  \n  670: \tret = (int)read(fd, buf, len);\n  671  \tif (ret >= 0)\n  672  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-spawn.c:\n  354  \t}\n  355  \n  356: \tr = read(fd, s, sizeof(s) - 1);\n  357  \tclose(fd);\n  358  \tif (r < 0) {\n  ...\n  547  \t\t\t\tcfd = lws_open(pth, LWS_O_WRONLY);\n  548  \t\t\t\tif (cfd >= 0) {\n  549: \t\t\t\t\tif (write(cfd, \"threaded\", 8) != 8)\n  550  \t\t\t\t\t\tlwsl_warn(\"%s: failed to write threaded\\n\", __func__);\n  551  \n  ...\n  558  \t\t\t\tcfd = lws_open(pth, LWS_O_WRONLY);\n  559  \t\t\t\tif (cfd >= 0) {\n  560: \t\t\t\t\tif (write(cfd, \"max\", 3) != 3)\n  561  \t\t\t\t\t\tlwsl_warn(\"%s: failed to write max\\n\", __func__);\n  562  \n  ...\n  652  \t\tif (fd >= 0) {\n  653  \t\t\tlen = lws_snprintf(pid_str, sizeof(pid_str) - 1, \"%d\", (int)getpid());\n  654: \t\t\tif (write(fd, pid_str, (size_t)len) != (ssize_t)len) {\n  655  \t\t\t\t/*\n  656  \t\t\t\t * using lwsl_err here is unsafe in vfork()\n  ...\n  817  \t}\n  818  \n  819: \tif (write(fd, \"+cpu +memory +pids +io\", 22) != 22)\n  820  \t\t/* ignore, may be there already or fail due to perms */\n  821  \t\tlwsl_debug(\"%s: setting admin cgroup options failed\\n\", __func__);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-resolv.c:\n   45  \t\treturn LADNS_CONF_SERVER_UNKNOWN;\n   46  \n   47: \tn = read(fd, r, context->pt_serv_buf_size - 1);\n   48  \tclose(fd);\n   49  \tif (n < 0)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/unix/unix-file.c:\n   55  \t\treturn 1;\n   56  \n   57: \tm = write(fd, buf, len);\n   58  \tclose(fd);\n   59  \n   ..\n   73  \t\treturn -1;\n   74  \n   75: \tn = read(fd, buf, len);\n   76  \tclose(fd);\n   77  \n   ..\n  152  \tssize_t n;\n  153  \n  154: \tn = read((int)fop_fd->fd, buf, (size_t)len);\n  155  \tif (n == -1l) {\n  156  \t\t*amount = 0;\n  ...\n  172  \tssize_t n;\n  173  \n  174: \tn = write((int)fop_fd->fd, buf, (size_t)len);\n  175  \tif (n == -1) {\n  176  \t\t*amount = 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-file.c:\n   88  \tlong n;\n   89  \n   90: \tn = read(fops_fd->fd, buf, len);\n   91  \tif (n == -1) {\n   92  \t\t*amount = 0;\n   ..\n  105  \tlong n;\n  106  \n  107: \tn = write(fops_fd->fd, buf, len);\n  108  \tif (n == -1) {\n  109  \t\t*amount = 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/freertos/freertos-sockets.c:\n  355  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  356  \n  357: \tret = write(fd, buf, len);\n  358  \tif (ret >= 0)\n  359  \t\treturn ret;\n  ...\n  380  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  381  \n  382: \tret = (int)read(fd, buf, len);\n  383  \tif (ret >= 0)\n  384  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/plat/optee/network.c:\n  176  #if 0\n  177  \t\tif (pt->fds[n].fd == pt->dummy_pipe_fds[0]) {\n  178: \t\t\tif (read(pt->fds[n].fd, &buf, 1) != 1)\n  179  \t\t\t\tlwsl_err(\"Cannot read from dummy pipe.\");\n  180  \t\t\tcontinue;\n  ...\n  285  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  286  \n  287: \tret = write(fd, buf, len);\n  288  \tif (ret >= 0)\n  289  \t\treturn ret;\n  ...\n  310  \t\treturn MBEDTLS_ERR_NET_INVALID_CONTEXT;\n  311  \n  312: \tret = (int)read(fd, buf, len);\n  313  \tif (ret >= 0)\n  314  \t\treturn ret;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/drivers/spi/bitbang/lws-bb-spi.c:\n   83  \t\tfor (n = 0; n < 8; n++) {\n   84  \t\t\tctx->gpio->set(ctx->clk, inv);\n   85: \t\t\tu = (u << 1) | !!ctx->gpio->read(ctx->miso);\n   86  \t\t\tctx->gpio->set(ctx->mosi, !!(u & 0x80));\n   87  \t\t\tctx->gpio->set(ctx->clk, !inv);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/drivers/i2c/lws-i2c.c:\n   35  \t\treturn 1;\n   36  \n   37: \tif (ctx->write(ctx, ads7 << 1)) {\n   38  \t\tctx->stop(ctx);\n   39  \n   ..\n   41  \t}\n   42  \n   43: \tctx->write(ctx, 0);\n   44: \tctx->write(ctx, c);\n   45  \tctx->stop(ctx);\n   46  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/drivers/i2c/bitbang/lws-bb-i2c.c:\n   47  \tctx->delay();\n   48  \n   49: \tif (!ctx->gpio->read(ctx->sda))\n   50  \t\treturn 1;\n   51  \n   ..\n   66  \tctx->delay();\n   67  \n   68: \twhile (!ctx->gpio->read(ctx->scl))\n   69  \t\t;\n   70  \n   ..\n   92  \tctx->gpio->set(ctx->scl, 1);\n   93  \tctx->delay();\n   94: \tn = ctx->gpio->read(ctx->sda);\n   95  \tctx->gpio->set(ctx->scl, 0);\n   96  \tctx->delay();\n   ..\n  112  \t\tctx->gpio->set(ctx->scl, 1);\n  113  \t\tctx->delay();\n  114: \t\tif (ctx->gpio->read(ctx->sda))\n  115  \t\t\tr |= 1 << n;\n  116  \t}\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/drivers/display/spd1656-spi.c:\n  121  \tconst lws_display_spd1656_spi_t *ea = lds_to_disp(priv->lds);\n  122  \n  123: \tif (ea->gpio->read(ea->busy_gpio) == level)\n  124  \t\treturn 0; /* good */\n  125  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/drivers/display/uc8176-spi.c:\n  387  \tconst lws_display_uc8176_spi_t *ea = lds_to_disp(priv->lds);\n  388  \n  389: \tif (ea->gpio->read(ea->busy_gpio) == level)\n  390  \t\treturn 0; /* good */\n  391  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/drivers/display/ssd1675b-spi.c:\n  193  \tconst lws_display_ssd1675b_spi_t *ea = lds_to_disp(priv->lds);\n  194  \n  195: \tif (ea->gpio->read(ea->busy_gpio) == level)\n  196  \t\treturn 0; /* good */\n  197  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/drivers/button/lws-button.c:\n  230  \t\t\t\tLWS_BUTTON_MON_TIMER_MS;\n  231  \n  232: \t\tactive = bc->gpio_ops->read(bc->button_map[n].gpio) ^\n  233  \t\t\t       (!(bc->active_state_bitmap & (1 << n)));\n  234  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/client/client-http.c:\n  113  \t\t}\n  114  \n  115: \t\tn = (int)recv(wsi->desc.sockfd, sb, context->pt_serv_buf_size, 0);\n  116  \t\tif (n < 0) {\n  117  \t\t\tif (LWS_ERRNO == LWS_EAGAIN) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/server/access-log.c:\n  188  \tass[sizeof(ass) - 1] = '\\0';\n  189  \n  190: \tif ((int)write(wsi->a.vhost->log_fd, ass, (size_t)l) != l)\n  191  \t\tlwsl_err(\"Failed to write log\\n\");\n  192  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/server/lejp-conf.c:\n 1028  \n 1029  \tdo {\n 1030: \t\tn = (int)read(fd, buf, sizeof(buf));\n 1031  \t\tif (!n)\n 1032  \t\t\tbreak;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/server/server.c:\n 1051  \twhile (1) {\n 1052  \t\tif (pos == n) {\n 1053: \t\t\tn = (int)read(fd, buf, sizeof(buf));\n 1054  \t\t\tif (n <= 0) {\n 1055  \t\t\t\tif (match == stringlen)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/cgi/cgi-server.c:\n  705  \t\tif (n < 0)\n  706  \t\t\treturn -1;\n  707: \t\tn = (int)read(n, &c, 1);\n  708  \t\tif (n < 0) {\n  709  \t\t\tif (errno != EAGAIN) {\n  ...\n  856  \tif (n < 0)\n  857  \t\treturn -1;\n  858: \tn = (int)read(n, start, sizeof(buf) - LWS_PRE - 16);\n  859  \n  860  \tif (n < 0 && errno != EAGAIN) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/pipe/ops-pipe.c:\n   48  \t * thinks we should.\n   49  \t */\n   50: \tn = (int)read(wsi->desc.sockfd, s, sizeof(s));\n   51  \t(void)n;\n   52  \tif (n < 0)\n   ..\n   56  \tint n;\n   57  \n   58: \tn = recv(wsi->desc.sockfd, s, sizeof(s), 0);\n   59  \tif (n == SOCKET_ERROR)\n   60  \t\treturn LWS_HPI_RET_PLEASE_CLOSE_ME;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/system/async-dns/async-dns.c:\n  878  \t\ts = _read(fd, buf, sizeof(buf) - 1);\n  879  #else\n  880: \t\ts = read(fd, buf, sizeof(buf) - 1);\n  881  #endif\n  882  \t\tif (s <= 0) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/policy-json.c:\n 1240  \n 1241  \tdo {\n 1242: \t\tn = (int)read(fd, buf, sizeof(buf));\n 1243  \t\tif (n < 0) {\n 1244  \t\t\tm = -1;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/protocols/ss-raw.c:\n  124         case LWS_CALLBACK_RAW_RX_FILE:\n  125                 in = p;\n  126:                f = (int)read((int)(intptr_t)wsi->desc.filefd, p, sizeof(buf) - LWS_PRE);\n  127                 if (f < 0)\n  128                         return 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/daemonize.c:\n   65  \t\t}\n   66  \t\tlen = sprintf(sz, \"%u\", (unsigned int)pid_daemon);\n   67: \t\tsent = (int)write(fd, sz, (size_t)len);\n   68  \t\tif (sent != len)\n   69  \t\t\tfprintf(stderr,\n   ..\n  118  \t\t\tchar buf[10];\n  119  \n  120: \t\t\tn = (int)read(fd, buf, sizeof(buf));\n  121  \t\t\tclose(fd);\n  122  \t\t\tif (n) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/cache-ttl/file.c:\n  179  \t\t\t * Removing this function from Coverity\n  180  \t\t\t */\n  181: \t\t\tn1s = read(fd, temp + n, sizeof(temp) - (size_t)n);\n  182  \n  183  \t\tlwsl_debug(\"%s: n1 %d\\n\", __func__, (int)n1s);\n  ...\n  615  \tcache->cache.current_footprint += (uint64_t)size;\n  616  \n  617: \tif (write(ctx->fdt, buf, /*msvc*/(unsigned int)size) != (ssize_t)size)\n  618  \t\treturn NIR_FINISH_ERROR;\n  619  \n  620  \tif (flags & LCN_EOL)\n  621: \t\tif ((size_t)write(ctx->fdt, \"\\n\", 1) != 1)\n  622  \t\t\treturn NIR_FINISH_ERROR;\n  623  \n  ...\n  657  \tif (lws_fi(&cache->cache.info.cx->fic, \"cache_regen_temp_write\") ||\n  658  \t/* other consumers insist to see this at start of cookie jar */\n  659: \t    write(ctx.fdt, \"# Netscape HTTP Cookie File\\n\", 28) != 28)\n  660  \t\tgoto bail1;\n  661  \n  ...\n  663  \n  664  \tif (pay &&\n  665: \t    write(ctx.fdt, pay, /*msvc*/(unsigned int)pay_size) !=\n  666  \t\t\t\t\t\t    (ssize_t)pay_size)\n  667  \t\tgoto bail1;\n  668: \tif (pay && write(ctx.fdt, \"\\n\", 1u) != (ssize_t)1)\n  669  \t\tgoto bail1;\n  670  \n  ...\n  809  \n  810  \t*ctx->psize = size;\n  811: \tif (ctx->l1->info.ops->write(ctx->l1,\n  812  \t\t\t\t     ctx->specific_key, (const uint8_t *)buf,\n  813  \t\t\t\t     size, ctx->expiry, (void **)ctx->pdata))\n  ...\n  832  \n  833  \t*ctx->psize = size;\n  834: \tif (ctx->l1->info.ops->write(ctx->l1, ctx->specific_key, NULL,\n  835  \t\t\t\t     lws_buflist_total_len(&ctx->buflist),\n  836  \t\t\t\t     ctx->expiry, (void **)&q))\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/cache-ttl/lws-cache-ttl.c:\n   74  \twhile (n) {\n   75  \t\tn--;\n   76: \t\tr = levels[n]->info.ops->write(levels[n], specific_key,\n   77  \t\t\t\t\t\tsource, size, expiry, ppay);\n   78  \t}\n   ..\n  185  \t */\n  186  \n  187: \tn = l1->info.ops->write(l1, meta_key, temp, sum, expiry, (void **)&p);\n  188  \t/* done with temp */\n  189  \tlws_free(temp);\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/lwsac/cached-file.c:\n  192  \ta[s.st_size] = '\\0';\n  193  \n  194: \trd = read(fd, a, (unsigned long)s.st_size);\n  195  \tif (rd != s.st_size) {\n  196  \t\tlwsl_err(\"%s: cannot read %s (%d)\\n\", __func__, filepath,\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/fts/trie.c:\n  170  #define spill(margin, force) \\\n  171  \tif (bp && ((uint32_t)bp >= (sizeof(buf) - (size_t)(margin)) || (force))) { \\\n  172: \t\tif ((int)write(t->fd, buf, (size_t)bp) != bp) { \\\n  173  \t\t\tlwsl_err(\"%s: write %d failed (%d)\\n\", __func__, \\\n  174  \t\t\t\t bp, errno); \\\n  ...\n  296  \tg32(&buf[0x10], 0);\n  297  \n  298: \tif (write(t->fd, buf, TRIE_FILE_HDR_SIZE) != TRIE_FILE_HDR_SIZE) {\n  299  \t\tlwsl_err(\"%s: trie header write failed\\n\", __func__);\n  300  \t\tgoto unwind;\n  ...\n  404  \tbp += g16(&buf[bp], 0);\n  405  \tbp += g32(&buf[bp], 0);\n  406: \tif ((int)write(t->fd, buf, (size_t)bp) != bp)\n  407  \t\treturn 1;\n  408  \tt->c += (unsigned int)bp;\n  ...\n  592  \t\t\tbp += wq32(&linetable[bp], (uint32_t)t->chars_in_line);\n  593  \t\t\tif ((unsigned int)bp > sizeof(linetable) - 6) {\n  594: \t\t\t\tif ((int)write(t->fd, linetable, (unsigned int)bp) != bp) {\n  595  \t\t\t\t\tlwsl_err(\"%s: linetable write failed\\n\",\n  596  \t\t\t\t\t\t\t__func__);\n  ...\n 1039  \t\t\tif (!strcmp(ne, \"describ\")) {\n 1040  \t\t\t\tlwsl_err(\"     %s %d\\n\", ne, t->str_match_pos);\n 1041: \t\t\t\twrite(1, buf - 10, 20);\n 1042  \t\t\t}\n 1043  \t\t}\n ....\n 1051  \n 1052  \tif (bp) {\n 1053: \t\tif ((int)write(t->fd, linetable, (size_t)bp) != bp)\n 1054  \t\t\treturn 1;\n 1055  \t\tt->c += (unsigned int)bp;\n ....\n 1066  \tg16(linetable + 2, (uint16_t)(t->line_number - sline));\n 1067  \tg32(linetable + 4, (uint32_t)chars);\n 1068: \tif ((int)write(t->fd, linetable, 8) != 8) {\n 1069  \t\tlwsl_err(\"%s: write linetable header failed\\n\", __func__);\n 1070  \t\treturn 1;\n ....\n 1188  \tg32(buf, t->c + (unsigned int)bp);\n 1189  \tg32(buf + 4, (uint32_t)t->next_file_index);\n 1190: \tif ((int)write(t->fd, buf, 8) != 8)\n 1191  \t\tgoto bail;\n 1192  \n ....\n 1347  \tg32(buf, t->root->ofs);\n 1348  \tg32(buf + 4, t->c);\n 1349: \tif (write(t->fd, buf, 0x8) != 0x8)\n 1350  \t\tgoto bail;\n 1351  \n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/misc/fts/trie-fd.c:\n  102  \t}\n  103  \n  104: \tra = (int)read(jtf->fd, buf, 4);\n  105  \tif (ra < 0)\n  106  \t\treturn 1;\n  ...\n  113  \t}\n  114  \n  115: \tra = (int)read(jtf->fd, buf, sizeof(buf));\n  116  \tif (ra < 0)\n  117  \t\treturn 1;\n  ...\n  151  \toff_t ot;\n  152  \n  153: \tif (read(jtf->fd, buf, TRIE_FILE_HDR_SIZE) != TRIE_FILE_HDR_SIZE) {\n  154  \t\tlwsl_err(\"%s: unable to read file header\\n\", __func__);\n  155  \t\tgoto bail;\n  ...\n  231  \t\t} \\\n  232  \\\n  233: \t\tra = (int)read(jtf->fd, buf, (size_t)(_size)); \\\n  234  \t\tif (ra < 0) \\\n  235  \t\t\tgoto bail; \\\n  ...\n  714  \t\t\t\t\tcontinue;\n  715  \n  716: \t\t\t\tm = (int)read(ofd, lbuf, sizeof(lbuf) - 1);\n  717  \t\t\t\tif (m < 0)\n  718  \t\t\t\t\tcontinue;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/types/readable-stream.ts:\n   57  \n   58  const defaultReader: polyfill.ReadableStreamDefaultReader<string> = readableStream.getReader();\n   59: const defaultReaderReadPromise: Promise<polyfill.ReadableStreamDefaultReadResult<string>> = defaultReader.read();\n   60  defaultReaderReadPromise.then((result) => {\n   61    const done: boolean = result.done;\n   ..\n   70  \n   71  const byobReader: polyfill.ReadableStreamBYOBReader = readableByteStream.getReader({ mode: 'byob' });\n   72: const byobReaderReadUint32Promise: Promise<polyfill.ReadableStreamBYOBReadResult<Uint32Array>> = byobReader.read(new Uint32Array(3));\n   73: const byobReaderReadDataViewPromise: Promise<polyfill.ReadableStreamBYOBReadResult<DataView>> = byobReader.read(\n   74    new DataView(new ArrayBuffer(3))\n   75  );\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/types/writable-stream.ts:\n    7      c.error(new TypeError('error'));\n    8    },\n    9:   write(chunk: string, c: polyfill.WritableStreamDefaultController) {\n   10      return Promise.resolve();\n   11    },\n   ..\n   32  const writerClosedPromise: Promise<void> = writer.closed;\n   33  const writerReadyPromise: Promise<void> = writer.ready;\n   34: const writerWritePromise: Promise<void> = writer.write('a');\n   35  const writerClosePromise: Promise<void> = writer.close();\n   36  const writerAbortPromise: Promise<void> = writer.abort('aborted');\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/test/types/polyfill.ts:\n   11  const defaultReader = readable.getReader();\n   12  defaultReader.closed.catch(() => undefined);\n   13: defaultReader.read().then(result => {\n   14    const done: boolean = result.done;\n   15    if (result.done) {\n   ..\n   23  const byobReader = readable.getReader({ mode: 'byob' });\n   24  byobReader.closed.catch(() => undefined);\n   25: byobReader.read(new Uint32Array(3)).then(result => {\n   26    const done: boolean = result.done;\n   27    if (result.done) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream.d.ts:\n   47       * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n   48       * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n   49:      * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n   50       * control over allocation.\n   51       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/writable-stream.d.ts:\n   94       *\n   95       * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n   96:      * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n   97       * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n   98       * other producers from writing in an interleaved manner.\n   ..\n  101      /**\n  102       * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n  103:      * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n  104       * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n  105       * errored before the writing process is initiated.\n  ...\n  108       * accepted, and not necessarily that it is safely saved to its ultimate destination.\n  109       */\n  110:     write(chunk: W): Promise<void>;\n  111  }\n  112  declare function WritableStreamDefaultWriterCloseWithErrorPropagation(writer: WritableStreamDefaultWriter): Promise<undefined>;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/transform-stream.ts:\n  257  function TransformStreamUnblockWrite(stream: TransformStream) {\n  258    if (stream._backpressure) {\n  259:     // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n  260      // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n  261      // _backpressure is set.\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream.ts:\n  173     * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n  174     * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n  175:    * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n  176     * control over allocation.\n  177     */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/writable-stream.ts:\n  263    stream._writeRequests = new SimpleQueue();\n  264  \n  265:   // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  266:   // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  267    stream._inFlightWriteRequest = undefined;\n  268  \n  ...\n  742     *\n  743     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n  744:    * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n  745     * Itâ€™s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n  746     * other producers from writing in an interleaved manner.\n  ...\n  764    /**\n  765     * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n  766:    * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n  767     * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n  768     * errored before the writing process is initiated.\n  ...\n  771     * accepted, and not necessarily that it is safely saved to its ultimate destination.\n  772     */\n  773:   write(chunk: W): Promise<void>;\n  774:   write(chunk: W = undefined!): Promise<void> {\n  775      if (!IsWritableStreamDefaultWriter(this)) {\n  776        return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/readable-stream-like.ts:\n   23    cancel(reason?: any): Promise<void>;\n   24  \n   25:   read(): Promise<ReadableStreamDefaultReadResult<R>>;\n   26  \n   27    releaseLock(): void;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/from.ts:\n   78      let readPromise;\n   79      try {\n   80:       readPromise = reader.read();\n   81      } catch (e) {\n   82        return promiseRejectedWith(e);\n   ..\n   84      return transformPromiseWith(readPromise, (readResult) => {\n   85        if (!typeIsObject(readResult)) {\n   86:         throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\n   87        }\n   88        if (readResult.done) {\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byob-reader.d.ts:\n   52       *\n   53       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   54:      * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n   55       * do so will throw a `TypeError` and leave the reader locked to the stream.\n   56       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byte-stream-controller.ts:\n  549    const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\n  550    const maxAlignedBytes = maxBytesFilled - remainderBytes;\n  551:   // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  552    // of the queue, so the underlying source can keep filling it.\n  553    if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n  ...\n  695      // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n  696      // - No change happens on desiredSize\n  697:     // - The source has already been notified of that there's at least 1 pending read(view)\n  698  \n  699      ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n  ...\n  769  \n  770    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\n  771:     // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  772      // of the queue, so the underlying source can keep filling it.\n  773      return;\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/readable-stream-like.d.ts:\n   17      readonly closed: Promise<undefined>;\n   18      cancel(reason?: any): Promise<void>;\n   19:     read(): Promise<ReadableStreamDefaultReadResult<R>>;\n   20      releaseLock(): void;\n   21  }\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/default-reader.d.ts:\n   43       * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   44       */\n   45:     read(): Promise<ReadableStreamDefaultReadResult<R>>;\n   46      /**\n   47       * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   ..\n   50       *\n   51       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   52:      * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n   53       * do so will throw a `TypeError` and leave the reader locked to the stream.\n   54       */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/default-reader.ts:\n  148     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n  149     */\n  150:   read(): Promise<ReadableStreamDefaultReadResult<R>> {\n  151      if (!IsReadableStreamDefaultReader(this)) {\n  152        return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n  ...\n  178     *\n  179     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  180:    * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n  181     * do so will throw a `TypeError` and leave the reader locked to the stream.\n  182     */\n\n~/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/byob-reader.ts:\n  236     *\n  237     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n  238:    * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n  239     * do so will throw a `TypeError` and leave the reader locked to the stream.\n  240     */\n\n142 matches across 62 files\n\n\nSearching 574 files for \"lws_ssl_capable_read_no_ssl\" (regex, case sensitive)\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/output.c:\n  245  \n  246  int\n  247: lws_ssl_capable_read_no_ssl(struct lws *wsi, unsigned char *buf, size_t len)\n  248  {\n  249  \tint n = 0, en;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core/private-lib-core.h:\n 1015   #define lws_ssl_destroy(_a)\n 1016   #define lws_context_init_alpn(_a)\n 1017:  #define lws_ssl_capable_read lws_ssl_capable_read_no_ssl\n 1018   #define lws_ssl_capable_write lws_ssl_capable_write_no_ssl\n 1019   #define lws_ssl_pending lws_ssl_pending_no_ssl\n ....\n 1062  \n 1063  int LWS_WARN_UNUSED_RESULT\n 1064: lws_ssl_capable_read_no_ssl(struct lws *wsi, unsigned char *buf, size_t len);\n 1065  \n 1066  int LWS_WARN_UNUSED_RESULT\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/mbedtls/mbedtls-ssl.c:\n   50  \n   51  \tif (!wsi->tls.ssl)\n   52: \t\treturn lws_ssl_capable_read_no_ssl(wsi, buf, len);\n   53  \n   54  \terrno = 0;\n\n~/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/tls/openssl/openssl-ssl.c:\n  224  \n  225  \tif (!wsi->tls.ssl)\n  226: \t\treturn lws_ssl_capable_read_no_ssl(wsi, buf, len);\n  227  \n  228  #ifndef WIN32\n\n5 matches across 4 files\n",
			"settings":
			{
				"buffer_size": 1174258,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"file": "libwebsockets/lib/roles/h2/http2.c",
			"settings":
			{
				"buffer_size": 79267,
				"line_ending": "Unix"
			}
		},
		{
			"file": "lws-socket.c",
			"settings":
			{
				"buffer_size": 26392,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					24,
					1,
					"insert",
					{
						"characters": " "
					},
					"AgAAAEY9AAAAAAAARz0AAAAAAAAAAAAARz0AAAAAAABHPQAAAAAAAAUAAAAgIC8qIA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAASz0AAAAAAABGPQAAAAAAAAAAAAAAAPC/"
				],
				[
					27,
					2,
					"left_delete",
					null,
					"AgAAAH09AAAAAAAAfT0AAAAAAAABAAAAL3w9AAAAAAAAfD0AAAAAAAABAAAAKg",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAfT0AAAAAAAB+PQAAAAAAAAAAAAAAAPC/"
				],
				[
					30,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAiZwAAI2luY2x1ZGUgImx3cy1zb2NrZXQuaCIKI2luY2x1ZGUgImx3cy1jb250ZXh0LmgiCiNpbmNsdWRlICJsd3Mtdmhvc3QuaCIKI2luY2x1ZGUgImx3cy1zb2NrYWRkcjQ2LmgiCiNpbmNsdWRlICJsd3MuaCIKI2luY2x1ZGUgImpzLXV0aWxzLmgiCiNpbmNsdWRlIDxhc3NlcnQuaD4KCiNpbmNsdWRlICJsaWJ3ZWJzb2NrZXRzL2xpYi9jb3JlL3ByaXZhdGUtbGliLWNvcmUuaCIKLy8gI2luY2x1ZGUgImxpYndlYnNvY2tldHMvbGliL3JvbGVzL3ByaXZhdGUtbGliLXJvbGVzLmgiCgpKU0NsYXNzSUQgbHdzanNfc29ja2V0X2NsYXNzX2lkOwpzdGF0aWMgSlNWYWx1ZSBsd3Nqc19zb2NrZXRfcHJvdG8sIGx3c2pzX3NvY2tldF9jdG9yOwoKc3RhdGljIHN0cnVjdCBsaXN0X2hlYWQgc29ja2V0X2xpc3Q7CnN0YXRpYyB1aW50MzJfdCBzb2NrZXRfaWQ7CgpzdGF0aWMgY29uc3QgZW51bSBsd3NfdG9rZW5faW5kZXhlcyBsd3Nqc19tZXRob2RfdG9rZW5zW10gPSB7CiAgICBXU0lfVE9LRU5fR0VUX1VSSSwKICAgIFdTSV9UT0tFTl9QT1NUX1VSSSwKI2lmZGVmIExXU19XSVRIX0hUVFBfVU5DT01NT05fSEVBREVSUwogICAgV1NJX1RPS0VOX09QVElPTlNfVVJJLAogICAgV1NJX1RPS0VOX1BVVF9VUkksCiAgICBXU0lfVE9LRU5fUEFUQ0hfVVJJLAogICAgV1NJX1RPS0VOX0RFTEVURV9VUkksCiNlbmRpZgogICAgV1NJX1RPS0VOX0NPTk5FQ1QsCiAgICBXU0lfVE9LRU5fSEVBRF9VUkksCiNpZmRlZiBMV1NfV0lUSF9IVFRQMgogICAgV1NJX1RPS0VOX0hUVFBfQ09MT05fUEFUSCwKI2VuZGlmCn07CgpzdGF0aWMgY29uc3QgY2hhciogY29uc3QgbHdzanNfbWV0aG9kX25hbWVzW10gPSB7CiAgICAiR0VUIiwKICAgICJQT1NUIiwKI2lmZGVmIExXU19XSVRIX0hUVFBfVU5DT01NT05fSEVBREVSUwogICAgIk9QVElPTlMiLAogICAgIlBVVCIsCiAgICAiUEFUQ0giLAogICAgIkRFTEVURSIsCiNlbmRpZgogICAgIkNPTk5FQ1QiLAogICAgIkhFQUQiLAojaWZkZWYgTFdTX1dJVEhfSFRUUDIKICAgICJDT0xPTl9QQVRIIiwKI2VuZGlmCn07CgpzdGF0aWMgQk9PTAppc191cmkoZW51bSBsd3NfdG9rZW5faW5kZXhlcyB0aSkgewogIGZvcihzaXplX3QgaSA9IDA7IGkgPCBjb3VudG9mKGx3c2pzX21ldGhvZF90b2tlbnMpOyBpKyspCiAgICBpZihsd3Nqc19tZXRob2RfdG9rZW5zW2ldID09IHRpKQogICAgICByZXR1cm4gVFJVRTsKCiAgcmV0dXJuIEZBTFNFOwp9CgppbnQKbHdzanNfbWV0aG9kX2luZGV4KGNvbnN0IGNoYXIqIG1ldGhvZCkgewogIGZvcihpbnQgaSA9IDA7IGkgPCAoaW50KWNvdW50b2YobHdzanNfbWV0aG9kX25hbWVzKTsgKytpKQogICAgaWYobHdzanNfbWV0aG9kX25hbWVzW2ldKQogICAgICBpZighc3RyY2FzZWNtcChtZXRob2QsIGx3c2pzX21ldGhvZF9uYW1lc1tpXSkpCiAgICAgICAgcmV0dXJuIGk7CgogIHJldHVybiAtMTsKfQoKY29uc3QgY2hhcioKbHdzanNfbWV0aG9kX25hbWUoaW50IGkpIHsKICBpZihpID49IDAgJiYgaSA8IChpbnQpY291bnRvZihsd3Nqc19tZXRob2RfbmFtZXMpKQogICAgcmV0dXJuIGx3c2pzX21ldGhvZF9uYW1lc1tpXTsKCiAgcmV0dXJuIDA7Cn0KCkxXU1NvY2tldCoKc29ja2V0X2R1cChMV1NTb2NrZXQqIHMpIHsKICArK3MtPnJlZl9jb3VudDsKICByZXR1cm4gczsKfQoKTFdTU29ja2V0Kgpzb2NrZXRfYWxsb2MoSlNDb250ZXh0KiBjdHgpIHsKICBMV1NTb2NrZXQqIHNvY2s7CgogIGlmKCEoc29jayA9IGpzX21hbGxvY3ooY3R4LCBzaXplb2YoTFdTU29ja2V0KSkpKQogICAgcmV0dXJuIDA7CgogIC8qaWYoc29ja2V0X2xpc3QubmV4dCA9PSAwKSBpbml0X2xpc3RfaGVhZCgmc29ja2V0X2xpc3QpOyovCgogIGFzc2VydChzb2NrZXRfbGlzdC5uZXh0KTsKICBhc3NlcnQoc29ja2V0X2xpc3QucHJldik7CgogIGxpc3RfYWRkKCZzb2NrLT5saW5rLCAmc29ja2V0X2xpc3QpOwoKICBzb2NrLT5yZWZfY291bnQgPSAxOwogIHNvY2stPmhlYWRlcnMgPSBKU19VTkRFRklORUQ7CiAgc29jay0+d3JpdGVfaGFuZGxlciA9IEpTX1VOREVGSU5FRDsKICBzb2NrLT5pZCA9ICsrc29ja2V0X2lkOwogIHNvY2stPm1ldGhvZCA9IC0xOwoKICByZXR1cm4gc29jazsKfQoKc3RhdGljIExXU1NvY2tldFR5cGUKc29ja2V0X3R5cGUoc3RydWN0IGx3cyogd3NpKSB7CiAgaWYobHdzaV9yb2xlX3dzKHdzaSkpCiAgICByZXR1cm4gU09DS0VUX1dTOwoKICBpZihsd3NpX3JvbGVfaDEod3NpKSkKICAgIHJldHVybiBTT0NLRVRfSFRUUDsKCiAgaWYobHdzaV9yb2xlX2gyKHdzaSkpCiAgICByZXR1cm4gU09DS0VUX0hUVFA7CgogIHJldHVybiBTT0NLRVRfT1RIRVI7Cn0KCmludApzb2NrZXRfZ2V0aWQoc3RydWN0IGx3cyogd3NpKSB7CiAgTFdTU29ja2V0KiBzb2NrOwoKICBpZigoc29jayA9IHNvY2tldF9nZXQod3NpKSkpCiAgICByZXR1cm4gc29jay0+aWQ7CiAgcmV0dXJuIC0xOwp9CgpzdGF0aWMgTFdTU29ja2V0Kgpzb2NrZXRfZmluZChzdHJ1Y3QgbHdzKiB3c2kpIHsKICBzdHJ1Y3QgbGlzdF9oZWFkKiBuOwoKICBsaXN0X2Zvcl9lYWNoKG4sICZzb2NrZXRfbGlzdCkgewogICAgTFdTU29ja2V0KiBzb2NrID0gbGlzdF9lbnRyeShuLCBMV1NTb2NrZXQsIGxpbmspOwoKICAgIGlmKHNvY2spCiAgICAgIGlmKCh1aW50cHRyX3Qpc29jayAhPSAodWludHB0cl90KS0xICYmIHNvY2stPndzaSA9PSB3c2kpCiAgICAgICAgcmV0dXJuIHNvY2s7CiAgfQoKICByZXR1cm4gMDsKfQoKTFdTU29ja2V0Kgpzb2NrZXRfZ2V0KHN0cnVjdCBsd3MqIHdzaSkgewogIEpTT2JqZWN0KiBvYmo7CgogIGlmKChvYmogPSBsd3NfZ2V0X29wYXF1ZV91c2VyX2RhdGEod3NpKSkpCiAgICByZXR1cm4gbHdzanNfc29ja2V0X2RhdGEoSlNfTUtQVFIoSlNfVEFHX09CSkVDVCwgb2JqKSk7CgogIHJldHVybiAwOwp9CgpKU1ZhbHVlCmpzX3NvY2tldF9nZXQoSlNDb250ZXh0KiBjdHgsIHN0cnVjdCBsd3MqIHdzaSkgewogIEpTT2JqZWN0KiBvYmo7CgogIGlmKChvYmogPSBsd3NfZ2V0X29wYXF1ZV91c2VyX2RhdGEod3NpKSkpCiAgICByZXR1cm4gSlNfRHVwVmFsdWUoY3R4LCBKU19NS1BUUihKU19UQUdfT0JKRUNULCBvYmopKTsKCiAgcmV0dXJuIEpTX1VOREVGSU5FRDsKfQoKc3RhdGljIExXU1NvY2tldCoKc29ja2V0X2dldF9ieV9pZChpbnQgaWQpIHsKICBzdHJ1Y3QgbGlzdF9oZWFkKiBuOwogIExXU1NvY2tldCogc29jazsKCiAgbGlzdF9mb3JfZWFjaChuLCAmc29ja2V0X2xpc3QpIHsKICAgIGlmKChzb2NrID0gbGlzdF9lbnRyeShuLCBMV1NTb2NrZXQsIGxpbmspKSkKICAgICAgaWYoc29jay0+aWQgPT0gaWQpCiAgICAgICAgcmV0dXJuIHNvY2s7CiAgfQoKICByZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQKc29ja2V0X2ZyZWUoTFdTU29ja2V0KiBzb2NrLCBKU1J1bnRpbWUqIHJ0KSB7CiAgREVCVUcoImZyZWUgTFdTU29ja2V0OiAlcCAocmVmX2NvdW50ID0gJWQpIiwgc29jaywgc29jay0+cmVmX2NvdW50KTsKICBpZigtLXNvY2stPnJlZl9jb3VudCA9PSAwKSB7CiAgICBpZighSlNfSXNVbmRlZmluZWQoc29jay0+d3JpdGVfaGFuZGxlcikpIHsKICAgICAgSlNfRnJlZVZhbHVlUlQocnQsIHNvY2stPndyaXRlX2hhbmRsZXIpOwogICAgICBzb2NrLT53cml0ZV9oYW5kbGVyID0gSlNfVU5ERUZJTkVEOwogICAgfQoKICAgIEpTX0ZyZWVWYWx1ZVJUKHJ0LCBzb2NrLT5oZWFkZXJzKTsKICAgIHNvY2stPmhlYWRlcnMgPSBKU19VTkRFRklORUQ7CgogICAgaWYoc29jay0+dXJpKSB7CiAgICAgIGpzX2ZyZWVfcnQocnQsIHNvY2stPnVyaSk7CiAgICAgIHNvY2stPnVyaSA9IDA7CiAgICB9CiAgICBpZihzb2NrLT5wcm90bykgewogICAgICBqc19mcmVlX3J0KHJ0LCBzb2NrLT5wcm90byk7CiAgICAgIHNvY2stPnByb3RvID0gMDsKICAgIH0KCiAgICBqc19mcmVlX3J0KHJ0LCBzb2NrKTsKICB9Cn0KCnN0YXRpYyB2b2lkCnNvY2tldF9kZWxldGUoTFdTU29ja2V0KiBzb2NrLCBKU1J1bnRpbWUqIHJ0KSB7CiAgYXNzZXJ0KHNvY2tldF9saXN0Lm5leHQpOwogIGFzc2VydChzb2NrZXRfbGlzdC5wcmV2KTsKCiAgLyogIGFzc2VydChzb2NrLT5saW5rLm5leHQpOwogICAgYXNzZXJ0KHNvY2stPmxpbmsucHJldik7Ki8KCiAgaWYoc29jay0+bGluay5uZXh0KQogICAgbGlzdF9kZWwoJnNvY2stPmxpbmspOwoKICBERUJVRygiZGVsZXRlIExXU1NvY2tldDogJXAgKHdzaSA9ICVwLCBuID0gJWQsIHJlZl9jb3VudCA9ICVkKSIsIHNvY2ssIHNvY2stPndzaSwgbGlzdF9zaXplKCZzb2NrZXRfbGlzdCksIHNvY2stPnJlZl9jb3VudCk7CgogIGlmKHNvY2stPm9iaikgewogICAgb2JqX2ZyZWUocnQsIHNvY2stPm9iaik7CiAgICBzb2NrLT5vYmogPSAwOwogIH0KCiAgc29ja2V0X2ZyZWUoc29jaywgcnQpOwp9CgpzdGF0aWMgSlNWYWx1ZQpzb2NrZXRfb2JqMihMV1NTb2NrZXQqIHNvY2ssIEpTQ29udGV4dCogY3R4KSB7CiAgcmV0dXJuIHNvY2sgPyBKU19EdXBWYWx1ZShjdHgsIHB0cl9vYmooY3R4LCBzb2NrLT5vYmopKSA6IEpTX05VTEw7Cn0KCnN0cnVjdCBsd3MqCmx3c2pzX3NvY2tldF93c2koSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgTFdTU29ja2V0KiBzb2NrOwoKICBpZigoc29jayA9IGx3c2pzX3NvY2tldF9kYXRhKHZhbHVlKSkpCiAgICByZXR1cm4gc29jay0+d3NpOwoKICByZXR1cm4gMDsKfQoKSlNWYWx1ZQpsd3Nqc19zb2NrZXRfd3JhcChKU0NvbnRleHQqIGN0eCwgTFdTU29ja2V0KiBzb2NrKSB7CiAgSlNWYWx1ZSBvYmogPSBKU19OZXdPYmplY3RQcm90b0NsYXNzKGN0eCwgbHdzanNfc29ja2V0X3Byb3RvLCBsd3Nqc19zb2NrZXRfY2xhc3NfaWQpOwoKICBKU19TZXRPcGFxdWUob2JqLCBzb2NrZXRfZHVwKHNvY2spKTsKCiAgc29jay0+b2JqID0gb2JqX3B0cihjdHgsIG9iaik7CgogIHJldHVybiBvYmo7Cn0KCkpTVmFsdWUKbHdzanNfc29ja2V0X2NyZWF0ZShKU0NvbnRleHQqIGN0eCwgc3RydWN0IGx3cyogd3NpKSB7CiAgSlNWYWx1ZSByZXQgPSBKU19VTkRFRklORUQ7CiAgTFdTU29ja2V0KiBzb2NrOwoKICBpZigoc29jayA9IHNvY2tldF9hbGxvYyhjdHgpKSkgewogICAgc29jay0+d3NpID0gd3NpOwogICAgcmV0ID0gbHdzanNfc29ja2V0X3dyYXAoY3R4LCBzb2NrKTsKICB9CgogIHJldHVybiByZXQ7Cn0KCnZvaWQKbHdzanNfc29ja2V0X2Rlc3Ryb3koSlNDb250ZXh0KiBjdHgsIHN0cnVjdCBsd3MqIHdzaSkgewogIExXU1NvY2tldCogc29jayA9IHNvY2tldF9nZXQod3NpKTsKCiAgLyppZihzb2NrID09IDApCiAgICByZXR1cm47Ki8KCiAgYXNzZXJ0KHNvY2spOwoKICBhc3NlcnQoc29jay0+d3NpKTsKICBzb2NrLT53c2kgPSAwOwoKICBzb2NrZXRfZGVsZXRlKHNvY2ssIEpTX0dldFJ1bnRpbWUoY3R4KSk7Cn0KCkpTVmFsdWUKbHdzanNfc29ja2V0X2dldF9vcl9jcmVhdGUoSlNDb250ZXh0KiBjdHgsIHN0cnVjdCBsd3MqIHdzaSkgewogIEpTVmFsdWUgcmV0ID0ganNfc29ja2V0X2dldChjdHgsIHdzaSk7CiAgQk9PTCBjcmVhdGU7CgogIGlmKChjcmVhdGUgPSBKU19Jc1VuZGVmaW5lZChyZXQpKSkKICAgIHJldCA9IGx3c2pzX3NvY2tldF9jcmVhdGUoY3R4LCB3c2kpOwoKICBERUJVRygiJXMgTFdTU29ja2V0ICh3c2kgPSAlcCwgaWQgPSAlZCwgcmVmX2NvdW50ID0gJWQsIG9iaiA9ICVwKSA9ICVwIiwKICAgICAgICBjcmVhdGUgPyAiY3JlYXRlIiA6ICJnZXQiLAogICAgICAgIHdzaSwKICAgICAgICBsd3Nqc19zb2NrZXRfZGF0YShyZXQpLT5pZCwKICAgICAgICBsd3Nqc19zb2NrZXRfZGF0YShyZXQpLT5yZWZfY291bnQsCiAgICAgICAgSlNfVkFMVUVfR0VUX09CSihyZXQpLAogICAgICAgIGx3c2pzX3NvY2tldF9kYXRhKHJldCkpOwoKICByZXR1cm4gcmV0Owp9Cgp0eXBlZGVmIHN0cnVjdCB7CiAgSlNWYWx1ZSBvYmo7CiAgSlNDb250ZXh0KiBjdHg7CiAgc3RydWN0IGx3cyogd3NpOwp9IEN1c3RvbUhlYWRlcnM7CgpzdGF0aWMgdm9pZApzZXRfcHJvcGVydHkoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIGNvbnN0IGNoYXIqIG5hbWUsIGludCBubGVuLCBjb25zdCBjaGFyKiB2YWx1ZSwgaW50IHZsZW4pIHsKICBKU0F0b20gcHJvcCA9IEpTX05ld0F0b21MZW4oY3R4LCBuYW1lLCBubGVuKTsKICBKU19TZXRQcm9wZXJ0eShjdHgsIG9iaiwgcHJvcCwgSlNfTmV3U3RyaW5nTGVuKGN0eCwgdmFsdWUsIHZsZW4pKTsKICBKU19GcmVlQXRvbShjdHgsIHByb3ApOwp9CgpzdGF0aWMgdm9pZApjdXN0b21faGVhZGVyc19jYWxsYmFjayhjb25zdCBjaGFyKiBuYW1lLCBpbnQgbmxlbiwgdm9pZCogb3BhcXVlKSB7CiAgQ3VzdG9tSGVhZGVycyogY2ggPSBvcGFxdWU7CiAgaW50IG5hbWVsZW4gPSBubGVuLCBsZW4gPSBsd3NfaGRyX2N1c3RvbV9sZW5ndGgoY2gtPndzaSwgbmFtZSwgbmxlbik7CiAgY2hhciBidWZbbGVuICsgMV07CiAgaW50IHIgPSBsd3NfaGRyX2N1c3RvbV9jb3B5KGNoLT53c2ksIGJ1ZiwgbGVuICsgMSwgbmFtZSwgbmxlbik7CiAgaW50IGkgPSAwLCBqOwoKICB3aGlsZSgoaiA9IGZpbmRiX2NoYXJzZXQoJm5hbWVbaV0sIG5sZW4gLSBpLCAiOiAiLCAyKSkgPCAobmxlbiAtIGkgLSAxKSkgewogICAgaW50IGsgPSBpICsgajsKCiAgICB3aGlsZShuYW1lW2tdID09ICc6JyB8fCBuYW1lW2tdID09ICcgJykKICAgICAgKytrOwoKICAgIGludCBuID0gZmluZGJfY2hhcnNldCgmbmFtZVtrXSwgbmxlbiAtIGssICJcclxuIiwgMik7CiAgICBpbnQgZW5kID0gayArIG47CgogICAgd2hpbGUobmFtZVtlbmRdID09ICdccicgfHwgbmFtZVtlbmRdID09ICdcbicpCiAgICAgICsrZW5kOwoKICAgIGlmKG4gPCAobmxlbiAtIGspKQogICAgICBzZXRfcHJvcGVydHkoY2gtPmN0eCwgY2gtPm9iaiwgJm5hbWVbaV0sIGosICZuYW1lW2tdLCBuKTsKCiAgICBpID0gZW5kOwoKICAgIGlmKG4gPj0gKG5sZW4gLSBrKSkKICAgICAgYnJlYWs7CiAgfQoKICBzZXRfcHJvcGVydHkoY2gtPmN0eCwgY2gtPm9iaiwgJm5hbWVbaV0sIGZpbmRiX2NoYXJzZXQoJm5hbWVbaV0sIG5sZW4gLSBpLCAiOiAiLCAyKSwgYnVmLCByKTsKfQoKSlNWYWx1ZQpsd3Nqc19zb2NrZXRfaGVhZGVycyhKU0NvbnRleHQqIGN0eCwgc3RydWN0IGx3cyogd3NpLCBjaGFyKiogcHByb3RvKSB7CiAgSlNWYWx1ZSByZXQgPSBKU19OZXdPYmplY3RQcm90byhjdHgsIEpTX05VTEwpOwoKICBmb3IoaW50IGkgPSBXU0lfVE9LRU5fR0VUX1VSSTsgaSA8IFdTSV9UT0tFTl9DT1VOVDsgKytpKSB7CiAgICBpZighaXNfdXJpKGkpICYmIGkgIT0gV1NJX1RPS0VOX0hUVFApIHsKICAgICAgc2l6ZV90IGxlbiA9IGx3c19oZHJfdG90YWxfbGVuZ3RoKHdzaSwgaSk7CgogICAgICBpZihsZW4gPiAwKSB7CiAgICAgICAgY29uc3QgY2hhciogbmFtZSA9IChjb25zdCBjaGFyKilsd3NfdG9rZW5fdG9fc3RyaW5nKGkpOwoKICAgICAgICBpZihuYW1lID09IE5VTEwpCiAgICAgICAgICBjb250aW51ZTsKCiAgICAgICAgc2l6ZV90IG5hbWVsZW4gPSBmaW5kX2NoYXJzZXQobmFtZSwgIjogIiwgMik7CiAgICAgICAgSlNBdG9tIHByb3AgPSBKU19OZXdBdG9tTGVuKGN0eCwgbmFtZSwgbmFtZWxlbik7CiAgICAgICAgY2hhciBidWZbbGVuICsgMV07CiAgICAgICAgaW50IHIgPSBsd3NfaGRyX2NvcHkod3NpLCBidWYsIGxlbiArIDEsIGkpOwoKICAgICAgICBpZihuYW1lbGVuID09IDApIHsKICAgICAgICAgIGlmKCpwcHJvdG8pCiAgICAgICAgICAgIGpzX2ZyZWUoY3R4LCAqcHByb3RvKTsKICAgICAgICAgICpwcHJvdG8gPSBqc19zdHJuZHVwKGN0eCwgYnVmLCByKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgSlNfU2V0UHJvcGVydHkoY3R4LCByZXQsIHByb3AsIEpTX05ld1N0cmluZ0xlbihjdHgsIGJ1ZiwgcikpOwogICAgICAgIH0KICAgICAgICBKU19GcmVlQXRvbShjdHgsIHByb3ApOwogICAgICB9CiAgICB9CiAgfQoKICBDdXN0b21IZWFkZXJzIGMgPSB7cmV0LCBjdHgsIHdzaX07CgogIGx3c19oZHJfY3VzdG9tX25hbWVfZm9yZWFjaCh3c2ksIGN1c3RvbV9oZWFkZXJzX2NhbGxiYWNrLCAmYyk7CgogIHJldHVybiByZXQ7Cn0KCmVudW0gewogIE1FVEhPRF9XQU5UX1dSSVRFID0gMCwKICBNRVRIT0RfV1JJVEUsCiAgTUVUSE9EX1JFU1BPTkQsCiAgTUVUSE9EX0NMT1NFLAogIE1FVEhPRF9IVFRQX0NMSUVOVF9SRUFELAogIE1FVEhPRF9BRERfSEVBREVSLAogIE1FVEhPRF9DTElFTlRfSFRUUF9NVUxUSVBBUlQsCn07CgpzdGF0aWMgSlNWYWx1ZQpsd3Nqc19zb2NrZXRfbWV0aG9kcyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSwgaW50IG1hZ2ljKSB7CiAgTFdTU29ja2V0KiBzOwogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwoKICBpZighKHMgPSBsd3Nqc19zb2NrZXRfZGF0YTIoY3R4LCB0aGlzX3ZhbCkpKQogICAgcmV0dXJuIEpTX0VYQ0VQVElPTjsKCiAgaWYoIXMtPndzaSkKICAgIHJldHVybiBKU19UaHJvd0ludGVybmFsRXJyb3IoY3R4LCAiJXMgKG1hZ2ljPSVkKSBzLT53c2kgPT0gTlVMTCIsIF9fZnVuY19fLCBtYWdpYyk7CgogIEJPT0wgaXNfd3MgPSBsd3NpX3JvbGVfd3Mocy0+d3NpKSwgaXNfaHR0cCA9IGx3c2lfcm9sZV9odHRwKHMtPndzaSk7CgogIC8qaWYoIWlzX2h0dHAgJiYgKG1hZ2ljID09IE1FVEhPRF9BRERfSEVBREVSIHx8IG1hZ2ljID09IE1FVEhPRF9IVFRQX0NMSUVOVF9SRUFEKSkKICAgIHJldHVybiBKU19UaHJvd0ludGVybmFsRXJyb3IoY3R4LCAiJXMgKG1hZ2ljPSVkKSB3c2kgaXMgbm90IEhUVFAiLCBfX2Z1bmNfXywgbWFnaWMpOyovCgogIHN3aXRjaChtYWdpYykgewogICAgY2FzZSBNRVRIT0RfV0FOVF9XUklURTogewogICAgICBpZighcy0+d2FudF93cml0ZSkgewogICAgICAgIGx3c19jYWxsYmFja19vbl93cml0YWJsZShzLT53c2kpOwoKICAgICAgICBzLT53YW50X3dyaXRlID0gVFJVRTsKICAgICAgICByZXQgPSBKU19OZXdCb29sKGN0eCwgVFJVRSk7CgogICAgICAgIGlmKGFyZ2MgPiAwKSB7CiAgICAgICAgICBKU19GcmVlVmFsdWUoY3R4LCBzLT53cml0ZV9oYW5kbGVyKTsKICAgICAgICAgIHMtPndyaXRlX2hhbmRsZXIgPSBKU19EdXBWYWx1ZShjdHgsIGFyZ3ZbMF0pOwogICAgICAgIH0KICAgICAgfQoKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBNRVRIT0RfV1JJVEU6IHsKICAgICAgRHluQnVmIGRidWYgPSB7MH07CgogICAgICBpZihsd3NfcGFydGlhbF9idWZmZXJlZChzLT53c2kpKSB7CiAgICAgICAgcmV0ID0gSlNfVGhyb3dJbnRlcm5hbEVycm9yKGN0eCwgIkkvTyBlcnJvcjogcGFydGlhbGx5IGJ1ZmZlcmVkIGx3c193cml0ZSgpIik7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KCiAgICAgIC8qaWYoIWx3c19zZW5kX3BpcGVfY2hva2VkKHMtPndzaSkpIHsKICAgICAgICByZXQgPSBKU19UaHJvd0ludGVybmFsRXJyb3IoY3R4LCAiSS9PIGVycm9yOiBzZW5kIHBpcGUgY2hva2VkIGx3c193cml0ZSgpIik7CiAgICAgICAgYnJlYWs7CiAgICAgIH0qLwoKICAgICAgQk9PTCB0ZXh0ID0gSlNfSXNTdHJpbmcoYXJndlswXSk7CiAgICAgIHNpemVfdCBsZW47CiAgICAgIHZvaWQqIHB0ciA9IHRleHQgPyAodm9pZCopSlNfVG9DU3RyaW5nTGVuKGN0eCwgJmxlbiwgYXJndlswXSkgOiBKU19HZXRBcnJheUJ1ZmZlcihjdHgsICZsZW4sIGFyZ3ZbMF0pOwogICAgICBzaXplX3QgbiA9IGxlbjsKICAgICAgZW51bSBsd3Nfd3JpdGVfcHJvdG9jb2wgcHJvdG8gPSBpc19odHRwID8gTFdTX1dSSVRFX0hUVFAgOiB0ZXh0ID8gTFdTX1dSSVRFX1RFWFQgOiBMV1NfV1JJVEVfQklOQVJZOwoKICAgICAgaWYoaXNfd3MpIHsKICAgICAgICBkYnVmX2luaXQyKCZkYnVmLCAwLCAwKTsKICAgICAgICBkYnVmX3B1dCgmZGJ1ZiwgKGNvbnN0IHZvaWQqKSJYWFhYWFhYWFhYWFhYWFhYWFhYWCIsIExXU19QUkUpOwogICAgICAgIGRidWZfcHV0KCZkYnVmLCBwdHIsIG4pOwogICAgICB9CgogICAgICBpZihhcmdjID4gMikKICAgICAgICBuID0gdG9faW50MzIoY3R4LCBhcmd2WzFdKTsKCiAgICAgIGlmKGFyZ2MgPiAxKQogICAgICAgIHByb3RvID0gdG9faW50MzIoY3R4LCBhcmd2W2FyZ2MgPiAyID8gMiA6IDFdKTsKCiAgICAgIGlmKHB0cikgewogICAgICAgIGludCByID0gbHdzX3dyaXRlKHMtPndzaSwgaXNfd3MgPyBkYnVmLmJ1ZiArIExXU19QUkUgOiBwdHIsIE1JTihuLCBsZW4pLCBwcm90byk7CgogICAgICAgIERFQlVHX1dTSShzLT53c2ksICJ3cm90ZSBkYXRhICglZCkiLCByKTsKCiAgICAgICAgcmV0ID0gSlNfTmV3SW50MzIoY3R4LCByKTsKCiAgICAgICAgaWYociA+IDApCiAgICAgICAgICBpZihwcm90byA9PSBMV1NfV1JJVEVfSFRUUF9GSU5BTCkKICAgICAgICAgICAgaWYobHdzX2h0dHBfdHJhbnNhY3Rpb25fY29tcGxldGVkKHMtPndzaSkpCiAgICAgICAgICAgICAgcy0+Y29tcGxldGVkID0gVFJVRTsKCiAgICAgICAgREVCVUdfV1NJKHMtPndzaSwgInNlbmQgcGlwZSBjaG9rZWQ6ICVkIHBhcnRpYWxseSBidWZmZXJlZDogJWQiLCBsd3Nfc2VuZF9waXBlX2Nob2tlZChzLT53c2kpLCBsd3NfcGFydGlhbF9idWZmZXJlZChzLT53c2kpKTsKICAgICAgfQoKICAgICAgaWYoSlNfSXNTdHJpbmcoYXJndlswXSkpCiAgICAgICAgSlNfRnJlZUNTdHJpbmcoY3R4LCBwdHIpOwoKICAgICAgaWYoZGJ1Zi5idWYpCiAgICAgICAgZnJlZShkYnVmLmJ1Zik7CgogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIE1FVEhPRF9SRVNQT05EOiB7CiAgICAgIHVpbnQ4X3QgcmVzdWx0W0xXU19QUkUgKyBMV1NfUkVDT01NRU5ERURfTUlOX0hFQURFUl9TUEFDRV0sICpwID0gKHVpbnQ4X3QqKXJlc3VsdCArIExXU19QUkUsICpzdGFydCA9IHA7CiAgICAgIHVpbnQ4X3QgKmVuZCA9IHAgKyBzaXplb2YocmVzdWx0KSAtIExXU19QUkUgLSAxLCAqcHRyID0gTlVMTDsKICAgICAgc2l6ZV90IHRtcF9sZW4sIHdyaXR0ZW4gPSAwOwogICAgICBpbnQ2NF90IGxlbiA9IC0xOwogICAgICBpbnQzMl90IGNvZGUgPSAtMTsKICAgICAgaW50IGhpZHggPSAtMTsKCiAgICAgIGZvcihpbnQgaSA9IDA7IGkgPCBhcmdjOyArK2kpIHsKICAgICAgICBpZihjb2RlID09IC0xICYmIEpTX0lzTnVtYmVyKGFyZ3ZbaV0pKQogICAgICAgICAgY29kZSA9IHRvX2ludGVnZXIoY3R4LCBhcmd2W2ldKTsKICAgICAgICBlbHNlIGlmKGxlbiA9PSAtMSAmJiBKU19Jc051bWJlcihhcmd2W2ldKSkKICAgICAgICAgIGxlbiA9IHRvX2ludGVnZXIoY3R4LCBhcmd2W2ldKTsKICAgICAgICBlbHNlIGlmKCFwdHIgJiYgKHB0ciA9IEpTX0dldEFycmF5QnVmZmVyKGN0eCwgJnRtcF9sZW4sIGFyZ3ZbaV0pKSkKICAgICAgICAgIGxlbiA9IGxlbiA9PSAtMSA/IChpbnQ2NF90KXRtcF9sZW4gOiBsZW47CiAgICAgICAgZWxzZSBpZighcHRyICYmIEpTX0lzU3RyaW5nKGFyZ3ZbaV0pICYmIChwdHIgPSAodWludDhfdCopSlNfVG9DU3RyaW5nTGVuKGN0eCwgJnRtcF9sZW4sIGFyZ3ZbaV0pKSkKICAgICAgICAgIGxlbiA9IGxlbiA9PSAtMSA/IChpbnQ2NF90KXRtcF9sZW4gOiBsZW47CiAgICAgICAgZWxzZSBpZihKU19Jc09iamVjdChhcmd2W2ldKSkKICAgICAgICAgIGhpZHggPSBpOwogICAgICB9CgogICAgICBpZihsd3NfYWRkX2h0dHBfY29tbW9uX2hlYWRlcnMocy0+d3NpLCBjb2RlLCBOVUxMLCBsZW4gPiAwID8gKHVpbnQ2NF90KWxlbiA6IExXU19JTExFR0FMX0hUVFBfQ09OVEVOVF9MRU4sICZwLCBlbmQpKSB7CiAgICAgICAgcmV0ID0gSlNfVGhyb3dJbnRlcm5hbEVycm9yKGN0eCwgImx3c19hZGRfaHR0cF9jb21tb25faGVhZGVycyBmYWlsZWQiKTsKICAgICAgICBicmVhazsKICAgICAgfQoKICAgICAgaWYoaGlkeCAhPSAtMSkgewogICAgICAgIEpTUHJvcGVydHlFbnVtKiB0bXBfdGFiID0gMDsKICAgICAgICB1aW50MzJfdCB0bXBfbGVuOwoKICAgICAgICBpZighSlNfR2V0T3duUHJvcGVydHlOYW1lcyhjdHgsICZ0bXBfdGFiLCAmdG1wX2xlbiwgYXJndltoaWR4XSwgSlNfR1BOX1NUUklOR19NQVNLIHwgSlNfR1BOX1NFVF9FTlVNKSkgewoKICAgICAgICAgIGZvcih1aW50MzJfdCBqID0gMDsgaiA8IHRtcF9sZW47IGorKykgewogICAgICAgICAgICBKU1ZhbHVlIGtleSA9IEpTX0F0b21Ub1ZhbHVlKGN0eCwgdG1wX3RhYltqXS5hdG9tKTsKICAgICAgICAgICAgY29uc3QgY2hhciogbmFtZSA9IEpTX1RvQ1N0cmluZyhjdHgsIGtleSk7CiAgICAgICAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGtleSk7CgogICAgICAgICAgICBKU1ZhbHVlIHZhbHVlID0gSlNfR2V0UHJvcGVydHkoY3R4LCBhcmd2W2hpZHhdLCB0bXBfdGFiW2pdLmF0b20pOwogICAgICAgICAgICBzaXplX3QgdmxlbjsKICAgICAgICAgICAgY29uc3QgY2hhciogdnN0ciA9IEpTX1RvQ1N0cmluZ0xlbihjdHgsICZ2bGVuLCB2YWx1ZSk7CiAgICAgICAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKCiAgICAgICAgICAgIGlmKGx3c19hZGRfaHR0cF9oZWFkZXJfYnlfbmFtZShzLT53c2ksIChjb25zdCB1aW50OF90KiluYW1lLCAodm9pZCopdnN0ciwgdmxlbiwgJnAsIGVuZCkpCiAgICAgICAgICAgICAgSlNfVGhyb3dJbnRlcm5hbEVycm9yKGN0eCwgImx3c19hZGRfaHR0cF9oZWFkZXJfYnlfbmFtZSIpOwoKICAgICAgICAgICAgSlNfRnJlZUNTdHJpbmcoY3R4LCBuYW1lKTsKICAgICAgICAgICAgSlNfRnJlZUNTdHJpbmcoY3R4LCB2c3RyKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIGludCBuID0gbHdzX2ZpbmFsaXplX3dyaXRlX2h0dHBfaGVhZGVyKHMtPndzaSwgc3RhcnQsICZwLCBlbmQpID8gLTEgOiAoaW50KWx3c19wdHJfZGlmZl9zaXplX3QocCwgc3RhcnQpOwoKICAgICAgREVCVUdfV1NJKHMtPndzaSwgIndyb3RlIGhlYWRlcnMgKCVkKSIsIG4pOwoKICAgICAgaWYobiA8IDApCiAgICAgICAgcmV0dXJuIEpTX1Rocm93SW50ZXJuYWxFcnJvcihjdHgsICJsd3Nfd3JpdGUiKTsKCiAgICAgIHdyaXR0ZW4gKz0gbjsKCiAgICAgIGlmKHB0ciAmJiBsZW4gPiAwKSB7CiAgICAgICAgaWYoKG4gPSBsd3Nfd3JpdGUocy0+d3NpLCAodWludDhfdCopcHRyLCAodW5zaWduZWQgaW50KWxlbiwgTFdTX1dSSVRFX0hUVFBfRklOQUwpKSA8IDApCiAgICAgICAgICByZXR1cm4gSlNfVGhyb3dJbnRlcm5hbEVycm9yKGN0eCwgImx3c193cml0ZSIpOwoKICAgICAgICB3cml0dGVuICs9IG47CiAgICAgIH0KCiAgICAgIHJldCA9IEpTX05ld1VpbnQzMihjdHgsIHdyaXR0ZW4pOwogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIE1FVEhPRF9DTE9TRTogewogICAgICB1aW50MzJfdCByZWFzb24gPSAxMDAwOwoKICAgICAgaWYoYXJnYyA+IDApCiAgICAgICAgcmVhc29uID0gdG9fdWludDMyKGN0eCwgYXJndlswXSk7CgogICAgICBpZihzb2NrZXRfdHlwZShzLT53c2kpID09IFNPQ0tFVF9XUykgewogICAgICAgIHNpemVfdCBuID0gMDsKICAgICAgICB1aW50OF90KiBwID0gTlVMTDsKICAgICAgICBjb25zdCBjaGFyKiBzdHIgPSAwOwoKICAgICAgICBpZihhcmdjID4gMSkgewogICAgICAgICAgaWYoIShwID0gZ2V0X2J1ZmZlcihjdHgsIGFyZ2MgLSAxLCBhcmd2ICsgMSwgJm4pKSkKICAgICAgICAgICAgcCA9ICh1aW50OF90Kikoc3RyID0gSlNfVG9DU3RyaW5nTGVuKGN0eCwgJm4sIGFyZ3ZbMV0pKTsKICAgICAgICB9CgogICAgICAgIGx3c19jbG9zZV9yZWFzb24ocy0+d3NpLCByZWFzb24sIHAsIG4pOwoKICAgICAgICBpZihzdHIpCiAgICAgICAgICBKU19GcmVlQ1N0cmluZyhjdHgsIHN0cik7CiAgICAgIH0KCiAgICAgIGx3c19jbG9zZV9mcmVlX3dzaShzLT53c2ksIHJlYXNvbiwgX19mdW5jX18pOwogICAgICAvLyBsd3Nfd3NpX2Nsb3NlKHMtPndzaSwgTFdTX1RPX0tJTExfU1lOQyk7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgTUVUSE9EX0hUVFBfQ0xJRU5UX1JFQUQ6IHsKICAgICAgc2l6ZV90IG47CiAgICAgIHVpbnQ4X3QgKnAsICpxOwogICAgICBpbnQgbCwgcmVzdWx0OwoKICAgICAgaWYoKHEgPSBwID0gZ2V0X2J1ZmZlcihjdHgsIGFyZ2MsIGFyZ3YsICZuKSkpIHsKICAgICAgICBsID0gbjsKICAgICAgICByZXN1bHQgPSBsd3NfaHR0cF9jbGllbnRfcmVhZChzLT53c2ksIChjaGFyKiopJnAsICZsKTsKCiAgICAgICAgaWYocmVzdWx0ICE9IC0xKQogICAgICAgICAgcmV0ID0gSlNfTmV3SW50MzIoY3R4LCBsKTsKICAgICAgfQoKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBNRVRIT0RfQUREX0hFQURFUjogewogICAgICBjb25zdCBjaGFyICpuYW1lID0gMCwgKnZhbHVlOwogICAgICBzaXplX3QgdmxlbiwgYmxlbjsKICAgICAgdW5zaWduZWQgY2hhciAqYnVmLCAqcHRyOwogICAgICBpbnQ2NF90IGxlbiA9IDA7CiAgICAgIGVudW0gbHdzX3Rva2VuX2luZGV4ZXMgdG9rZW4gPSAtMTsKCiAgICAgIGlmKEpTX0lzTnVtYmVyKGFyZ3ZbMF0pKSB7CiAgICAgICAgdG9rZW4gPSB0b19pbnQzMihjdHgsIGFyZ3ZbMF0pOwogICAgICB9IGVsc2UgaWYoIShuYW1lID0gSlNfVG9DU3RyaW5nKGN0eCwgYXJndlswXSkpKSB7CiAgICAgICAgcmV0ID0gSlNfVGhyb3dUeXBlRXJyb3IoY3R4LCAiYXJndW1lbnQgMSBtdXN0IGJlIG5hbWUiKTsKICAgICAgICBicmVhazsKICAgICAgfQoKICAgICAgaWYoISh2YWx1ZSA9IEpTX1RvQ1N0cmluZ0xlbihjdHgsICZ2bGVuLCBhcmd2WzFdKSkpIHsKICAgICAgICByZXQgPSBKU19UaHJvd1R5cGVFcnJvcihjdHgsICJhcmd1bWVudCAyIG11c3QgYmUgdmFsdWUiKTsKICAgICAgICBKU19GcmVlQ1N0cmluZyhjdHgsIG5hbWUpOwogICAgICAgIGJyZWFrOwogICAgICB9CgogICAgICBpZighKGJ1ZiA9IEpTX0dldEFycmF5QnVmZmVyKGN0eCwgJmJsZW4sIGFyZ3ZbMl0pKSkgewogICAgICAgIHJldCA9IEpTX1Rocm93VHlwZUVycm9yKGN0eCwgImFyZ3VtZW50IDMgbXVzdCBiZSBBcnJheUJ1ZmZlciIpOwogICAgICAgIEpTX0ZyZWVDU3RyaW5nKGN0eCwgbmFtZSk7CiAgICAgICAgSlNfRnJlZUNTdHJpbmcoY3R4LCB2YWx1ZSk7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KCiAgICAgIGxlbiA9IHRvX2ludDY0KGN0eCwgSlNfR2V0UHJvcGVydHlVaW50MzIoY3R4LCBhcmd2WzNdLCAwKSk7CiAgICAgIGxlbiA9IE1JTihNQVgoMCwgbGVuKSwgKGludDY0X3QpYmxlbik7CgogICAgICBwdHIgPSBidWYgKyBsZW47CgogICAgICBpbnQgciA9IG5hbWUgPyBsd3NfYWRkX2h0dHBfaGVhZGVyX2J5X25hbWUocy0+d3NpLCAoY29uc3QgdW5zaWduZWQgY2hhciopbmFtZSwgKGNvbnN0IHVuc2lnbmVkIGNoYXIqKXZhbHVlLCB2bGVuLCAmcHRyLCBidWYgKyBibGVuKQogICAgICAgICAgICAgICAgICAgOiBsd3NfYWRkX2h0dHBfaGVhZGVyX2J5X3Rva2VuKHMtPndzaSwgdG9rZW4sIChjb25zdCB1bnNpZ25lZCBjaGFyKil2YWx1ZSwgdmxlbiwgJnB0ciwgYnVmICsgYmxlbik7CgogICAgICBKU19TZXRQcm9wZXJ0eVVpbnQzMihjdHgsIGFyZ3ZbM10sIDAsIEpTX05ld1VpbnQzMihjdHgsIHB0ciAtIGJ1ZikpOwoKICAgICAgcmV0ID0gSlNfTmV3SW50MzIoY3R4LCByKTsKCiAgICAgIEpTX0ZyZWVDU3RyaW5nKGN0eCwgbmFtZSk7CiAgICAgIEpTX0ZyZWVDU3RyaW5nKGN0eCwgdmFsdWUpOwogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIE1FVEhPRF9DTElFTlRfSFRUUF9NVUxUSVBBUlQ6IHsKCiAgICAgICAgICBpZighcy0+d3NpLT5odHRwLm11bHRpcGFydCkKICAgICAgICAgICAgICBicmVhazsKCiAgICAgIHN0cnVjdCBsd3NfcHJvY2Vzc19odG1sX2FyZ3MgYSA9IHswfSwgYiwgYzsKICAgICAgY29uc3QgY2hhciAqbmFtZSA9IDAsICpmaWxlbmFtZSA9IDAsICpjb250ZW50X3R5cGUgPSAwOwogICAgICBpbnQgaSA9IDA7CgogICAgICBpZihhcmdjID4gMCAmJiAhaXNfbnVsbGlzaChhcmd2WzBdKSkKICAgICAgICBuYW1lID0gSlNfVG9DU3RyaW5nKGN0eCwgYXJndlswXSk7CiAgICAgIGlmKGFyZ2MgPiAxICYmICFpc19udWxsaXNoKGFyZ3ZbMV0pKQogICAgICAgIGZpbGVuYW1lID0gSlNfVG9DU3RyaW5nKGN0eCwgYXJndlsxXSk7CiAgICAgIGlmKGFyZ2MgPiAyICYmICFpc19udWxsaXNoKGFyZ3ZbMl0pKQogICAgICAgIGNvbnRlbnRfdHlwZSA9IEpTX1RvQ1N0cmluZyhjdHgsIGFyZ3ZbMl0pOwogICAgICBpZihhcmdjID4gMykKICAgICAgICBpID0gbHdzanNfaHRtbF9wcm9jZXNzX2FyZ3MoY3R4LCAmYSwgYXJnYyAtIDMsIGFyZ3YgKyAzKTsKCiAgICAgIGIgPSBhOwoKICAgICAgYi5wICs9IGIubGVuOwogICAgICBiLm1heF9sZW4gLT0gYi5sZW47CgogICAgICBjID0gYjsKCiAgICAgIGlmKGx3c19jbGllbnRfaHR0cF9tdWx0aXBhcnQocy0+d3NpLCBuYW1lLCBmaWxlbmFtZSwgY29udGVudF90eXBlLCAmYi5wLCBiLnAgKyBiLm1heF9sZW4pKSB7CiAgICAgICAgcmV0ID0gSlNfVGhyb3dSYW5nZUVycm9yKGN0eCwgImx3c19jbGllbnRfaHR0cF9tdWx0aXBhcnQ6IGRvZXMgbm90IGZpdCBpbnRvIGJ1ZmZlciBvZiBsZW4gJWQiLCBhLm1heF9sZW4pOwogICAgICB9IGVsc2UgewogICAgICAgIHB0cmRpZmZfdCBuID0gYi5wIC0gYy5wOwoKICAgICAgICBhLmxlbiArPSBuOwoKICAgICAgICBpZihhcmdjID4gNCAmJiBKU19Jc09iamVjdChhcmd2WzRdKSkKICAgICAgICAgIEpTX1NldFByb3BlcnR5VWludDMyKGN0eCwgYXJndls0XSwgMCwgSlNfTmV3VWludDMyKGN0eCwgYS5sZW4pKTsKCiAgICAgICAgcmV0ID0gSlNfTmV3VWludDMyKGN0eCwgbik7CiAgICAgIH0KCiAgICAgIGlmKG5hbWUpCiAgICAgICAgSlNfRnJlZUNTdHJpbmcoY3R4LCBuYW1lKTsKICAgICAgaWYoZmlsZW5hbWUpCiAgICAgICAgSlNfRnJlZUNTdHJpbmcoY3R4LCBmaWxlbmFtZSk7CiAgICAgIGlmKGNvbnRlbnRfdHlwZSkKICAgICAgICBKU19GcmVlQ1N0cmluZyhjdHgsIGNvbnRlbnRfdHlwZSk7CgogICAgICBicmVhazsKICAgIH0KICB9CgogIHJldHVybiByZXQ7Cn0KCmVudW0gewogIEZVTkNUSU9OX0xJU1QsCiAgRlVOQ1RJT05fR0VULAp9OwoKc3RhdGljIEpTVmFsdWUKbHdzanNfc29ja2V0X2Z1bmN0aW9ucyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSwgaW50IG1hZ2ljKSB7CiAgSlNWYWx1ZSByZXQgPSBKU19VTkRFRklORUQ7CgogIHN3aXRjaChtYWdpYykgewogICAgY2FzZSBGVU5DVElPTl9MSVNUOiB7CiAgICAgIGlmKHNvY2tldF9saXN0Lm5leHQgIT0gMCkgewogICAgICAgIHVpbnQzMl90IGkgPSAwOwogICAgICAgIHN0cnVjdCBsaXN0X2hlYWQqIGVsOwoKICAgICAgICByZXQgPSBKU19OZXdBcnJheShjdHgpOwoKICAgICAgICBsaXN0X2Zvcl9lYWNoKGVsLCAmc29ja2V0X2xpc3QpIHsKICAgICAgICAgIExXU1NvY2tldCogc29jayA9IGxpc3RfZW50cnkoZWwsIExXU1NvY2tldCwgbGluayk7CgogICAgICAgICAgaWYoc29jayA9PSAoTFdTU29ja2V0KikodWludHB0cl90KShpbnRwdHJfdCktMSkKICAgICAgICAgICAgY29udGludWU7CgogICAgICAgICAgSlNfU2V0UHJvcGVydHlVaW50MzIoY3R4LCByZXQsIGkrKywgc29ja2V0X29iajIoc29jaywgY3R4KSk7CiAgICAgICAgfQogICAgICB9CgogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIEZVTkNUSU9OX0dFVDogewogICAgICByZXQgPSBzb2NrZXRfb2JqMihzb2NrZXRfZ2V0X2J5X2lkKHRvX2ludDMyKGN0eCwgYXJndlswXSkpLCBjdHgpOwogICAgICBicmVhazsKICAgIH0KICB9CgogIHJldHVybiByZXQ7Cn0KCmVudW0gewogIFBST1BfVkhPU1QsCiAgUFJPUF9IRUFERVJTLAogIFBST1BfSUQsCiAgUFJPUF9DTElFTlQsCiAgUFJPUF9SRVNQT05TRV9DT0RFLAogIFBST1BfRkQsCiAgUFJPUF9NRVRIT0QsCiAgUFJPUF9VUkksCiAgUFJPUF9CT0RZX1BFTkRJTkcsCiAgUFJPUF9SRURJUkVDVEVEX1RPX0dFVCwKICBQUk9QX1BST1RPQ09MLAogIFBST1BfVEFHLAogIFBST1BfVExTLAogIFBST1BfUEVFUiwKICBQUk9QX0xPQ0FMLAogIFBST1BfQ09OVEVYVCwKICBQUk9QX1BFRVJfV1JJVEVfQUxMT1dBTkNFLAogIFBST1BfUEFSRU5ULAogIFBST1BfQ0hJTEQsCiAgUFJPUF9ORVRXT1JLLAogIFBST1BfRVhURU5TSU9OUywKICBQUk9QX0gyLAp9OwoKc3RhdGljIEpTVmFsdWUKbHdzanNfc29ja2V0X3NldChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBKU1ZhbHVlQ29uc3QgdmFsdWUsIGludCBtYWdpYykgewogIExXU1NvY2tldCogczsKICBKU1ZhbHVlIHJldCA9IEpTX1VOREVGSU5FRDsKCiAgaWYoIShzID0gbHdzanNfc29ja2V0X2RhdGEyKGN0eCwgdGhpc192YWwpKSkKICAgIHJldHVybiBKU19FWENFUFRJT047CgogIGlmKCFzLT53c2kpCiAgICByZXR1cm4gSlNfVU5JTklUSUFMSVpFRDsKCiAgc3dpdGNoKG1hZ2ljKSB7CiAgICBjYXNlIFBST1BfQk9EWV9QRU5ESU5HOiB7CiAgICAgIGx3c19jbGllbnRfaHR0cF9ib2R5X3BlbmRpbmcocy0+d3NpLCAocy0+Ym9keV9wZW5kaW5nID0gdG9faW50MzIoY3R4LCB2YWx1ZSkpKTsKICAgICAgYnJlYWs7CiAgICB9CiAgfQoKICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgSlNWYWx1ZQpsd3Nqc19zb2NrZXRfZ2V0KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBtYWdpYykgewogIExXU1NvY2tldCogczsKICBKU1ZhbHVlIHJldCA9IEpTX1VOREVGSU5FRDsKCiAgaWYoIShzID0gbHdzanNfc29ja2V0X2RhdGEyKGN0eCwgdGhpc192YWwpKSkKICAgIHJldHVybiBKU19FWENFUFRJT047CgogIGlmKCFzLT53c2kgJiYgbWFnaWMgPiBQUk9QX1BST1RPQ09MKQogICAgcmV0dXJuIEpTX1VOSU5JVElBTElaRUQ7CgogIHN3aXRjaChtYWdpYykgewogICAgY2FzZSBQUk9QX1ZIT1NUOiB7CiAgICAgIHN0cnVjdCBsd3Nfdmhvc3QqIHZobzsKCiAgICAgIGlmKCh2aG8gPSBsd3NfZ2V0X3Zob3N0KHMtPndzaSkpKQogICAgICAgIHJldCA9IGx3c192aG9zdF9vYmplY3QoY3R4LCB2aG8pOwoKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIFBST1BfSEVBREVSUzogewogICAgICByZXQgPSBKU19EdXBWYWx1ZShjdHgsIHMtPmhlYWRlcnMpOwogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIFBST1BfSUQ6IHsKICAgICAgcmV0ID0gSlNfTmV3VWludDMyKGN0eCwgcy0+aWQpOwogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIFBST1BfQ0xJRU5UOiB7CiAgICAgIHJldCA9IEpTX05ld0Jvb2woY3R4LCBzLT5jbGllbnQpOwogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIFBST1BfUkVTUE9OU0VfQ09ERTogewogICAgICBpZihzLT5yZXNwb25zZV9jb2RlICE9IDApCiAgICAgICAgcmV0ID0gSlNfTmV3SW50MzIoY3R4LCBzLT5yZXNwb25zZV9jb2RlKTsKCiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgUFJPUF9GRDogewogICAgICBpbnQzMl90IGZkID0gcy0+d3NpID8gKGludDMyX3QpbHdzX2dldF9zb2NrZXRfZmQocy0+d3NpKSA6IC0xOwogICAgICByZXQgPSBKU19OZXdJbnQzMihjdHgsIGZkKTsKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBQUk9QX01FVEhPRDogewogICAgICBjb25zdCBjaGFyKiBtZXRob2Q7CgogICAgICBpZigobWV0aG9kID0gbHdzanNfbWV0aG9kX25hbWUocy0+bWV0aG9kKSkpCiAgICAgICAgcmV0ID0gSlNfTmV3U3RyaW5nKGN0eCwgbWV0aG9kKTsKCiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgUFJPUF9VUkk6IHsKICAgICAgcmV0ID0gcy0+dXJpID8gSlNfTmV3U3RyaW5nKGN0eCwgcy0+dXJpKSA6IEpTX05VTEw7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgUFJPUF9CT0RZX1BFTkRJTkc6IHsKICAgICAgcmV0ID0gSlNfTmV3SW50MzIoY3R4LCBzLT5ib2R5X3BlbmRpbmcpOwogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIFBST1BfUkVESVJFQ1RFRF9UT19HRVQ6IHsKICAgICAgcmV0ID0gSlNfTmV3Qm9vbChjdHgsIHMtPnJlZGlyZWN0ZWRfdG9fZ2V0KTsKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBQUk9QX1BST1RPQ09MOiB7CiAgICAgIHJldCA9IHMtPnByb3RvID8gSlNfTmV3U3RyaW5nKGN0eCwgcy0+cHJvdG8pIDogSlNfTlVMTDsKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBQUk9QX1RBRzogewogICAgICBjb25zdCBjaGFyKiB0YWc7CgogICAgICBpZigodGFnID0gbHdzX3dzaV90YWcocy0+d3NpKSkpCiAgICAgICAgcmV0ID0gSlNfTmV3U3RyaW5nKGN0eCwgdGFnKTsKCiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgUFJPUF9UTFM6IHsKICAgICAgcmV0ID0gSlNfTmV3Qm9vbChjdHgsIGx3c19pc19zc2wocy0+d3NpKSk7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgUFJPUF9QRUVSOiB7CiAgICAgIGx3c19zb2NrZmRfdHlwZSBmZCA9IGx3c19nZXRfc29ja2V0X2ZkKHMtPndzaSk7CgogICAgICBpZihmZCA9PSAtMSkgewogICAgICAgIHJldCA9IEpTX05VTEw7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KCiAgICAgIHJldCA9IGx3c2pzX3NvY2thZGRyNDZfbmV3KGN0eCk7CiAgICAgIGx3c19zb2NrYWRkcjQ2KiBzYSA9IGx3c2pzX3NvY2thZGRyNDZfZGF0YShjdHgsIHJldCk7CiAgICAgIHNvY2tsZW5fdCBsZW4gPSBzaXplb2YoKnNhKTsKCiAgICAgIGlmKGdldHBlZXJuYW1lKGZkLCAoc3RydWN0IHNvY2thZGRyKilzYSwgJmxlbikgPT0gLTEpIHsKICAgICAgICBKU19GcmVlVmFsdWUoY3R4LCByZXQpOwogICAgICAgIGlmKGVycm5vID09IEVCQURGKQogICAgICAgICAgcmV0ID0gSlNfTlVMTDsKICAgICAgICBlbHNlCiAgICAgICAgICByZXQgPSBKU19UaHJvd0ludGVybmFsRXJyb3IoY3R4LCAiZ2VldHBlZXJuYW1lKCVkKSByZXR1cm5lZCAtMTogJXMiLCBmZCwgc3RyZXJyb3IoZXJybm8pKTsKICAgICAgfQoKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBQUk9QX0xPQ0FMOiB7CiAgICAgIGx3c19zb2NrZmRfdHlwZSBmZCA9IGx3c19nZXRfc29ja2V0X2ZkKHMtPndzaSk7CgogICAgICBpZihmZCA9PSAtMSkgewogICAgICAgIHJldCA9IEpTX05VTEw7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KCiAgICAgIHJldCA9IGx3c2pzX3NvY2thZGRyNDZfbmV3KGN0eCk7CiAgICAgIGx3c19zb2NrYWRkcjQ2KiBzYSA9IGx3c2pzX3NvY2thZGRyNDZfZGF0YShjdHgsIHJldCk7CiAgICAgIHNvY2tsZW5fdCBsZW4gPSBzaXplb2YoKnNhKTsKCiAgICAgIGlmKGdldHNvY2tuYW1lKGZkLCAoc3RydWN0IHNvY2thZGRyKilzYSwgJmxlbikgPT0gLTEpIHsKICAgICAgICBKU19GcmVlVmFsdWUoY3R4LCByZXQpOwogICAgICAgIGlmKGVycm5vID09IEVCQURGKQogICAgICAgICAgcmV0ID0gSlNfTlVMTDsKICAgICAgICBlbHNlCiAgICAgICAgICByZXQgPSBKU19UaHJvd0ludGVybmFsRXJyb3IoY3R4LCAiZ2V0c29ja25hbWUoJWQpIHJldHVybmVkIC0xOiAlcyIsIGZkLCBzdHJlcnJvcihlcnJubykpOwogICAgICB9CgogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIFBST1BfQ09OVEVYVDogewogICAgICBzdHJ1Y3QgbHdzX2NvbnRleHQqIGx3czsKCiAgICAgIGlmKChsd3MgPSBsd3NfZ2V0X2NvbnRleHQocy0+d3NpKSkpCiAgICAgICAgcmV0ID0gcHRyX29iaihjdHgsIGx3c19jb250ZXh0X3VzZXIobHdzKSk7CgogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIFBST1BfUEVFUl9XUklURV9BTExPV0FOQ0U6IHsKICAgICAgcmV0ID0gSlNfTmV3SW50MzIoY3R4LCBsd3NfZ2V0X3BlZXJfd3JpdGVfYWxsb3dhbmNlKHMtPndzaSkpOwogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIFBST1BfUEFSRU5UOiB7CiAgICAgIHN0cnVjdCBsd3MqIHdzaSA9IGx3c19nZXRfcGFyZW50KHMtPndzaSk7CgogICAgICBpZih3c2kpCiAgICAgICAgcmV0ID0gd3NpID09IHMtPndzaSA/IEpTX0R1cFZhbHVlKGN0eCwgdGhpc192YWwpIDogbHdzanNfc29ja2V0X2dldF9vcl9jcmVhdGUoY3R4LCB3c2kpOwoKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBQUk9QX0NISUxEOiB7CiAgICAgIHN0cnVjdCBsd3MqIHdzaSA9IGx3c19nZXRfY2hpbGQocy0+d3NpKTsKCiAgICAgIGlmKHdzaSkKICAgICAgICByZXQgPSB3c2kgPT0gcy0+d3NpID8gSlNfRHVwVmFsdWUoY3R4LCB0aGlzX3ZhbCkgOiBsd3Nqc19zb2NrZXRfZ2V0X29yX2NyZWF0ZShjdHgsIHdzaSk7CgogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIFBST1BfTkVUV09SSzogewogICAgICBzdHJ1Y3QgbHdzKiB3c2kgPSBsd3NfZ2V0X25ldHdvcmtfd3NpKHMtPndzaSk7CgogICAgICBpZih3c2kpCiAgICAgICAgcmV0ID0gd3NpID09IHMtPndzaSA/IEpTX0R1cFZhbHVlKGN0eCwgdGhpc192YWwpIDogbHdzanNfc29ja2V0X2dldF9vcl9jcmVhdGUoY3R4LCB3c2kpOwoKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBQUk9QX0VYVEVOU0lPTlM6IHsKICAgICAgTFdTQ29udGV4dCogbGM7CgogICAgICBpZigobGMgPSBsd3Nqc19zb2NrZXRfY29udGV4dChzLT53c2kpKSAmJiBsYy0+aW5mby5leHRlbnNpb25zKSB7CiAgICAgICAgcmV0ID0gSlNfTmV3QXJyYXkoY3R4KTsKCiAgICAgICAgZm9yKGludCBpID0gMDsgbGMtPmluZm8uZXh0ZW5zaW9uc1tpXS5uYW1lOyBpKyspCiAgICAgICAgICBKU19TZXRQcm9wZXJ0eVVpbnQzMihjdHgsIHJldCwgaSwgSlNfTmV3U3RyaW5nKGN0eCwgbGMtPmluZm8uZXh0ZW5zaW9uc1tpXS5uYW1lKSk7CiAgICAgIH0KCiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgUFJPUF9IMjogewogICAgICBpZihzLT53c2kpCiAgICAgICAgcmV0ID0gSlNfTmV3Qm9vbChjdHgsIGx3c193c2lfaXNfaDIocy0+d3NpKSk7CgogICAgICBicmVhazsKICAgIH0KICB9CgogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyB2b2lkCmx3c2pzX3NvY2tldF9maW5hbGl6ZXIoSlNSdW50aW1lKiBydCwgSlNWYWx1ZSB2YWwpIHsKICBMV1NTb2NrZXQqIHM7CgogIGlmKChzID0gbHdzanNfc29ja2V0X2RhdGEodmFsKSkpCiAgICBzb2NrZXRfZnJlZShzLCBydCk7Cn0KCnN0YXRpYyBjb25zdCBKU0NsYXNzRGVmIGx3c19zb2NrZXRfY2xhc3MgPSB7CiAgICAiTFdTU29ja2V0IiwKICAgIC5maW5hbGl6ZXIgPSBsd3Nqc19zb2NrZXRfZmluYWxpemVyLAp9OwoKc3RhdGljIGNvbnN0IEpTQ0Z1bmN0aW9uTGlzdEVudHJ5IGx3c19zb2NrZXRfcHJvdG9fZnVuY3NbXSA9IHsKICAgIEpTX0NGVU5DX01BR0lDX0RFRigid2FudFdyaXRlIiwgMCwgbHdzanNfc29ja2V0X21ldGhvZHMsIE1FVEhPRF9XQU5UX1dSSVRFKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigid3JpdGUiLCAxLCBsd3Nqc19zb2NrZXRfbWV0aG9kcywgTUVUSE9EX1dSSVRFKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigicmVzcG9uZCIsIDEsIGx3c2pzX3NvY2tldF9tZXRob2RzLCBNRVRIT0RfUkVTUE9ORCksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImNsb3NlIiwgMCwgbHdzanNfc29ja2V0X21ldGhvZHMsIE1FVEhPRF9DTE9TRSksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImh0dHBDbGllbnRSZWFkIiwgMSwgbHdzanNfc29ja2V0X21ldGhvZHMsIE1FVEhPRF9IVFRQX0NMSUVOVF9SRUFEKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiYWRkSGVhZGVyIiwgNCwgbHdzanNfc29ja2V0X21ldGhvZHMsIE1FVEhPRF9BRERfSEVBREVSKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiY2xpZW50SHR0cE11bHRpcGFydCIsIDQsIGx3c2pzX3NvY2tldF9tZXRob2RzLCBNRVRIT0RfQ0xJRU5UX0hUVFBfTVVMVElQQVJUKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfRkxBR1NfREVGKCJpZCIsIGx3c2pzX3NvY2tldF9nZXQsIDAsIFBST1BfSUQsIEpTX1BST1BfRU5VTUVSQUJMRSksCiAgICBKU19DR0VUU0VUX01BR0lDX0ZMQUdTX0RFRigidGFnIiwgbHdzanNfc29ja2V0X2dldCwgMCwgUFJPUF9UQUcsIEpTX1BST1BfQ09ORklHVVJBQkxFKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJ2aG9zdCIsIGx3c2pzX3NvY2tldF9nZXQsIDAsIFBST1BfVkhPU1QpLAogICAgSlNfQ0dFVFNFVF9NQUdJQ19ERUYoImhlYWRlcnMiLCBsd3Nqc19zb2NrZXRfZ2V0LCAwLCBQUk9QX0hFQURFUlMpLAogICAgSlNfQ0dFVFNFVF9NQUdJQ19ERUYoInRscyIsIGx3c2pzX3NvY2tldF9nZXQsIDAsIFBST1BfVExTKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJwZWVyIiwgbHdzanNfc29ja2V0X2dldCwgMCwgUFJPUF9QRUVSKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJsb2NhbCIsIGx3c2pzX3NvY2tldF9nZXQsIDAsIFBST1BfTE9DQUwpLAogICAgSlNfQ0dFVFNFVF9NQUdJQ19ERUYoImZkIiwgbHdzanNfc29ja2V0X2dldCwgMCwgUFJPUF9GRCksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigicGFyZW50IiwgbHdzanNfc29ja2V0X2dldCwgMCwgUFJPUF9QQVJFTlQpLAogICAgSlNfQ0dFVFNFVF9NQUdJQ19ERUYoImNoaWxkIiwgbHdzanNfc29ja2V0X2dldCwgMCwgUFJPUF9DSElMRCksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigibmV0d29yayIsIGx3c2pzX3NvY2tldF9nZXQsIDAsIFBST1BfTkVUV09SSyksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigiY29udGV4dCIsIGx3c2pzX3NvY2tldF9nZXQsIDAsIFBST1BfQ09OVEVYVCksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigicGVlcldyaXRlQWxsb3dhbmNlIiwgbHdzanNfc29ja2V0X2dldCwgMCwgUFJPUF9QRUVSX1dSSVRFX0FMTE9XQU5DRSksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigicHJvdG9jb2wiLCBsd3Nqc19zb2NrZXRfZ2V0LCAwLCBQUk9QX1BST1RPQ09MKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJtZXRob2QiLCBsd3Nqc19zb2NrZXRfZ2V0LCAwLCBQUk9QX01FVEhPRCksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigidXJpIiwgbHdzanNfc29ja2V0X2dldCwgMCwgUFJPUF9VUkkpLAogICAgSlNfQ0dFVFNFVF9NQUdJQ19ERUYoImNsaWVudCIsIGx3c2pzX3NvY2tldF9nZXQsIDAsIFBST1BfQ0xJRU5UKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJyZXNwb25zZSIsIGx3c2pzX3NvY2tldF9nZXQsIDAsIFBST1BfUkVTUE9OU0VfQ09ERSksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigiYm9keVBlbmRpbmciLCBsd3Nqc19zb2NrZXRfZ2V0LCBsd3Nqc19zb2NrZXRfc2V0LCBQUk9QX0JPRFlfUEVORElORyksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigicmVkaXJlY3RlZFRvR2V0IiwgbHdzanNfc29ja2V0X2dldCwgMCwgUFJPUF9SRURJUkVDVEVEX1RPX0dFVCksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigiZXh0ZW5zaW9ucyIsIGx3c2pzX3NvY2tldF9nZXQsIDAsIFBST1BfRVhURU5TSU9OUyksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigiaDIiLCBsd3Nqc19zb2NrZXRfZ2V0LCAwLCBQUk9QX0gyKSwKICAgIEpTX1BST1BfU1RSSU5HX0RFRigiW1N5bWJvbC50b1N0cmluZ1RhZ10iLCAiTFdTU29ja2V0IiwgSlNfUFJPUF9DT05GSUdVUkFCTEUpLAp9OwoKc3RhdGljIGNvbnN0IEpTQ0Z1bmN0aW9uTGlzdEVudHJ5IGx3c19zb2NrZXRfc3RhdGljX2Z1bmNzW10gPSB7CiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImxpc3QiLCAwLCBsd3Nqc19zb2NrZXRfZnVuY3Rpb25zLCBGVU5DVElPTl9MSVNUKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZ2V0IiwgMSwgbHdzanNfc29ja2V0X2Z1bmN0aW9ucywgRlVOQ1RJT05fR0VUKSwKfTsKCmludApsd3Nqc19zb2NrZXRfaW5pdChKU0NvbnRleHQqIGN0eCwgSlNNb2R1bGVEZWYqIG0pIHsKICBpbml0X2xpc3RfaGVhZCgmc29ja2V0X2xpc3QpOwoKICBKU19OZXdDbGFzc0lEKCZsd3Nqc19zb2NrZXRfY2xhc3NfaWQpOwogIEpTX05ld0NsYXNzKEpTX0dldFJ1bnRpbWUoY3R4KSwgbHdzanNfc29ja2V0X2NsYXNzX2lkLCAmbHdzX3NvY2tldF9jbGFzcyk7CiAgbHdzanNfc29ja2V0X3Byb3RvID0gSlNfTmV3T2JqZWN0UHJvdG8oY3R4LCBKU19OVUxMKTsKICBKU19TZXRQcm9wZXJ0eUZ1bmN0aW9uTGlzdChjdHgsIGx3c2pzX3NvY2tldF9wcm90bywgbHdzX3NvY2tldF9wcm90b19mdW5jcywgY291bnRvZihsd3Nfc29ja2V0X3Byb3RvX2Z1bmNzKSk7CgogIGx3c2pzX3NvY2tldF9jdG9yID0gSlNfTmV3T2JqZWN0UHJvdG8oY3R4LCBKU19OVUxMKTsKICBKU19TZXRQcm9wZXJ0eUZ1bmN0aW9uTGlzdChjdHgsIGx3c2pzX3NvY2tldF9jdG9yLCBsd3Nfc29ja2V0X3N0YXRpY19mdW5jcywgY291bnRvZihsd3Nfc29ja2V0X3N0YXRpY19mdW5jcykpOwogIEpTX1NldENvbnN0cnVjdG9yKGN0eCwgbHdzanNfc29ja2V0X2N0b3IsIGx3c2pzX3NvY2tldF9wcm90byk7CgogIGlmKG0pIHsKICAgIEpTX1NldE1vZHVsZUV4cG9ydChjdHgsIG0sICJMV1NTb2NrZXQiLCBsd3Nqc19zb2NrZXRfY3Rvcik7CiAgfQoKICByZXR1cm4gMDsKfQoAAAAAAAAAABhnAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAfD0AAAAAAAB8PQAAAAAAAAAAAAAAAPC/"
				],
				[
					31,
					1,
					"revert",
					null,
					"BQAAAAAAAAAAAAAAAAAAAAAAAAAYZwAAI2luY2x1ZGUgImx3cy1zb2NrZXQuaCIKI2luY2x1ZGUgImx3cy1jb250ZXh0LmgiCiNpbmNsdWRlICJsd3Mtdmhvc3QuaCIKI2luY2x1ZGUgImx3cy1zb2NrYWRkcjQ2LmgiCiNpbmNsdWRlICJsd3MuaCIKI2luY2x1ZGUgImpzLXV0aWxzLmgiCiNpbmNsdWRlIDxhc3NlcnQuaD4KCiNpbmNsdWRlICJsaWJ3ZWJzb2NrZXRzL2xpYi9jb3JlL3ByaXZhdGUtbGliLWNvcmUuaCIKLy8gI2luY2x1ZGUgImxpYndlYnNvY2tldHMvbGliL3JvbGVzL3ByaXZhdGUtbGliLXJvbGVzLmgiCgpKU0NsYXNzSUQgbHdzanNfc29ja2V0X2NsYXNzX2lkOwpzdGF0aWMgSlNWYWx1ZSBsd3Nqc19zb2NrZXRfcHJvdG8sIGx3c2pzX3NvY2tldF9jdG9yOwoKc3RhdGljIHN0cnVjdCBsaXN0X2hlYWQgc29ja2V0X2xpc3Q7CnN0YXRpYyB1aW50MzJfdCBzb2NrZXRfaWQ7CgpzdGF0aWMgY29uc3QgZW51bSBsd3NfdG9rZW5faW5kZXhlcyBsd3Nqc19tZXRob2RfdG9rZW5zW10gPSB7CiAgICBXU0lfVE9LRU5fR0VUX1VSSSwKICAgIFdTSV9UT0tFTl9QT1NUX1VSSSwKI2lmZGVmIExXU19XSVRIX0hUVFBfVU5DT01NT05fSEVBREVSUwogICAgV1NJX1RPS0VOX09QVElPTlNfVVJJLAogICAgV1NJX1RPS0VOX1BVVF9VUkksCiAgICBXU0lfVE9LRU5fUEFUQ0hfVVJJLAogICAgV1NJX1RPS0VOX0RFTEVURV9VUkksCiNlbmRpZgogICAgV1NJX1RPS0VOX0NPTk5FQ1QsCiAgICBXU0lfVE9LRU5fSEVBRF9VUkksCiNpZmRlZiBMV1NfV0lUSF9IVFRQMgogICAgV1NJX1RPS0VOX0hUVFBfQ09MT05fUEFUSCwKI2VuZGlmCn07CgpzdGF0aWMgY29uc3QgY2hhciogY29uc3QgbHdzanNfbWV0aG9kX25hbWVzW10gPSB7CiAgICAiR0VUIiwKICAgICJQT1NUIiwKI2lmZGVmIExXU19XSVRIX0hUVFBfVU5DT01NT05fSEVBREVSUwogICAgIk9QVElPTlMiLAogICAgIlBVVCIsCiAgICAiUEFUQ0giLAogICAgIkRFTEVURSIsCiNlbmRpZgogICAgIkNPTk5FQ1QiLAogICAgIkhFQUQiLAojaWZkZWYgTFdTX1dJVEhfSFRUUDIKICAgICJDT0xPTl9QQVRIIiwKI2VuZGlmCn07CgpzdGF0aWMgQk9PTAppc191cmkoZW51bSBsd3NfdG9rZW5faW5kZXhlcyB0aSkgewogIGZvcihzaXplX3QgaSA9IDA7IGkgPCBjb3VudG9mKGx3c2pzX21ldGhvZF90b2tlbnMpOyBpKyspCiAgICBpZihsd3Nqc19tZXRob2RfdG9rZW5zW2ldID09IHRpKQogICAgICByZXR1cm4gVFJVRTsKCiAgcmV0dXJuIEZBTFNFOwp9CgppbnQKbHdzanNfbWV0aG9kX2luZGV4KGNvbnN0IGNoYXIqIG1ldGhvZCkgewogIGZvcihpbnQgaSA9IDA7IGkgPCAoaW50KWNvdW50b2YobHdzanNfbWV0aG9kX25hbWVzKTsgKytpKQogICAgaWYobHdzanNfbWV0aG9kX25hbWVzW2ldKQogICAgICBpZighc3RyY2FzZWNtcChtZXRob2QsIGx3c2pzX21ldGhvZF9uYW1lc1tpXSkpCiAgICAgICAgcmV0dXJuIGk7CgogIHJldHVybiAtMTsKfQoKY29uc3QgY2hhcioKbHdzanNfbWV0aG9kX25hbWUoaW50IGkpIHsKICBpZihpID49IDAgJiYgaSA8IChpbnQpY291bnRvZihsd3Nqc19tZXRob2RfbmFtZXMpKQogICAgcmV0dXJuIGx3c2pzX21ldGhvZF9uYW1lc1tpXTsKCiAgcmV0dXJuIDA7Cn0KCkxXU1NvY2tldCoKc29ja2V0X2R1cChMV1NTb2NrZXQqIHMpIHsKICArK3MtPnJlZl9jb3VudDsKICByZXR1cm4gczsKfQoKTFdTU29ja2V0Kgpzb2NrZXRfYWxsb2MoSlNDb250ZXh0KiBjdHgpIHsKICBMV1NTb2NrZXQqIHNvY2s7CgogIGlmKCEoc29jayA9IGpzX21hbGxvY3ooY3R4LCBzaXplb2YoTFdTU29ja2V0KSkpKQogICAgcmV0dXJuIDA7CgogIC8qaWYoc29ja2V0X2xpc3QubmV4dCA9PSAwKSBpbml0X2xpc3RfaGVhZCgmc29ja2V0X2xpc3QpOyovCgogIGFzc2VydChzb2NrZXRfbGlzdC5uZXh0KTsKICBhc3NlcnQoc29ja2V0X2xpc3QucHJldik7CgogIGxpc3RfYWRkKCZzb2NrLT5saW5rLCAmc29ja2V0X2xpc3QpOwoKICBzb2NrLT5yZWZfY291bnQgPSAxOwogIHNvY2stPmhlYWRlcnMgPSBKU19VTkRFRklORUQ7CiAgc29jay0+d3JpdGVfaGFuZGxlciA9IEpTX1VOREVGSU5FRDsKICBzb2NrLT5pZCA9ICsrc29ja2V0X2lkOwogIHNvY2stPm1ldGhvZCA9IC0xOwoKICByZXR1cm4gc29jazsKfQoKc3RhdGljIExXU1NvY2tldFR5cGUKc29ja2V0X3R5cGUoc3RydWN0IGx3cyogd3NpKSB7CiAgaWYobHdzaV9yb2xlX3dzKHdzaSkpCiAgICByZXR1cm4gU09DS0VUX1dTOwoKICBpZihsd3NpX3JvbGVfaDEod3NpKSkKICAgIHJldHVybiBTT0NLRVRfSFRUUDsKCiAgaWYobHdzaV9yb2xlX2gyKHdzaSkpCiAgICByZXR1cm4gU09DS0VUX0hUVFA7CgogIHJldHVybiBTT0NLRVRfT1RIRVI7Cn0KCmludApzb2NrZXRfZ2V0aWQoc3RydWN0IGx3cyogd3NpKSB7CiAgTFdTU29ja2V0KiBzb2NrOwoKICBpZigoc29jayA9IHNvY2tldF9nZXQod3NpKSkpCiAgICByZXR1cm4gc29jay0+aWQ7CiAgcmV0dXJuIC0xOwp9CgpzdGF0aWMgTFdTU29ja2V0Kgpzb2NrZXRfZmluZChzdHJ1Y3QgbHdzKiB3c2kpIHsKICBzdHJ1Y3QgbGlzdF9oZWFkKiBuOwoKICBsaXN0X2Zvcl9lYWNoKG4sICZzb2NrZXRfbGlzdCkgewogICAgTFdTU29ja2V0KiBzb2NrID0gbGlzdF9lbnRyeShuLCBMV1NTb2NrZXQsIGxpbmspOwoKICAgIGlmKHNvY2spCiAgICAgIGlmKCh1aW50cHRyX3Qpc29jayAhPSAodWludHB0cl90KS0xICYmIHNvY2stPndzaSA9PSB3c2kpCiAgICAgICAgcmV0dXJuIHNvY2s7CiAgfQoKICByZXR1cm4gMDsKfQoKTFdTU29ja2V0Kgpzb2NrZXRfZ2V0KHN0cnVjdCBsd3MqIHdzaSkgewogIEpTT2JqZWN0KiBvYmo7CgogIGlmKChvYmogPSBsd3NfZ2V0X29wYXF1ZV91c2VyX2RhdGEod3NpKSkpCiAgICByZXR1cm4gbHdzanNfc29ja2V0X2RhdGEoSlNfTUtQVFIoSlNfVEFHX09CSkVDVCwgb2JqKSk7CgogIHJldHVybiAwOwp9CgpKU1ZhbHVlCmpzX3NvY2tldF9nZXQoSlNDb250ZXh0KiBjdHgsIHN0cnVjdCBsd3MqIHdzaSkgewogIEpTT2JqZWN0KiBvYmo7CgogIGlmKChvYmogPSBsd3NfZ2V0X29wYXF1ZV91c2VyX2RhdGEod3NpKSkpCiAgICByZXR1cm4gSlNfRHVwVmFsdWUoY3R4LCBKU19NS1BUUihKU19UQUdfT0JKRUNULCBvYmopKTsKCiAgcmV0dXJuIEpTX1VOREVGSU5FRDsKfQoKc3RhdGljIExXU1NvY2tldCoKc29ja2V0X2dldF9ieV9pZChpbnQgaWQpIHsKICBzdHJ1Y3QgbGlzdF9oZWFkKiBuOwogIExXU1NvY2tldCogc29jazsKCiAgbGlzdF9mb3JfZWFjaChuLCAmc29ja2V0X2xpc3QpIHsKICAgIGlmKChzb2NrID0gbGlzdF9lbnRyeShuLCBMV1NTb2NrZXQsIGxpbmspKSkKICAgICAgaWYoc29jay0+aWQgPT0gaWQpCiAgICAgICAgcmV0dXJuIHNvY2s7CiAgfQoKICByZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQKc29ja2V0X2ZyZWUoTFdTU29ja2V0KiBzb2NrLCBKU1J1bnRpbWUqIHJ0KSB7CiAgREVCVUcoImZyZWUgTFdTU29ja2V0OiAlcCAocmVmX2NvdW50ID0gJWQpIiwgc29jaywgc29jay0+cmVmX2NvdW50KTsKICBpZigtLXNvY2stPnJlZl9jb3VudCA9PSAwKSB7CiAgICBpZighSlNfSXNVbmRlZmluZWQoc29jay0+d3JpdGVfaGFuZGxlcikpIHsKICAgICAgSlNfRnJlZVZhbHVlUlQocnQsIHNvY2stPndyaXRlX2hhbmRsZXIpOwogICAgICBzb2NrLT53cml0ZV9oYW5kbGVyID0gSlNfVU5ERUZJTkVEOwogICAgfQoKICAgIEpTX0ZyZWVWYWx1ZVJUKHJ0LCBzb2NrLT5oZWFkZXJzKTsKICAgIHNvY2stPmhlYWRlcnMgPSBKU19VTkRFRklORUQ7CgogICAgaWYoc29jay0+dXJpKSB7CiAgICAgIGpzX2ZyZWVfcnQocnQsIHNvY2stPnVyaSk7CiAgICAgIHNvY2stPnVyaSA9IDA7CiAgICB9CiAgICBpZihzb2NrLT5wcm90bykgewogICAgICBqc19mcmVlX3J0KHJ0LCBzb2NrLT5wcm90byk7CiAgICAgIHNvY2stPnByb3RvID0gMDsKICAgIH0KCiAgICBqc19mcmVlX3J0KHJ0LCBzb2NrKTsKICB9Cn0KCnN0YXRpYyB2b2lkCnNvY2tldF9kZWxldGUoTFdTU29ja2V0KiBzb2NrLCBKU1J1bnRpbWUqIHJ0KSB7CiAgYXNzZXJ0KHNvY2tldF9saXN0Lm5leHQpOwogIGFzc2VydChzb2NrZXRfbGlzdC5wcmV2KTsKCiAgLyogIGFzc2VydChzb2NrLT5saW5rLm5leHQpOwogICAgYXNzZXJ0KHNvY2stPmxpbmsucHJldik7Ki8KCiAgaWYoc29jay0+bGluay5uZXh0KQogICAgbGlzdF9kZWwoJnNvY2stPmxpbmspOwoKICBERUJVRygiZGVsZXRlIExXU1NvY2tldDogJXAgKHdzaSA9ICVwLCBuID0gJWQsIHJlZl9jb3VudCA9ICVkKSIsIHNvY2ssIHNvY2stPndzaSwgbGlzdF9zaXplKCZzb2NrZXRfbGlzdCksIHNvY2stPnJlZl9jb3VudCk7CgogIGlmKHNvY2stPm9iaikgewogICAgb2JqX2ZyZWUocnQsIHNvY2stPm9iaik7CiAgICBzb2NrLT5vYmogPSAwOwogIH0KCiAgc29ja2V0X2ZyZWUoc29jaywgcnQpOwp9CgpzdGF0aWMgSlNWYWx1ZQpzb2NrZXRfb2JqMihMV1NTb2NrZXQqIHNvY2ssIEpTQ29udGV4dCogY3R4KSB7CiAgcmV0dXJuIHNvY2sgPyBKU19EdXBWYWx1ZShjdHgsIHB0cl9vYmooY3R4LCBzb2NrLT5vYmopKSA6IEpTX05VTEw7Cn0KCnN0cnVjdCBsd3MqCmx3c2pzX3NvY2tldF93c2koSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgTFdTU29ja2V0KiBzb2NrOwoKICBpZigoc29jayA9IGx3c2pzX3NvY2tldF9kYXRhKHZhbHVlKSkpCiAgICByZXR1cm4gc29jay0+d3NpOwoKICByZXR1cm4gMDsKfQoKSlNWYWx1ZQpsd3Nqc19zb2NrZXRfd3JhcChKU0NvbnRleHQqIGN0eCwgTFdTU29ja2V0KiBzb2NrKSB7CiAgSlNWYWx1ZSBvYmogPSBKU19OZXdPYmplY3RQcm90b0NsYXNzKGN0eCwgbHdzanNfc29ja2V0X3Byb3RvLCBsd3Nqc19zb2NrZXRfY2xhc3NfaWQpOwoKICBKU19TZXRPcGFxdWUob2JqLCBzb2NrZXRfZHVwKHNvY2spKTsKCiAgc29jay0+b2JqID0gb2JqX3B0cihjdHgsIG9iaik7CgogIHJldHVybiBvYmo7Cn0KCkpTVmFsdWUKbHdzanNfc29ja2V0X2NyZWF0ZShKU0NvbnRleHQqIGN0eCwgc3RydWN0IGx3cyogd3NpKSB7CiAgSlNWYWx1ZSByZXQgPSBKU19VTkRFRklORUQ7CiAgTFdTU29ja2V0KiBzb2NrOwoKICBpZigoc29jayA9IHNvY2tldF9hbGxvYyhjdHgpKSkgewogICAgc29jay0+d3NpID0gd3NpOwogICAgcmV0ID0gbHdzanNfc29ja2V0X3dyYXAoY3R4LCBzb2NrKTsKICB9CgogIHJldHVybiByZXQ7Cn0KCnZvaWQKbHdzanNfc29ja2V0X2Rlc3Ryb3koSlNDb250ZXh0KiBjdHgsIHN0cnVjdCBsd3MqIHdzaSkgewogIExXU1NvY2tldCogc29jayA9IHNvY2tldF9nZXQod3NpKTsKCiAgLyppZihzb2NrID09IDApCiAgICByZXR1cm47Ki8KCiAgYXNzZXJ0KHNvY2spOwoKICBhc3NlcnQoc29jay0+d3NpKTsKICBzb2NrLT53c2kgPSAwOwoKICBzb2NrZXRfZGVsZXRlKHNvY2ssIEpTX0dldFJ1bnRpbWUoY3R4KSk7Cn0KCkpTVmFsdWUKbHdzanNfc29ja2V0X2dldF9vcl9jcmVhdGUoSlNDb250ZXh0KiBjdHgsIHN0cnVjdCBsd3MqIHdzaSkgewogIEpTVmFsdWUgcmV0ID0ganNfc29ja2V0X2dldChjdHgsIHdzaSk7CiAgQk9PTCBjcmVhdGU7CgogIGlmKChjcmVhdGUgPSBKU19Jc1VuZGVmaW5lZChyZXQpKSkKICAgIHJldCA9IGx3c2pzX3NvY2tldF9jcmVhdGUoY3R4LCB3c2kpOwoKICBERUJVRygiJXMgTFdTU29ja2V0ICh3c2kgPSAlcCwgaWQgPSAlZCwgcmVmX2NvdW50ID0gJWQsIG9iaiA9ICVwKSA9ICVwIiwKICAgICAgICBjcmVhdGUgPyAiY3JlYXRlIiA6ICJnZXQiLAogICAgICAgIHdzaSwKICAgICAgICBsd3Nqc19zb2NrZXRfZGF0YShyZXQpLT5pZCwKICAgICAgICBsd3Nqc19zb2NrZXRfZGF0YShyZXQpLT5yZWZfY291bnQsCiAgICAgICAgSlNfVkFMVUVfR0VUX09CSihyZXQpLAogICAgICAgIGx3c2pzX3NvY2tldF9kYXRhKHJldCkpOwoKICByZXR1cm4gcmV0Owp9Cgp0eXBlZGVmIHN0cnVjdCB7CiAgSlNWYWx1ZSBvYmo7CiAgSlNDb250ZXh0KiBjdHg7CiAgc3RydWN0IGx3cyogd3NpOwp9IEN1c3RvbUhlYWRlcnM7CgpzdGF0aWMgdm9pZApzZXRfcHJvcGVydHkoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIGNvbnN0IGNoYXIqIG5hbWUsIGludCBubGVuLCBjb25zdCBjaGFyKiB2YWx1ZSwgaW50IHZsZW4pIHsKICBKU0F0b20gcHJvcCA9IEpTX05ld0F0b21MZW4oY3R4LCBuYW1lLCBubGVuKTsKICBKU19TZXRQcm9wZXJ0eShjdHgsIG9iaiwgcHJvcCwgSlNfTmV3U3RyaW5nTGVuKGN0eCwgdmFsdWUsIHZsZW4pKTsKICBKU19GcmVlQXRvbShjdHgsIHByb3ApOwp9CgpzdGF0aWMgdm9pZApjdXN0b21faGVhZGVyc19jYWxsYmFjayhjb25zdCBjaGFyKiBuYW1lLCBpbnQgbmxlbiwgdm9pZCogb3BhcXVlKSB7CiAgQ3VzdG9tSGVhZGVycyogY2ggPSBvcGFxdWU7CiAgaW50IG5hbWVsZW4gPSBubGVuLCBsZW4gPSBsd3NfaGRyX2N1c3RvbV9sZW5ndGgoY2gtPndzaSwgbmFtZSwgbmxlbik7CiAgY2hhciBidWZbbGVuICsgMV07CiAgaW50IHIgPSBsd3NfaGRyX2N1c3RvbV9jb3B5KGNoLT53c2ksIGJ1ZiwgbGVuICsgMSwgbmFtZSwgbmxlbik7CiAgaW50IGkgPSAwLCBqOwoKICB3aGlsZSgoaiA9IGZpbmRiX2NoYXJzZXQoJm5hbWVbaV0sIG5sZW4gLSBpLCAiOiAiLCAyKSkgPCAobmxlbiAtIGkgLSAxKSkgewogICAgaW50IGsgPSBpICsgajsKCiAgICB3aGlsZShuYW1lW2tdID09ICc6JyB8fCBuYW1lW2tdID09ICcgJykKICAgICAgKytrOwoKICAgIGludCBuID0gZmluZGJfY2hhcnNldCgmbmFtZVtrXSwgbmxlbiAtIGssICJcclxuIiwgMik7CiAgICBpbnQgZW5kID0gayArIG47CgogICAgd2hpbGUobmFtZVtlbmRdID09ICdccicgfHwgbmFtZVtlbmRdID09ICdcbicpCiAgICAgICsrZW5kOwoKICAgIGlmKG4gPCAobmxlbiAtIGspKQogICAgICBzZXRfcHJvcGVydHkoY2gtPmN0eCwgY2gtPm9iaiwgJm5hbWVbaV0sIGosICZuYW1lW2tdLCBuKTsKCiAgICBpID0gZW5kOwoKICAgIGlmKG4gPj0gKG5sZW4gLSBrKSkKICAgICAgYnJlYWs7CiAgfQoKICBzZXRfcHJvcGVydHkoY2gtPmN0eCwgY2gtPm9iaiwgJm5hbWVbaV0sIGZpbmRiX2NoYXJzZXQoJm5hbWVbaV0sIG5sZW4gLSBpLCAiOiAiLCAyKSwgYnVmLCByKTsKfQoKSlNWYWx1ZQpsd3Nqc19zb2NrZXRfaGVhZGVycyhKU0NvbnRleHQqIGN0eCwgc3RydWN0IGx3cyogd3NpLCBjaGFyKiogcHByb3RvKSB7CiAgSlNWYWx1ZSByZXQgPSBKU19OZXdPYmplY3RQcm90byhjdHgsIEpTX05VTEwpOwoKICBmb3IoaW50IGkgPSBXU0lfVE9LRU5fR0VUX1VSSTsgaSA8IFdTSV9UT0tFTl9DT1VOVDsgKytpKSB7CiAgICBpZighaXNfdXJpKGkpICYmIGkgIT0gV1NJX1RPS0VOX0hUVFApIHsKICAgICAgc2l6ZV90IGxlbiA9IGx3c19oZHJfdG90YWxfbGVuZ3RoKHdzaSwgaSk7CgogICAgICBpZihsZW4gPiAwKSB7CiAgICAgICAgY29uc3QgY2hhciogbmFtZSA9IChjb25zdCBjaGFyKilsd3NfdG9rZW5fdG9fc3RyaW5nKGkpOwoKICAgICAgICBpZihuYW1lID09IE5VTEwpCiAgICAgICAgICBjb250aW51ZTsKCiAgICAgICAgc2l6ZV90IG5hbWVsZW4gPSBmaW5kX2NoYXJzZXQobmFtZSwgIjogIiwgMik7CiAgICAgICAgSlNBdG9tIHByb3AgPSBKU19OZXdBdG9tTGVuKGN0eCwgbmFtZSwgbmFtZWxlbik7CiAgICAgICAgY2hhciBidWZbbGVuICsgMV07CiAgICAgICAgaW50IHIgPSBsd3NfaGRyX2NvcHkod3NpLCBidWYsIGxlbiArIDEsIGkpOwoKICAgICAgICBpZihuYW1lbGVuID09IDApIHsKICAgICAgICAgIGlmKCpwcHJvdG8pCiAgICAgICAgICAgIGpzX2ZyZWUoY3R4LCAqcHByb3RvKTsKICAgICAgICAgICpwcHJvdG8gPSBqc19zdHJuZHVwKGN0eCwgYnVmLCByKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgSlNfU2V0UHJvcGVydHkoY3R4LCByZXQsIHByb3AsIEpTX05ld1N0cmluZ0xlbihjdHgsIGJ1ZiwgcikpOwogICAgICAgIH0KICAgICAgICBKU19GcmVlQXRvbShjdHgsIHByb3ApOwogICAgICB9CiAgICB9CiAgfQoKICBDdXN0b21IZWFkZXJzIGMgPSB7cmV0LCBjdHgsIHdzaX07CgogIGx3c19oZHJfY3VzdG9tX25hbWVfZm9yZWFjaCh3c2ksIGN1c3RvbV9oZWFkZXJzX2NhbGxiYWNrLCAmYyk7CgogIHJldHVybiByZXQ7Cn0KCmVudW0gewogIE1FVEhPRF9XQU5UX1dSSVRFID0gMCwKICBNRVRIT0RfV1JJVEUsCiAgTUVUSE9EX1JFU1BPTkQsCiAgTUVUSE9EX0NMT1NFLAogIE1FVEhPRF9IVFRQX0NMSUVOVF9SRUFELAogIE1FVEhPRF9BRERfSEVBREVSLAogIE1FVEhPRF9DTElFTlRfSFRUUF9NVUxUSVBBUlQsCn07CgpzdGF0aWMgSlNWYWx1ZQpsd3Nqc19zb2NrZXRfbWV0aG9kcyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSwgaW50IG1hZ2ljKSB7CiAgTFdTU29ja2V0KiBzOwogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwoKICBpZighKHMgPSBsd3Nqc19zb2NrZXRfZGF0YTIoY3R4LCB0aGlzX3ZhbCkpKQogICAgcmV0dXJuIEpTX0VYQ0VQVElPTjsKCiAgaWYoIXMtPndzaSkKICAgIHJldHVybiBKU19UaHJvd0ludGVybmFsRXJyb3IoY3R4LCAiJXMgKG1hZ2ljPSVkKSBzLT53c2kgPT0gTlVMTCIsIF9fZnVuY19fLCBtYWdpYyk7CgogIEJPT0wgaXNfd3MgPSBsd3NpX3JvbGVfd3Mocy0+d3NpKSwgaXNfaHR0cCA9IGx3c2lfcm9sZV9odHRwKHMtPndzaSk7CgogIC8qaWYoIWlzX2h0dHAgJiYgKG1hZ2ljID09IE1FVEhPRF9BRERfSEVBREVSIHx8IG1hZ2ljID09IE1FVEhPRF9IVFRQX0NMSUVOVF9SRUFEKSkKICAgIHJldHVybiBKU19UaHJvd0ludGVybmFsRXJyb3IoY3R4LCAiJXMgKG1hZ2ljPSVkKSB3c2kgaXMgbm90IEhUVFAiLCBfX2Z1bmNfXywgbWFnaWMpOyovCgogIHN3aXRjaChtYWdpYykgewogICAgY2FzZSBNRVRIT0RfV0FOVF9XUklURTogewogICAgICBpZighcy0+d2FudF93cml0ZSkgewogICAgICAgIGx3c19jYWxsYmFja19vbl93cml0YWJsZShzLT53c2kpOwoKICAgICAgICBzLT53YW50X3dyaXRlID0gVFJVRTsKICAgICAgICByZXQgPSBKU19OZXdCb29sKGN0eCwgVFJVRSk7CgogICAgICAgIGlmKGFyZ2MgPiAwKSB7CiAgICAgICAgICBKU19GcmVlVmFsdWUoY3R4LCBzLT53cml0ZV9oYW5kbGVyKTsKICAgICAgICAgIHMtPndyaXRlX2hhbmRsZXIgPSBKU19EdXBWYWx1ZShjdHgsIGFyZ3ZbMF0pOwogICAgICAgIH0KICAgICAgfQoKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBNRVRIT0RfV1JJVEU6IHsKICAgICAgRHluQnVmIGRidWYgPSB7MH07CgogICAgICBpZihsd3NfcGFydGlhbF9idWZmZXJlZChzLT53c2kpKSB7CiAgICAgICAgcmV0ID0gSlNfVGhyb3dJbnRlcm5hbEVycm9yKGN0eCwgIkkvTyBlcnJvcjogcGFydGlhbGx5IGJ1ZmZlcmVkIGx3c193cml0ZSgpIik7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KCiAgICAgIC8qaWYoIWx3c19zZW5kX3BpcGVfY2hva2VkKHMtPndzaSkpIHsKICAgICAgICByZXQgPSBKU19UaHJvd0ludGVybmFsRXJyb3IoY3R4LCAiSS9PIGVycm9yOiBzZW5kIHBpcGUgY2hva2VkIGx3c193cml0ZSgpIik7CiAgICAgICAgYnJlYWs7CiAgICAgIH0qLwoKICAgICAgQk9PTCB0ZXh0ID0gSlNfSXNTdHJpbmcoYXJndlswXSk7CiAgICAgIHNpemVfdCBsZW47CiAgICAgIHZvaWQqIHB0ciA9IHRleHQgPyAodm9pZCopSlNfVG9DU3RyaW5nTGVuKGN0eCwgJmxlbiwgYXJndlswXSkgOiBKU19HZXRBcnJheUJ1ZmZlcihjdHgsICZsZW4sIGFyZ3ZbMF0pOwogICAgICBzaXplX3QgbiA9IGxlbjsKICAgICAgZW51bSBsd3Nfd3JpdGVfcHJvdG9jb2wgcHJvdG8gPSBpc19odHRwID8gTFdTX1dSSVRFX0hUVFAgOiB0ZXh0ID8gTFdTX1dSSVRFX1RFWFQgOiBMV1NfV1JJVEVfQklOQVJZOwoKICAgICAgaWYoaXNfd3MpIHsKICAgICAgICBkYnVmX2luaXQyKCZkYnVmLCAwLCAwKTsKICAgICAgICBkYnVmX3B1dCgmZGJ1ZiwgKGNvbnN0IHZvaWQqKSJYWFhYWFhYWFhYWFhYWFhYWFhYWCIsIExXU19QUkUpOwogICAgICAgIGRidWZfcHV0KCZkYnVmLCBwdHIsIG4pOwogICAgICB9CgogICAgICBpZihhcmdjID4gMikKICAgICAgICBuID0gdG9faW50MzIoY3R4LCBhcmd2WzFdKTsKCiAgICAgIGlmKGFyZ2MgPiAxKQogICAgICAgIHByb3RvID0gdG9faW50MzIoY3R4LCBhcmd2W2FyZ2MgPiAyID8gMiA6IDFdKTsKCiAgICAgIGlmKHB0cikgewogICAgICAgIGludCByID0gbHdzX3dyaXRlKHMtPndzaSwgaXNfd3MgPyBkYnVmLmJ1ZiArIExXU19QUkUgOiBwdHIsIE1JTihuLCBsZW4pLCBwcm90byk7CgogICAgICAgIERFQlVHX1dTSShzLT53c2ksICJ3cm90ZSBkYXRhICglZCkiLCByKTsKCiAgICAgICAgcmV0ID0gSlNfTmV3SW50MzIoY3R4LCByKTsKCiAgICAgICAgaWYociA+IDApCiAgICAgICAgICBpZihwcm90byA9PSBMV1NfV1JJVEVfSFRUUF9GSU5BTCkKICAgICAgICAgICAgaWYobHdzX2h0dHBfdHJhbnNhY3Rpb25fY29tcGxldGVkKHMtPndzaSkpCiAgICAgICAgICAgICAgcy0+Y29tcGxldGVkID0gVFJVRTsKCiAgICAgICAgREVCVUdfV1NJKHMtPndzaSwgInNlbmQgcGlwZSBjaG9rZWQ6ICVkIHBhcnRpYWxseSBidWZmZXJlZDogJWQiLCBsd3Nfc2VuZF9waXBlX2Nob2tlZChzLT53c2kpLCBsd3NfcGFydGlhbF9idWZmZXJlZChzLT53c2kpKTsKICAgICAgfQoKICAgICAgaWYoSlNfSXNTdHJpbmcoYXJndlswXSkpCiAgICAgICAgSlNfRnJlZUNTdHJpbmcoY3R4LCBwdHIpOwoKICAgICAgaWYoZGJ1Zi5idWYpCiAgICAgICAgZnJlZShkYnVmLmJ1Zik7CgogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIE1FVEhPRF9SRVNQT05EOiB7CiAgICAgIHVpbnQ4X3QgcmVzdWx0W0xXU19QUkUgKyBMV1NfUkVDT01NRU5ERURfTUlOX0hFQURFUl9TUEFDRV0sICpwID0gKHVpbnQ4X3QqKXJlc3VsdCArIExXU19QUkUsICpzdGFydCA9IHA7CiAgICAgIHVpbnQ4X3QgKmVuZCA9IHAgKyBzaXplb2YocmVzdWx0KSAtIExXU19QUkUgLSAxLCAqcHRyID0gTlVMTDsKICAgICAgc2l6ZV90IHRtcF9sZW4sIHdyaXR0ZW4gPSAwOwogICAgICBpbnQ2NF90IGxlbiA9IC0xOwogICAgICBpbnQzMl90IGNvZGUgPSAtMTsKICAgICAgaW50IGhpZHggPSAtMTsKCiAgICAgIGZvcihpbnQgaSA9IDA7IGkgPCBhcmdjOyArK2kpIHsKICAgICAgICBpZihjb2RlID09IC0xICYmIEpTX0lzTnVtYmVyKGFyZ3ZbaV0pKQogICAgICAgICAgY29kZSA9IHRvX2ludGVnZXIoY3R4LCBhcmd2W2ldKTsKICAgICAgICBlbHNlIGlmKGxlbiA9PSAtMSAmJiBKU19Jc051bWJlcihhcmd2W2ldKSkKICAgICAgICAgIGxlbiA9IHRvX2ludGVnZXIoY3R4LCBhcmd2W2ldKTsKICAgICAgICBlbHNlIGlmKCFwdHIgJiYgKHB0ciA9IEpTX0dldEFycmF5QnVmZmVyKGN0eCwgJnRtcF9sZW4sIGFyZ3ZbaV0pKSkKICAgICAgICAgIGxlbiA9IGxlbiA9PSAtMSA/IChpbnQ2NF90KXRtcF9sZW4gOiBsZW47CiAgICAgICAgZWxzZSBpZighcHRyICYmIEpTX0lzU3RyaW5nKGFyZ3ZbaV0pICYmIChwdHIgPSAodWludDhfdCopSlNfVG9DU3RyaW5nTGVuKGN0eCwgJnRtcF9sZW4sIGFyZ3ZbaV0pKSkKICAgICAgICAgIGxlbiA9IGxlbiA9PSAtMSA/IChpbnQ2NF90KXRtcF9sZW4gOiBsZW47CiAgICAgICAgZWxzZSBpZihKU19Jc09iamVjdChhcmd2W2ldKSkKICAgICAgICAgIGhpZHggPSBpOwogICAgICB9CgogICAgICBpZihsd3NfYWRkX2h0dHBfY29tbW9uX2hlYWRlcnMocy0+d3NpLCBjb2RlLCBOVUxMLCBsZW4gPiAwID8gKHVpbnQ2NF90KWxlbiA6IExXU19JTExFR0FMX0hUVFBfQ09OVEVOVF9MRU4sICZwLCBlbmQpKSB7CiAgICAgICAgcmV0ID0gSlNfVGhyb3dJbnRlcm5hbEVycm9yKGN0eCwgImx3c19hZGRfaHR0cF9jb21tb25faGVhZGVycyBmYWlsZWQiKTsKICAgICAgICBicmVhazsKICAgICAgfQoKICAgICAgaWYoaGlkeCAhPSAtMSkgewogICAgICAgIEpTUHJvcGVydHlFbnVtKiB0bXBfdGFiID0gMDsKICAgICAgICB1aW50MzJfdCB0bXBfbGVuOwoKICAgICAgICBpZighSlNfR2V0T3duUHJvcGVydHlOYW1lcyhjdHgsICZ0bXBfdGFiLCAmdG1wX2xlbiwgYXJndltoaWR4XSwgSlNfR1BOX1NUUklOR19NQVNLIHwgSlNfR1BOX1NFVF9FTlVNKSkgewoKICAgICAgICAgIGZvcih1aW50MzJfdCBqID0gMDsgaiA8IHRtcF9sZW47IGorKykgewogICAgICAgICAgICBKU1ZhbHVlIGtleSA9IEpTX0F0b21Ub1ZhbHVlKGN0eCwgdG1wX3RhYltqXS5hdG9tKTsKICAgICAgICAgICAgY29uc3QgY2hhciogbmFtZSA9IEpTX1RvQ1N0cmluZyhjdHgsIGtleSk7CiAgICAgICAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGtleSk7CgogICAgICAgICAgICBKU1ZhbHVlIHZhbHVlID0gSlNfR2V0UHJvcGVydHkoY3R4LCBhcmd2W2hpZHhdLCB0bXBfdGFiW2pdLmF0b20pOwogICAgICAgICAgICBzaXplX3QgdmxlbjsKICAgICAgICAgICAgY29uc3QgY2hhciogdnN0ciA9IEpTX1RvQ1N0cmluZ0xlbihjdHgsICZ2bGVuLCB2YWx1ZSk7CiAgICAgICAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKCiAgICAgICAgICAgIGlmKGx3c19hZGRfaHR0cF9oZWFkZXJfYnlfbmFtZShzLT53c2ksIChjb25zdCB1aW50OF90KiluYW1lLCAodm9pZCopdnN0ciwgdmxlbiwgJnAsIGVuZCkpCiAgICAgICAgICAgICAgSlNfVGhyb3dJbnRlcm5hbEVycm9yKGN0eCwgImx3c19hZGRfaHR0cF9oZWFkZXJfYnlfbmFtZSIpOwoKICAgICAgICAgICAgSlNfRnJlZUNTdHJpbmcoY3R4LCBuYW1lKTsKICAgICAgICAgICAgSlNfRnJlZUNTdHJpbmcoY3R4LCB2c3RyKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIGludCBuID0gbHdzX2ZpbmFsaXplX3dyaXRlX2h0dHBfaGVhZGVyKHMtPndzaSwgc3RhcnQsICZwLCBlbmQpID8gLTEgOiAoaW50KWx3c19wdHJfZGlmZl9zaXplX3QocCwgc3RhcnQpOwoKICAgICAgREVCVUdfV1NJKHMtPndzaSwgIndyb3RlIGhlYWRlcnMgKCVkKSIsIG4pOwoKICAgICAgaWYobiA8IDApCiAgICAgICAgcmV0dXJuIEpTX1Rocm93SW50ZXJuYWxFcnJvcihjdHgsICJsd3Nfd3JpdGUiKTsKCiAgICAgIHdyaXR0ZW4gKz0gbjsKCiAgICAgIGlmKHB0ciAmJiBsZW4gPiAwKSB7CiAgICAgICAgaWYoKG4gPSBsd3Nfd3JpdGUocy0+d3NpLCAodWludDhfdCopcHRyLCAodW5zaWduZWQgaW50KWxlbiwgTFdTX1dSSVRFX0hUVFBfRklOQUwpKSA8IDApCiAgICAgICAgICByZXR1cm4gSlNfVGhyb3dJbnRlcm5hbEVycm9yKGN0eCwgImx3c193cml0ZSIpOwoKICAgICAgICB3cml0dGVuICs9IG47CiAgICAgIH0KCiAgICAgIHJldCA9IEpTX05ld1VpbnQzMihjdHgsIHdyaXR0ZW4pOwogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIE1FVEhPRF9DTE9TRTogewogICAgICB1aW50MzJfdCByZWFzb24gPSAxMDAwOwoKICAgICAgaWYoYXJnYyA+IDApCiAgICAgICAgcmVhc29uID0gdG9fdWludDMyKGN0eCwgYXJndlswXSk7CgogICAgICBpZihzb2NrZXRfdHlwZShzLT53c2kpID09IFNPQ0tFVF9XUykgewogICAgICAgIHNpemVfdCBuID0gMDsKICAgICAgICB1aW50OF90KiBwID0gTlVMTDsKICAgICAgICBjb25zdCBjaGFyKiBzdHIgPSAwOwoKICAgICAgICBpZihhcmdjID4gMSkgewogICAgICAgICAgaWYoIShwID0gZ2V0X2J1ZmZlcihjdHgsIGFyZ2MgLSAxLCBhcmd2ICsgMSwgJm4pKSkKICAgICAgICAgICAgcCA9ICh1aW50OF90Kikoc3RyID0gSlNfVG9DU3RyaW5nTGVuKGN0eCwgJm4sIGFyZ3ZbMV0pKTsKICAgICAgICB9CgogICAgICAgIGx3c19jbG9zZV9yZWFzb24ocy0+d3NpLCByZWFzb24sIHAsIG4pOwoKICAgICAgICBpZihzdHIpCiAgICAgICAgICBKU19GcmVlQ1N0cmluZyhjdHgsIHN0cik7CiAgICAgIH0KCiAgICAgIGx3c19jbG9zZV9mcmVlX3dzaShzLT53c2ksIHJlYXNvbiwgX19mdW5jX18pOwogICAgICAvLyBsd3Nfd3NpX2Nsb3NlKHMtPndzaSwgTFdTX1RPX0tJTExfU1lOQyk7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgTUVUSE9EX0hUVFBfQ0xJRU5UX1JFQUQ6IHsKICAgICAgc2l6ZV90IG47CiAgICAgIHVpbnQ4X3QgKnAsICpxOwogICAgICBpbnQgbCwgcmVzdWx0OwoKICAgICAgaWYoKHEgPSBwID0gZ2V0X2J1ZmZlcihjdHgsIGFyZ2MsIGFyZ3YsICZuKSkpIHsKICAgICAgICBsID0gbjsKICAgICAgICByZXN1bHQgPSBsd3NfaHR0cF9jbGllbnRfcmVhZChzLT53c2ksIChjaGFyKiopJnAsICZsKTsKCiAgICAgICAgaWYocmVzdWx0ICE9IC0xKQogICAgICAgICAgcmV0ID0gSlNfTmV3SW50MzIoY3R4LCBsKTsKICAgICAgfQoKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBNRVRIT0RfQUREX0hFQURFUjogewogICAgICBjb25zdCBjaGFyICpuYW1lID0gMCwgKnZhbHVlOwogICAgICBzaXplX3QgdmxlbiwgYmxlbjsKICAgICAgdW5zaWduZWQgY2hhciAqYnVmLCAqcHRyOwogICAgICBpbnQ2NF90IGxlbiA9IDA7CiAgICAgIGVudW0gbHdzX3Rva2VuX2luZGV4ZXMgdG9rZW4gPSAtMTsKCiAgICAgIGlmKEpTX0lzTnVtYmVyKGFyZ3ZbMF0pKSB7CiAgICAgICAgdG9rZW4gPSB0b19pbnQzMihjdHgsIGFyZ3ZbMF0pOwogICAgICB9IGVsc2UgaWYoIShuYW1lID0gSlNfVG9DU3RyaW5nKGN0eCwgYXJndlswXSkpKSB7CiAgICAgICAgcmV0ID0gSlNfVGhyb3dUeXBlRXJyb3IoY3R4LCAiYXJndW1lbnQgMSBtdXN0IGJlIG5hbWUiKTsKICAgICAgICBicmVhazsKICAgICAgfQoKICAgICAgaWYoISh2YWx1ZSA9IEpTX1RvQ1N0cmluZ0xlbihjdHgsICZ2bGVuLCBhcmd2WzFdKSkpIHsKICAgICAgICByZXQgPSBKU19UaHJvd1R5cGVFcnJvcihjdHgsICJhcmd1bWVudCAyIG11c3QgYmUgdmFsdWUiKTsKICAgICAgICBKU19GcmVlQ1N0cmluZyhjdHgsIG5hbWUpOwogICAgICAgIGJyZWFrOwogICAgICB9CgogICAgICBpZighKGJ1ZiA9IEpTX0dldEFycmF5QnVmZmVyKGN0eCwgJmJsZW4sIGFyZ3ZbMl0pKSkgewogICAgICAgIHJldCA9IEpTX1Rocm93VHlwZUVycm9yKGN0eCwgImFyZ3VtZW50IDMgbXVzdCBiZSBBcnJheUJ1ZmZlciIpOwogICAgICAgIEpTX0ZyZWVDU3RyaW5nKGN0eCwgbmFtZSk7CiAgICAgICAgSlNfRnJlZUNTdHJpbmcoY3R4LCB2YWx1ZSk7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KCiAgICAgIGxlbiA9IHRvX2ludDY0KGN0eCwgSlNfR2V0UHJvcGVydHlVaW50MzIoY3R4LCBhcmd2WzNdLCAwKSk7CiAgICAgIGxlbiA9IE1JTihNQVgoMCwgbGVuKSwgKGludDY0X3QpYmxlbik7CgogICAgICBwdHIgPSBidWYgKyBsZW47CgogICAgICBpbnQgciA9IG5hbWUgPyBsd3NfYWRkX2h0dHBfaGVhZGVyX2J5X25hbWUocy0+d3NpLCAoY29uc3QgdW5zaWduZWQgY2hhciopbmFtZSwgKGNvbnN0IHVuc2lnbmVkIGNoYXIqKXZhbHVlLCB2bGVuLCAmcHRyLCBidWYgKyBibGVuKQogICAgICAgICAgICAgICAgICAgOiBsd3NfYWRkX2h0dHBfaGVhZGVyX2J5X3Rva2VuKHMtPndzaSwgdG9rZW4sIChjb25zdCB1bnNpZ25lZCBjaGFyKil2YWx1ZSwgdmxlbiwgJnB0ciwgYnVmICsgYmxlbik7CgogICAgICBKU19TZXRQcm9wZXJ0eVVpbnQzMihjdHgsIGFyZ3ZbM10sIDAsIEpTX05ld1VpbnQzMihjdHgsIHB0ciAtIGJ1ZikpOwoKICAgICAgcmV0ID0gSlNfTmV3SW50MzIoY3R4LCByKTsKCiAgICAgIEpTX0ZyZWVDU3RyaW5nKGN0eCwgbmFtZSk7CiAgICAgIEpTX0ZyZWVDU3RyaW5nKGN0eCwgdmFsdWUpOwogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIE1FVEhPRF9DTElFTlRfSFRUUF9NVUxUSVBBUlQ6IHsKCiAgICAgIGlmKCFzLT53c2ktPmh0dHAubXVsdGlwYXJ0KQogICAgICAgIGJyZWFrOwoKICAgICAgc3RydWN0IGx3c19wcm9jZXNzX2h0bWxfYXJncyBhID0gezB9LCBiLCBjOwogICAgICBjb25zdCBjaGFyICpuYW1lID0gMCwgKmZpbGVuYW1lID0gMCwgKmNvbnRlbnRfdHlwZSA9IDA7CiAgICAgIGludCBpID0gMDsKCiAgICAgIGlmKGFyZ2MgPiAwICYmICFpc19udWxsaXNoKGFyZ3ZbMF0pKQogICAgICAgIG5hbWUgPSBKU19Ub0NTdHJpbmcoY3R4LCBhcmd2WzBdKTsKICAgICAgaWYoYXJnYyA+IDEgJiYgIWlzX251bGxpc2goYXJndlsxXSkpCiAgICAgICAgZmlsZW5hbWUgPSBKU19Ub0NTdHJpbmcoY3R4LCBhcmd2WzFdKTsKICAgICAgaWYoYXJnYyA+IDIgJiYgIWlzX251bGxpc2goYXJndlsyXSkpCiAgICAgICAgY29udGVudF90eXBlID0gSlNfVG9DU3RyaW5nKGN0eCwgYXJndlsyXSk7CiAgICAgIGlmKGFyZ2MgPiAzKQogICAgICAgIGkgPSBsd3Nqc19odG1sX3Byb2Nlc3NfYXJncyhjdHgsICZhLCBhcmdjIC0gMywgYXJndiArIDMpOwoKICAgICAgYiA9IGE7CgogICAgICBiLnAgKz0gYi5sZW47CiAgICAgIGIubWF4X2xlbiAtPSBiLmxlbjsKCiAgICAgIGMgPSBiOwoKICAgICAgaWYobHdzX2NsaWVudF9odHRwX211bHRpcGFydChzLT53c2ksIG5hbWUsIGZpbGVuYW1lLCBjb250ZW50X3R5cGUsICZiLnAsIGIucCArIGIubWF4X2xlbikpIHsKICAgICAgICByZXQgPSBKU19UaHJvd1JhbmdlRXJyb3IoY3R4LCAibHdzX2NsaWVudF9odHRwX211bHRpcGFydDogZG9lcyBub3QgZml0IGludG8gYnVmZmVyIG9mIGxlbiAlZCIsIGEubWF4X2xlbik7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcHRyZGlmZl90IG4gPSBiLnAgLSBjLnA7CgogICAgICAgIGEubGVuICs9IG47CgogICAgICAgIGlmKGFyZ2MgPiA0ICYmIEpTX0lzT2JqZWN0KGFyZ3ZbNF0pKQogICAgICAgICAgSlNfU2V0UHJvcGVydHlVaW50MzIoY3R4LCBhcmd2WzRdLCAwLCBKU19OZXdVaW50MzIoY3R4LCBhLmxlbikpOwoKICAgICAgICByZXQgPSBKU19OZXdVaW50MzIoY3R4LCBuKTsKICAgICAgfQoKICAgICAgaWYobmFtZSkKICAgICAgICBKU19GcmVlQ1N0cmluZyhjdHgsIG5hbWUpOwogICAgICBpZihmaWxlbmFtZSkKICAgICAgICBKU19GcmVlQ1N0cmluZyhjdHgsIGZpbGVuYW1lKTsKICAgICAgaWYoY29udGVudF90eXBlKQogICAgICAgIEpTX0ZyZWVDU3RyaW5nKGN0eCwgY29udGVudF90eXBlKTsKCiAgICAgIGJyZWFrOwogICAgfQogIH0KCiAgcmV0dXJuIHJldDsKfQoKZW51bSB7CiAgRlVOQ1RJT05fTElTVCwKICBGVU5DVElPTl9HRVQsCn07CgpzdGF0aWMgSlNWYWx1ZQpsd3Nqc19zb2NrZXRfZnVuY3Rpb25zKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdLCBpbnQgbWFnaWMpIHsKICBKU1ZhbHVlIHJldCA9IEpTX1VOREVGSU5FRDsKCiAgc3dpdGNoKG1hZ2ljKSB7CiAgICBjYXNlIEZVTkNUSU9OX0xJU1Q6IHsKICAgICAgaWYoc29ja2V0X2xpc3QubmV4dCAhPSAwKSB7CiAgICAgICAgdWludDMyX3QgaSA9IDA7CiAgICAgICAgc3RydWN0IGxpc3RfaGVhZCogZWw7CgogICAgICAgIHJldCA9IEpTX05ld0FycmF5KGN0eCk7CgogICAgICAgIGxpc3RfZm9yX2VhY2goZWwsICZzb2NrZXRfbGlzdCkgewogICAgICAgICAgTFdTU29ja2V0KiBzb2NrID0gbGlzdF9lbnRyeShlbCwgTFdTU29ja2V0LCBsaW5rKTsKCiAgICAgICAgICBpZihzb2NrID09IChMV1NTb2NrZXQqKSh1aW50cHRyX3QpKGludHB0cl90KS0xKQogICAgICAgICAgICBjb250aW51ZTsKCiAgICAgICAgICBKU19TZXRQcm9wZXJ0eVVpbnQzMihjdHgsIHJldCwgaSsrLCBzb2NrZXRfb2JqMihzb2NrLCBjdHgpKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgRlVOQ1RJT05fR0VUOiB7CiAgICAgIHJldCA9IHNvY2tldF9vYmoyKHNvY2tldF9nZXRfYnlfaWQodG9faW50MzIoY3R4LCBhcmd2WzBdKSksIGN0eCk7CiAgICAgIGJyZWFrOwogICAgfQogIH0KCiAgcmV0dXJuIHJldDsKfQoKZW51bSB7CiAgUFJPUF9WSE9TVCwKICBQUk9QX0hFQURFUlMsCiAgUFJPUF9JRCwKICBQUk9QX0NMSUVOVCwKICBQUk9QX1JFU1BPTlNFX0NPREUsCiAgUFJPUF9GRCwKICBQUk9QX01FVEhPRCwKICBQUk9QX1VSSSwKICBQUk9QX0JPRFlfUEVORElORywKICBQUk9QX1JFRElSRUNURURfVE9fR0VULAogIFBST1BfUFJPVE9DT0wsCiAgUFJPUF9UQUcsCiAgUFJPUF9UTFMsCiAgUFJPUF9QRUVSLAogIFBST1BfTE9DQUwsCiAgUFJPUF9DT05URVhULAogIFBST1BfUEVFUl9XUklURV9BTExPV0FOQ0UsCiAgUFJPUF9QQVJFTlQsCiAgUFJPUF9DSElMRCwKICBQUk9QX05FVFdPUkssCiAgUFJPUF9FWFRFTlNJT05TLAogIFBST1BfSDIsCn07CgpzdGF0aWMgSlNWYWx1ZQpsd3Nqc19zb2NrZXRfc2V0KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIEpTVmFsdWVDb25zdCB2YWx1ZSwgaW50IG1hZ2ljKSB7CiAgTFdTU29ja2V0KiBzOwogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwoKICBpZighKHMgPSBsd3Nqc19zb2NrZXRfZGF0YTIoY3R4LCB0aGlzX3ZhbCkpKQogICAgcmV0dXJuIEpTX0VYQ0VQVElPTjsKCiAgaWYoIXMtPndzaSkKICAgIHJldHVybiBKU19VTklOSVRJQUxJWkVEOwoKICBzd2l0Y2gobWFnaWMpIHsKICAgIGNhc2UgUFJPUF9CT0RZX1BFTkRJTkc6IHsKICAgICAgbHdzX2NsaWVudF9odHRwX2JvZHlfcGVuZGluZyhzLT53c2ksIChzLT5ib2R5X3BlbmRpbmcgPSB0b19pbnQzMihjdHgsIHZhbHVlKSkpOwogICAgICBicmVhazsKICAgIH0KICB9CgogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBKU1ZhbHVlCmx3c2pzX3NvY2tldF9nZXQoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IG1hZ2ljKSB7CiAgTFdTU29ja2V0KiBzOwogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwoKICBpZighKHMgPSBsd3Nqc19zb2NrZXRfZGF0YTIoY3R4LCB0aGlzX3ZhbCkpKQogICAgcmV0dXJuIEpTX0VYQ0VQVElPTjsKCiAgaWYoIXMtPndzaSAmJiBtYWdpYyA+IFBST1BfUFJPVE9DT0wpCiAgICByZXR1cm4gSlNfVU5JTklUSUFMSVpFRDsKCiAgc3dpdGNoKG1hZ2ljKSB7CiAgICBjYXNlIFBST1BfVkhPU1Q6IHsKICAgICAgc3RydWN0IGx3c192aG9zdCogdmhvOwoKICAgICAgaWYoKHZobyA9IGx3c19nZXRfdmhvc3Qocy0+d3NpKSkpCiAgICAgICAgcmV0ID0gbHdzX3Zob3N0X29iamVjdChjdHgsIHZobyk7CgogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgUFJPUF9IRUFERVJTOiB7CiAgICAgIHJldCA9IEpTX0R1cFZhbHVlKGN0eCwgcy0+aGVhZGVycyk7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgUFJPUF9JRDogewogICAgICByZXQgPSBKU19OZXdVaW50MzIoY3R4LCBzLT5pZCk7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgUFJPUF9DTElFTlQ6IHsKICAgICAgcmV0ID0gSlNfTmV3Qm9vbChjdHgsIHMtPmNsaWVudCk7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgUFJPUF9SRVNQT05TRV9DT0RFOiB7CiAgICAgIGlmKHMtPnJlc3BvbnNlX2NvZGUgIT0gMCkKICAgICAgICByZXQgPSBKU19OZXdJbnQzMihjdHgsIHMtPnJlc3BvbnNlX2NvZGUpOwoKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBQUk9QX0ZEOiB7CiAgICAgIGludDMyX3QgZmQgPSBzLT53c2kgPyAoaW50MzJfdClsd3NfZ2V0X3NvY2tldF9mZChzLT53c2kpIDogLTE7CiAgICAgIHJldCA9IEpTX05ld0ludDMyKGN0eCwgZmQpOwogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIFBST1BfTUVUSE9EOiB7CiAgICAgIGNvbnN0IGNoYXIqIG1ldGhvZDsKCiAgICAgIGlmKChtZXRob2QgPSBsd3Nqc19tZXRob2RfbmFtZShzLT5tZXRob2QpKSkKICAgICAgICByZXQgPSBKU19OZXdTdHJpbmcoY3R4LCBtZXRob2QpOwoKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBQUk9QX1VSSTogewogICAgICByZXQgPSBzLT51cmkgPyBKU19OZXdTdHJpbmcoY3R4LCBzLT51cmkpIDogSlNfTlVMTDsKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBQUk9QX0JPRFlfUEVORElORzogewogICAgICByZXQgPSBKU19OZXdJbnQzMihjdHgsIHMtPmJvZHlfcGVuZGluZyk7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgUFJPUF9SRURJUkVDVEVEX1RPX0dFVDogewogICAgICByZXQgPSBKU19OZXdCb29sKGN0eCwgcy0+cmVkaXJlY3RlZF90b19nZXQpOwogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIFBST1BfUFJPVE9DT0w6IHsKICAgICAgcmV0ID0gcy0+cHJvdG8gPyBKU19OZXdTdHJpbmcoY3R4LCBzLT5wcm90bykgOiBKU19OVUxMOwogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIFBST1BfVEFHOiB7CiAgICAgIGNvbnN0IGNoYXIqIHRhZzsKCiAgICAgIGlmKCh0YWcgPSBsd3Nfd3NpX3RhZyhzLT53c2kpKSkKICAgICAgICByZXQgPSBKU19OZXdTdHJpbmcoY3R4LCB0YWcpOwoKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBQUk9QX1RMUzogewogICAgICByZXQgPSBKU19OZXdCb29sKGN0eCwgbHdzX2lzX3NzbChzLT53c2kpKTsKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBQUk9QX1BFRVI6IHsKICAgICAgbHdzX3NvY2tmZF90eXBlIGZkID0gbHdzX2dldF9zb2NrZXRfZmQocy0+d3NpKTsKCiAgICAgIGlmKGZkID09IC0xKSB7CiAgICAgICAgcmV0ID0gSlNfTlVMTDsKICAgICAgICBicmVhazsKICAgICAgfQoKICAgICAgcmV0ID0gbHdzanNfc29ja2FkZHI0Nl9uZXcoY3R4KTsKICAgICAgbHdzX3NvY2thZGRyNDYqIHNhID0gbHdzanNfc29ja2FkZHI0Nl9kYXRhKGN0eCwgcmV0KTsKICAgICAgc29ja2xlbl90IGxlbiA9IHNpemVvZigqc2EpOwoKICAgICAgaWYoZ2V0cGVlcm5hbWUoZmQsIChzdHJ1Y3Qgc29ja2FkZHIqKXNhLCAmbGVuKSA9PSAtMSkgewogICAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHJldCk7CiAgICAgICAgaWYoZXJybm8gPT0gRUJBREYpCiAgICAgICAgICByZXQgPSBKU19OVUxMOwogICAgICAgIGVsc2UKICAgICAgICAgIHJldCA9IEpTX1Rocm93SW50ZXJuYWxFcnJvcihjdHgsICJnZWV0cGVlcm5hbWUoJWQpIHJldHVybmVkIC0xOiAlcyIsIGZkLCBzdHJlcnJvcihlcnJubykpOwogICAgICB9CgogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIFBST1BfTE9DQUw6IHsKICAgICAgbHdzX3NvY2tmZF90eXBlIGZkID0gbHdzX2dldF9zb2NrZXRfZmQocy0+d3NpKTsKCiAgICAgIGlmKGZkID09IC0xKSB7CiAgICAgICAgcmV0ID0gSlNfTlVMTDsKICAgICAgICBicmVhazsKICAgICAgfQoKICAgICAgcmV0ID0gbHdzanNfc29ja2FkZHI0Nl9uZXcoY3R4KTsKICAgICAgbHdzX3NvY2thZGRyNDYqIHNhID0gbHdzanNfc29ja2FkZHI0Nl9kYXRhKGN0eCwgcmV0KTsKICAgICAgc29ja2xlbl90IGxlbiA9IHNpemVvZigqc2EpOwoKICAgICAgaWYoZ2V0c29ja25hbWUoZmQsIChzdHJ1Y3Qgc29ja2FkZHIqKXNhLCAmbGVuKSA9PSAtMSkgewogICAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHJldCk7CiAgICAgICAgaWYoZXJybm8gPT0gRUJBREYpCiAgICAgICAgICByZXQgPSBKU19OVUxMOwogICAgICAgIGVsc2UKICAgICAgICAgIHJldCA9IEpTX1Rocm93SW50ZXJuYWxFcnJvcihjdHgsICJnZXRzb2NrbmFtZSglZCkgcmV0dXJuZWQgLTE6ICVzIiwgZmQsIHN0cmVycm9yKGVycm5vKSk7CiAgICAgIH0KCiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgUFJPUF9DT05URVhUOiB7CiAgICAgIHN0cnVjdCBsd3NfY29udGV4dCogbHdzOwoKICAgICAgaWYoKGx3cyA9IGx3c19nZXRfY29udGV4dChzLT53c2kpKSkKICAgICAgICByZXQgPSBwdHJfb2JqKGN0eCwgbHdzX2NvbnRleHRfdXNlcihsd3MpKTsKCiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgUFJPUF9QRUVSX1dSSVRFX0FMTE9XQU5DRTogewogICAgICByZXQgPSBKU19OZXdJbnQzMihjdHgsIGx3c19nZXRfcGVlcl93cml0ZV9hbGxvd2FuY2Uocy0+d3NpKSk7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgUFJPUF9QQVJFTlQ6IHsKICAgICAgc3RydWN0IGx3cyogd3NpID0gbHdzX2dldF9wYXJlbnQocy0+d3NpKTsKCiAgICAgIGlmKHdzaSkKICAgICAgICByZXQgPSB3c2kgPT0gcy0+d3NpID8gSlNfRHVwVmFsdWUoY3R4LCB0aGlzX3ZhbCkgOiBsd3Nqc19zb2NrZXRfZ2V0X29yX2NyZWF0ZShjdHgsIHdzaSk7CgogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIFBST1BfQ0hJTEQ6IHsKICAgICAgc3RydWN0IGx3cyogd3NpID0gbHdzX2dldF9jaGlsZChzLT53c2kpOwoKICAgICAgaWYod3NpKQogICAgICAgIHJldCA9IHdzaSA9PSBzLT53c2kgPyBKU19EdXBWYWx1ZShjdHgsIHRoaXNfdmFsKSA6IGx3c2pzX3NvY2tldF9nZXRfb3JfY3JlYXRlKGN0eCwgd3NpKTsKCiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgUFJPUF9ORVRXT1JLOiB7CiAgICAgIHN0cnVjdCBsd3MqIHdzaSA9IGx3c19nZXRfbmV0d29ya193c2kocy0+d3NpKTsKCiAgICAgIGlmKHdzaSkKICAgICAgICByZXQgPSB3c2kgPT0gcy0+d3NpID8gSlNfRHVwVmFsdWUoY3R4LCB0aGlzX3ZhbCkgOiBsd3Nqc19zb2NrZXRfZ2V0X29yX2NyZWF0ZShjdHgsIHdzaSk7CgogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIFBST1BfRVhURU5TSU9OUzogewogICAgICBMV1NDb250ZXh0KiBsYzsKCiAgICAgIGlmKChsYyA9IGx3c2pzX3NvY2tldF9jb250ZXh0KHMtPndzaSkpICYmIGxjLT5pbmZvLmV4dGVuc2lvbnMpIHsKICAgICAgICByZXQgPSBKU19OZXdBcnJheShjdHgpOwoKICAgICAgICBmb3IoaW50IGkgPSAwOyBsYy0+aW5mby5leHRlbnNpb25zW2ldLm5hbWU7IGkrKykKICAgICAgICAgIEpTX1NldFByb3BlcnR5VWludDMyKGN0eCwgcmV0LCBpLCBKU19OZXdTdHJpbmcoY3R4LCBsYy0+aW5mby5leHRlbnNpb25zW2ldLm5hbWUpKTsKICAgICAgfQoKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBQUk9QX0gyOiB7CiAgICAgIGlmKHMtPndzaSkKICAgICAgICByZXQgPSBKU19OZXdCb29sKGN0eCwgbHdzX3dzaV9pc19oMihzLT53c2kpKTsKCiAgICAgIGJyZWFrOwogICAgfQogIH0KCiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIHZvaWQKbHdzanNfc29ja2V0X2ZpbmFsaXplcihKU1J1bnRpbWUqIHJ0LCBKU1ZhbHVlIHZhbCkgewogIExXU1NvY2tldCogczsKCiAgaWYoKHMgPSBsd3Nqc19zb2NrZXRfZGF0YSh2YWwpKSkKICAgIHNvY2tldF9mcmVlKHMsIHJ0KTsKfQoKc3RhdGljIGNvbnN0IEpTQ2xhc3NEZWYgbHdzX3NvY2tldF9jbGFzcyA9IHsKICAgICJMV1NTb2NrZXQiLAogICAgLmZpbmFsaXplciA9IGx3c2pzX3NvY2tldF9maW5hbGl6ZXIsCn07CgpzdGF0aWMgY29uc3QgSlNDRnVuY3Rpb25MaXN0RW50cnkgbHdzX3NvY2tldF9wcm90b19mdW5jc1tdID0gewogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJ3YW50V3JpdGUiLCAwLCBsd3Nqc19zb2NrZXRfbWV0aG9kcywgTUVUSE9EX1dBTlRfV1JJVEUpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJ3cml0ZSIsIDEsIGx3c2pzX3NvY2tldF9tZXRob2RzLCBNRVRIT0RfV1JJVEUpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJyZXNwb25kIiwgMSwgbHdzanNfc29ja2V0X21ldGhvZHMsIE1FVEhPRF9SRVNQT05EKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiY2xvc2UiLCAwLCBsd3Nqc19zb2NrZXRfbWV0aG9kcywgTUVUSE9EX0NMT1NFKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiaHR0cENsaWVudFJlYWQiLCAxLCBsd3Nqc19zb2NrZXRfbWV0aG9kcywgTUVUSE9EX0hUVFBfQ0xJRU5UX1JFQUQpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJhZGRIZWFkZXIiLCA0LCBsd3Nqc19zb2NrZXRfbWV0aG9kcywgTUVUSE9EX0FERF9IRUFERVIpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJjbGllbnRIdHRwTXVsdGlwYXJ0IiwgNCwgbHdzanNfc29ja2V0X21ldGhvZHMsIE1FVEhPRF9DTElFTlRfSFRUUF9NVUxUSVBBUlQpLAogICAgSlNfQ0dFVFNFVF9NQUdJQ19GTEFHU19ERUYoImlkIiwgbHdzanNfc29ja2V0X2dldCwgMCwgUFJPUF9JRCwgSlNfUFJPUF9FTlVNRVJBQkxFKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfRkxBR1NfREVGKCJ0YWciLCBsd3Nqc19zb2NrZXRfZ2V0LCAwLCBQUk9QX1RBRywgSlNfUFJPUF9DT05GSUdVUkFCTEUpLAogICAgSlNfQ0dFVFNFVF9NQUdJQ19ERUYoInZob3N0IiwgbHdzanNfc29ja2V0X2dldCwgMCwgUFJPUF9WSE9TVCksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigiaGVhZGVycyIsIGx3c2pzX3NvY2tldF9nZXQsIDAsIFBST1BfSEVBREVSUyksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigidGxzIiwgbHdzanNfc29ja2V0X2dldCwgMCwgUFJPUF9UTFMpLAogICAgSlNfQ0dFVFNFVF9NQUdJQ19ERUYoInBlZXIiLCBsd3Nqc19zb2NrZXRfZ2V0LCAwLCBQUk9QX1BFRVIpLAogICAgSlNfQ0dFVFNFVF9NQUdJQ19ERUYoImxvY2FsIiwgbHdzanNfc29ja2V0X2dldCwgMCwgUFJPUF9MT0NBTCksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigiZmQiLCBsd3Nqc19zb2NrZXRfZ2V0LCAwLCBQUk9QX0ZEKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJwYXJlbnQiLCBsd3Nqc19zb2NrZXRfZ2V0LCAwLCBQUk9QX1BBUkVOVCksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigiY2hpbGQiLCBsd3Nqc19zb2NrZXRfZ2V0LCAwLCBQUk9QX0NISUxEKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJuZXR3b3JrIiwgbHdzanNfc29ja2V0X2dldCwgMCwgUFJPUF9ORVRXT1JLKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJjb250ZXh0IiwgbHdzanNfc29ja2V0X2dldCwgMCwgUFJPUF9DT05URVhUKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJwZWVyV3JpdGVBbGxvd2FuY2UiLCBsd3Nqc19zb2NrZXRfZ2V0LCAwLCBQUk9QX1BFRVJfV1JJVEVfQUxMT1dBTkNFKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJwcm90b2NvbCIsIGx3c2pzX3NvY2tldF9nZXQsIDAsIFBST1BfUFJPVE9DT0wpLAogICAgSlNfQ0dFVFNFVF9NQUdJQ19ERUYoIm1ldGhvZCIsIGx3c2pzX3NvY2tldF9nZXQsIDAsIFBST1BfTUVUSE9EKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJ1cmkiLCBsd3Nqc19zb2NrZXRfZ2V0LCAwLCBQUk9QX1VSSSksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigiY2xpZW50IiwgbHdzanNfc29ja2V0X2dldCwgMCwgUFJPUF9DTElFTlQpLAogICAgSlNfQ0dFVFNFVF9NQUdJQ19ERUYoInJlc3BvbnNlIiwgbHdzanNfc29ja2V0X2dldCwgMCwgUFJPUF9SRVNQT05TRV9DT0RFKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJib2R5UGVuZGluZyIsIGx3c2pzX3NvY2tldF9nZXQsIGx3c2pzX3NvY2tldF9zZXQsIFBST1BfQk9EWV9QRU5ESU5HKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJyZWRpcmVjdGVkVG9HZXQiLCBsd3Nqc19zb2NrZXRfZ2V0LCAwLCBQUk9QX1JFRElSRUNURURfVE9fR0VUKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJleHRlbnNpb25zIiwgbHdzanNfc29ja2V0X2dldCwgMCwgUFJPUF9FWFRFTlNJT05TKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJoMiIsIGx3c2pzX3NvY2tldF9nZXQsIDAsIFBST1BfSDIpLAogICAgSlNfUFJPUF9TVFJJTkdfREVGKCJbU3ltYm9sLnRvU3RyaW5nVGFnXSIsICJMV1NTb2NrZXQiLCBKU19QUk9QX0NPTkZJR1VSQUJMRSksCn07CgpzdGF0aWMgY29uc3QgSlNDRnVuY3Rpb25MaXN0RW50cnkgbHdzX3NvY2tldF9zdGF0aWNfZnVuY3NbXSA9IHsKICAgIEpTX0NGVU5DX01BR0lDX0RFRigibGlzdCIsIDAsIGx3c2pzX3NvY2tldF9mdW5jdGlvbnMsIEZVTkNUSU9OX0xJU1QpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXQiLCAxLCBsd3Nqc19zb2NrZXRfZnVuY3Rpb25zLCBGVU5DVElPTl9HRVQpLAp9OwoKaW50Cmx3c2pzX3NvY2tldF9pbml0KEpTQ29udGV4dCogY3R4LCBKU01vZHVsZURlZiogbSkgewogIGluaXRfbGlzdF9oZWFkKCZzb2NrZXRfbGlzdCk7CgogIEpTX05ld0NsYXNzSUQoJmx3c2pzX3NvY2tldF9jbGFzc19pZCk7CiAgSlNfTmV3Q2xhc3MoSlNfR2V0UnVudGltZShjdHgpLCBsd3Nqc19zb2NrZXRfY2xhc3NfaWQsICZsd3Nfc29ja2V0X2NsYXNzKTsKICBsd3Nqc19zb2NrZXRfcHJvdG8gPSBKU19OZXdPYmplY3RQcm90byhjdHgsIEpTX05VTEwpOwogIEpTX1NldFByb3BlcnR5RnVuY3Rpb25MaXN0KGN0eCwgbHdzanNfc29ja2V0X3Byb3RvLCBsd3Nfc29ja2V0X3Byb3RvX2Z1bmNzLCBjb3VudG9mKGx3c19zb2NrZXRfcHJvdG9fZnVuY3MpKTsKCiAgbHdzanNfc29ja2V0X2N0b3IgPSBKU19OZXdPYmplY3RQcm90byhjdHgsIEpTX05VTEwpOwogIEpTX1NldFByb3BlcnR5RnVuY3Rpb25MaXN0KGN0eCwgbHdzanNfc29ja2V0X2N0b3IsIGx3c19zb2NrZXRfc3RhdGljX2Z1bmNzLCBjb3VudG9mKGx3c19zb2NrZXRfc3RhdGljX2Z1bmNzKSk7CiAgSlNfU2V0Q29uc3RydWN0b3IoY3R4LCBsd3Nqc19zb2NrZXRfY3RvciwgbHdzanNfc29ja2V0X3Byb3RvKTsKCiAgaWYobSkgewogICAgSlNfU2V0TW9kdWxlRXhwb3J0KGN0eCwgbSwgIkxXU1NvY2tldCIsIGx3c2pzX3NvY2tldF9jdG9yKTsKICB9CgogIHJldHVybiAwOwp9CgAAAAAAAAAAGGcAAAAAAAAAAAAAAAAAAAAAAAAYZwAAAAAAAAAAAAAAAAAAAAAAABhnAAAAAAAAAAAAAAAAAAAAAAAAGGcAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAfD0AAAAAAAB8PQAAAAAAAAAAAAAAAPC/"
				]
			]
		},
		{
			"file": "lib/fetch.js",
			"settings":
			{
				"buffer_size": 6644,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					29,
					1,
					"insert",
					{
						"characters": "cop"
					},
					"AwAAAJsKAAAAAAAAnAoAAAAAAAAAAAAAnAoAAAAAAACdCgAAAAAAAAAAAACdCgAAAAAAAJ4KAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAmwoAAAAAAACbCgAAAAAAAAAAAAAAAPC/"
				],
				[
					30,
					1,
					"left_delete",
					null,
					"AQAAAJ0KAAAAAAAAnQoAAAAAAAABAAAAcA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAngoAAAAAAACeCgAAAAAAAAAAAAAAAPC/"
				],
				[
					31,
					1,
					"insert",
					{
						"characters": "nsole.config({"
					},
					"DgAAAJ0KAAAAAAAAngoAAAAAAAAAAAAAngoAAAAAAACfCgAAAAAAAAAAAACfCgAAAAAAAKAKAAAAAAAAAAAAAKAKAAAAAAAAoQoAAAAAAAAAAAAAoQoAAAAAAACiCgAAAAAAAAAAAACiCgAAAAAAAKMKAAAAAAAAAAAAAKMKAAAAAAAApAoAAAAAAAAAAAAApAoAAAAAAAClCgAAAAAAAAAAAAClCgAAAAAAAKYKAAAAAAAAAAAAAKYKAAAAAAAApwoAAAAAAAAAAAAApwoAAAAAAACoCgAAAAAAAAAAAACoCgAAAAAAAKkKAAAAAAAAAAAAAKkKAAAAAAAAqgoAAAAAAAAAAAAAqgoAAAAAAACrCgAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAnQoAAAAAAACdCgAAAAAAAAAAAAAAAPC/"
				],
				[
					32,
					1,
					"insert",
					{
						"characters": "  "
					},
					"AgAAAKsKAAAAAAAArAoAAAAAAAAAAAAArAoAAAAAAACtCgAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAqwoAAAAAAACrCgAAAAAAAAAAAAAAAPC/"
				],
				[
					34,
					1,
					"insert",
					{
						"characters": " m,ax"
					},
					"BQAAAKwKAAAAAAAArQoAAAAAAAAAAAAArQoAAAAAAACuCgAAAAAAAAAAAACuCgAAAAAAAK8KAAAAAAAAAAAAAK8KAAAAAAAAsAoAAAAAAAAAAAAAsAoAAAAAAACxCgAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAArAoAAAAAAACsCgAAAAAAAAAAAAAAAPC/"
				],
				[
					35,
					3,
					"left_delete",
					null,
					"AwAAALAKAAAAAAAAsAoAAAAAAAABAAAAeK8KAAAAAAAArwoAAAAAAAABAAAAYa4KAAAAAAAArgoAAAAAAAABAAAALA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAsQoAAAAAAACxCgAAAAAAAAAAAAAAAPC/"
				],
				[
					36,
					1,
					"insert",
					{
						"characters": "axArrayLength:"
					},
					"DgAAAK4KAAAAAAAArwoAAAAAAAAAAAAArwoAAAAAAACwCgAAAAAAAAAAAACwCgAAAAAAALEKAAAAAAAAAAAAALEKAAAAAAAAsgoAAAAAAAAAAAAAsgoAAAAAAACzCgAAAAAAAAAAAACzCgAAAAAAALQKAAAAAAAAAAAAALQKAAAAAAAAtQoAAAAAAAAAAAAAtQoAAAAAAAC2CgAAAAAAAAAAAAC2CgAAAAAAALcKAAAAAAAAAAAAALcKAAAAAAAAuAoAAAAAAAAAAAAAuAoAAAAAAAC5CgAAAAAAAAAAAAC5CgAAAAAAALoKAAAAAAAAAAAAALoKAAAAAAAAuwoAAAAAAAAAAAAAuwoAAAAAAAC8CgAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAArgoAAAAAAACuCgAAAAAAAAAAAAAAAPC/"
				],
				[
					37,
					1,
					"insert",
					{
						"characters": " 10"
					},
					"AwAAALwKAAAAAAAAvQoAAAAAAAAAAAAAvQoAAAAAAAC+CgAAAAAAAAAAAAC+CgAAAAAAAL8KAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAvAoAAAAAAAC8CgAAAAAAAAAAAAAAAPC/"
				],
				[
					38,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAL8KAAAAAAAAwAoAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAvwoAAAAAAAC/CgAAAAAAAAAAAAAAAPC/"
				],
				[
					39,
					3,
					"left_delete",
					null,
					"AwAAAL8KAAAAAAAAvwoAAAAAAAABAAAAIL4KAAAAAAAAvgoAAAAAAAABAAAAML0KAAAAAAAAvQoAAAAAAAABAAAAMQ",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAwAoAAAAAAADACgAAAAAAAAAAAAAAAPC/"
				],
				[
					40,
					1,
					"insert",
					{
						"characters": "20"
					},
					"AgAAAL0KAAAAAAAAvgoAAAAAAAAAAAAAvgoAAAAAAAC/CgAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAvQoAAAAAAAC9CgAAAAAAAAAAAAAAAPC/"
				],
				[
					41,
					1,
					"insert",
					{
						"characters": " }),"
					},
					"BAAAAL8KAAAAAAAAwAoAAAAAAAAAAAAAwAoAAAAAAADBCgAAAAAAAAAAAADBCgAAAAAAAMIKAAAAAAAAAAAAAMIKAAAAAAAAwwoAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAvwoAAAAAAAC/CgAAAAAAAAAAAAAAAPC/"
				],
				[
					42,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAMMKAAAAAAAAxAoAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAwwoAAAAAAADDCgAAAAAAAAAAAAAAAPC/"
				],
				[
					53,
					1,
					"insert",
					{
						"characters": "\n\n\n"
					},
					"CQAAAAsOAAAAAAAADA4AAAAAAAAAAAAADA4AAAAAAAAWDgAAAAAAAAAAAAAWDgAAAAAAABgOAAAAAAAAAAAAABgOAAAAAAAAGQ4AAAAAAAAAAAAAGQ4AAAAAAAAlDgAAAAAAAAAAAAAMDgAAAAAAAAwOAAAAAAAADAAAACAgICAgICAgICAgIBkOAAAAAAAAGg4AAAAAAAAAAAAAGg4AAAAAAAAmDgAAAAAAAAAAAAANDgAAAAAAAA0OAAAAAAAADAAAACAgICAgICAgICAgIA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAACw4AAAAAAAALDgAAAAAAAP///////+9/"
				],
				[
					55,
					1,
					"insert",
					{
						"characters": "cojn"
					},
					"BQAAAA0OAAAAAAAADg4AAAAAAAAAAAAADw4AAAAAAAAPDgAAAAAAAAwAAAAgICAgICAgICAgICAODgAAAAAAAA8OAAAAAAAAAAAAAA8OAAAAAAAAEA4AAAAAAAAAAAAAEA4AAAAAAAARDgAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAADQ4AAAAAAAANDgAAAAAAAAAAAAAAAFhA"
				],
				[
					56,
					2,
					"left_delete",
					null,
					"AgAAABAOAAAAAAAAEA4AAAAAAAABAAAAbg8OAAAAAAAADw4AAAAAAAABAAAAag",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAEQ4AAAAAAAARDgAAAAAAAAAAAAAAAPC/"
				],
				[
					57,
					1,
					"insert",
					{
						"characters": "nst"
					},
					"AwAAAA8OAAAAAAAAEA4AAAAAAAAAAAAAEA4AAAAAAAARDgAAAAAAAAAAAAARDgAAAAAAABIOAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAADw4AAAAAAAAPDgAAAAAAAAAAAAAAAPC/"
				],
				[
					58,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAABIOAAAAAAAAEw4AAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAEg4AAAAAAAASDgAAAAAAAAAAAAAAAPC/"
				],
				[
					59,
					1,
					"insert_snippet",
					{
						"contents": "{$0}"
					},
					"AQAAABMOAAAAAAAAFQ4AAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAEw4AAAAAAAATDgAAAAAAAAAAAAAAAPC/"
				],
				[
					60,
					1,
					"insert",
					{
						"characters": " bodyPending"
					},
					"DAAAABQOAAAAAAAAFQ4AAAAAAAAAAAAAFQ4AAAAAAAAWDgAAAAAAAAAAAAAWDgAAAAAAABcOAAAAAAAAAAAAABcOAAAAAAAAGA4AAAAAAAAAAAAAGA4AAAAAAAAZDgAAAAAAAAAAAAAZDgAAAAAAABoOAAAAAAAAAAAAABoOAAAAAAAAGw4AAAAAAAAAAAAAGw4AAAAAAAAcDgAAAAAAAAAAAAAcDgAAAAAAAB0OAAAAAAAAAAAAAB0OAAAAAAAAHg4AAAAAAAAAAAAAHg4AAAAAAAAfDgAAAAAAAAAAAAAfDgAAAAAAACAOAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAFA4AAAAAAAAUDgAAAAAAAAAAAAAAAPC/"
				],
				[
					61,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAACAOAAAAAAAAIQ4AAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAIA4AAAAAAAAgDgAAAAAAAAAAAAAAAPC/"
				],
				[
					63,
					1,
					"insert",
					{
						"characters": " ="
					},
					"AgAAACIOAAAAAAAAIw4AAAAAAAAAAAAAIw4AAAAAAAAkDgAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAIg4AAAAAAAAiDgAAAAAAAAAAAAAAAPC/"
				],
				[
					64,
					1,
					"insert",
					{
						"characters": " wsi;"
					},
					"BQAAACQOAAAAAAAAJQ4AAAAAAAAAAAAAJQ4AAAAAAAAmDgAAAAAAAAAAAAAmDgAAAAAAACcOAAAAAAAAAAAAACcOAAAAAAAAKA4AAAAAAAAAAAAAKA4AAAAAAAApDgAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAJA4AAAAAAAAkDgAAAAAAAAAAAAAAAPC/"
				],
				[
					82,
					1,
					"paste",
					null,
					"AQAAAF8OAAAAAAAAag4AAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAXw4AAAAAAABfDgAAAAAAAAAAAAAAAPC/"
				],
				[
					83,
					1,
					"insert",
					{
						"characters": "."
					},
					"AQAAAGoOAAAAAAAAaw4AAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAag4AAAAAAABqDgAAAAAAAAAAAAAAAPC/"
				],
				[
					84,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAGsOAAAAAAAAbA4AAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAaw4AAAAAAABrDgAAAAAAAAAAAAAAAPC/"
				],
				[
					85,
					2,
					"left_delete",
					null,
					"AgAAAGsOAAAAAAAAaw4AAAAAAAABAAAAIGoOAAAAAAAAag4AAAAAAAABAAAALg",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAbA4AAAAAAABsDgAAAAAAAAAAAAAAAPC/"
				],
				[
					86,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAAGoOAAAAAAAAaw4AAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAag4AAAAAAABqDgAAAAAAAAAAAAAAAPC/"
				],
				[
					87,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAGsOAAAAAAAAbA4AAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAaw4AAAAAAABrDgAAAAAAAAAAAAAAAPC/"
				],
				[
					94,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAACAOAAAAAAAAIQ4AAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAIA4AAAAAAAAgDgAAAAAAAAAAAAAAAPC/"
				],
				[
					95,
					1,
					"insert",
					{
						"characters": " method"
					},
					"BwAAACEOAAAAAAAAIg4AAAAAAAAAAAAAIg4AAAAAAAAjDgAAAAAAAAAAAAAjDgAAAAAAACQOAAAAAAAAAAAAACQOAAAAAAAAJQ4AAAAAAAAAAAAAJQ4AAAAAAAAmDgAAAAAAAAAAAAAmDgAAAAAAACcOAAAAAAAAAAAAACcOAAAAAAAAKA4AAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAIQ4AAAAAAAAhDgAAAAAAAAAAAAAAAPC/"
				],
				[
					102,
					1,
					"insert",
					{
						"characters": "method,"
					},
					"BwAAAHQOAAAAAAAAdQ4AAAAAAAAAAAAAdQ4AAAAAAAB2DgAAAAAAAAAAAAB2DgAAAAAAAHcOAAAAAAAAAAAAAHcOAAAAAAAAeA4AAAAAAAAAAAAAeA4AAAAAAAB5DgAAAAAAAAAAAAB5DgAAAAAAAHoOAAAAAAAAAAAAAHoOAAAAAAAAew4AAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAdA4AAAAAAAB0DgAAAAAAAAAAAAAAAPC/"
				],
				[
					103,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAHsOAAAAAAAAfA4AAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAew4AAAAAAAB7DgAAAAAAAAAAAAAAAPC/"
				],
				[
					117,
					1,
					"insert",
					{
						"characters": "e"
					},
					"AQAAABsRAAAAAAAAHBEAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAGxEAAAAAAAAbEQAAAAAAAAAAAAAAQIJA"
				],
				[
					118,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAABwRAAAAAAAAHREAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAHBEAAAAAAAAcEQAAAAAAAAAAAAAAAPC/"
				],
				[
					119,
					2,
					"left_delete",
					null,
					"AgAAABwRAAAAAAAAHBEAAAAAAAABAAAAIBsRAAAAAAAAGxEAAAAAAAABAAAAZQ",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAHREAAAAAAAAdEQAAAAAAAAAAAAAAAPC/"
				],
				[
					120,
					1,
					"insert",
					{
						"characters": " else"
					},
					"BQAAABsRAAAAAAAAHBEAAAAAAAAAAAAAHBEAAAAAAAAdEQAAAAAAAAAAAAAdEQAAAAAAAB4RAAAAAAAAAAAAAB4RAAAAAAAAHxEAAAAAAAAAAAAAHxEAAAAAAAAgEQAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAGxEAAAAAAAAbEQAAAAAAAAAAAAAAAPC/"
				],
				[
					121,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAACARAAAAAAAAIREAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAIBEAAAAAAAAgEQAAAAAAAAAAAAAAAPC/"
				],
				[
					122,
					1,
					"insert_snippet",
					{
						"contents": "{$0}"
					},
					"AQAAACERAAAAAAAAIxEAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAIREAAAAAAAAhEQAAAAAAAAAAAAAAAPC/"
				],
				[
					123,
					1,
					"run_macro_file",
					{
						"file": "res://Packages/Default/Add Line in Braces.sublime-macro"
					},
					"BgAAACIRAAAAAAAAIxEAAAAAAAAAAAAAIxEAAAAAAAAvEQAAAAAAAAAAAAAvEQAAAAAAADARAAAAAAAAAAAAADARAAAAAAAAPBEAAAAAAAAAAAAAIxEAAAAAAAAjEQAAAAAAAAwAAAAgICAgICAgICAgICAjEQAAAAAAADERAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAIhEAAAAAAAAiEQAAAAAAAAAAAAAAAPC/"
				],
				[
					124,
					1,
					"insert",
					{
						"characters": "\nwsi."
					},
					"BwAAADERAAAAAAAAMhEAAAAAAAAAAAAAMhEAAAAAAABAEQAAAAAAAAAAAAAjEQAAAAAAACMRAAAAAAAADgAAACAgICAgICAgICAgICAgMhEAAAAAAAAzEQAAAAAAAAAAAAAzEQAAAAAAADQRAAAAAAAAAAAAADQRAAAAAAAANREAAAAAAAAAAAAANREAAAAAAAA2EQAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAMREAAAAAAAAxEQAAAAAAAAAAAAAAAPC/"
				],
				[
					127,
					1,
					"insert",
					{
						"characters": "write"
					},
					"BQAAADYRAAAAAAAANxEAAAAAAAAAAAAANxEAAAAAAAA4EQAAAAAAAAAAAAA4EQAAAAAAADkRAAAAAAAAAAAAADkRAAAAAAAAOhEAAAAAAAAAAAAAOhEAAAAAAAA7EQAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAANhEAAAAAAAA2EQAAAAAAAAAAAAAAAPC/"
				],
				[
					128,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAADsRAAAAAAAAPREAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAOxEAAAAAAAA7EQAAAAAAAAAAAAAAAPC/"
				],
				[
					129,
					1,
					"insert_snippet",
					{
						"contents": "'$0'"
					},
					"AQAAADwRAAAAAAAAPhEAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAPBEAAAAAAAA8EQAAAAAAAAAAAAAAAPC/"
				],
				[
					130,
					1,
					"insert",
					{
						"characters": "TEST!\\r\\n"
					},
					"CQAAAD0RAAAAAAAAPhEAAAAAAAAAAAAAPhEAAAAAAAA/EQAAAAAAAAAAAAA/EQAAAAAAAEARAAAAAAAAAAAAAEARAAAAAAAAQREAAAAAAAAAAAAAQREAAAAAAABCEQAAAAAAAAAAAABCEQAAAAAAAEMRAAAAAAAAAAAAAEMRAAAAAAAARBEAAAAAAAAAAAAARBEAAAAAAABFEQAAAAAAAAAAAABFEQAAAAAAAEYRAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAPREAAAAAAAA9EQAAAAAAAAAAAAAAAPC/"
				],
				[
					132,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAAEcRAAAAAAAASBEAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAARxEAAAAAAABHEQAAAAAAAAAAAAAAAPC/"
				],
				[
					133,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAEgRAAAAAAAASREAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAASBEAAAAAAABIEQAAAAAAAAAAAAAAAPC/"
				],
				[
					136,
					2,
					"left_delete",
					null,
					"AgAAAEgRAAAAAAAASBEAAAAAAAABAAAAIEcRAAAAAAAARxEAAAAAAAABAAAALA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAASREAAAAAAABJEQAAAAAAAAAAAAAAAPC/"
				],
				[
					138,
					1,
					"insert",
					{
						"characters": ";"
					},
					"AQAAAEgRAAAAAAAASREAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAASBEAAAAAAABIEQAAAAAAAAAAAAAAAPC/"
				],
				[
					140,
					1,
					"left_delete",
					null,
					"AQAAACIRAAAAAAAAIhEAAAAAAAABAAAACg",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAIxEAAAAAAAAjEQAAAAAAAAAAAAAAgHJA"
				],
				[
					167,
					1,
					"insert",
					{
						"characters": "\n\nresolve"
					},
					"DAAAAJUUAAAAAAAAlhQAAAAAAAAAAAAAlhQAAAAAAACiFAAAAAAAAAAAAACiFAAAAAAAAKMUAAAAAAAAAAAAAKMUAAAAAAAArxQAAAAAAAAAAAAAlhQAAAAAAACWFAAAAAAAAAwAAAAgICAgICAgICAgICCjFAAAAAAAAKQUAAAAAAAAAAAAAKQUAAAAAAAApRQAAAAAAAAAAAAApRQAAAAAAACmFAAAAAAAAAAAAACmFAAAAAAAAKcUAAAAAAAAAAAAAKcUAAAAAAAAqBQAAAAAAAAAAAAAqBQAAAAAAACpFAAAAAAAAAAAAACpFAAAAAAAAKoUAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAlRQAAAAAAACVFAAAAAAAAAAAAAAAAPC/"
				],
				[
					168,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAKoUAAAAAAAArBQAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAqhQAAAAAAACqFAAAAAAAAAAAAAAAAPC/"
				],
				[
					170,
					1,
					"insert",
					{
						"characters": ";"
					},
					"AQAAAKwUAAAAAAAArRQAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAArBQAAAAAAACsFAAAAAAAAAAAAAAAAPC/"
				],
				[
					175,
					2,
					"left_delete",
					null,
					"AgAAAKwUAAAAAAAArBQAAAAAAAABAAAAO6sUAAAAAAAAqxQAAAAAAAABAAAAKQ",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAArRQAAAAAAACtFAAAAAAAAAAAAAAAAPC/"
				],
				[
					176,
					1,
					"insert",
					{
						"characters": "resp);"
					},
					"BgAAAKsUAAAAAAAArBQAAAAAAAAAAAAArBQAAAAAAACtFAAAAAAAAAAAAACtFAAAAAAAAK4UAAAAAAAAAAAAAK4UAAAAAAAArxQAAAAAAAAAAAAArxQAAAAAAACwFAAAAAAAAAAAAACwFAAAAAAAALEUAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAqxQAAAAAAACrFAAAAAAAAAAAAAAAAPC/"
				],
				[
					180,
					1,
					"cut",
					null,
					"AQAAAKMUAAAAAAAAoxQAAAAAAAAOAAAAcmVzb2x2ZShyZXNwKTs",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAsRQAAAAAAACjFAAAAAAAAAAAAAAAAFhA"
				],
				[
					181,
					1,
					"paste",
					null,
					"AQAAAKMUAAAAAAAAsRQAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAoxQAAAAAAACjFAAAAAAAAAAAAAAAAPC/"
				]
			]
		},
		{
			"file": "libwebsockets/include/libwebsockets/lws-write.h",
			"settings":
			{
				"buffer_size": 9628,
				"line_ending": "Unix"
			}
		},
		{
			"file": "libwebsockets/lib/roles/http/client/client-http.c",
			"settings":
			{
				"buffer_size": 55002,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"edit",
				"Color Scheme Editor: Edit current color scheme"
			],
			[
				"out",
				"Browse Mode: Outline (Right)"
			],
			[
				"cam",
				"Convert Case: camelCase"
			],
			[
				"camel",
				"Convert Case: camelCase"
			],
			[
				"ins",
				"Package Control: Install Package"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"came",
				"Convert Case: camelCase"
			],
			[
				"case ",
				"Convert Case: camelCase"
			],
			[
				"doxy",
				"DoxyDoxygen: Comment All"
			],
			[
				"",
				":$ - EOF"
			],
			[
				"format",
				"JsPrettier: Format Code"
			],
			[
				"prett",
				"JsPrettier: Format Code"
			],
			[
				"ou",
				"Browse Mode: Outline (Right)"
			],
			[
				"instga",
				"Package Control: Install Package"
			],
			[
				"prettier",
				"JsPrettier: Format Code"
			],
			[
				"json",
				"Pretty JSON: Minify JSON"
			],
			[
				"jspr",
				"JsPrettier: Format Code"
			],
			[
				"outline",
				"Browse Mode: Outline (Right)"
			],
			[
				"color",
				"Color Highlight: Reset"
			],
			[
				"scheme",
				"Color Scheme Editor: Edit current color scheme"
			],
			[
				"edit cu",
				"Color Scheme Editor: Edit current color scheme"
			],
			[
				"insta",
				"Package Control: Install Package"
			],
			[
				"install pac",
				"Package Control: Install Package"
			],
			[
				"list pack",
				"Package Control: List Packages"
			],
			[
				"edit ",
				"Color Scheme Editor: Edit current color scheme"
			],
			[
				"remove",
				"Package Control: Remove Package"
			],
			[
				"outli",
				"Browse Mode: Outline (Right)"
			],
			[
				"debugger",
				"Preferences: Debugger Settings"
			],
			[
				"add re",
				"Package Control: Add Repository"
			],
			[
				"outlin",
				"Browse Mode: Outline (Right)"
			],
			[
				"INSTALL",
				"Package Control: Install Package"
			],
			[
				"disable",
				"Package Control: Disable Package"
			],
			[
				"Package Control: disable",
				"Package Control: Disable Package"
			],
			[
				"Package Control: ",
				"Package Control: Disable Package"
			],
			[
				"adap",
				"Debugger: Install Adapters"
			],
			[
				"install ada",
				"Debugger: Install Adapters"
			],
			[
				"adapter",
				"Debugger: Install Adapters"
			],
			[
				"debug",
				"Debugger: Install Adapters"
			],
			[
				"Package Control: remove",
				"Package Control: Remove Package"
			],
			[
				"debu",
				"Debugger: Install Adapters"
			],
			[
				"instal",
				"Package Control: Install Package"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 289.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/h2"
	],
	"file_history":
	[
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lws.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/h2/http2.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lws-sockaddr46.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lws-context.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lws-socket.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lws-vhost.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lws.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/js-utils.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/lws/body.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/lws/headers.js",
		"/home/roman/.config/sublime-text/Packages/User/Themes/C Theme.tmTheme",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lws-sockaddr46.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-network-helper.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lws-socket.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/client/client-http.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/minimal-examples-lowlevel/http-client/minimal-http-client-multi/minimal-http-client-multi.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/minimal-examples-lowlevel/http-client/minimal-http-client-post/minimal-http-client-post.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/fetch.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/parsers.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/h2/ops-h2.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core/private-lib-core.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-http.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-client.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/protocols/ss-h1.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/tcpSocket.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/lws/util.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lws-context.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/serve.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/websocket.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/helpers/webidl.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/helpers/webidl.ts",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/lws/assert.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/lws/streams.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/websocketstream.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream/pipe.ts",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/lws/context.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/lws/request.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/lws/response.js",
		"/home/roman/Projects/plot-cv/quickjs/quickjs-libc.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/js-utils.c",
		"/home/roman/Projects/plot-cv/quickjs/quickjs.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/streams.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/quickjs.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-callbacks.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/lws/events.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/lws/body.old.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/lws/abort.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/readable-stream.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-context-vhost.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-eventlib-exports.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/header.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/minimal-examples-lowlevel/raw/minimal-raw-proxy/minimal-raw-proxy.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/plugins/raw-proxy/protocol_lws_raw_proxy.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-protocols-plugins.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/h2/hpack.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lws-vhost.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lws-spa.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/minimal-examples-lowlevel/http-server/minimal-http-server-deaddrop/minimal-http-server-deaddrop.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/plugins/deaddrop/protocol_lws_deaddrop.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-misc.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/network.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-x509.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-writeable.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-adopt.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/test.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/private-lib-core-net.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-async-dns.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets.h",
		"/home/roman/Projects/plot-cv/quickjs/quickjs.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-struct.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/private-lib-roles-http.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/private-lib-roles.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/minimal-examples-lowlevel/raw/minimal-raw-client/main.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream.ts",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/validators/underlying-sink.ts",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/ponyfill.ts",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/transform-stream/transformer.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-tokenize.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/lws/simple-queue.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/lws/list.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/lws/mimetypes.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/lws/abort-controller.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/lws/abort-signal.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/lws/event-target-shim.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/lws/event-attribute-handler.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/fetch/body.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/events.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/assert.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/CMakeLists.txt",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/list.js",
		"/home/roman/Projects/plot-cv/quickjs/cutils.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/fetch/request.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/fetch/response.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/streams.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/http/server/server.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/minimal-examples-lowlevel/http-client/minimal-http-client-post/README.md",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/minimal-examples/embedded/lhp/esp32-waveshare-104-212/main/splash-212-104.jpg.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-write.h",
		"/home/roman/Projects/plot-cv/quickjs/list.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/fetch/headers.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/simple-queue.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/tests/test_websocket.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-ws-ext.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/ws/ext/extension-permessage-deflate.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/plugin-standalone/protocol_example_standalone.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/minimal-examples-lowlevel/ws-server/minimal-ws-server-echo/minimal-ws-server-echo.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/minimal-examples-lowlevel/ws-client/minimal-ws-client-echo/minimal-ws-client-echo.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/secure-streams/policy-common.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/minimal-examples-lowlevel/ws-server/minimal-ws-server-pmd-corner/minimal-ws-server-pmd-corner.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/quickjs.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/qjs-lws.sublime-project",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/web-streams-polyfill/src/lib/readable-stream.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/cmake/BuildLibwebsockets.cmake",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/websocketStream.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-logs.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/lib/formData.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/test-client.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/dummy-callback.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/vhost.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/minimal-examples-lowlevel/http-client/minimal-http-client-jit-trust/minimal-http-client.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/minimal-examples-lowlevel/http-client/minimal-http-client/minimal-http-client.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/minimal-examples-lowlevel/http-client/minimal-http-client-custom-headers/minimal-http-client-custom-headers.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-jrpc.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/server.ts",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-ws-state.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/roles/ws/ops-ws.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/wsi.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/lib/core-net/output.c"
	],
	"find":
	{
		"height": 26.0
	},
	"find_in_files":
	{
		"height": 138.0,
		"where_history":
		[
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.jsx,*.ts,-*/libwebsockets/*example*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,*.ts,-*/libwebsockets/*example*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,*.ts,-*/libwebsockets/*examplex*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,*.ts,-*/libwebsockets/*example*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,*.ts,-*/libwebsockets/*example*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginx*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.hx,*.cx,*.js,*.ts,-*/libwebsockets/*example*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginx*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,*.ts,-*/libwebsockets/*example*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginx*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,*.ts,-*/libwebsockets/*example*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginx*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,*.ts,-*/libwebsockets/*example*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginx*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,*.ts,-*/libwebsockets/*example*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,*.ts,-*/libwebsockets/*example*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.cx,*.js,*.ts,-*/libwebsockets/*example*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,*.ts,-*/libwebsockets/*example*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,*.ts,-*/libwebsockets/*example*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,*.ts,-*/libwebsockets/*example*/*,-*/libwebsockets/lib/*,-*/libwebsockets/include/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,*.ts,-*/libwebsockets/*example*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.jsx,*.ts,-*/libwebsockets/*example*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,*.ts,-*/libwebsockets/*example*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*example*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*example*/*,-*/libwebsockets/lib/*,-*/libwebsockets/include/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*example*/*,-*/libwebsockets/libx/*,-*/libwebsockets/include/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplex*/*,-*/libwebsockets/libx/*,-*/libwebsockets/include/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplex*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*example*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*example*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplex*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplex*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplex*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplex*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*example*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*example*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginx*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*example*/*,-*/libwebsockets/xlib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginx*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*example*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*example*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*example*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginx*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginx*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginx*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginx*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginx*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginx*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginx*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugin*/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugins/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginsx/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-appsx/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginsx/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-appsx/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginsx/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugins/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/libáº/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugins/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/libáº/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugins/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/libáº/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginsx/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/libáº/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginsx/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginsx/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/libáº/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginsx/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/libáº/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginsx/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginsx/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginsx/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginsx/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-appsx/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginsx/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-appsx/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginsx/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-appsx/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginsx/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-appsx/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/pluginsx/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-appsx/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugins/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-appsx/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugins/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-appsx/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugins/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-appsx/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugins/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugins/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugins/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugins/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/lib/*,-*/libwebsockets/include/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugins/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugins/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugins/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/lib/*,-*/libwebsockets/include/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugins/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/libx/*,-*/libwebsockets/include/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugins/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugins/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/libx/*,-*/libwebsockets/include/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugins/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/lib/*,-*/libwebsockets/include/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/plugins/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/lib/*,-*/libwebsockets/include/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/libx/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/lib/*,-*/libwebsockets/includex/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/lib/*,-*/libwebsockets/include/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/lwsws/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/lib/*,-*/libwebsockets/include/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examples*/*,-*/libwebsockets/lib/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,*.js,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/libx/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,-*/libwebsockets/*examplesx*/*,-*/libwebsockets/libx/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,-*/libwebsockets/*examples*/*,-*/libwebsockets/libx/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,-*/libwebsockets/*examples*x/*,-*/libwebsockets/libx/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,-*/libwebsockets/*examples*/*,-*/libwebsockets/libx/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,-*/libwebsockets/*examples*/*,-*/libwebsockets/lib/*,-*/libwebsockets/test-apps/*,-*/libwebsockets/win32port/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,-*/libwebsockets/*examples*/*,-*/libwebsockets/lib/*,-*/libwebsockets/test-apps/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,-*/libwebsockets/lib/*,-*/libwebsockets/test-apps/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,-*/libwebsockets/lib/*,-*/libwebsockets/*examples*/*",
			"/home/roman/Projects/plot-cv/quickjs/qjs-lws,*.h,*.c,-*/libwebsockets/lib/*",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"lws_ssl_capable_read_no_ssl",
			"\\b(read|recv|write|send)(|to)\\(",
			"= \\b(read|recv|write|send)(|to)\\(",
			"\\s\\b(read|recv|write|send)(|to)\\(",
			"\\b(read|recv|write|send)(|to)\\(",
			"\\b(read|recv|write|send)(|to)",
			"lws_plat_write_cert",
			"\\blws_plat_write_cert\\b",
			"\\swrite\\(",
			"\\bwrite\\(",
			"^lws_write\\b",
			"^lws_write",
			"new Promise",
			"lws_\\w*header.*LEN",
			"lws_\\w*header",
			"lws_write\\(.*LEN",
			"lws_write\\(",
			"[A-Z0-9_]+CONTENT_LENGTH",
			"[A-Z0-9_]+LENGTH",
			"_INVALID",
			"INVALID",
			"_on_writable\\(",
			"_on_writable",
			"body.*pending",
			"body.pending",
			"client_http_body_pending",
			"body\\w* = 1",
			"lws_callback_g",
			"lws_callback_g\\b",
			"multipart",
			"LCCSCF_HTTP_MULTIPART_MIME",
			"lws_http_multipart_headers",
			"\\bmultipart = ",
			"1",
			"find_charset",
			"WSI_TOKEN_GET_URI",
			"headers =",
			"_HEADERS:",
			"client_connect_info_fromobj",
			"lwsjs_uri_toconnectinfo",
			"Ran out of header",
			"\"h2,",
			"h1",
			"APPEND_HANDSHAKE_HEADER",
			"Ran out of header",
			"_ADD_HEADER:",
			"is_h2",
			"\"h2\"",
			"^const struct ss_pcols",
			"alpn =",
			"LCCSCF_H2_",
			"LCCSCF_H2_MANUAL_RXFLOW",
			"LCCSCF_H2_PRIOR_KNOWLEDGE",
			"LCCSCF_ALLOW_EXPIRED",
			"LCCSCF_ALLOW_SELFSIGNED",
			"onClientHttpWriteable",
			"CLIENT_HTTP_WRITEABLE",
			"CLIENT_HTTP_WRITeABLE",
			"onClosed",
			"WSI_DES",
			"JS_VALUE_GET_OBJ.ret",
			"JS_VALUE_GET_OBJ",
			"^socket_get\\b",
			"socket_get",
			"\\bjs_socket_get\\b",
			"js_socket_get\\b",
			"\\bsocket_",
			"\\bsocket_get",
			"socket_obj2",
			"\\bsocket_obj\\b",
			"_CONNECT:",
			"lws_[sg]et_opaque_user_data",
			"lws_set_opaque_user_data",
			"^http_callback",
			"onClosedClientHttp",
			"PROP_FD:",
			"\"fd\"",
			"on_writable",
			"case \\w*_WRITE*ABLE",
			"case LWS\\w*_WRITE*ABLE",
			"_WRITE*ABLE",
			"WRITE*ABLE",
			"LCCSCF_HTTP_MULTIPART_MIME",
			"LCCSCF_",
			"LCCSCF",
			"LCCSCF_ALLOW_INSECURE",
			"ssl(C|_c)onnection",
			"'rest'",
			"padEnd",
			"padStart",
			"padEnd",
			"pad",
			"onCompletedClientHttp",
			"onEstablished",
			"readable",
			"define\\(",
			"class ReadableStream {",
			"readableStreamCall",
			"underlyingSource",
			"ResetQueue",
			"ReadableByteStreamControllerClearPendingPullIntos",
			"ReadableByteStreamControllerRespondInternal",
			"ReadableByteStreamControllerHandleQueueDrain",
			"ReadableStreamDefaultControllerCanCloseOrEnqueue",
			"SetUpReadableStreamDefaultController",
			"uponPromise",
			"ion uponPromise",
			"uponPromise",
			"let \\w*Algorithm",
			"Algorithm =",
			"\\b_?pull\\w*\\(",
			"InitializeReadableStream",
			"\\b_?pull\\w*\\(",
			"pull",
			"\\bassert_default\\b",
			"ReadableByteStreamControllerClearPendingPullIntos",
			"defaultReaderClosedPromiseReject",
			"TransformStreamDefaultControllerClearAlgorithms",
			"defaultControllerFinishPromiseResolve",
			"^(var|const|let)\\b",
			"closeSentinel",
			"^(var|const|let)\\b",
			"number_isinteger_default",
			"^(var|const|let)\\b",
			"\\bmath_trunc_default\\b",
			"\\bnumber_isfinite_default\\b",
			"number_isfinite_default",
			"^(var|const|let)\\b"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
			"assert",
			"NumberIsInteger",
			"MathTrunc",
			"NumberIsFinite",
			"Symbol.asyncIterator",
			"",
			"  }\\n\\n  \\1",
			"\\2",
			"NumberIsNaN",
			"typeIsObject",
			"return;",
			"\\1\\n\\n\\2",
			";\\n\\nfunction ",
			"socket_obj2",
			"readWholeStream",
			"local",
			"Port",
			"#sock",
			"TCPSocketStream",
			"struct lws_client_connect_info",
			"struct lws_protocols",
			"struct lws_context_creation_info",
			"struct lws_protocol_vhost_options",
			"lwsjs_\\1",
			"lwsjs_context_creation_info_",
			"JSContext",
			"lwsjs_context_creation_info_",
			"length",
			"_sockaddr46_",
			"TCPSocket",
			"TCPSocker",
			"assign",
			"export function",
			"s",
			"/* \\1 */",
			"\"\\\\033[",
			"\"\\x1b[",
			"ctx",
			"/* \\1 */",
			"\\*/\\n ",
			"}\\n\n  /**",
			"#bodyStream",
			"act(",
			"act",
			"ws.",
			"ws",
			",",
			"wsi2spa",
			": ",
			"c_callback",
			":",
			"JSCClosure",
			"js_iterator_get",
			"ssl_ca",
			"ssl_private_key",
			"#lws",
			"#act",
			"this.#",
			"this.#table",
			"this.#entries",
			"map",
			"socket_get_or_create",
			"lwsjs_socket_obj",
			"socket_wrap",
			"\\1.#\\2 = \\3",
			"Blob",
			"#bodyText",
			"this.#\\1 = \\2",
			"#bodyFormData",
			"#bodyArrayBuffer",
			"#bodyBlob",
			"\\1assign(\\2, { \\3: \\4 });",
			"\\1   \\3: \\4,",
			"\\1assign(this, { \\2: \\3 });",
			"\\1: \\2,",
			"/*Object.defineProperties(\\1);*/",
			"\\1;",
			"return \\1;",
			"return false;",
			"const",
			"\\1 '\\2'",
			"undefined",
			"if(s && ",
			"if(s)",
			"js_wsi_\\1",
			"lwsjs_method_\\1",
			"",
			"str_property(\\3, ctx, obj, \"\\1\");",
			"str_replace(ctx, &\\1, \\2);",
			"lwsjs_uri_toobj",
			"assign",
			"define(this, { \\1: \\2 });",
			"is_ws",
			": \\1 => \\2,",
			": \\1 => (\\2, 0),",
			": \\1 => \\2,",
			"act",
			": \\1 => \\2,",
			": \\1 => \\,",
			": (\\1) => \\2,",
			": wsi => \\1,",
			"ctx",
			"lws",
			"map",
			"lws",
			"",
			"export const ",
			"actor",
			"action",
			"act",
			"ct",
			"WS",
			"ws",
			"$",
			"x",
			"event",
			"map",
			"#mapper",
			"DEBUG",
			"debug",
			"listeners",
			"\\1=",
			"event in this.#handlers",
			"",
			"this.#handlers[event]",
			"this.#handlers",
			"LinkedList",
			"list_node"
		],
		"reverse": false,
		"scrollbar_highlights": true,
		"show_context": true,
		"use_buffer2": true,
		"use_gitignore": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"sheets":
			[
				{
					"buffer": 0,
					"selected": true,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 450,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"color_scheme": "Packages/Outline/outline-Dark.hidden-tmTheme",
							"current_file": "/home/roman/Projects/plot-cv/quickjs/qjs-lws/libwebsockets/include/libwebsockets/lws-write.h",
							"function_name_status_row": -1,
							"outline_rename_mode": false,
							"show_line_column": "disabled",
							"symkeys":
							[
								[
									1329,
									1342
								],
								[
									1365,
									1436
								],
								[
									1508,
									1526
								],
								[
									3641,
									3659
								],
								[
									4648,
									4666
								],
								[
									6639,
									6656
								],
								[
									8189,
									8198
								],
								[
									8343,
									8357
								],
								[
									8866,
									8884
								],
								[
									9573,
									9602
								]
							],
							"symlist":
							[
								"â“‚  LWS_WRITE_RAW â€¦ â€” macro object",
								"âœŽ  NOTE: These public enums are part of the abi.  If you want to add one,",
								"â€”â’¸â€“ lws_write_protocol { â€¦ } ; â€” type",
								"â€”â’¸â€“ lws_write_passthru { â€¦ } ; â€” type",
								"âœŽ  IMPORTANT NOTICE!",
								"=== ==========================================================",
								"â€”â’»â€“ lws_write ( ) { â€¦ } â€” function",
								"â€”â“‚â€“ lws_write_http ( ) â€¦ â€” macro function",
								"â€”â’»â€“ lws_write_ws_flags ( ) { â€¦ } â€” function",
								"â’¡  lws_raw_transaction_completed ( ) ; â€” function declaration"
							],
							"syntax": "Packages/Outline/outline.hidden-tmLanguage",
							"tabs_extra_last_activated": 1755295321.54,
							"tabs_extra_last_activated_sheet_index": 0
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"stack_multiselect": false,
					"type": "text"
				}
			]
		},
		{
			"sheets":
			[
				{
					"buffer": 1,
					"file": "libwebsockets/lib/plat/unix/unix-misc.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3400,
						"regions":
						{
						},
						"selection":
						[
							[
								2581,
								2600
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 96,
							"show_line_column": "disabled",
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 8,
							"tabs_extra_last_activated": 1756322085.64,
							"tabs_extra_last_activated_sheet_index": 0,
							"tabs_extra_moving":
							[
								8,
								1
							],
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 907.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "libwebsockets/lib/core-net/state.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3971,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 0,
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 8,
							"tabs_extra_last_activated": 1756322098.62,
							"tabs_extra_last_activated_sheet_index": 1,
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "lws-context.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 49967,
						"regions":
						{
						},
						"selection":
						[
							[
								18174,
								18174
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 562,
							"show_line_column": "disabled",
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1756322085.25,
							"tabs_extra_last_activated_sheet_index": 1,
							"tabs_extra_moving":
							[
								8,
								1
							],
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 12795.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "libwebsockets/lib/plat/freertos/freertos-sockets.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9580,
						"regions":
						{
						},
						"selection":
						[
							[
								8727,
								8727
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 356,
							"show_line_column": "disabled",
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 4,
							"tabs_extra_last_activated": 1756322083.93,
							"tabs_extra_last_activated_sheet_index": 2,
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 5371.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "libwebsockets/lib/plat/optee/network.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6989,
						"regions":
						{
						},
						"selection":
						[
							[
								6146,
								6146
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 286,
							"show_line_column": "disabled",
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 8,
							"tabs_extra_last_activated": 1756322126.37,
							"tabs_extra_last_activated_sheet_index": 4,
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 4251.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "libwebsockets/lib/core-net/output.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9914,
						"regions":
						{
						},
						"selection":
						[
							[
								7148,
								7148
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 255,
							"show_line_column": "disabled",
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 8,
							"tabs_extra_last_activated": 1756323834.79,
							"tabs_extra_last_activated_sheet_index": 5,
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 4006.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 7,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1174258,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions": "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",
								"scope": ""
							}
						},
						"selection":
						[
							[
								1173221,
								1173221
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"detect_indentation": false,
							"function_name_status_row": 27600,
							"line_numbers": false,
							"output_tag": 9,
							"result_base_dir": "",
							"result_file_regex": "^([^ \t].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"show_line_column": "disabled",
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage",
							"tabs_extra_last_activated": 1756323835.14,
							"tabs_extra_last_activated_sheet_index": 6,
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 509235.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "libwebsockets/lib/roles/h2/http2.c",
					"semi_transient": true,
					"settings":
					{
						"buffer_size": 79267,
						"regions":
						{
							"col_00FFFFFF":
							{
								"flags": 16,
								"regions":
								[
									[
										15572,
										15582
									]
								],
								"scope": "col_00FFFFFF"
							},
							"col_00FFFFFF_icon":
							{
								"flags": 16,
								"icon": "Packages/User/Color Highlight.cache/col_00FFFFFF_circle.png",
								"regions":
								[
									[
										15561,
										15561
									]
								],
								"scope": "col_gutter"
							},
							"col_7FFFFFFF":
							{
								"flags": 16,
								"regions":
								[
									[
										13981,
										13991
									],
									[
										14281,
										14291
									],
									[
										25783,
										25793
									],
									[
										52395,
										52405
									],
									[
										52440,
										52450
									],
									[
										52557,
										52567
									]
								],
								"scope": "col_7FFFFFFF"
							},
							"col_7FFFFFFF_icon":
							{
								"flags": 16,
								"icon": "Packages/User/Color Highlight.cache/col_7FFFFFFF_circle.png",
								"regions":
								[
									[
										13970,
										13970
									],
									[
										14269,
										14269
									],
									[
										25760,
										25760
									],
									[
										52379,
										52379
									],
									[
										52407,
										52407
									],
									[
										52541,
										52541
									]
								],
								"scope": "col_gutter"
							},
							"col_80000001":
							{
								"flags": 16,
								"regions":
								[
									[
										16911,
										16921
									]
								],
								"scope": "col_80000001"
							},
							"col_80000001_icon":
							{
								"flags": 16,
								"icon": "Packages/User/Color Highlight.cache/col_80000001_circle.png",
								"regions":
								[
									[
										16901,
										16901
									]
								],
								"scope": "col_gutter"
							},
							"col_FFFFFFFF":
							{
								"flags": 16,
								"regions":
								[
									[
										78462,
										78472
									]
								],
								"scope": "col_FFFFFFFF"
							},
							"col_FFFFFFFF_icon":
							{
								"flags": 16,
								"icon": "Packages/User/Color Highlight.cache/col_FFFFFFFF_circle.png",
								"regions":
								[
									[
										78429,
										78429
									]
								],
								"scope": "col_gutter"
							}
						},
						"selection":
						[
							[
								72839,
								72839
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 2701,
							"show_line_column": "disabled",
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 8,
							"tabs_extra_last_activated": 1757225907.48,
							"tabs_extra_last_activated_sheet_index": 7,
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 46404.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "lws-socket.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 26392,
						"regions":
						{
						},
						"selection":
						[
							[
								11695,
								11723
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 498,
							"show_line_column": "disabled",
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1757225908.92,
							"tabs_extra_last_activated_sheet_index": 8,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7790.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "lib/fetch.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6644,
						"regions":
						{
						},
						"selection":
						[
							[
								5297,
								5297
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 138,
							"show_line_column": "disabled",
							"syntax": "Packages/JavaScriptNext - ES6 Syntax/JavaScriptNext.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1756322015.35,
							"tabs_extra_last_activated_sheet_index": 3,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1854.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "libwebsockets/include/libwebsockets/lws-write.h",
					"selected": true,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9628,
						"regions":
						{
						},
						"selection":
						[
							[
								8189,
								8189
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 208,
							"show_line_column": "disabled",
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 4,
							"tabs_extra_last_activated": 1757232910.95,
							"tabs_extra_last_activated_sheet_index": 10,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1593.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "libwebsockets/lib/roles/http/client/client-http.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 55002,
						"regions":
						{
						},
						"selection":
						[
							[
								43223,
								43247
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 1630,
							"show_line_column": "disabled",
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 8,
							"tabs_extra_last_activated": 1756321600.43,
							"tabs_extra_last_activated_sheet_index": 3,
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 25803.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"stack_multiselect": false,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 26.0
	},
	"input":
	{
		"height": 43.0
	},
	"layout":
	{
		"cells":
		[
			[
				2,
				0,
				3,
				2
			],
			[
				0,
				0,
				2,
				2
			]
		],
		"cols":
		[
			0.0,
			0.2,
			0.762267779463,
			1.0
		],
		"rows":
		[
			0.0,
			0.5,
			1.0
		]
	},
	"menu_visible": true,
	"output.Debugger":
	{
		"height": 300.0
	},
	"output.Debugger Console":
	{
		"height": 300.0
	},
	"output.coffeecompile_output":
	{
		"height": 132.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "qjs-lws.sublime-project",
	"replace":
	{
		"height": 48.0
	},
	"save_all_on_build": false,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"lws-write",
				"libwebsockets/include/libwebsockets/lws-write.h"
			],
			[
				"lws.c",
				"lws.c"
			],
			[
				"lws-soc",
				"lws-socket.c"
			],
			[
				"fetch",
				"lib/fetch.js"
			],
			[
				"header",
				"lib/lws/headers.js"
			],
			[
				"lws-net",
				"libwebsockets/include/libwebsockets/lws-network-helper.h"
			],
			[
				"http2",
				"libwebsockets/lib/roles/h2/http2.c"
			],
			[
				"lws-s",
				"lws-socket.c"
			],
			[
				"lws-c",
				"lws-context.c"
			],
			[
				"lws-so",
				"lws-socket.c"
			],
			[
				"lws-con",
				"lws-context.c"
			],
			[
				"http2.c",
				"libwebsockets/lib/roles/h2/http2.c"
			],
			[
				"util",
				"lib/lws/util.js"
			],
			[
				"body",
				"lib/lws/body.js"
			],
			[
				"webidl",
				"web-streams-polyfill/src/lib/helpers/webidl.js"
			],
			[
				"webidl.ts",
				"web-streams-polyfill/src/lib/helpers/webidl.ts"
			],
			[
				"pipe.ts",
				"web-streams-polyfill/src/lib/readable-stream/pipe.ts"
			],
			[
				"streams",
				"lib/lws/streams.js"
			],
			[
				"context",
				"lib/lws/context.js"
			],
			[
				"js-u",
				"js-utils.c"
			],
			[
				"util.js",
				"lib/lws/util.js"
			],
			[
				"heade",
				"lib/lws/headers.js"
			],
			[
				"lws-call",
				"libwebsockets/include/libwebsockets/lws-callbacks.h"
			],
			[
				"body.js",
				"lib/lws/body.js"
			],
			[
				"abort",
				"lib/lws/abort.js"
			],
			[
				"hpack.c",
				"libwebsockets/lib/roles/h2/hpack.c"
			],
			[
				"lws-ca",
				"libwebsockets/include/libwebsockets/lws-callbacks.h"
			],
			[
				"dead",
				"libwebsockets/minimal-examples-lowlevel/http-server/minimal-http-server-deaddrop/minimal-http-server-deaddrop.c"
			],
			[
				"deaddrop",
				"libwebsockets/minimal-examples-lowlevel/http-server/minimal-http-server-deaddrop/minimal-http-server-deaddrop.c"
			],
			[
				"lws-vhos",
				"libwebsockets/include/libwebsockets/lws-context-vhost.h"
			],
			[
				"lws-vho",
				"lws-vhost.h"
			],
			[
				"lws-conte",
				"libwebsockets/include/libwebsockets/lws-context-vhost.h"
			],
			[
				"lws-asy",
				"libwebsockets/include/libwebsockets/lws-async-dns.h"
			],
			[
				"network",
				"libwebsockets/lib/core-net/network.c"
			],
			[
				"lws-netwo",
				"libwebsockets/include/libwebsockets/lws-network-helper.h"
			],
			[
				"lws-str",
				"libwebsockets/include/libwebsockets/lws-struct.h"
			],
			[
				"lws-",
				"libwebsockets/include/libwebsockets/lws-misc.h"
			],
			[
				"lws-ad",
				"libwebsockets/include/libwebsockets/lws-adopt.h"
			],
			[
				"tcpso",
				"lib/tcpSocket.js"
			],
			[
				"client.h",
				"libwebsockets/include/libwebsockets/lws-client.h"
			],
			[
				"ts/lws-",
				"libwebsockets/include/libwebsockets/lws-misc.h"
			],
			[
				"context.js",
				"lib/lws/context.js"
			],
			[
				"lws-cn",
				"lws-context.c"
			],
			[
				"serve",
				"lib/serve.js"
			],
			[
				"abort-si",
				"lib/lws/abort-signal.js"
			],
			[
				"abort-sig",
				"lib/lws/abort-signal.js"
			],
			[
				"fetch.js",
				"lib/fetch.js"
			],
			[
				"cmakelists",
				"CMakeLists.txt"
			],
			[
				"lws.h",
				"lws.h"
			],
			[
				"js-ut",
				"js-utils.h"
			],
			[
				"js-utils.h",
				"js-utils.h"
			],
			[
				"121",
				"libwebsockets/minimal-examples/embedded/lhp/esp32-waveshare-104-212/main/splash-212-104.jpg.h"
			],
			[
				"test.js",
				"test.js"
			],
			[
				"serve.js",
				"lib/serve.js"
			],
			[
				"response",
				"lib/fetch/response.js"
			],
			[
				"request",
				"lib/fetch/request.js"
			],
			[
				"lws-sock",
				"lws-socket.c"
			],
			[
				"websocket.js",
				"lib/websocket.js"
			],
			[
				"lws-clie",
				"libwebsockets/include/libwebsockets/lws-client.h"
			],
			[
				"dummy",
				"libwebsockets/lib/core-net/dummy-callback.c"
			],
			[
				"test-clie",
				"test-client.js"
			],
			[
				"lws-co",
				"lws-context.c"
			],
			[
				"dummy-ca",
				"libwebsockets/lib/core-net/dummy-callback.c"
			],
			[
				"lws-client",
				"libwebsockets/include/libwebsockets/lws-client.h"
			],
			[
				"lws-htt",
				"libwebsockets/include/libwebsockets/lws-http.h"
			],
			[
				"conte",
				"lws-context.c"
			],
			[
				"simple-que",
				"lib/simple-queue.js"
			],
			[
				"lws-cont",
				"lws-context.c"
			],
			[
				"client-ht",
				"libwebsockets/lib/roles/http/client/client-http.c"
			],
			[
				"lws-h",
				"libwebsockets/include/libwebsockets/lws-http.h"
			],
			[
				"post.c",
				"libwebsockets/minimal-examples-lowlevel/http-client/minimal-http-client-post/minimal-http-client-post.c"
			],
			[
				"fet",
				"lib/fetch.js"
			],
			[
				"headers",
				"lib/fetch/headers.js"
			],
			[
				"private",
				"libwebsockets/lib/roles/private-lib-roles.h"
			],
			[
				"ops-ws",
				"libwebsockets/lib/roles/ws/ops-ws.c"
			],
			[
				"websock",
				"lib/websocket.js"
			],
			[
				"service",
				"libwebsockets/lib/core-net/service.c"
			],
			[
				"wsi.c",
				"libwebsockets/lib/core-net/wsi.c"
			],
			[
				"websocket",
				"lib/websocket.js"
			],
			[
				"socket.js",
				"lib/websocket.js"
			],
			[
				"webspo",
				"web-streams-polyfill/.idea/web-streams-polyfill.iml"
			],
			[
				"webso",
				"lib/websocket.js"
			],
			[
				"minnet-client",
				"libwebsockets/minimal-examples-lowlevel/mqtt-client/minimal-mqtt-client/minimal-mqtt-client.c"
			],
			[
				"private-lib-core",
				"libwebsockets/lib/core/private-lib-core.h"
			],
			[
				"private-lib-",
				"libwebsockets/lib/roles/private-lib-roles.h"
			],
			[
				"lws-socket.h",
				"lws-socket.h"
			],
			[
				"mirror",
				"libwebsockets/plugins/protocol_lws_mirror.c"
			],
			[
				"otocol_lws_raw_proxy.c",
				"libwebsockets/plugins/raw-proxy/protocol_lws_raw_proxy.c"
			],
			[
				"test-cli",
				"test-client.js"
			],
			[
				"lws-misc",
				"libwebsockets/include/libwebsockets/lws-misc.h"
			],
			[
				"lws-html",
				"libwebsockets/include/libwebsockets/lws-html.h"
			],
			[
				"context.c",
				"libwebsockets/lib/core/context.c"
			],
			[
				"lws-spa",
				"libwebsockets/lib/roles/http/server/lws-spa.c"
			],
			[
				"lws-sp",
				"libwebsockets/lib/roles/http/server/lws-spa.c"
			],
			[
				"quickj",
				"~/Projects/plot-cv/quickjs/quickjs.h"
			],
			[
				"lws-http",
				"libwebsockets/include/libwebsockets/lws-http.h"
			],
			[
				"spa.c",
				"lws-spa.c"
			],
			[
				"wsi-http",
				"libwebsockets/include/libwebsockets/lws-http.h"
			],
			[
				"quickjs.h",
				"~/Projects/plot-cv/quickjs/quickjs.h"
			],
			[
				"vhost",
				"libwebsockets/lib/core-net/vhost.c"
			],
			[
				"tls-clie",
				"libwebsockets/lib/tls/tls-client.c"
			],
			[
				"context.",
				"libwebsockets/lib/core/context.c"
			],
			[
				"raw-fall",
				"libwebsockets/minimal-examples-lowlevel/raw/minimal-raw-fallback-http-server/minimal-raw-fallback-http-server.c"
			],
			[
				"test-cl",
				"test-client.js"
			],
			[
				"socket.h",
				"lws-socket.h"
			],
			[
				"lws-log",
				"libwebsockets/include/libwebsockets/lws-logs.h"
			],
			[
				"spa.h",
				"libwebsockets/include/libwebsockets/lws-spa.h"
			],
			[
				"server.c",
				"libwebsockets/lib/roles/http/server/server.c"
			],
			[
				"lws-context-v",
				"libwebsockets/include/libwebsockets/lws-context-vhost.h"
			],
			[
				"buffer-ut",
				"src/buffer-utils.c"
			],
			[
				"repl",
				"lib/repl.js"
			],
			[
				"utils.c",
				"src/utils.c"
			],
			[
				"console.js",
				"lib/console.js"
			],
			[
				"qjsm.c",
				"src/qjsm.c"
			],
			[
				"",
				"include/utils.h"
			],
			[
				"utils.h",
				"include/utils.h"
			],
			[
				"quickjs-inspec",
				"quickjs-inspect.c"
			],
			[
				"io.js",
				"lib/io.js"
			],
			[
				"repl.js",
				"lib/repl.js"
			],
			[
				"util.sj",
				"web-platform-tests-streams/shared-storage/resources/util.sub.js"
			],
			[
				"quickjs.c",
				"~/Projects/plot-cv/quickjs/quickjs.c"
			],
			[
				"js-utils.c",
				"src/js-utils.c"
			],
			[
				"quickjs-strea",
				"quickjs-stream.h"
			],
			[
				"quickjs-st",
				"quickjs-stream.c"
			],
			[
				"quickjs-stream.h",
				"quickjs-stream.h"
			],
			[
				"quickjs-ins",
				"quickjs-inspect.c"
			],
			[
				"fs.js",
				"lib/fs.js"
			],
			[
				"ringbuffer.c",
				"src/ringbuffer.c"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"~/Projects/plot-cv/plot-cv.sublime-project"
			]
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 309.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"WS"
			]
		],
		"width": 1059.0
	},
	"selected_group": 1,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 268.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
